/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sub_146147030(__int64 a1);
__int64 __fastcall sub_146147240(_BYTE *a1, unsigned __int64 a2);
__int64 __fastcall sub_146147500(_DWORD *a1, unsigned int *a2, __int64 a3);
__int64 __fastcall sub_146148A0D(__m128i *a1, const __m128i *a2, __int64 a3);
__int64 __fastcall sub_146148DCD(_DWORD *a1, const __m128i *a2, __int64 a3);
__int64 __fastcall sub_146149D0D(_DWORD *a1, unsigned __int64 a2, __int64 a3);
__int64 __fastcall sub_14614AC8D(_DWORD *a1, __int64 a2, __int64 a3, __int64 a4, int a5, char a6, __int64 a7, _DWORD *a8, int a9, unsigned __int64 a10);
__int64 __fastcall sub_14614C0E0(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4);
void __fastcall sub_14614C230(__int64 a1, __int64 a2, _QWORD *a3);
int sub_14614C290();
int sub_14614C400();
int sub_14614C410();
void sub_14614C420();
FARPROC sub_14614C450();
void *sub_14614C480();
HANDLE sub_14614C4D0();
int sub_14614C500();
int sub_14614C510();
int sub_14614C680();
int sub_146157270();
int sub_146159030();
int sub_1461591A0();
int sub_1461591E0();
int sub_146159350();
__int64 sub_1461594C0(); // weak
int sub_146159510();
int sub_146159680();
int sub_1461597E8();
__int64 *__fastcall sub_146159800(__int64 *a1, __int64 *a2, int a3);
void __fastcall __noreturn sub_146159870(_QWORD, _QWORD); // weak
void __fastcall __noreturn sub_1461598F0(_QWORD, _QWORD); // weak
char __fastcall sub_146159970(unsigned int *a1, _QWORD **a2);
_QWORD *__fastcall sub_146159F90(_QWORD *a1, __int64 a2, unsigned int *a3);
char *__fastcall sub_14615A430(_QWORD *a1, __int64 a2);
char *__fastcall sub_14615A510(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_14615A5E0(size_t a1);
void *__fastcall sub_14615A650(_QWORD *a1, const void *a2, size_t a3);
void __fastcall sub_14615A710(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14615A770(__int64 *a1, __int64 a2, __int64 *a3, __int64 a4);
__int64 __fastcall sub_14615A9D0(__int64 *a1, __int64 a2, __int64 a3);
void *__fastcall sub_14615AAE0(__int64 a1, char *a2, char *a3);
void __fastcall __noreturn sub_14615AB90(__int64 a1);
_QWORD *__fastcall sub_14615ABC0(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4);
_QWORD *__fastcall sub_14615ACB0(_QWORD *a1, __int64 a2, unsigned int a3, int a4);
_QWORD *__fastcall sub_14615AE10(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4);
_QWORD *__fastcall sub_14615AF70(_QWORD *a1, __int64 a2, unsigned int a3, int a4);
_QWORD *__fastcall sub_14615B0D0(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4);
_QWORD *__fastcall sub_14615B230(_QWORD *a1, __int64 a2, unsigned int a3, int a4, char a5);
_QWORD *__fastcall sub_14615B3C0(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4, char a5);
__int64 __fastcall sub_14615B550(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14615B6D0(char **a1, char *a2, __int64 a3, __int64 *a4);
__int64 __fastcall sub_14615B920(char **a1, char *a2, unsigned int a3);
__int64 __fastcall sub_14615B9F0(int a1);
__int64 __fastcall sub_14615BA20(__int64 *a1, _DWORD *a2);
__int64 __fastcall sub_14615BB30(__int64 *a1, _DWORD *a2);
__int64 __fastcall sub_14615BC90(__int64 *a1, _DWORD *a2);
__int64 __fastcall sub_14615BD90(__int64 *a1, int *a2);
__int64 __fastcall sub_14615BF10(__int64 *a1, unsigned int *a2);
__int64 *__fastcall sub_14615C090(__int64 *a1, __int64 *a2, int *a3);
__int64 __fastcall sub_14615C4A0(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_14615CA80(__int64 a1, unsigned int *a2);
void *__fastcall sub_14615CF80(__int64 a1, __int64 a2, __int128 *a3);
__int64 *__fastcall sub_14615D880(__int64 *a1, __int64 a2, char a3, __int64 a4, __int64 a5);
__int64 *__fastcall sub_14615DA40(__int64 *a1, __int64 a2, unsigned __int64 *a3, __int64 a4);
__int64 *__fastcall sub_14615DBD0(__int64 *a1, __int64 a2, float a3, __int64 a4, __int64 a5);
__int64 *__fastcall sub_14615E050(__int64 *a1, __int64 a2, double a3, __int64 a4, __int64 a5);
__int64 *__fastcall sub_14615E4D0(__int64 *a1, __int64 a2, long double a3, __int64 a4, __int64 a5);
_QWORD *__fastcall sub_14615E950(_QWORD *a1, __int64 a2, __int64 a3, char *a4);
__int64 *__fastcall sub_14615EA10(__int64 *a1, __int64 a2, char a3, char *a4);
_QWORD *__fastcall sub_14615EA50(_QWORD *a1, int a2, __int64 a3);
__int64 *__fastcall sub_14615EBF0(__int64 *a1, __int64 a2, __int64 a3, char *a4, __int64 a5, char a6);
__int64 *__fastcall sub_14615EFB0(__int64 *a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5);
__int64 *__fastcall sub_14615F5D0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_14615FBB0(__int64 *a1, unsigned __int64 a2, int a3, __int64 a4, __int64 a5);
__int64 *__fastcall sub_146160020(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, char **a6);
__int64 *__fastcall sub_1461601E0(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _BYTE *a6);
__int64 *__fastcall sub_146160390(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, __int64 a6);
_QWORD *__fastcall sub_146160530(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
__int64 *__fastcall sub_146160760(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int *a6);
__int64 *__fastcall sub_146160900(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, __int64 a6);
_QWORD *__fastcall sub_146160AA0(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
_QWORD *__fastcall sub_146160CD0(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, __int64 a6);
_QWORD *__fastcall sub_146160EC0(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
__int64 *__fastcall sub_1461610F0(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6);
_QWORD *__fastcall sub_146161290(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
_QWORD *__fastcall sub_1461614B0(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
__int64 *__fastcall sub_1461616E0(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6);
_QWORD *__fastcall sub_146161880(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
__int64 *__fastcall sub_146161AB0(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6);
_QWORD *__fastcall sub_146161C50(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
_QWORD *__fastcall sub_146161E70(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
__int64 *__fastcall sub_1461620A0(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, __int64 a6);
unsigned __int64 *__fastcall sub_146162240(unsigned __int64 *a1, int a2, unsigned int a3, unsigned int *a4);
__int64 __fastcall sub_146162350(__int64 a1, __int64 a2);
__int64 __fastcall sub_146162390(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_1461623D0(_QWORD *a1);
__int64 __fastcall sub_146162400(__int64 a1, __int64 a2);
__int64 __fastcall sub_146162440(__int64 a1, __int64 a2);
__int64 __fastcall sub_146162480(__int64 a1, __int64 a2);
void __fastcall sub_1461624C0(__int64 a1);
void __fastcall sub_146162550(__int64 a1);
__int64 __fastcall guard_check_icall_nop(); // weak
void __fastcall sub_146162590(__int64 a1);
void __fastcall sub_1461625E0(void **a1);
void __fastcall sub_146162640(_QWORD *a1);
void __fastcall sub_1461626B0(__int64 a1);
__int64 __fastcall sub_146162730(__int64 a1);
__int64 sub_1461627C0(); // weak
void __fastcall sub_146162820(void *); // idb
void **__fastcall sub_146162830(void **a1, char *Str);
_QWORD *__fastcall sub_146162960(int *a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_146162AC0(__int64 *a1, __int64 a2, int a3);
__int64 *__fastcall sub_146162BC0(int **a1, __int64 *a2, __int64 a3);
__int64 *__fastcall sub_146162CF0(int **a1, __int64 *a2, __int64 a3);
unsigned __int8 *__fastcall sub_146162E60(_QWORD **a1, unsigned __int8 *a2);
_QWORD *__fastcall sub_1461630C0(__int64 a1, _QWORD *a2, __int64 a3);
_QWORD *__fastcall sub_146163240(unsigned int *a1, _QWORD *a2, __int64 a3);
__int64 *__fastcall sub_1461633C0(int **a1, __int64 *a2, __int64 a3);
bool __fastcall sub_146163510(__int64 a1, __int64 a2, __int64 a3);
__int64 *__fastcall sub_1461635D0(__int64 *a1, __int64 *a2, const char *a3);
_QWORD *__fastcall sub_1461637A0(__int64 *a1, _QWORD *a2, unsigned __int64 a3);
void __fastcall __noreturn sub_146163960(_QWORD, _QWORD, _QWORD); // weak
unsigned int *__fastcall sub_1461639F0(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4);
unsigned __int64 __fastcall sub_146163B70(_QWORD *a1, __int64 a2, unsigned __int64 a3, __int64 a4, int *a5, _DWORD *a6);
__int64 __fastcall sub_146163EF0(const char *a1, int a2, int a3, const char *a4, __int128 *a5);
__int64 __fastcall sub_146163F20(const char *a1, int a2, int a3, const char *a4, _OWORD *a5);
__int64 __fastcall sub_146164130(int a1, char *a2);
unsigned __int64 __fastcall sub_1461643F0(double a1, __int64 a2, int *a3, _DWORD *a4);
__int64 __fastcall sub_1461645B0(__int64 a1, void **a2, __int64 a3, __int64 a4);
char *__fastcall sub_146164810(__int64 a1, __int64 a2);
void __fastcall sub_1461648D0(__int64 a1);
char *__fastcall sub_146164980(char *Src, int a2, int a3, int a4);
char __fastcall sub_146164B40(_QWORD **a1, unsigned __int8 *a2, unsigned int a3);
__int64 __fastcall sub_146164C90(char *Str); // idb
_BYTE *__fastcall sub_146165040(int a1, _BYTE *a2);
void __fastcall sub_1461650D0(__int64 a1, void *a2, __int64 a3);
__int64 __fastcall sub_146165130(_QWORD *a1, __int64 a2, __int64 a3);
void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD); // weak
// void __fastcall __noreturn unknown_libname_3(_QWORD, _QWORD, _QWORD); weak
// void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD); weak
_QWORD *__fastcall sub_1461653F0(_QWORD *Src, void *a2, unsigned __int64 a3, __int64 a4);
__int64 __fastcall sub_146165560(unsigned __int64 a1);
void __fastcall sub_146165760(_QWORD *a1, size_t a2);
_BYTE *__fastcall sub_146165830(unsigned int a1, _BYTE *a2);
_BYTE *__fastcall sub_146165A90(unsigned __int64 a1, _BYTE *a2);
const char *__fastcall sub_1461660E0(__int64 a1);
__int64 *__fastcall sub_146166100(__int64 *a1, __int64 *a2, char a3);
__int64 GetErrorData(void); // weak
void *sub_146166290();
int sub_1461662A0(FILE *Stream, char *Format, ...);
void (__fastcall *__fastcall sub_1461662F0(HMODULE a1, const char *a2))(struct _STARTUPINFOW *a1);
__int64 __fastcall sub_146166300(); // weak
__int64 __fastcall sub_146166310(); // weak
__int64 __fastcall sub_146166320(__int64 a1, __int64 a2);
__int64 __fastcall sub_146166510(__int64 a1, __int64 a2);
__int64 __fastcall sub_146166700(__int64 a1, __int64 *a2);
_QWORD *__fastcall sub_146166AC0(_QWORD *a1, wchar_t *String);
__int64 __fastcall sub_146166BD0(__int64 a1);
void __fastcall sub_146166C80(__int64 a1);
void __fastcall sub_146166CF0(_QWORD *a1, __int64 a2);
void __fastcall sub_146166D90(__int64 a1);
void **__fastcall sub_146166DC0(void **a1, void **Src, __int64 a3, __int64 a4);
void (__fastcall *__fastcall sub_146166F00(__int64 a1, HMODULE a2, const char *a3))(struct _STARTUPINFOW *a1);
const char *sub_146166FF0();
wchar_t *__fastcall sub_146167110(__int64 a1, wchar_t *a2, __int64 (__fastcall *a3)(__int64));
HMODULE __fastcall sub_1461671F0(__int64 a1, const char *a2);
PVOID sub_146167640();
HANDLE __fastcall sub_146167670(wchar_t *a1, DWORD a2, DWORD a3, struct _SECURITY_ATTRIBUTES *a4, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
__int64 __fastcall sub_146167760(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_146167790(wchar_t *a1, GET_FILEEX_INFO_LEVELS a2, void *a3);
__int64 __fastcall sub_146167860(wchar_t *a1);
void __fastcall sub_146167910(struct _STARTUPINFOW *a1);
__int64 __fastcall Handler(struct _EXCEPTION_POINTERS *ExceptionInfo);
BOOL sub_146167A00();
__int64 __fastcall sub_146167D30(_QWORD); // weak
void __fastcall sub_146167DB0(wchar_t *a1, char a2);
char *__fastcall sub_146168400(char *a1, wchar_t *a2);
// __int64 __fastcall charNode::raw_length(charNode *__hidden this); idb
FARPROC sub_146168980();
void **__fastcall sub_1461689C0(void **Src, __int64 a2, __int64 a3, __int64 a4);
char sub_1461689D0();
// void __fastcall __noreturn unknown_libname_5(_QWORD, _QWORD, _QWORD, _QWORD); weak
void __fastcall sub_146168A00(_QWORD *a1, unsigned __int64 a2, __int64 a3);
void __fastcall __noreturn StartAddress(PVOID Parameter);
__int64 *__fastcall sub_146168B10(__int64 *a1, __int64 *a2, int a3);
__int64 __fastcall sub_146168B80(__int64 a1, unsigned int a2);
_QWORD *__fastcall sub_146168C20(__int64 *a1, _QWORD *a2, const wchar_t *a3);
__int64 __fastcall sub_146168DE0(__int64 a1, __int64 a2);
__int64 __fastcall sub_146168E90(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_146168F30(_QWORD *a1, const void *a2, unsigned __int64 a3, __int64 a4);
__int64 __fastcall sub_146169020(char a1, __int64 a2);
_QWORD *__fastcall sub_1461690E0(_QWORD *a1, char *a2, char *a3, __int64 a4);
char __fastcall sub_146169170(__int64 a1, __int64 a2);
char __fastcall sub_146169370(_QWORD *a1, __int64 a2);
__int64 *__fastcall sub_146169570(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_146169630(_QWORD *a1, __int64 a2, __int64 a3, _WORD *a4);
_QWORD *__fastcall sub_1461696B0(char **a1, _QWORD *a2, const struct tm *a3, __int64 *a4);
__int64 *__fastcall sub_146169A80(const struct tm *a1, __int64 a2, __int64 *a3);
_QWORD *__fastcall sub_146169B50(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4, char a5);
__int64 __fastcall sub_146169CC0(unsigned __int16 **a1, unsigned __int16 *a2, __int64 a3, __int64 *a4);
__int64 __fastcall sub_146169F30(unsigned __int16 **a1, unsigned __int16 *a2, unsigned int a3);
_QWORD *__fastcall sub_14616A020(__int64 a1);
char __fastcall sub_14616A1A0(__int64 a1, char a2);
__int64 __fastcall sub_14616A1F0(__int64 *a1, _DWORD *a2);
__int64 __fastcall sub_14616A350(__int64 *a1, _DWORD *a2);
__int64 __fastcall sub_14616A480(__int64 *a1, _DWORD *a2);
__int64 __fastcall sub_14616A590(__int64 *a1, int *a2);
__int64 __fastcall sub_14616A6F0(__int64 *a1, unsigned int *a2);
__int64 *__fastcall sub_14616A860(__int64 *a1, __int64 *a2, unsigned int *a3);
__int64 __fastcall sub_14616ACE0(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_14616B250(__int64 a1, unsigned int *a2);
unsigned __int64 __fastcall sub_14616B4B0(__int64 a1, __int64 a2, __int128 *a3);
_QWORD *__fastcall sub_14616BE70(_QWORD *a1, __int128 *a2, __int128 *a3);
__int64 *__fastcall sub_14616BFB0(__int64 *a1, __int64 a2, unsigned __int16 a3, __int64 a4, __int64 a5);
__int64 *__fastcall sub_14616C0A0(__int64 *a1, __int64 a2, float a3, __int64 a4, __int64 a5);
__int64 *__fastcall sub_14616C530(__int64 *a1, __int64 a2, double a3, __int64 a4, __int64 a5);
__int64 *__fastcall sub_14616C9B0(__int64 *a1, __int64 a2, long double a3, __int64 a4, __int64 a5);
__int64 *__fastcall sub_14616CE30(__int64 *a1, __int64 a2, __int16 a3, unsigned int *a4);
_QWORD *__fastcall sub_14616CE70(_QWORD *a1, int a2, __int64 a3);
__int64 *__fastcall sub_14616D020(__int64 *a1, __int64 a2, __int64 a3, unsigned int *a4, __int64 a5, __int16 a6);
__int64 *__fastcall sub_14616D3E0(__int64 *a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5);
__int64 *__fastcall sub_14616DA00(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_14616E030(__int64 *a1, unsigned __int64 a2, int a3, __int64 a4, __int64 a5);
__int64 *__fastcall sub_14616E400(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, char **a6);
__int64 *__fastcall sub_14616E5D0(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, int *a6);
__int64 *__fastcall sub_14616E7C0(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, _WORD *a6);
__int64 *__fastcall sub_14616E970(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, _QWORD *a6);
__int64 *__fastcall sub_14616EB40(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
__int64 *__fastcall sub_14616ED50(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
__int64 *__fastcall sub_14616EF60(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, int **a6);
__int64 *__fastcall sub_14616F0E0(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, int **a6);
__int64 *__fastcall sub_14616F330(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
__int64 *__fastcall sub_14616F540(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, int *a6);
__int64 *__fastcall sub_14616F6C0(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
__int64 *__fastcall sub_14616F8D0(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
__int64 *__fastcall sub_14616FAE0(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, __int64 a6);
__int64 *__fastcall sub_14616FCE0(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
__int64 *__fastcall sub_14616FF10(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, int **a6);
__int64 *__fastcall sub_146170090(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
__int64 *__fastcall sub_1461702A0(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, char **a6);
__int64 *__fastcall sub_146170470(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6);
__int64 *__fastcall sub_146170680(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, __int64 a6);
__int64 *__fastcall sub_146170850(__int64 *a1, __int64 a2, char *a3, int a4, int a5, __int16 a6);
__int64 __fastcall sub_146170930(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_146170A90(__int64 a1, __int64 *a2);
__int64 __fastcall sub_146170E60(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_146170F20(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void __fastcall sub_146171010(_QWORD *a1);
void __fastcall sub_146171080(__int64 a1);
void **__fastcall sub_1461710A0(_QWORD *a1);
__int64 __fastcall sub_146171310(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_1461713B0(__int64 a1, _QWORD *a2, __int64 a3);
_QWORD *__fastcall sub_146171510(unsigned int *a1, _QWORD *a2, __int64 a3);
_QWORD *__fastcall sub_146171670(int **a1, _QWORD *a2, __int64 a3);
_QWORD *__fastcall sub_146171810(unsigned int *a1, _QWORD *a2, __int64 a3);
_QWORD *__fastcall sub_146171940(unsigned int *a1, _QWORD *a2, __int64 a3);
_QWORD *__fastcall sub_146171A70(int *a1, _QWORD *a2, __int64 a3);
_QWORD *__fastcall sub_146171BE0(int *a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_146171CE0(__int64 a1, __int64 a2);
void __fastcall __noreturn sub_146171E10(_QWORD, _QWORD); // weak
_QWORD *__fastcall sub_146172330(unsigned __int64 *a1, _QWORD *a2, __int64 a3);
_QWORD *__fastcall sub_146172460(unsigned __int64 *a1, _QWORD *a2, __int64 a3);
__int64 *__fastcall sub_1461725A0(int **a1, __int64 *a2, __int64 a3);
_QWORD *__fastcall sub_146172710(__int64 *a1, _QWORD *a2, char *a3);
_QWORD *__fastcall sub_146172910(_QWORD *a1, char a2);
_QWORD *__fastcall sub_146172940(_QWORD *a1);
unsigned __int16 *__fastcall sub_146172B00(unsigned __int16 *a1);
void sub_146172E80();
void __fastcall sub_146173110(__int64 a1);
void __fastcall sub_146173950(__int64 a1, void *a2, __int64 a3);
// void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD); weak
signed __int64 __fastcall sub_1461739D0(__int64 a1, signed __int64 a2);
__int64 __fastcall sub_146173A20(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_146173AF0(__int64 a1);
char __fastcall sub_146173E70(__int64 a1);
__int64 *__fastcall sub_146173FD0(__int64 *a1, __int64 *a2, char a3);
void __fastcall AsyncTrace(char *Str);
__int64 __fastcall sub_1461741D0(HANDLE *a1);
__int64 __fastcall sub_1461742B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1461742E0(__int64 a1, __int64 a2);
void __fastcall sub_146174320(_QWORD **a1, __int64 a2);
void __fastcall sub_146174370(__int64 a1);
int __fastcall sub_146174390(__int64 a1, const wchar_t *a2);
__int64 __fastcall sub_146174520(struct _EXCEPTION_POINTERS *ExceptionInfo);
__int64 sub_1461747F0(void); // weak
__int64 sub_1461748D0(void); // weak
__int64 __fastcall sub_146174A70(__int64 a1, __int64 a2);
int __fastcall sub_146174E40(__int64 a1, void *a2);
__int64 __fastcall sub_146175100(struct _EXCEPTION_POINTERS *ExceptionInfo);
int __fastcall sub_146175490(char a1);
_QWORD *__fastcall sub_146175620(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_146175630(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_146175650(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_146175660(__int64 a1, _QWORD *a2);
void __fastcall sub_146175670(void *a1, char a2);
__int64 __fastcall sub_146175680(__int64 a1, __int64 *a2);
__int64 __fastcall sub_146175690(__int64 a1, __int64 *a2);
__int64 __fastcall sub_1461756B0(__int64 a1, __int64 *a2);
void *sub_146175710();
void *sub_146175720();
void *sub_146175730();
void *sub_146175740();
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
char *__fastcall sub_146175770(__int64 *a1, __int64 a2, __int64 a3);
char *__fastcall sub_146175930(_QWORD *a1, __int64 a2, __int64 a3);
_OWORD *__fastcall sub_146175B20(__int64 a1, __int64 a2, _OWORD *a3);
_QWORD *__fastcall sub_146175B90(_QWORD *a1, __int64 a2);
void **__fastcall sub_146175C00(__int64 a1, __int64 a2);
__int64 __fastcall sub_146176090(__int64 *a1, __int64 a2);
__int64 __fastcall sub_146176540(_QWORD *a1, __int64 a2);
BOOL (__fastcall *__fastcall sub_1461766F0(HMODULE a1, const CHAR *a2))(struct _STARTUPINFOW *a1);
HMODULE __fastcall sub_146176740(const CHAR *a1);
BOOL __fastcall sub_146176770(struct _STARTUPINFOW *a1);
char sub_146176900();
void __fastcall sub_146176A20(const wchar_t *a1, _QWORD *a2);
void __fastcall sub_146176C60(__int64 a1);
__int64 __fastcall sub_146176CD0(__int64 a1, _DWORD *a2, _QWORD *a3);
__int64 __fastcall sub_146176D00(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4);
__int64 __fastcall sub_146176D40(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_146176F80(__int64 a1, _QWORD *a2);
void __fastcall sub_146176FA0(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4);
void __fastcall sub_146177300(__int64 *a1, _QWORD *a2, unsigned __int64 a3);
_QWORD *__fastcall sub_146177540(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_146177630(unsigned __int64 a1, __int64 a2, __int64 a3);
_QWORD *__fastcall sub_146177800(__int64 *a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_146177A10(__int64 *a1, __int64 a2, __int64 a3);
void __fastcall sub_146177C20(__int64 a1, __int64 a2, void **a3);
void __fastcall sub_146177CC0(__int64 a1, __int64 a2, __int64 *a3);
void __fastcall sub_146177D60(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_146177DF0(_QWORD **a1, __int64 a2, __int64 *a3, int *a4);
__int64 __fastcall sub_146178070(__int64 *a1, __int64 a2, __int64 a3, const void **a4);
__int64 __fastcall sub_146178280(__int64 *a1, __int64 a2, const void **a3);
_QWORD *__fastcall sub_146178350(_QWORD *Src, unsigned __int64 a2, __int64 a3, size_t a4, void *Srca, size_t Size);
_QWORD *__fastcall sub_1461784D0(_QWORD *a1, __int128 *a2, __int128 *a3);
__int64 __fastcall sub_146178600(__int64 a1);
_QWORD *__fastcall sub_146178620(_QWORD *a1, const char *a2);
const char **__fastcall sub_146178670(const char **a1, const char *a2);
__int64 __fastcall sub_1461786A0(__int64 a1, __int64 *a2);
__int64 *__fastcall sub_1461787F0(__int64 *a1, _QWORD *a2);
__int64 *__fastcall sub_1461788D0(__int64 *a1, __int64 *a2);
_QWORD *__fastcall sub_146178A30(_QWORD *a1, __int64 a2, __int64 a3);
_QWORD *__fastcall sub_146178AE0(_QWORD *a1, __int64 a2, __int64 a3);
_QWORD *__fastcall sub_146178B90(_QWORD *a1, _QWORD *a2);
_QWORD *__fastcall sub_146178CB0(_QWORD *a1, __int64 *a2, __int64 a3);
__int64 __fastcall sub_146178DD0(__int64 a1, __int128 *a2, __int128 *a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_146178E60(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_146178F20(_QWORD *a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_146178FA0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int128 *a6);
void __fastcall sub_1461790F0(void **a1);
void __fastcall sub_146179120(void **a1);
void __fastcall sub_146179150(__int64 *a1);
void __fastcall sub_146179190(__int64 *a1);
void __fastcall sub_1461791D0(__int64 *a1);
void __fastcall sub_146179220(void **a1);
void __fastcall sub_146179250(_QWORD *a1);
void __fastcall sub_146179280(_QWORD *a1);
void __fastcall sub_1461792F0(void *a1); // idb
void __fastcall sub_146179300(_QWORD *a1);
void __fastcall sub_146179330(_QWORD *a1);
void **__fastcall sub_1461793E0(void **a1, const void **a2);
__int64 *__fastcall sub_146179530(__int64 *a1, __int64 a2);
__int64 __fastcall sub_146179580(__int64 a1, __int64 a2);
__int64 __fastcall sub_146179630(__int64 *a1, int *a2);
__int64 *__fastcall sub_146179760(__int64 *a1);
__int64 __fastcall sub_1461797D0(__int64 a1, size_t *a2, const void **a3);
__int64 __fastcall sub_146179840(__int64 a1, __int64 a2, __int64 a3);
__int64 sub_146179D90(void); // weak
_QWORD *__fastcall sub_146179E30(__int64 a1);
// __int64 __fastcall std::string::_Calculate_growth(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_14617D0A0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_14617D1B0(_QWORD *a1, unsigned __int64 a2);
void __fastcall sub_14617D330(_QWORD *a1);
void __fastcall sub_14617D400(_QWORD *a1);
void **__fastcall sub_14617D4E0(void **a1, void *Src, size_t Size, __int64 a4);
void **__fastcall sub_14617D600(void **a1, void *Src, unsigned __int64 a3, __int64 a4);
// __int64 __fastcall std::_Char_traits<char,int>::copy(_QWORD, _QWORD, _QWORD); weak
void __fastcall sub_14617D740(__int64 a1, void *a2, __int64 a3);
void __fastcall sub_14617D7A0(__int64 a1, void *a2, __int64 a3);
void __fastcall sub_14617D800(const wchar_t *a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_14617D810(_QWORD *a1, _BYTE *a2, _BYTE *a3, __int64 a4);
__int64 __fastcall sub_14617D900(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_14617D9A0(__int64 a1, _QWORD *a2, wchar_t *a3);
HMODULE __fastcall sub_14617DA20(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_14617DB10(__int64 *a1, __int64 a2, __int64 a3);
_QWORD *__fastcall sub_14617DC00(__int64 *a1, __int64 a2, __int64 a3);
_OWORD *__fastcall sub_14617DCF0(_OWORD *a1, __int64 a2, __int64 a3, __int64 a4);
_BYTE *__fastcall sub_14617E120(_QWORD *a1, _BYTE *a2, __int64 a3);
__int64 __fastcall sub_14617E280(__int64 a1, __int64 a2);
unsigned __int8 *__fastcall sub_14617E450(__int64 a1, __int64 a2, __int64 *a3);
unsigned __int8 *__fastcall sub_14617E650(__int64 a1, __int64 a2, __int64 a3);
unsigned __int8 *__fastcall sub_14617E870(__int64 a1, __int64 a2, __int64 *a3);
unsigned __int8 *__fastcall sub_14617EA60(__int64 a1, __int64 a2, __int64 *a3);
unsigned __int8 *__fastcall sub_14617EC50(__int64 a1, __int64 a2, char *a3);
__int64 __fastcall sub_14617EE50(__int64 a1, __int64 a2, char *a3);
char *__fastcall sub_14617F010(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14617F1D0(__int64 a1, __int64 a2, char *a3);
void __fastcall sub_14617F3A0(__int64 a1, __int64 a2, unsigned __int8 **a3);
__int64 __fastcall sub_14617F440(_QWORD *a1);
char *__fastcall sub_14617F4C0(__int64 a1, unsigned __int64 a2, _DWORD *a3);
_OWORD *__fastcall sub_14617F620(__int64 a1, __int64 a2, _OWORD *a3);
void **__fastcall sub_14617F690(void **Src, char *a2, _QWORD *a3);
void **__fastcall sub_14617F740(void **Src, char *a2, const char **a3);
void **__fastcall sub_14617F800(void **Src, char *a2, _QWORD *a3, char *a4);
void **__fastcall sub_14617F9D0(void **Src, char *a2, _QWORD *a3, char *a4, void **a5);
void **__fastcall sub_14617FAD0(void **Src, _QWORD *a2, char *a3, _QWORD *a4, char *Str, void **a6, void **a7);
void **__fastcall sub_14617FC20(void **Src, _QWORD *a2, _QWORD *a3, _QWORD *a4);
__int64 __fastcall sub_14617FCF0(__int64 a1, unsigned int a2, _QWORD *a3, __int64 a4);
__int64 __fastcall sub_14617FF70(__int64 a1, unsigned int a2, _QWORD *a3, __int64 a4);
__int64 __fastcall sub_1461801E0(__int64 a1, unsigned int a2, __int64 *a3, void **a4);
__int64 __fastcall sub_1461804D0(__int64 a1, unsigned int a2, _QWORD *a3, __int64 a4);
__int64 __fastcall sub_146180740(__int64 a1, unsigned int a2, _QWORD *a3);
__int64 __fastcall sub_1461809B0(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_146180AF0(_QWORD *a1, unsigned __int64 a2);
__int64 __fastcall sub_146180CC0(_QWORD *a1, unsigned __int64 a2);
__int64 __fastcall sub_146180DF0(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_146180E30(__int64 a1, _QWORD *a2, _QWORD *a3);
void __fastcall sub_1461810F0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1461812B0(__int64 *a1, __int64 a2, __int64 a3, char a4);
__int64 __fastcall sub_146181540(__int64 *a1, __int64 a2, unsigned __int8 ***a3, char a4);
__int64 __fastcall sub_1461817F0(unsigned __int8 **a1, __int64 *a2);
__int64 __fastcall sub_146181950(__int64 *a1, __int64 a2, __int64 a3, char a4);
__int64 __fastcall sub_146181C20(unsigned __int8 **a1, __int64 a2);
__int64 __fastcall sub_146181DC0(__int64 *a1, __int64 a2, unsigned __int8 ***a3, char a4);
__int64 __fastcall sub_146182070(unsigned __int8 **a1, __int64 *a2);
__int64 __fastcall sub_1461821A0(__int64 *a1, __int64 a2, unsigned __int8 ***a3, char a4);
__int64 __fastcall sub_146182450(unsigned __int8 **a1, __int64 *a2);
__int64 __fastcall sub_146182580(__int64 *a1, __int64 a2, char *a3, char a4);
__int64 __fastcall sub_146182830(unsigned __int8 **a1, char *a2);
__int64 __fastcall sub_146182980(__int64 *a1, __int64 a2, unsigned __int8 *a3, char a4);
__int64 __fastcall sub_146182C10(unsigned __int8 **a1, char *a2);
char __fastcall sub_146182D30(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_146182D70(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_146182DB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_146182DF0(__int64 a1, _QWORD *a2, __int64 a3, char a4, char a5);
__int64 __fastcall sub_146183010(__int64 a1, __int64 *a2);
__int64 __fastcall sub_146183CC0(__int64 a1, __int64 a2);
char *__fastcall sub_1461849E0(char *Src, __int64 a2, double a3);
_OWORD *__fastcall sub_146184B70(__int64 a1, __int64 *a2, __int64 a3, __int128 *a4);
__int64 __fastcall sub_146184E30(__int64 a1);
_QWORD *__fastcall sub_146184F50(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_146184F80(__int64 a1, __int64 *a2);
__int64 __fastcall sub_146185200(__int64 a1, const wchar_t *a2, int a3, int a4, int a5);
__int64 __fastcall sub_146185420(__int64 a1, __int64 a2);
char *__fastcall sub_146185760(__int64 a1, __int64 *a2, char a3, char a4);
__int64 __fastcall sub_146185B90(__int64 a1, __int64 a2);
char *__fastcall sub_146185BD0(char *a1, __int64 a2, _QWORD *a3, _QWORD *a4);
__int64 __fastcall sub_146185DB0(__int64 a1, __int64 a2, __int64 a3, char a4);
_QWORD *__fastcall sub_146185EC0(_QWORD *a1, unsigned __int64 a2, __int64 a3);
void **__fastcall sub_146185F40(void **a1, __int64 a2);
__int64 __fastcall sub_146186140(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_146186180(_QWORD *a1);
__int64 __fastcall sub_1461861B0(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_146186230(_QWORD *a1, const wchar_t *a2);
_QWORD *__fastcall sub_146186280(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_1461862B0(_QWORD *a1, char a2);
_QWORD *__fastcall sub_146186440(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_146186470(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_1461864A0(__int64 a1, int a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_146186520(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_146186560(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_146186590(__int64 a1);
int __fastcall sub_1461865E0(__int64 a1);
void __fastcall sub_1461866A0(__int64 *a1);
void __fastcall sub_1461866E0(unsigned __int8 ****a1);
__int64 __fastcall sub_146186730(__int64 a1);
__int64 __fastcall sub_146186810(unsigned __int8 *a1);
void __fastcall sub_146186830(__int64 a1);
void __fastcall sub_1461868C0(__int64 a1);
__int64 __fastcall sub_146186920(__int64 a1);
void __fastcall sub_146186970(__int64 a1);
void __fastcall sub_146186A00(__int64 a1);
void __fastcall sub_146186AE0(_QWORD **a1);
void __fastcall sub_146186B70(__int64 a1);
void __fastcall sub_146186BF0(__int64 *a1);
void __fastcall sub_146186CB0(_QWORD *a1);
void __fastcall sub_146186D60(__int64 a1);
__int64 __fastcall sub_146186DB0(_QWORD *a1);
void __fastcall sub_146186DF0(__int64 a1);
char *__fastcall sub_146186E30(char *a1, unsigned __int8 *a2);
__int64 __fastcall sub_146186E80(__int64 *a1, const void **a2);
__int64 __fastcall sub_146186F80(_OWORD *a1, __int64 a2, __int64 a3);
void __fastcall sub_146186FF0(void (__fastcall ***a1)(_QWORD *));
void __fastcall sub_1461871B0(__int64 a1, const wchar_t *a2, __int64 a3, __int64 a4);
bool sub_146187360();
BOOL sub_1461873D0();
_QWORD *__fastcall sub_146187600(_QWORD *Src, wchar_t *a2);
__int64 __fastcall sub_146187630(__int64 a1);
void *__fastcall sub_146187690(__int64 a1, char a2);
_QWORD *__fastcall sub_1461876D0(_QWORD *a1, char a2);
void *__fastcall sub_146187740(__int64 a1, char a2);
_QWORD *__fastcall sub_146187800(_QWORD *Block, char a2);
_QWORD *__fastcall sub_146187860(_QWORD *Block, char a2);
void __fastcall sub_1461878C0(signed int dwMessageId, __m128i *a2, __int64 a3, __int64 a4);
_QWORD *sub_146187CF0();
_OWORD *sub_146187DB0();
_QWORD *__fastcall sub_146187E30(_QWORD *a1);
__int64 __fastcall sub_146188370(_QWORD); // weak
__int64 __fastcall sub_1461883F0(_QWORD); // weak
__int64 __fastcall sub_146188490(__int64 a1, void **a2);
int __stdcall WinMain_0(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
__int64 __fastcall sub_14618AC00(_WORD *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14618ACC0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void __fastcall sub_14618AD60(unsigned __int8 **a1, unsigned __int8 *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14618AE40(volatile signed __int32 *a1);
__int64 __fastcall sub_14618AE90(__int64 a1);
__int64 __fastcall sub_14618AEB0(__int64 a1);
void __fastcall sub_14618AEC0(__int64 a1);
bool __fastcall sub_14618AF10(__int64 a1);
__int64 __fastcall sub_14618B000(_QWORD *a1, __int64 a2);
HRESULT __stdcall DllCanUnloadNow();
__int64 __fastcall sub_14618B3C0(__int64 *a1, _QWORD *a2, unsigned __int64 a3);
void __fastcall sub_14618B630(__int64 a1);
_QWORD *__fastcall sub_14618B650(__int64 a1, __int64 a2);
__int64 __fastcall sub_14618B6B0(__int64 a1);
_QWORD *__fastcall sub_14618B6F0(__int64 a1, _QWORD *a2);
void __fastcall __noreturn sub_14618B750(_QWORD); // weak
void __fastcall sub_14618B770(unsigned __int8 **a1);
void __fastcall sub_14618B820(__int64 a1);
void __fastcall sub_14618B890(__int64 a1);
// void __fastcall __noreturn unknown_libname_7(_QWORD); weak
_QWORD *__fastcall sub_14618B8D0(_QWORD *Src, void *a2, size_t Size, __int64 a4);
_QWORD *__fastcall sub_14618BA50(_QWORD *Src, size_t Size, __int64 a3, __int64 a4);
char *__fastcall sub_14618BBD0(_QWORD *a1);
__int64 __fastcall sub_14618BBF0(__int64 a1);
_QWORD *__fastcall sub_14618BC00(__int64 *a1, _QWORD *a2);
_QWORD *__fastcall sub_14618BC90(_QWORD *a1);
void __fastcall sub_14618BCA0(__int64 a1, void *a2, __int64 a3);
void __fastcall sub_14618BD00(__int64 a1, void *a2, __int64 a3);
void __fastcall sub_14618BD60(unsigned __int8 ***a1, __int64 a2);
__int64 __fastcall sub_14618C320(unsigned __int8 *a1, __int64 a2, int a3, char a4, unsigned __int8 a5, int a6);
__int64 __fastcall sub_14618C640(__int64 **a1, unsigned __int8 *a2, char a3, unsigned __int8 a4, int a5, unsigned int a6);
void __fastcall sub_14618D010(__int64 **a1, _QWORD *a2, char a3);
_QWORD *__fastcall sub_14618D4F0(__int64 a1, _QWORD *a2);
char __fastcall sub_14618D580(_QWORD *a1);
char __fastcall sub_14618D680(_QWORD *a1);
__int64 __fastcall sub_14618DB00(unsigned __int64 *a1, __int64 a2, __m128i *a3);
__int64 __fastcall sub_14618DCE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14618E3C0(_QWORD *a1, const wchar_t *a2, size_t a3);
char *__fastcall sub_14618E470(char *Src, int a2, int a3, int a4, int a5);
__int64 __fastcall sub_14618E640(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14618E6E0(__int64 a1, __int64 a2, __int64 a3);
_QWORD *__fastcall sub_14618E820(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4);
unsigned __int64 __fastcall sub_14618EA40(__int64 a1, int *a2, int *a3, unsigned __int64 *a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_14618EC80(__int64 a1, int *a2, _DWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6);
__int64 __fastcall sub_14618EF10(__int64 a1, unsigned __int8 a2);
char __fastcall sub_14618EF80(__int64 a1, __int64 a2);
char __fastcall sub_14618EFD0(_QWORD *a1, const void **a2);
__int64 __fastcall sub_14618F120(__int64 a1);
void **__fastcall sub_14618F180(void **Src, _QWORD *a2, __int64 a3, __int64 a4);
char __fastcall sub_14618F530(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_14618F630(__int64 *a1);
char __fastcall sub_14618F660(unsigned __int8 **a1);
__int64 __fastcall sub_14618F770(__int64 a1, unsigned int a2);
void __fastcall sub_14618F930(__int64 a1, char a2, unsigned __int8 *a3);
__int64 __fastcall sub_14618FFD0(_QWORD *a1, unsigned int a2);
__int64 __fastcall sub_1461900F0(unsigned __int64 *a1);
void **__fastcall sub_146190190(void **Src, __int64 a2);
void __fastcall sub_146190570(void **Src, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1461906D0(const void **a1, __int64 *a2);
unsigned __int64 __fastcall sub_1461907F0(__int64 *a1, char *a2);
void __fastcall sub_146190960(void **Src, unsigned __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_146190AF0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_146190F50(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned int a4);
__int64 __fastcall sub_146191050(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1461916F0(__int64 a1, __int64 a2, __int64 a3);
fpos_t *__fastcall sub_146192040(__int64 a1, fpos_t *a2, __int64 a3, int a4);
fpos_t *__fastcall sub_146192120(__int64 a1, fpos_t *a2, _QWORD *a3);
__int64 __fastcall sub_1461921D0(__int64 a1, char *a2, size_t a3);
__int64 __fastcall sub_1461922B0(__int64 a1);
__int64 __fastcall sub_146192320(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_1461923F0(__int64 a1, unsigned __int64 a2);
char __fastcall sub_146192540(__int64 a1, unsigned __int64 a2);
char __fastcall sub_146192630(__int64 a1, unsigned __int64 a2);
char __fastcall sub_146192780(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_146192870(FILE **a1);
_QWORD *__fastcall sub_1461928C0(_QWORD *a1, unsigned __int64 a2);
const char *__fastcall sub_146192950(int a1);
const char *__fastcall sub_146192A40(_BYTE *a1);
__int64 __fastcall sub_146192AD0(__int64 a1);
__int64 __fastcall sub_146192E90(__int64 a1);
__int64 __fastcall sub_146192F10(__int64 a1);
void __fastcall sub_146192F30(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_146192F40(__int64 a1, void *a2, size_t a3, __int64 a4);
__int64 __fastcall sub_146192F50(__int64 a1, char *a2, __int64 a3);
__int64 __fastcall sub_146193080(__int64 a1, char *a2, signed __int64 a3);
int sub_146193140(const char *a1, ...);
// int swprintf(wchar_t *, const wchar_t *, ...);
__int64 __fastcall sub_146193210(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, unsigned __int8 a6);
LONG __stdcall j_TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
FARPROC sub_146193230();
__int64 __fastcall sub_146193270(char *a1, char *a2);
__int64 sub_146193E50(void); // weak
__int64 __fastcall BeforeTerminateHandler(__int64 a1);
int EarlyInitializeExceptionHandler();
char InitializeExceptionHandler();
char *__fastcall RemoteExceptionFunc(__int64 a1);
char __fastcall TerminateForException(__int64 a1);
__int64 __fastcall TryCollectCrashLog(__int64 a1);
// int swprintf_0(wchar_t *, const wchar_t *, ...);
// __int64 __fastcall unknown_libname_17(_QWORD); weak
_QWORD *__fastcall sub_146194910(_QWORD *a1, _QWORD *Src, wchar_t *String);
void __fastcall sub_146194A40(__int64 *a1);
FARPROC sub_146194A90();
void sub_146194AE0();
void __fastcall sub_146195910(__int64 *a1);
__int64 __fastcall sub_1461959C0(_BYTE *a1, int *a2);
__int64 __fastcall sub_146195CE0(__int64 a1);
__int64 __fastcall sub_146195D40(_DWORD *a1, char *a2, size_t a3);
void sub_146195E70();
__int64 __fastcall sub_146196000(unsigned __int16 *a1);
_BOOL8 __fastcall sub_1461960C0(unsigned int a1, unsigned __int16 a2);
__int64 __fastcall sub_1461960E0(unsigned int a1);
__int64 __fastcall sub_146196120(double a1, int a2, __int64 a3, _QWORD *a4);
void __fastcall __noreturn sub_146196480(_QWORD, _QWORD); // weak
void __fastcall __noreturn sub_146196500(_QWORD, _QWORD); // weak
__int64 __fastcall sub_146196580(__int64 a1, unsigned int a2);
__int64 __fastcall sub_146196600(char *a1, __int64 a2, const _Cvtvec *a3);
__int64 __fastcall sub_146196700(__int64 a1);
__int64 __fastcall sub_146196810(__int64 a1);
char *__fastcall sub_146196920(const char *a1, char *a2, __int64 a3);
char *__fastcall sub_146196B00(char *a1, char *a2, __int64 *a3);
char *__fastcall sub_146196DA0(char *a1, char *a2, __int64 *a3);
void __fastcall sub_146197040(double a1, unsigned int a2, char a3, __int64 a4, _DWORD *a5);
_QWORD *__fastcall sub_146198090(_QWORD *a1, __int64 a2, unsigned int a3, int a4);
_QWORD *__fastcall sub_1461981B0(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4);
__int64 __fastcall sub_1461982F0(double a1, int a2, __int64 a3, _QWORD *a4);
unsigned __int64 __fastcall sub_146198650(unsigned int *a1, char a2);
unsigned __int64 __fastcall sub_146198700(unsigned int *a1, char a2);
__int64 __fastcall sub_1461987B0(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_146198880(unsigned __int64 *a1, unsigned __int64 a2, int *a3, __int64 a4);
bool __fastcall sub_146198CE0(__int64 a1, int a2, int a3);
const char *__fastcall sub_146198D20(const char *a1, unsigned __int64 a2, _QWORD *a3);
char *__fastcall sub_146198E90(const char *a1, char *a2, _QWORD *a3);
void __fastcall sub_146199020(__int64 a1, void ***a2);
char *__fastcall sub_146199530(__int64 a1, char *a2, __int64 a3);
char *__fastcall sub_146199890(char *a1, char *a2, __int64 a3);
unsigned __int64 __fastcall sub_146199B80(int a1);
__int64 __fastcall sub_146199D60(double a1, int a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_146199FE0(double a1, int a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14619A260(__int64 a1, __int64 a2);
__int64 __fastcall sub_14619A3D0(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_14619A530(double a1);
__int64 __fastcall sub_14619A920(__int64 a1, double a2);
std::locale::facet *__fastcall sub_14619AD00(__int64 a1);
__int64 __fastcall sub_14619AEC0(__int64 a1);
void __fastcall sub_14619B060(__int64 a1, __int64 a2, __int64 *a3, __int64 a4);
__int64 *__fastcall sub_14619B1C0(__int64 *a1, __int64 *a2, unsigned int *a3);
__int64 *__fastcall sub_14619B6F0(__int64 *a1, _QWORD *a2, int *a3);
__int64 __fastcall sub_14619BE40(__int64 a1, unsigned int *a2);
__int64 __fastcall sub_14619C350(__int64 a1, unsigned int *a2);
__int64 *__fastcall sub_14619C860(__int64 *a1, __int64 a2, int a3);
_QWORD *__fastcall sub_14619C9B0(_QWORD *a1, _QWORD *a2, unsigned int a3);
_QWORD *__fastcall sub_14619CAB0(_QWORD *a1, _QWORD *a2, unsigned __int64 a3);
_QWORD *__fastcall sub_14619CB40(_QWORD *a1, __int64 a2, unsigned __int8 a3, __int64 a4);
__int64 *__fastcall sub_14619CC20(__int64 *a1, __int64 a2, int *a3, char *a4, char *a5, char a6);
__int64 *__fastcall sub_14619CF40(__int64 *a1, __int64 a2, __int64 a3, char *a4, __int64 a5, char a6);
__int64 *__fastcall sub_14619D250(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6);
__int64 *__fastcall sub_14619D3C0(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6);
__int64 *__fastcall sub_14619D530(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6);
__int64 *__fastcall sub_14619D740(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int *a6);
__int64 *__fastcall sub_14619D8B0(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6);
__int64 *__fastcall sub_14619DA20(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6);
__int64 *__fastcall sub_14619DB90(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int *a6);
__int64 *__fastcall sub_14619DD00(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6);
_QWORD *__fastcall sub_14619DF10(_QWORD *a1, __int64 a2, __int64 a3, int a4, int a5, char a6);
_QWORD *__fastcall sub_14619E0C0(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4, int a5, char a6);
mbstate_t __fastcall sub_14619E2B0(mbstate_t a1, std::_Locinfo *a2, unsigned __int64 a3, char a4);
void __fastcall sub_14619E490(void ***a1);
void __fastcall sub_14619E4D0(_QWORD *a1);
_QWORD *__fastcall sub_14619E550(int **a1, _QWORD *a2, __int64 a3);
_QWORD *__fastcall sub_14619E6A0(int **a1, _QWORD *a2, __int64 a3);
_QWORD *__fastcall sub_14619E7F0(int *a1, _QWORD *a2, __int64 a3);
__int64 *__fastcall sub_14619E900(int **a1, __int64 *a2, __int64 a3);
__int64 *__fastcall sub_14619EA70(int **a1, __int64 *a2, __int64 a3);
_QWORD *__fastcall sub_14619EBE0(int *a1, _QWORD *a2, __int64 a3);
void __fastcall sub_14619ECF0(__int64 *a1, char *a2, char *a3);
__int64 __fastcall sub_14619EE30(__int64 a1, int a2);
void **__fastcall sub_14619EEF0(void **Block, char a2);
void **__fastcall sub_14619EF50(void **Block, char a2);
char __fastcall sub_14619EFB0(__int64 a1, std::_Locinfo *a2, char a3);
__int64 __fastcall sub_14619F150(__int64 a1, __int64 a2, __int64 a3);
void __fastcall __noreturn sub_14619F290(const char *a1, unsigned int a2, const char *a3);
_DWORD *__fastcall sub_14619F2E0(__int64 a1, _DWORD *a2, unsigned __int64 a3);
void __fastcall sub_14619F410(__int64 a1);
__int64 __fastcall sub_14619F4A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14619F540(__int64 a1, __int64 a2);
__int64 __fastcall sub_14619F7D0(__int64 a1);
_QWORD *__fastcall sub_14619F7F0(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_14619F840(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_14619F890(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_14619F8E0(__int64 a1);
__int64 __fastcall sub_14619F8F0(__int64 a1);
_QWORD *__fastcall sub_14619F900(__int64 a1, _QWORD *a2);
_QWORD *__fastcall sub_14619F950(__int64 a1, _QWORD *a2);
int sub_14619F9A0(char *Buffer, size_t BufferCount, char *Format, ...);
__int64 __fastcall sub_14619FA10(__int64 a1, __int64 a2, _OWORD *a3);
__m128i *__fastcall sub_14619FB50(__m128i *a1, int a2);
void __fastcall sub_14619FC90(_QWORD *a1, unsigned __int64 a2);
__int64 __fastcall sub_14619FD90(__int64 a1);
void __fastcall __noreturn sub_14619FE20(__int64 a1, __int64 a2);
void **__fastcall sub_14619FE90(_QWORD *a1, __int64 a2);
char *__fastcall sub_14619FFC0(void ***a1, int a2, const char *a3, char *a4);
__int64 *__fastcall sub_1461A0200(_QWORD *a1, int a2);
__int64 __fastcall sub_1461A0330(_DWORD *a1, int a2);
__int64 __fastcall sub_1461A0410(unsigned __int64 *a1);
__int64 __fastcall sub_1461A0620(__int64 a1);
void __fastcall sub_1461A06B0(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall sub_1461A0990(__int64 a1, unsigned __int64 a2);
_QWORD *__fastcall sub_1461A09D0(_QWORD *a1, __int128 *a2, __int128 *a3);
__int64 __fastcall sub_1461A0B00(__int64 a1, __int64 a2);
__int64 __fastcall sub_1461A1350(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_QWORD *__fastcall sub_1461A1680(_QWORD *a1);
void __fastcall sub_1461A1A40(signed int dwThreadId, char *Str);
__int64 *__fastcall sub_1461A1C30(wchar_t *String, wchar_t *a2, int a3);
char *__fastcall sub_1461A1DF0(char **a1, unsigned __int64 a2);
void ***__fastcall sub_1461A1F80(void ***a1, __int64 a2, void **a3, __int64 a4);
_QWORD *__fastcall sub_1461A2050(_QWORD *a1, const char *a2, __int64 *a3, __int64 *a4);
__int64 __fastcall sub_1461A21E0(__int128 *a1, __int128 *a2);
__int64 __fastcall sub_1461A2480(__int128 *a1, __int128 *a2);
_QWORD *__fastcall sub_1461A2730(_QWORD *a1, __int128 *a2, __int128 *a3);
__int64 __fastcall sub_1461A2870(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1461A2980(__int64 a1, int a2);
void __fastcall sub_1461A29A0(__int64 a1);
void __fastcall sub_1461A2A80(__int64 a1, __int64 a2);
__int64 __fastcall sub_1461A2B10(__int64 a1);
__int64 __fastcall sub_1461A2B60(__int64 a1, unsigned __int16 **a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1461A2C60(__int64 a1, __int64 a2);
void __fastcall sub_1461A2D50(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int128 *a5, __int128 *a6);
__int64 __fastcall sub_1461A30D0(__int128 *a1, __int128 *a2);
__int64 __fastcall sub_1461A30F0(__int128 *a1, __int128 *a2);
HMODULE sub_1461A3120();
__int64 __fastcall sub_1461A3150(__int64 a1, unsigned int a2);
_QWORD *__fastcall sub_1461A31D0(__int64 a1, _QWORD *a2);
void __fastcall sub_1461A3580(__int64 a1, unsigned __int64 a2);
char __fastcall sub_1461A3AC0(_QWORD *a1, _BYTE *a2);
__int64 __fastcall sub_1461A3C40(__int64 a1, unsigned int a2);
__int64 __fastcall sub_1461A40E0(_QWORD, _QWORD, _QWORD); // weak
HMODULE __fastcall sub_1461A4170(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_1461A4320(unsigned __int64 a1, void **a2, _QWORD *a3, __int64 a4);
_BOOL8 __fastcall sub_1461A4660(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1461A48B0(_QWORD); // weak
__int64 __fastcall sub_1461A4C70(__int64 a1, __int64 a2, int a3, _OWORD *a4);
__int64 __fastcall sub_1461A4CF0(__int64 a1, const wchar_t *a2, int a3, _OWORD *a4);
__int64 __fastcall sub_1461A4DA0(_QWORD *a1);
HANDLE __fastcall sub_1461A4DF0(const WCHAR *lpNamedPipeName);
char __fastcall sub_1461A4EE0(__int64 a1);
bool __fastcall sub_1461A5090(__int64 a1, __int64 a2, __int128 *a3);
_QWORD *__fastcall sub_1461A51A0(_QWORD *a1, _BYTE *a2, _QWORD *a3);
__int64 __fastcall sub_1461A5320(__int64 a1);
struct _RTL_CRITICAL_SECTION *__fastcall sub_1461A53B0(struct _RTL_CRITICAL_SECTION *lpParameter, char *Src, struct _RTL_CRITICAL_SECTION_DEBUG *a3, __int64 a4, void *a5, int a6, __int64 a7);
void __fastcall sub_1461A54B0(void **a1);
void __fastcall sub_1461A5510(_QWORD **a1);
void sub_1461A5540();
__int64 __fastcall sub_1461A5590(HANDLE *Parameter);
__int64 __fastcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
void __fastcall __noreturn sub_1461A5820(const wchar_t *a1, const wchar_t *a2, const wchar_t *a3, unsigned int a4, uintptr_t a5);
void __fastcall sub_1461A5A10();
void __fastcall sub_1461A5D20(struct _RTL_CRITICAL_SECTION *lpParameter, char *Src, struct _RTL_CRITICAL_SECTION_DEBUG *a3, __int64 a4, void *a5, int a6, int a7, const wchar_t *a8, __int64 a9, __int64 a10, _OWORD *a11);
bool __fastcall sub_1461A61B0(__int64 a1);
__int64 __fastcall sub_1461A61C0(_QWORD **a1, __int64 a2, __int64 a3);
void **__fastcall sub_1461A6240(__int64 a1);
char __fastcall sub_1461A6400(_QWORD *a1, __int64 a2);
char __fastcall sub_1461A6460(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_1461A6530(_QWORD *a1, int a2, __int64 a3, __int128 *a4);
bool __fastcall sub_1461A65F0(__int64 a1, int a2, __int64 a3, __int64 a4, HANDLE hProcess, char a6);
// void __fastcall __noreturn unknown_libname_8(_QWORD); weak
__int64 __fastcall sub_1461A6850(__int64 a1);
int sub_1461A6860(wchar_t *Buffer, size_t BufferCount, size_t MaxCount, wchar_t *Format, ...);
// int swprintf_1(wchar_t *, const wchar_t *, ...);
_QWORD *__fastcall sub_1461A6930(_QWORD *a1, unsigned int *a2);
__int64 __fastcall sub_1461A6A40(const __m128i *Src, unsigned __int64 a2, __m128i *a3, unsigned __int64 a4);
const __m128i *__fastcall sub_1461A6C40(const __m128i *Src, __int64 a2, const __m128i *a3, size_t a4);
int __fastcall sub_1461A6E30(char *a1, unsigned __int64 a2);
char __fastcall sub_1461A6F90(unsigned __int64 a1, unsigned __int64 a2, char a3);
__int64 __fastcall sub_1461A7020(__int64 a1, __int64 a2, unsigned __int8 a3);
const __m128i *__fastcall sub_1461A7170(const __m128i *a1, const __m128i *a2, unsigned __int8 a3);
const __m128i *__fastcall sub_1461A7270(const __m128i *a1, const __m128i *a2, __int16 a3);
const __m128i *__fastcall sub_1461A7370(const __m128i *a1, const __m128i *a2, const __m128i *a3, size_t a4);
const __m128i *__fastcall sub_1461A7560(const __m128i *a1, const __m128i *a2, const __m128i *a3, __int64 a4);
__int64 __fastcall sub_1461A7770(const __m128i *a1, unsigned __int64 a2, __m128i *a3, unsigned __int64 a4);
__int64 __fastcall sub_1461A7810(__int64, __int64, unsigned __int8);
const __m128i *__fastcall sub_1461A7820(const __m128i *, const __m128i *, unsigned __int8);
const __m128i *__fastcall sub_1461A7830(const __m128i *, const __m128i *, __int16);
__int64 __fastcall sub_1461A7840(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_1461A7850(_QWORD, _QWORD, _QWORD, _QWORD); // weak
// void __fastcall __noreturn std::_Xlength_error(const char *); idb
// void __fastcall std::_Xout_of_range(const char *); idb
// int __cdecl Thrd_join(_Thrd_t *__struct_ptr, int *);
// _Thrd_id_t __cdecl Thrd_id();
// void __cdecl Cnd_do_broadcast_at_thread_exit();
// void __fastcall std::_Throw_Cpp_error(int); idb
// void std::_Xbad_function_call(void); idb
// int __cdecl Thrd_detach(_Thrd_t *__struct_ptr);
void *__fastcall sub_1461A7888(__int64 a1);
// struct std::locale::_Locimp *std::locale::_Getgloballocale(void); idb
// struct _iobuf *__fastcall std::_Fiopen(const wchar_t *, int, int); idb
// void std::_Xbad_alloc(void); idb
// int __cdecl Mbrtowc(wchar_t *, const char *, size_t, mbstate_t *, const _Cvtvec *);
// struct std::locale::_Locimp *__fastcall std::locale::_Init(bool); idb
// void *__fastcall operator new(size_t Size); idb
void __cdecl j_j_free(void *Block);
char sub_1461A79C4();
char __fastcall sub_1461A7A48(int a1);
// int __cdecl atexit(void (__cdecl *)());
void __fastcall sub_1461A7C4C(_DWORD *a1);
// __int64 __fastcall Init_thread_footer(_QWORD); weak
void __fastcall sub_1461A7CF4(_DWORD *a1);
// __int64 __fastcall _tlregdtor(_QWORD); weak
__int64 __fastcall sub_1461A7ED4(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_1461A7FF0(_QWORD *a1, char a2);
void *__fastcall operator new(size_t Size); // idb
// void __fastcall `eh vector destructor iterator'(void *, unsigned __int64, unsigned __int64, void (__fastcall *)(void *)); idb
__int64 __fastcall sub_1461A80F8(__int64 a1, __int64 a2, __int64 a3, __int64 (__fastcall *a4)(__int64));
__int64 sub_1461A81C0(void); // weak
int __fastcall dllmain_crt_dispatch(HINSTANCE, unsigned int, void *const); // idb
__int64 sub_1461A88D4(void); // weak
_QWORD *__fastcall sub_1461A8B6C(_QWORD *a1);
void __noreturn sub_1461A8B90(); // weak
void sub_1461A8BC4();
bool sub_1461A8D60();
LPTOP_LEVEL_EXCEPTION_FILTER sub_1461A8DB4();
__int64 __fastcall sub_1461A8DC4(_QWORD *a1);
void sub_1461A8E28();
__int64 sub_1461A8E38(); // weak
void *sub_1461A8E44();
__int64 (__fastcall **sub_1461A8E68())();
void sub_1461A8E70();
void __fastcall sub_1461A8EAC();
__int64 (__fastcall **sub_1461A8EFC())();
// __int64 __fastcall _std_exception_copy(_QWORD); weak
// __int64 __fastcall _std_exception_destroy(_QWORD); weak
// void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount);
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);
// wchar_t *__cdecl wcsstr(const wchar_t *Str, const wchar_t *SubStr);
// wchar_t *__cdecl wcschr(const wchar_t *Str, wchar_t Ch);
// wchar_t *__cdecl wcsrchr(const wchar_t *Str, wchar_t Ch);
// _purecall_handler __cdecl set_purecall_handler(_purecall_handler Handler);
// __int64 _current_exception(void); weak
// __int64 _current_exception_context(void); weak
// __int64 __fastcall _std_type_info_destroy_list(_QWORD); weak
// int __cdecl dsign(double X);
// int __cdecl ldsign(long double X);
// int __cdecl fdsign(float X);
// __int16 __cdecl dclass(double X);
// __int16 __cdecl fdclass(float X);
// __int16 __cdecl ldclass(long double X);
// size_t __cdecl strlen(const char *Str);
// size_t __cdecl wcslen(const wchar_t *String);
// wchar_t *__cdecl wcscpy(wchar_t *Destination, const wchar_t *Source);
// errno_t __cdecl gmtime64_s(struct tm *Tm, const __time64_t *Time);
// size_t __cdecl strftime(char *Buffer, size_t SizeInBytes, const char *Format, const struct tm *Tm);
// __time64_t __cdecl time64(__time64_t *Time);
// __int64 terminate(void); weak
// uintptr_t __cdecl beginthreadex(void *Security, unsigned int StackSize, _beginthreadex_proc_type StartAddress, void *ArgList, unsigned int InitFlag, unsigned int *ThrdAddr);
// int __cdecl wunlink(const wchar_t *FileName);
// int __cdecl wstat64i32(const wchar_t *FileName, struct _stat64i32 *Stat);
// int __cdecl unlink(const char *FileName);
// int __cdecl wrename(const wchar_t *OldFileName, const wchar_t *NewFileName);
// struct lconv *__cdecl localeconv();
void sub_1461AE220();
void __fastcall sub_1461AE260();
void __fastcall sub_1461AE270();
void sub_1461AE280();
void __fastcall sub_1461AE2C0();
void sub_1461AE330();
void sub_1461AE3E0();
void __fastcall sub_1461AE460();
void __fastcall sub_1461AE4F0();
__int64 sub_1461AE570(); // weak
void __fastcall sub_1461AE5F0();
void __fastcall sub_1461AE660();
void __fastcall sub_1461AE700();
void __fastcall sub_1461AE710();
void __fastcall sub_1461AE780();
void __fastcall sub_1461AE7C0();
void __fastcall sub_1461AE840();
void __fastcall sub_1461AE890();
void __fastcall sub_1461AE900();
void __fastcall sub_1461AE950();
void __fastcall sub_1461AE9C0();
_QWORD *sub_1461AE9E0();
_QWORD *sub_1461AEA70();
void __fastcall sub_1461AEB00();
void __fastcall sub_1461AEB80();
void __fastcall sub_1461AEBF0();
void __fastcall sub_1461AEC54();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_146106000; // weak
_UNKNOWN unk_146106008; // weak
_UNKNOWN unk_146106028; // weak
_UNKNOWN unk_146106030; // weak
_UNKNOWN unk_146106050; // weak
void *qword_1461090A0 = NULL; // idb
_UNKNOWN unk_1461090B0; // weak
__int64 qword_1461090B8 = 15i64; // weak
int dword_1461090C0 = -1; // weak
int dword_1461090C4 = -1; // weak
wchar_t *FileName = NULL; // idb
__int128 xmmword_1461090D8 = 0x70000000000000000i64; // weak
wchar_t *off_146109100[20] =
{
  L"d3d11.dll",
  L"d2d1.dll",
  L"d3dcompiler_47.dll",
  L"dwrite.dll",
  L"ole32.dll",
  L"shcore.dll",
  L"api-ms-win-core-winrt-error-l1-1-1.dll",
  L"api-ms-win-core-winrt-l1-1-0.dll",
  L"api-ms-win-core-winrt-error-l1-1-0.dll",
  L"api-ms-win-core-winrt-string-l1-1-0.dll",
  L"api-ms-win-shcore-stream-winrt-l1-1-0.dll",
  L"version.dll",
  L"dwmapi.dll",
  L"bcrypt.dll",
  L"wininet.dll",
  L"rpcrt4.dll",
  L"winmm.dll",
  L"dbghelp.dll",
  L"shlwapi.dll",
  L"ws2_32.dll"
}; // weak
_UNKNOWN unk_1461091A0; // weak
__int128 xmmword_1461099B8 = 0x0FFFFFFFF00000000i64; // weak
__int64 qword_1461099C8 = 1099511635968i64; // weak
__int128 xmmword_1461099D0 = 0x0FFFFFFFF00000000i64; // weak
__int64 qword_1461099E0 = 1099511635968i64; // weak
__int128 xmmword_1461099E8 = 0x0FFFFFFFF00000000i64; // weak
__int64 qword_1461099F8 = 1099511635968i64; // weak
int dword_146109A04 = 2147483648; // weak
uintptr_t _security_cookie = 47936899621426ui64;
__int64 qword_146109A80 = -47936899621427i64; // weak
__int64 qword_146109A90 = -1i64; // weak
int dword_146109A98 = 1; // weak
int dword_146109A9C = 2; // weak
__int64 qword_146109AA0 = 524288i64; // weak
__int64 qword_146109AA8 = 33554432i64; // weak
_UNKNOWN _lambda_4cf28de73b92b3a2e651a2f1f6480e01_ `RTTI Type Descriptor'; // weak
_UNKNOWN _lambda_0f47cb7c548717280bc83b7ce23c8970_ `RTTI Type Descriptor'; // weak
_UNKNOWN _lambda_f42722e5fe4e40ac09c541a5093d66ae_ `RTTI Type Descriptor'; // weak
_UNKNOWN _lambda_b697347c6c0928237e401262969d5641_ `RTTI Type Descriptor'; // weak
_UNKNOWN unk_14610A950; // weak
void *Block = NULL; // idb
__int64 qword_14610A960 = 0i64; // weak
__int64 qword_14610A968 = 0i64; // weak
int dword_14610A970 = 0; // weak
int dword_14610A974 = 0; // weak
char byte_14610A978 = '\0'; // weak
__int64 qword_14610A980 = 0i64; // weak
__int64 qword_14610A988 = 0i64; // weak
void *qword_14610A990 = NULL; // idb
__int128 xmmword_14610A998 = 0i64; // weak
char byte_14610A9A8 = '\0'; // weak
int dword_14610A9AC = 0; // weak
char byte_14610A9B0 = '\0'; // weak
int dword_14610A9B4 = 0; // weak
char byte_14610A9B8 = '\0'; // weak
int dword_14610A9BC = 0; // weak
__int64 qword_14610A9C0 = 0i64; // weak
HANDLE hObject = NULL; // idb
LPCVOID lpBaseAddress = NULL; // idb
int dword_14610A9D8 = 0; // weak
int dword_14610A9DC = 0; // weak
RTL_CONDITION_VARIABLE ConditionVariable = { NULL }; // idb
RTL_SRWLOCK SRWLock = { NULL }; // idb
__int64 qword_14610A9F0 = 0i64; // weak
__int64 qword_14610A9F8 = 0i64; // weak
__int64 qword_14610AA08; // weak
int dword_14610AA10; // weak
__int64 qword_14610AA18; // weak
RTL_SRWLOCK stru_14610AA20; // idb
__int64 qword_14610AA28; // weak
__int16 word_14610AA30; // weak
__int16 word_14610AA32; // weak
__int16 word_14610AA36; // weak
__int16 word_14610AA38; // weak
__int16 word_14610AA3A; // weak
__int16 word_14610AA3C; // weak
int dword_14610AA40; // weak
__int64 qword_14610AA48; // weak
int dword_14610AA50; // weak
void *qword_14610AA58; // idb
__int128 xmmword_14610AA68; // weak
int dword_14610AA78; // weak
__int64 qword_14610AA80; // weak
__int64 qword_14610AA88; // weak
struct _SYSTEMTIME stru_14610AA90; // weak
void *qword_14610AAA0; // idb
__int64 qword_14610AAA8; // weak
__int64 qword_14610AAB0; // weak
char byte_14610AAB8; // weak
int dword_14610AABC; // weak
__int128 xmmword_14610AAC0; // weak
__int64 qword_14610AAD0; // weak
void *qword_14610AAD8; // idb
__int64 qword_14610AAE0; // weak
void *qword_14610AAE8; // idb
HANDLE hEvent; // idb
__int64 qword_14610AB00; // weak
HMODULE hModule; // idb
void *qword_14610AB10; // idb
__int64 qword_14610AB18; // weak
void *qword_14610AB20; // idb
__int64 qword_14610AB28; // weak
wchar_t String[32768]; // weak
HANDLE qword_14611AB30; // idb
LPCVOID qword_14611AB38; // idb
int dword_14611AB40; // weak
HANDLE qword_14611AB48; // idb
LPCVOID qword_14611AB50; // idb
int dword_14611AB58; // weak
void *qword_14611AB60; // idb
_UNKNOWN unk_14611AB70; // weak
__int64 qword_14611AB78; // weak
int dword_14611AB80; // weak
__int64 qword_14611AB88; // weak
__int64 qword_14611AB90; // weak
void *qword_14611AB98; // idb
__int64 qword_14611ABA0; // weak
int qword_14611ABA8; // idb
char byte_14611ABB0; // weak
char byte_14611ABB1; // weak
char *Destination; // idb
WCHAR Buffer; // idb
int dword_14611AC70; // weak
__int64 qword_14611AC80; // weak
__int64 qword_14611AC88; // weak
__int64 qword_14611AC90; // weak
_UNKNOWN unk_14611ACA0; // weak
__int128 xmmword_14611ACC0; // weak
_UNKNOWN unk_14611ACD0; // weak
__int64 qword_14611ACD8; // weak
int dword_14611ACE0; // weak
int dword_14611ACE4; // weak
int dword_14611ACE8; // weak
__int64 qword_14611ACF0; // weak
__int64 qword_14611ACF8; // weak
__int64 (__fastcall *qword_14611AD00)(_QWORD, _QWORD, _QWORD); // weak
int dword_14611AD08; // weak
__int64 qword_14611AD10; // weak
__int64 qword_14611AD18; // weak
__int64 qword_14611AD20; // weak
__int64 qword_14611AD38; // weak
__int64 qword_14611AD40; // weak
void *qword_14611AD48; // idb
__int64 qword_14611AD50; // weak
__int64 qword_14611AD58; // weak
__int128 xmmword_14611AD68; // weak
int dword_14611AD78; // weak
__int64 qword_14611AD80; // weak
int dword_14611AD88; // weak
__int64 qword_14611AD90; // weak
__int64 qword_14611AD98; // weak
int dword_14611ADA0; // weak
__int64 qword_14611ADA8; // weak
int dword_14611ADB0; // weak
__int64 qword_14611ADB8; // weak
int dword_14611ADC0; // weak
void *qword_14611ADC8; // idb
__int64 qword_14611ADD0; // weak
__int64 qword_14611ADD8; // weak
int dword_14611ADE0; // weak
int dword_14611ADE4; // weak
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
void *qword_14611AE10; // idb
char byte_14611AE30; // weak
RTL_CONDITION_VARIABLE stru_14611AE68; // idb
RTL_SRWLOCK stru_14611AE70; // idb
int TlsIndex; // weak
int dword_14611B3F0; // weak
int dword_14611B3F4; // weak
int dword_14611B3F8; // weak
union _SLIST_HEADER stru_14611B400; // weak
_UNKNOWN unk_14611B410; // weak
__int64 qword_14611B450; // weak
__int64 qword_14611B458; // weak
// extern LSTATUS (__stdcall *RegSetKeyValueW)(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegOpenKeyW)(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegEnumValueW)(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegDeleteValueW)(HKEY hKey, LPCWSTR lpValueName);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern BOOL (__stdcall *GetFileAttributesExW)(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern DWORD (__stdcall *GetLastError)();
// extern PVOID (__stdcall *AddVectoredExceptionHandler)(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern void (__stdcall *GetStartupInfoW)(LPSTARTUPINFOW lpStartupInfo);
// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern HANDLE (__stdcall *CreateFileMappingW)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
// extern LPVOID (__stdcall *MapViewOfFile)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// extern BOOL (__stdcall *UnmapViewOfFile)(LPCVOID lpBaseAddress);
// extern DWORD (__stdcall *GetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern BOOL (__stdcall *CreateDirectoryW)(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// extern void (__stdcall *ReleaseSRWLockExclusive)(PSRWLOCK SRWLock);
// extern void (__stdcall *AcquireSRWLockExclusive)(PSRWLOCK SRWLock);
// extern void (__stdcall *WakeAllConditionVariable)(PCONDITION_VARIABLE ConditionVariable);
// extern BOOL (__stdcall *SleepConditionVariableSRW)(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags);
// extern HANDLE (__stdcall *CreateMutexW)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
// extern HANDLE (__stdcall *OpenMutexW)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern HANDLE (__stdcall *GetCurrentThread)();
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern void (__stdcall *GetSystemTime)(LPSYSTEMTIME lpSystemTime);
// extern ULONGLONG (__stdcall *GetTickCount64)();
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern ULONGLONG (__stdcall *VerSetConditionMask)(ULONGLONG ConditionMask, DWORD TypeMask, BYTE Condition);
// extern HANDLE (__stdcall *OpenThread)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId);
// extern DWORD (__stdcall *SuspendThread)(HANDLE hThread);
// extern DWORD (__stdcall *ResumeThread)(HANDLE hThread);
// extern BOOL (__stdcall *GetThreadContext)(HANDLE hThread, LPCONTEXT lpContext);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *VerifyVersionInfoW)(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask);
// extern BOOLEAN (__cdecl *RtlAddFunctionTable)(PRUNTIME_FUNCTION FunctionTable, ULONG EntryCount, ULONG64 BaseAddress);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern DWORD (__stdcall *FormatMessageW)(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
// extern DWORD (__stdcall *GetEnvironmentVariableW)(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// extern BOOL (__stdcall *SetEnvironmentVariableW)(LPCWSTR lpName, LPCWSTR lpValue);
// extern BOOL (__stdcall *SetCurrentDirectoryW)(LPCWSTR lpPathName);
// extern DWORD (__stdcall *GetCurrentDirectoryW)(DWORD nBufferLength, LPWSTR lpBuffer);
// extern DWORD (__stdcall *GetFullPathNameW)(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern HANDLE (__stdcall *CreateEventW)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// extern BOOL (__stdcall *GetExitCodeProcess)(HANDLE hProcess, LPDWORD lpExitCode);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern UINT (__stdcall *GetSystemDirectoryW)(LPWSTR lpBuffer, UINT uSize);
// extern BOOL (__stdcall *IsProcessInJob)(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result);
// extern HANDLE (__stdcall *CreateJobObjectW)(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName);
// extern BOOL (__stdcall *AssignProcessToJobObject)(HANDLE hJob, HANDLE hProcess);
// extern BOOL (__stdcall *SetInformationJobObject)(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength);
// extern BOOL (__stdcall *SetDllDirectoryW)(LPCWSTR lpPathName);
// extern BOOL (__stdcall *DeleteFileW)(LPCWSTR lpFileName);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *CreateProcessW)(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern UINT (__stdcall *GetPrivateProfileIntW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName);
// extern BOOL (__stdcall *CopyFileW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
// extern BOOL (__stdcall *MoveFileW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern HMODULE (__stdcall *LoadLibraryW)(LPCWSTR lpLibFileName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern DWORD (__stdcall *GetFileAttributesW)(LPCWSTR lpFileName);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern BOOL (__stdcall *SetThreadContext)(HANDLE hThread, const CONTEXT *lpContext);
// extern BOOL (__stdcall *IsDebuggerPresent)();
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern SIZE_T (__stdcall *VirtualQueryEx)(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// extern DWORD (__stdcall *GetProcessId)(HANDLE Process);
// extern HANDLE (__stdcall *CreateSemaphoreW)(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);
// extern BOOL (__stdcall *ReleaseSemaphore)(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern DWORD (__stdcall *WaitForMultipleObjects)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// extern BOOL (__stdcall *ResetEvent)(HANDLE hEvent);
// extern BOOL (__stdcall *WaitNamedPipeW)(LPCWSTR lpNamedPipeName, DWORD nTimeOut);
// extern BOOL (__stdcall *TransactNamedPipe)(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *SetNamedPipeHandleState)(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout);
// extern void (__stdcall *OutputDebugStringA)(LPCSTR lpOutputString);
// extern DWORD (__stdcall *GetPrivateProfileStringW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern int std::locale::id::_Id_cnt; weak
// extern _UNKNOWN std::codecvt<char,char,_Mbstatet>::id; weak
// extern _UNKNOWN std::numpunct<char>::id; weak
// extern _UNKNOWN std::numpunct<wchar_t>::id; weak
// extern HRESULT (__stdcall *SetCurrentProcessExplicitAppUserModelID)(PCWSTR AppID);
// extern LPWSTR *(__stdcall *CommandLineToArgvW)(LPCWSTR lpCmdLine, int *pNumArgs);
// extern int (__stdcall *MessageBoxW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
// extern unsigned __int64 (__cdecl *wcstoull)(const wchar_t *String, wchar_t **EndPtr, int Radix);
// extern double (__cdecl *strtod)(const char *String, char **EndPtr);
// extern unsigned __int64 (__cdecl *strtoull)(const char *String, char **EndPtr, int Radix);
// extern __int64 (__cdecl *strtoll)(const char *String, char **EndPtr, int Radix);
// extern char *(__cdecl *getenv)(const char *VarName);
// extern void (__cdecl *unlock_file)(FILE *Stream);
// extern void (__cdecl *lock_file)(FILE *Stream);
// extern void *(__cdecl *malloc_0)(size_t Size);
// extern void *(__cdecl *calloc)(size_t Count, size_t Size);
// extern void *(__cdecl *realloc_0)(void *Block, size_t Size);
// extern void (__cdecl *free_0)(void *Block);
// extern struct lconv *(__cdecl *localeconv)();
// extern void (__cdecl *invalid_parameter_noinfo)();
// extern void (__cdecl __noreturn *exit)(int Code);
// extern _invalid_parameter_handler (__cdecl *set_invalid_parameter_handler)(_invalid_parameter_handler Handler);
// extern void (__cdecl __noreturn *invoke_watson)(const wchar_t *Expression, const wchar_t *FunctionName, const wchar_t *FileName, unsigned int LineNo, uintptr_t Reserved);
// extern int *(__cdecl *errno)();
// extern int (__cdecl *_stdio_common_vsnwprintf_s)(unsigned __int64 Options, wchar_t *Buffer, size_t BufferCount, size_t MaxCount, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern size_t (__cdecl *fread)(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// extern int (__cdecl *fseek)(FILE *Stream, int Offset, int Origin);
// extern int (__cdecl *ftell)(FILE *Stream);
// extern size_t (__cdecl *fwrite)(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// extern __int64 (__cdecl *ftelli64)(FILE *Stream);
// extern int (__cdecl *_stdio_common_vsnprintf_s)(unsigned __int64 Options, char *Buffer, size_t BufferCount, size_t MaxCount, const char *Format, _locale_t Locale, va_list ArgList);
// extern FILE *(__cdecl *wfopen)(const wchar_t *FileName, const wchar_t *Mode);
// extern int (__cdecl *fclose)(FILE *Stream);
// extern FILE *(__cdecl *_acrt_iob_func)(unsigned int Ix);
// extern int (__cdecl *ungetc)(int Character, FILE *Stream);
// extern int (__cdecl *setvbuf)(FILE *Stream, char *Buffer, int Mode, size_t Size);
// extern int (__cdecl *fseeki64)(FILE *Stream, __int64 Offset, int Origin);
// extern int (__cdecl *fsetpos)(FILE *Stream, const fpos_t *Position);
// extern int (__cdecl *fputc)(int Character, FILE *Stream);
// extern int (__cdecl *fgetpos)(FILE *Stream, fpos_t *Position);
// extern int (__cdecl *fgetc)(FILE *Stream);
// extern int (__cdecl *fflush)(FILE *Stream);
// extern errno_t (__cdecl *get_stream_buffer_pointers)(FILE *Stream, char ***Base, char ***Pointer, int **Count);
// extern int (__cdecl *_stdio_common_vfprintf)(unsigned __int64 Options, FILE *Stream, const char *Format, _locale_t Locale, va_list ArgList);
// extern int (__cdecl *wcsicmp)(const wchar_t *String1, const wchar_t *String2);
// extern int (__cdecl *wcsnicmp)(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// extern int (__cdecl *stricmp)(const char *String1, const char *String2);
// extern char *(__cdecl *strncpy)(char *Destination, const char *Source, size_t Count);
// extern wchar_t *(__cdecl *wcsncpy)(wchar_t *Destination, const wchar_t *Source, size_t Count);
// extern errno_t (__cdecl *wcscpy_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// extern int (__cdecl *isalnum)(int C);
// extern errno_t (__cdecl *wcscat_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// extern PEXCEPTION_ROUTINE (__stdcall *RtlVirtualUnwind)(ULONG HandlerType, ULONG64 ImageBase, ULONG64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PULONG64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers);
// extern void (__stdcall *RtlCaptureContext)(PCONTEXT ContextRecord);
void *std::exception::`vftable' = &CMenuHash::`scalar deleting destructor'; // weak
void *std::bad_alloc::`vftable' = &CMenuHash::`scalar deleting destructor'; // weak
void *std::bad_array_new_length::`vftable' = &CMenuHash::`scalar deleting destructor'; // weak
void *std::runtime_error::`vftable' = &CMenuHash::`scalar deleting destructor'; // weak
const char Src[11] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
void *fmt::v8::format_error::`vftable' = &CMenuHash::`scalar deleting destructor'; // weak
char a00010203040506[217] = "000102030405060708091011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798990123456789abcdef"; // weak
char byte_14611CFAC[4] = { '\0', '-', '+', ' ' }; // weak
int dword_14611CFB0[] = { 0 }; // weak
_BYTE byte_14611CFC0[8] = { 31, 31, 0, 1, 0, 0, 0, 0 }; // weak
_BYTE byte_14611CFC8[8] = { 0, 31, 0, 1, 0, 0, 0, 0 }; // weak
__int64 qword_14611CFD0[32] =
{
  4294967296i64,
  4294967296i64,
  4294967296i64,
  8589934582i64,
  8589934582i64,
  8589934582i64,
  12884901788i64,
  12884901788i64,
  12884901788i64,
  17179868184i64,
  17179868184i64,
  17179868184i64,
  21474826480i64,
  21474826480i64,
  21474826480i64,
  25769703776i64,
  25769703776i64,
  25769703776i64,
  30063771072i64,
  30063771072i64,
  30063771072i64,
  34349738368i64,
  34349738368i64,
  34349738368i64,
  38554705664i64,
  38554705664i64,
  38554705664i64,
  41949672960i64,
  41949672960i64,
  41949672960i64,
  41949672960i64,
  41949672960i64
}; // weak
void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable' = &sub_146165760; // weak
char a0123456789abcd[17] = "0123456789ABCDEF"; // weak
__int64 qword_14611D2E0[88] =
{
  -391859759250406776i64,
  -4994806998408183946i64,
  -8424269937281487754i64,
  -3512093806901185046i64,
  -7319562523736982739i64,
  -1865951482774665761i64,
  -6093090917745768758i64,
  -38366372719436721i64,
  -4731433901725329908i64,
  -8228041688891786180i64,
  -3219690930897053053i64,
  -7101705404292871755i64,
  -1541319077368263733i64,
  -5851220927660403859i64,
  -9062348037703676329i64,
  -4462904269766699465i64,
  -8027971522334779313i64,
  -2921563150702462265i64,
  -6879582898840692748i64,
  -1210330751515841307i64,
  -5604615407819967858i64,
  -8878612607581929669i64,
  -4189117143640191558i64,
  -7823984217374209642i64,
  -2617598379430861436i64,
  -6653111496142234890i64,
  -872862063775190746i64,
  -5353181642124984136i64,
  -8691279853972075893i64,
  -3909969587797413805i64,
  -7616003081050118571i64,
  -2307682335666372931i64,
  -6422206049907525489i64,
  -528786136287117932i64,
  -5096825099203863601i64,
  -8500279345513818773i64,
  -3625356651333078602i64,
  -7403949918844649556i64,
  -1991698500497491194i64,
  -6186779746782440749i64,
  -177973607073265138i64,
  -4835449396872013077i64,
  -8305539271883716404i64,
  -3335171328526686932i64,
  -7187745005283311616i64,
  -1669528073709551616i64,
  -5946744073709551616i64,
  -9133518327554766460i64,
  -4568956265895094861i64,
  -8106986416796705680i64,
  -3039304518611664792i64,
  -6967307053960650171i64,
  -1341049929119499481i64,
  -5702008784649933400i64,
  -8951176327949752869i64,
  -4297245513042813542i64,
  -7904546130479028392i64,
  -2737644984756826646i64,
  -6742553186979055798i64,
  -1006140569036166267i64,
  -5452481866653427593i64,
  -8765264286586255934i64,
  -4020214983419339459i64,
  -7698142301602209613i64,
  -2430079312244744221i64,
  -6513398903789220827i64,
  -664674077828931748i64,
  -5198069505264599346i64,
  -8575712306248138270i64,
  -3737760522056206171i64,
  -7487697328667536417i64,
  -2116491865831296966i64,
  -6279758049420528746i64,
  -316522074587315140i64,
  -4938676049251384304i64,
  -8382449121214030822i64,
  -3449775934753242068i64,
  -7273132090830278359i64,
  -1796764746270372707i64,
  -6041542782089432023i64,
  -9204148869281624187i64,
  -4674203974643163859i64,
  -8185402070463610993i64,
  -3156152948152813503i64,
  -7054365918152680535i64,
  -1470777745987373095i64,
  -5798663540173640085i64,
  0i64
}; // weak
__int16 word_14611D5A0[88] =
{
  -1220,
  -1193,
  -1166,
  -1140,
  -1113,
  -1087,
  -1060,
  -1034,
  -1007,
  -980,
  -954,
  -927,
  -901,
  -874,
  -847,
  -821,
  -794,
  -768,
  -741,
  -715,
  -688,
  -661,
  -635,
  -608,
  -582,
  -555,
  -529,
  -502,
  -475,
  -449,
  -422,
  -396,
  -369,
  -343,
  -316,
  -289,
  -263,
  -236,
  -210,
  -183,
  -157,
  -130,
  -103,
  -77,
  -50,
  -24,
  3,
  30,
  56,
  83,
  109,
  136,
  162,
  189,
  216,
  242,
  269,
  295,
  322,
  348,
  375,
  402,
  428,
  455,
  481,
  508,
  534,
  561,
  588,
  614,
  641,
  667,
  694,
  720,
  747,
  774,
  800,
  827,
  853,
  880,
  907,
  933,
  960,
  986,
  1013,
  1039,
  1066,
  0
}; // weak
_BYTE byte_14611D650[200] =
{
  48,
  48,
  48,
  49,
  48,
  50,
  48,
  51,
  48,
  52,
  48,
  53,
  48,
  54,
  48,
  55,
  48,
  56,
  48,
  57,
  49,
  48,
  49,
  49,
  49,
  50,
  49,
  51,
  49,
  52,
  49,
  53,
  49,
  54,
  49,
  55,
  49,
  56,
  49,
  57,
  50,
  48,
  50,
  49,
  50,
  50,
  50,
  51,
  50,
  52,
  50,
  53,
  50,
  54,
  50,
  55,
  50,
  56,
  50,
  57,
  51,
  48,
  51,
  49,
  51,
  50,
  51,
  51,
  51,
  52,
  51,
  53,
  51,
  54,
  51,
  55,
  51,
  56,
  51,
  57,
  52,
  48,
  52,
  49,
  52,
  50,
  52,
  51,
  52,
  52,
  52,
  53,
  52,
  54,
  52,
  55,
  52,
  56,
  52,
  57,
  53,
  48,
  53,
  49,
  53,
  50,
  53,
  51,
  53,
  52,
  53,
  53,
  53,
  54,
  53,
  55,
  53,
  56,
  53,
  57,
  54,
  48,
  54,
  49,
  54,
  50,
  54,
  51,
  54,
  52,
  54,
  53,
  54,
  54,
  54,
  55,
  54,
  56,
  54,
  57,
  55,
  48,
  55,
  49,
  55,
  50,
  55,
  51,
  55,
  52,
  55,
  53,
  55,
  54,
  55,
  55,
  55,
  56,
  55,
  57,
  56,
  48,
  56,
  49,
  56,
  50,
  56,
  51,
  56,
  52,
  56,
  53,
  56,
  54,
  56,
  55,
  56,
  56,
  56,
  57,
  57,
  48,
  57,
  49,
  57,
  50,
  57,
  51,
  57,
  52,
  57,
  53,
  57,
  54,
  57,
  55,
  57,
  56,
  57,
  57
}; // weak
int dword_14611D718[10] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 }; // weak
__int128 xmmword_14611D7B0 = 0x6300610063005C0061007400610064i64; // weak
__int128 xmmword_14611D7C0 = 0x72006F007200720065005C00650068i64; // weak
_UNKNOWN unk_14611D8C7; // weak
char a0123456789abcd_0[17] = "0123456789ABCDEF"; // weak
char aUuuuuuuubtnufr[33] = "uuuuuuuubtnufruuuuuuuuuuuuuuuuuu"; // weak
__int128 xmmword_14611DA20 = 0x70000000000000000i64; // weak
__int128 xmmword_14611DA30 = 0x1000000000000000000i64; // weak
__int128 xmmword_14611DA40 = 0x4000000000000000000i64; // weak
__int128 xmmword_14611DA50 = 0x2000000040000000600000000i64; // weak
__int128 xmmword_14611DA60 = 0x60000000C0000001200000000i64; // weak
__int128 xmmword_14611DA70 = 0xF0000001F0000007F00000000i64; // weak
__int128 xmmword_14611DA80 = 0x40303020202020000000000000000i64; // weak
__int128 xmmword_14611DA90 = 0x1010101010101010101010101010101i64; // weak
const size_t Size = 0ui64; // idb
__int128 xmmword_14611E150 = 0xF000000000000000Ci64; // weak
void *fmt::v8::basic_memory_buffer<wchar_t,500,std::allocator<wchar_t>>::`vftable' = &sub_146168A00; // weak
void *moodycamel::ConcurrentQueue<std::tuple<std::string,std::string>,moodycamel::ConcurrentQueueDefaultTraits>::ProducerBase::`vftable' = &sub_146172910; // weak
void *moodycamel::ConcurrentQueue<std::tuple<std::string,std::string>,moodycamel::ConcurrentQueueDefaultTraits>::ImplicitProducer::`vftable' = &CMemDC::`scalar deleting destructor'; // weak
__int128 xmmword_14611ECB0 = 0xF000000000000000Ei64; // weak
__int128 xmmword_14611ECC0 = 0x1F0000000000000013i64; // weak
__int128 xmmword_14611ECD0 = 0x1F0000000000000014i64; // weak
void *std::_Func_impl_no_alloc<_lambda_b697347c6c0928237e401262969d5641_,void,_CONTEXT *>::`vftable' = &sub_146175650; // weak
void *std::_Func_impl_no_alloc<_lambda_f42722e5fe4e40ac09c541a5093d66ae_,void,_CONTEXT *>::`vftable' = &sub_146175660; // weak
void *std::_Func_impl_no_alloc<_lambda_0f47cb7c548717280bc83b7ce23c8970_,void,_CONTEXT *>::`vftable' = &sub_146175620; // weak
void *std::_Func_impl_no_alloc<_lambda_4cf28de73b92b3a2e651a2f1f6480e01_,void,_CONTEXT *>::`vftable' = &sub_146175630; // weak
const wchar_t aW[] = L"w"; // idb
__int128 xmmword_14611F2A0 = 0x6F0066002F00650068006300610063i64; // weak
__int128 xmmword_14611F2B0 = 0x62002E00700065005F0064006E0075i64; // weak
__int64 qword_1461212B8 = 8227625119777058933i64; // weak
__int64 qword_1461217D8 = 3328834625104801909i64; // weak
_BYTE byte_146127D10[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // weak
char aSocialClub[13] = "Social Club/"; // weak
char aLauncher_1[10] = "Launcher/"; // weak
__int128 xmmword_14612A920 = 0xF0000000000000008i64; // weak
__int128 xmmword_14612A930 = 0xF000000000000000Ai64; // weak
__int128 xmmword_14612A940 = 0xF000000000000000Bi64; // weak
__int128 xmmword_14612A950 = 0x5F000000000000005Ai64; // weak
__int128 xmmword_14612A960 = 0x5F000000000000005Bi64; // weak
void *std::bad_cast::`vftable' = &CMenuHash::`scalar deleting destructor'; // weak
const WCHAR Default = 0u; // idb
void *nlohmann::json_abi_v3_11_2::detail::exception::`vftable' = &sub_146187800; // weak
_UNKNOWN unk_14612BC20; // weak
void *nlohmann::json_abi_v3_11_2::detail::parse_error::`vftable' = &sub_146187860; // weak
void *nlohmann::json_abi_v3_11_2::detail::invalid_iterator::`vftable' = &sub_146187800; // weak
void *nlohmann::json_abi_v3_11_2::detail::type_error::`vftable' = &sub_146187800; // weak
void *nlohmann::json_abi_v3_11_2::detail::out_of_range::`vftable' = &sub_146187800; // weak
void *nlohmann::json_abi_v3_11_2::detail::other_error::`vftable' = &sub_146187800; // weak
__m128i stru_14612BCE0[79] =
{
  {
    { -54, -58, -102, -57, 23, -2, 112, -85, -36, -5, -1, -1, -44, -2, -1, -1 }
  },
  { { 79, -36, -68, -66, -4, -79, 119, -1, -10, -5, -1, -1, -36, -2, -1, -1 } },
  { { 12, -42, 107, 65, -17, -111, 86, -66, 17, -4, -1, -1, -28, -2, -1, -1 } },
  { { 60, -4, 127, -112, -83, 31, -48, -115, 44, -4, -1, -1, -20, -2, -1, -1 } },
  { { -125, -102, 85, 49, 40, 92, 81, -45, 70, -4, -1, -1, -12, -2, -1, -1 } },
  {
    { -75, -55, -90, -83, -113, -84, 113, -99, 97, -4, -1, -1, -4, -2, -1, -1 }
  },
  { { -53, -117, -18, 35, 119, 34, -100, -22, 123, -4, -1, -1, 4, -1, -1, -1 } },
  { { 109, 83, 120, 64, -111, 73, -52, -82, -106, -4, -1, -1, 12, -1, -1, -1 } },
  { { 87, -50, -74, 93, 121, 18, 60, -126, -79, -4, -1, -1, 20, -1, -1, -1 } },
  { { 55, 86, -5, 77, 54, -108, 16, -62, -53, -4, -1, -1, 28, -1, -1, -1 } },
  {
    { 79, -104, 72, 56, 111, -22, -106, -112, -26, -4, -1, -1, 36, -1, -1, -1 }
  },
  { { -57, 58, -126, 37, -53, -123, 116, -41, 0, -3, -1, -1, 44, -1, -1, -1 } },
  {
    {
      -12,
      -105,
      -65,
      -105,
      -51,
      -49,
      -122,
      -96,
      27,
      -3,
      -1,
      -1,
      52,
      -1,
      -1,
      -1
    }
  },
  { { -27, -84, 42, 23, -104, 10, 52, -17, 53, -3, -1, -1, 60, -1, -1, -1 } },
  { { -114, -78, 53, 42, -5, 103, 56, -78, 80, -3, -1, -1, 68, -1, -1, -1 } },
  { { 59, 63, -58, -46, -33, -44, -56, -124, 107, -3, -1, -1, 76, -1, -1, -1 } },
  { { -70, -51, -45, 26, 39, 68, -35, -59, -123, -3, -1, -1, 84, -1, -1, -1 } },
  {
    { -106, -55, 37, -69, -50, -97, 107, -109, -96, -3, -1, -1, 92, -1, -1, -1 }
  },
  {
    { -124, -91, 98, 125, 36, 108, -84, -37, -70, -3, -1, -1, 100, -1, -1, -1 }
  },
  { { -10, -38, 95, 13, 88, 102, -85, -93, -43, -3, -1, -1, 108, -1, -1, -1 } },
  {
    { 38, -15, -61, -34, -109, -8, -30, -13, -17, -3, -1, -1, 116, -1, -1, -1 }
  },
  { { -72, 128, -1, -86, -88, -83, -75, -75, 10, -2, -1, -1, 124, -1, -1, -1 } },
  { { -117, 74, 124, 108, 5, 95, 98, -121, 37, -2, -1, -1, -124, -1, -1, -1 } },
  { { 83, 48, -63, 52, 96, -1, -68, -55, 63, -2, -1, -1, -116, -1, -1, -1 } },
  {
    {
      85,
      38,
      -70,
      -111,
      -116,
      -123,
      78,
      -106,
      90,
      -2,
      -1,
      -1,
      -108,
      -1,
      -1,
      -1
    }
  },
  { { -67, 126, 41, 112, 36, 119, -7, -33, 116, -2, -1, -1, -100, -1, -1, -1 } },
  {
    {
      -113,
      -72,
      -27,
      -72,
      -97,
      -67,
      -33,
      -90,
      -113,
      -2,
      -1,
      -1,
      -92,
      -1,
      -1,
      -1
    }
  },
  {
    { -108, 125, 116, -120, -49, 95, -87, -8, -87, -2, -1, -1, -84, -1, -1, -1 }
  },
  {
    {
      -49,
      -101,
      -88,
      -113,
      -109,
      112,
      68,
      -71,
      -60,
      -2,
      -1,
      -1,
      -76,
      -1,
      -1,
      -1
    }
  },
  { { 107, 21, 15, -65, -8, -16, 8, -118, -33, -2, -1, -1, -68, -1, -1, -1 } },
  { { -74, 49, 49, 101, 85, 37, -80, -51, -7, -2, -1, -1, -60, -1, -1, -1 } },
  {
    { -84, 127, 123, -48, -58, -30, 63, -103, 20, -1, -1, -1, -52, -1, -1, -1 }
  },
  { { 6, 59, 43, 42, -60, 16, 92, -28, 46, -1, -1, -1, -44, -1, -1, -1 } },
  {
    { -45, -110, 115, 105, -103, 36, 36, -86, 73, -1, -1, -1, -36, -1, -1, -1 }
  },
  { { 14, -54, 0, -125, -14, -75, -121, -3, 99, -1, -1, -1, -28, -1, -1, -1 } },
  { { -21, 26, 17, -110, 100, 8, -27, -68, 126, -1, -1, -1, -20, -1, -1, -1 } },
  {
    { -52, -120, 80, 111, 9, -52, -68, -116, -103, -1, -1, -1, -12, -1, -1, -1 }
  },
  { { 44, 101, 25, -30, 88, 23, -73, -47, -77, -1, -1, -1, -4, -1, -1, -1 } },
  { { 0, 0, 0, 0, 0, 0, 64, -100, -50, -1, -1, -1, 4, 0, 0, 0 } },
  { { 0, 0, 0, 0, 16, -91, -44, -24, -24, -1, -1, -1, 12, 0, 0, 0 } },
  { { 0, 0, 98, -84, -59, -21, 120, -83, 3, 0, 0, 0, 20, 0, 0, 0 } },
  { { -124, 9, -108, -8, 120, 57, 63, -127, 30, 0, 0, 0, 28, 0, 0, 0 } },
  { { -77, 21, 7, -55, 123, -50, -105, -64, 56, 0, 0, 0, 36, 0, 0, 0 } },
  { { 112, 92, -22, 123, -50, 50, 126, -113, 83, 0, 0, 0, 44, 0, 0, 0 } },
  { { 104, 128, -23, -85, -92, 56, -46, -43, 109, 0, 0, 0, 52, 0, 0, 0 } },
  { { 69, 34, -102, 23, 38, 39, 79, -97, -120, 0, 0, 0, 60, 0, 0, 0 } },
  { { 39, -5, -60, -44, 49, -94, 99, -19, -94, 0, 0, 0, 68, 0, 0, 0 } },
  { { -88, -83, -56, -116, 56, 101, -34, -80, -67, 0, 0, 0, 76, 0, 0, 0 } },
  { { -37, 101, -85, 26, -114, 8, -57, -125, -40, 0, 0, 0, 84, 0, 0, 0 } },
  { { -102, 29, 113, 66, -7, 29, 93, -60, -14, 0, 0, 0, 92, 0, 0, 0 } },
  { { 88, -25, 27, -90, 44, 105, 77, -110, 13, 1, 0, 0, 100, 0, 0, 0 } },
  { { -22, -115, 112, 26, 100, -18, 1, -38, 39, 1, 0, 0, 108, 0, 0, 0 } },
  { { 74, 119, -17, -102, -103, -93, 109, -94, 66, 1, 0, 0, 116, 0, 0, 0 } },
  { { -123, 107, 125, -76, 123, 120, 9, -14, 92, 1, 0, 0, 124, 0, 0, 0 } },
  { { 119, 24, -35, 121, -95, -28, 84, -76, 119, 1, 0, 0, -124, 0, 0, 0 } },
  { { -62, -59, -101, 91, -110, -122, 91, -122, -110, 1, 0, 0, -116, 0, 0, 0 } },
  { { 61, 93, -106, -56, -59, 83, 53, -56, -84, 1, 0, 0, -108, 0, 0, 0 } },
  { { -77, -96, -105, -6, 92, -76, 42, -107, -57, 1, 0, 0, -100, 0, 0, 0 } },
  { { -29, 95, -96, -103, -67, -97, 70, -34, -31, 1, 0, 0, -92, 0, 0, 0 } },
  { { 37, -116, 57, -37, 52, -62, -101, -91, -4, 1, 0, 0, -84, 0, 0, 0 } },
  { { 92, -97, -104, -93, 114, -102, -58, -10, 22, 2, 0, 0, -76, 0, 0, 0 } },
  { { -50, -66, -23, 84, 83, -65, -36, -73, 49, 2, 0, 0, -68, 0, 0, 0 } },
  { { -30, 65, 34, -14, 23, -13, -4, -120, 76, 2, 0, 0, -60, 0, 0, 0 } },
  { { -91, 120, 92, -45, -101, -50, 32, -52, 102, 2, 0, 0, -52, 0, 0, 0 } },
  { { -33, 83, 33, 123, -13, 90, 22, -104, -127, 2, 0, 0, -44, 0, 0, 0 } },
  { { 58, 48, 31, -105, -36, -75, -96, -30, -101, 2, 0, 0, -36, 0, 0, 0 } },
  { { -106, -77, -29, 92, 83, -47, -39, -88, -74, 2, 0, 0, -28, 0, 0, 0 } },
  { { 60, 68, -89, -92, -39, 124, -101, -5, -48, 2, 0, 0, -20, 0, 0, 0 } },
  { { 16, 68, -92, -89, 76, 76, 118, -69, -21, 2, 0, 0, -12, 0, 0, 0 } },
  { { 26, -100, 64, -74, -17, -114, -85, -117, 6, 3, 0, 0, -4, 0, 0, 0 } },
  { { 44, -124, 87, -90, 16, -17, 31, -48, 32, 3, 0, 0, 4, 1, 0, 0 } },
  { { 41, 49, -111, -23, -27, -92, 16, -101, 59, 3, 0, 0, 12, 1, 0, 0 } },
  { { -99, 12, -100, -95, -5, -101, 16, -25, 85, 3, 0, 0, 20, 1, 0, 0 } },
  { { 41, -12, 59, 98, -39, 32, 40, -84, 112, 3, 0, 0, 28, 1, 0, 0 } },
  { { -123, -49, -89, 122, 94, 75, 68, 128, -117, 3, 0, 0, 36, 1, 0, 0 } },
  { { 45, -35, -84, 3, 64, -28, 33, -65, -91, 3, 0, 0, 44, 1, 0, 0 } },
  { { -113, -1, 68, 94, 47, -100, 103, -114, -64, 3, 0, 0, 52, 1, 0, 0 } },
  { { 65, -72, -116, -100, -99, 23, 51, -44, -38, 3, 0, 0, 60, 1, 0, 0 } },
  { { -87, 27, -29, -76, -110, -37, 25, -98, -11, 3, 0, 0, 68, 1, 0, 0 } }
}; // weak
void *std::filebuf::`vftable' = &CAnimationGroup::`scalar deleting destructor'; // weak
void *std::ifstream::`vftable' = &sub_146187690; // weak
_UNKNOWN unk_14612C260; // weak
const wchar_t asc_14612C3A4[] = L"\\"; // idb
void *std::_Ref_count_obj2<fx::MinModeManifest>::`vftable' = &sub_14618AEC0; // weak
_UNKNOWN unk_14612CB30; // weak
_UNKNOWN unk_14612CB34; // weak
_UNKNOWN unk_14612CB38; // weak
_UNKNOWN unk_14612CB3C; // weak
_UNKNOWN unk_14612CB40; // weak
_UNKNOWN unk_14612CB44; // weak
void *nlohmann::json_abi_v3_11_2::detail::output_string_adapter<char,std::string>::`vftable' = &sub_146192F30; // weak
int dword_14612CC44 = 1634890337; // weak
int dword_14612CC4C = 1701470831; // weak
char a00010203040506_0[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899"; // weak
char a00010203040506_1[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899"; // weak
_BYTE byte_14612CE20[200] =
{
  48,
  48,
  48,
  49,
  48,
  50,
  48,
  51,
  48,
  52,
  48,
  53,
  48,
  54,
  48,
  55,
  48,
  56,
  48,
  57,
  49,
  48,
  49,
  49,
  49,
  50,
  49,
  51,
  49,
  52,
  49,
  53,
  49,
  54,
  49,
  55,
  49,
  56,
  49,
  57,
  50,
  48,
  50,
  49,
  50,
  50,
  50,
  51,
  50,
  52,
  50,
  53,
  50,
  54,
  50,
  55,
  50,
  56,
  50,
  57,
  51,
  48,
  51,
  49,
  51,
  50,
  51,
  51,
  51,
  52,
  51,
  53,
  51,
  54,
  51,
  55,
  51,
  56,
  51,
  57,
  52,
  48,
  52,
  49,
  52,
  50,
  52,
  51,
  52,
  52,
  52,
  53,
  52,
  54,
  52,
  55,
  52,
  56,
  52,
  57,
  53,
  48,
  53,
  49,
  53,
  50,
  53,
  51,
  53,
  52,
  53,
  53,
  53,
  54,
  53,
  55,
  53,
  56,
  53,
  57,
  54,
  48,
  54,
  49,
  54,
  50,
  54,
  51,
  54,
  52,
  54,
  53,
  54,
  54,
  54,
  55,
  54,
  56,
  54,
  57,
  55,
  48,
  55,
  49,
  55,
  50,
  55,
  51,
  55,
  52,
  55,
  53,
  55,
  54,
  55,
  55,
  55,
  56,
  55,
  57,
  56,
  48,
  56,
  49,
  56,
  50,
  56,
  51,
  56,
  52,
  56,
  53,
  56,
  54,
  56,
  55,
  56,
  56,
  56,
  57,
  57,
  48,
  57,
  49,
  57,
  50,
  57,
  51,
  57,
  52,
  57,
  53,
  57,
  54,
  57,
  55,
  57,
  56,
  57,
  57
}; // weak
void *std::_Ref_count_obj2<nlohmann::json_abi_v3_11_2::detail::output_string_adapter<char,std::string>>::`vftable' = &sub_14618AEB0; // weak
char byte_14612D028[8] = { '\xEF', '\xBF', '\xBD', '\0', '\0', '\0', '\0', '\0' }; // weak
unsigned __int8 byte_14612D1E0[400] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  9u,
  9u,
  9u,
  9u,
  9u,
  9u,
  9u,
  9u,
  9u,
  9u,
  9u,
  9u,
  9u,
  9u,
  9u,
  9u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  8u,
  8u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  10u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  4u,
  3u,
  3u,
  11u,
  6u,
  6u,
  6u,
  5u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  0u,
  1u,
  2u,
  3u,
  5u,
  8u,
  7u,
  1u,
  1u,
  1u,
  4u,
  6u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  3u,
  1u,
  3u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  3u,
  1u,
  1u,
  1u,
  1u,
  1u,
  3u,
  1u,
  3u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  3u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // weak
__int128 xmmword_14612E0F0 = 0xF0000000000000005i64; // weak
__int128 xmmword_14612E100 = 0xF0000000000000006i64; // weak
__int128 xmmword_14612E110 = 0x1F0000000000000010i64; // weak
__int128 xmmword_14612E120 = 0x20F0000000000000200i64; // weak
__int128 xmmword_14612E130 = 0xBF000000800000008F00000080i64; // weak
__int128 xmmword_14612E140 = 0xBF000000800000009F00000080i64; // weak
__int128 xmmword_14612E150 = 0xBF00000080000000BF00000080i64; // weak
__int128 xmmword_14612E160 = 0xBF00000080000000BF00000090i64; // weak
__int128 xmmword_14612E170 = 0xBF00000080000000BF000000A0i64; // weak
__int128 xmmword_14612E730 = 0x1F0000000000000012i64; // weak
_BYTE aHhhhh[256] =
{
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  104,
  0,
  72,
  0,
  72,
  0,
  72,
  0,
  72,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  64,
  0,
  40,
  9,
  128,
  3,
  128,
  3,
  128,
  3,
  128,
  3,
  128,
  3,
  128,
  3,
  128,
  11,
  128,
  11,
  128,
  11,
  128,
  3,
  128,
  15,
  128,
  11,
  128,
  11,
  128,
  11,
  128,
  15,
  -108,
  13,
  -108,
  13,
  -108,
  13,
  -108,
  13,
  -108,
  13,
  -108,
  13,
  -108,
  13,
  -108,
  13,
  -108,
  13,
  -108,
  13,
  128,
  11,
  128,
  3,
  128,
  3,
  128,
  15,
  128,
  3,
  128,
  11,
  128,
  3,
  -110,
  13,
  -110,
  13,
  -110,
  13,
  -110,
  13,
  -110,
  13,
  -110,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  -126,
  13,
  128,
  3,
  128,
  3,
  128,
  3,
  128,
  3,
  128,
  3,
  128,
  3,
  -111,
  13,
  -111,
  13,
  -111,
  13,
  -111,
  13,
  -111,
  13,
  -111,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  -127,
  13,
  128,
  3,
  128,
  3,
  128,
  3,
  128,
  3,
  64,
  0
}; // weak
void *std::numpunct<char>::`vftable' = &sub_14619EEF0; // weak
void *std::numpunct<wchar_t>::`vftable' = &sub_14619EF50; // weak
__int64 qword_14612EEE8[87] =
{
  -4994806998408183946i64,
  -8424269937281487754i64,
  -3512093806901185046i64,
  -7319562523736982739i64,
  -1865951482774665761i64,
  -6093090917745768758i64,
  -38366372719436721i64,
  -4731433901725329908i64,
  -8228041688891786180i64,
  -3219690930897053053i64,
  -7101705404292871755i64,
  -1541319077368263733i64,
  -5851220927660403859i64,
  -9062348037703676329i64,
  -4462904269766699465i64,
  -8027971522334779313i64,
  -2921563150702462265i64,
  -6879582898840692748i64,
  -1210330751515841307i64,
  -5604615407819967858i64,
  -8878612607581929669i64,
  -4189117143640191558i64,
  -7823984217374209642i64,
  -2617598379430861436i64,
  -6653111496142234890i64,
  -872862063775190746i64,
  -5353181642124984136i64,
  -8691279853972075893i64,
  -3909969587797413805i64,
  -7616003081050118571i64,
  -2307682335666372931i64,
  -6422206049907525489i64,
  -528786136287117932i64,
  -5096825099203863601i64,
  -8500279345513818773i64,
  -3625356651333078602i64,
  -7403949918844649556i64,
  -1991698500497491194i64,
  -6186779746782440749i64,
  -177973607073265138i64,
  -4835449396872013077i64,
  -8305539271883716404i64,
  -3335171328526686932i64,
  -7187745005283311616i64,
  -1669528073709551616i64,
  -5946744073709551616i64,
  -9133518327554766460i64,
  -4568956265895094861i64,
  -8106986416796705680i64,
  -3039304518611664792i64,
  -6967307053960650171i64,
  -1341049929119499481i64,
  -5702008784649933400i64,
  -8951176327949752869i64,
  -4297245513042813542i64,
  -7904546130479028392i64,
  -2737644984756826646i64,
  -6742553186979055798i64,
  -1006140569036166267i64,
  -5452481866653427593i64,
  -8765264286586255934i64,
  -4020214983419339459i64,
  -7698142301602209613i64,
  -2430079312244744221i64,
  -6513398903789220827i64,
  -664674077828931748i64,
  -5198069505264599346i64,
  -8575712306248138270i64,
  -3737760522056206171i64,
  -7487697328667536417i64,
  -2116491865831296966i64,
  -6279758049420528746i64,
  -316522074587315140i64,
  -4938676049251384304i64,
  -8382449121214030822i64,
  -3449775934753242068i64,
  -7273132090830278359i64,
  -1796764746270372707i64,
  -6041542782089432023i64,
  -9204148869281624187i64,
  -4674203974643163859i64,
  -8185402070463610993i64,
  -3156152948152813503i64,
  -7054365918152680535i64,
  -1470777745987373095i64,
  -5798663540173640085i64,
  0i64
}; // weak
__int16 word_14612F1A2[87] =
{
  -1193,
  -1166,
  -1140,
  -1113,
  -1087,
  -1060,
  -1034,
  -1007,
  -980,
  -954,
  -927,
  -901,
  -874,
  -847,
  -821,
  -794,
  -768,
  -741,
  -715,
  -688,
  -661,
  -635,
  -608,
  -582,
  -555,
  -529,
  -502,
  -475,
  -449,
  -422,
  -396,
  -369,
  -343,
  -316,
  -289,
  -263,
  -236,
  -210,
  -183,
  -157,
  -130,
  -103,
  -77,
  -50,
  -24,
  3,
  30,
  56,
  83,
  109,
  136,
  162,
  189,
  216,
  242,
  269,
  295,
  322,
  348,
  375,
  402,
  428,
  455,
  481,
  508,
  534,
  561,
  588,
  614,
  641,
  667,
  694,
  720,
  747,
  774,
  800,
  827,
  853,
  880,
  907,
  933,
  960,
  986,
  1013,
  1039,
  1066,
  0
}; // weak
void *fmt::v8::basic_memory_buffer<unsigned int,32,std::allocator<unsigned int>>::`vftable' = &sub_14619FC90; // weak
__int64 qword_14612F260[20] =
{
  1i64,
  10i64,
  100i64,
  1000i64,
  10000i64,
  100000i64,
  1000000i64,
  10000000i64,
  100000000i64,
  1000000000i64,
  10000000000i64,
  100000000000i64,
  1000000000000i64,
  10000000000000i64,
  100000000000000i64,
  1000000000000000i64,
  10000000000000000i64,
  100000000000000000i64,
  1000000000000000000i64,
  -8446744073709551616i64
}; // weak
_DWORD dword_14612F300[24] =
{
  1,
  -1,
  -858993459,
  858993459,
  -1030792151,
  171798691,
  652835029,
  34359738,
  989560465,
  6871947,
  197912093,
  1374389,
  1757569337,
  274877,
  -1366473051,
  54975,
  585698849,
  10995,
  976133229,
  2199,
  1054220105,
  439,
  0,
  0
}; // weak
_QWORD qword_14612F360[48] =
{
  1i64,
  -1i64,
  -3689348814741910323i64,
  3689348814741910323i64,
  -8116567392432202711i64,
  737869762948382064i64,
  2066035336255469781i64,
  147573952589676412i64,
  -3276141747490816367i64,
  29514790517935282i64,
  6723469279985657373i64,
  5902958103587056i64,
  8723391485480952121i64,
  1180591620717411i64,
  -1944670517645719899i64,
  236118324143482i64,
  -4078282918271054303i64,
  47223664828696i64,
  -8194354213138031507i64,
  9444732965739i64,
  5739826786856214345i64,
  1888946593147i64,
  1147965357371242869i64,
  377789318629i64,
  3918941886216158897i64,
  75557863725i64,
  -6594909252240588867i64,
  15111572745i64,
  6059715779035702873i64,
  3022314549i64,
  8590640785290961221i64,
  604462909i64,
  -1971220657683718079i64,
  120892581i64,
  -4083592946278653939i64,
  24178516i64,
  -4506067403997641111i64,
  4835703i64,
  2788135333942382101i64,
  967140i64,
  -3131721747953433903i64,
  193428i64,
  -8005041979074507427i64,
  38685i64,
  5777689233668919161i64,
  7737i64,
  -2533810968008126491i64,
  1547i64
}; // weak
__int128 xmmword_14612F4E0[23] =
{
  0x25E8E89C13BB0F7BFF77B1FCBEBCDC4Fi64,
  0xFB0A3D212DC81290CE5D73FF402D98E3i64,
  0xF42FAA48C0EA481FA6B34AD8C9DFC06Fi64,
  0xAE5DFF9C0203319886A8D39EF77164BCi64,
  0x3BADD624DD9B0958D98DDAEE19068C76i64,
  0xE5D1929EF90898FBAFBD2350644EEACFi64,
  0xCA8D3FFA1EF463C28DF5EFABC5979C8Fi64,
  0xCC420A6A101D0516E55990879DDCAABDi64,
  0xF808E40E8D5B3E6AB94470938FA89BCEi64,
  0xDDE7001379A44AA995A8637627989AADi64,
  0x5324C68B12DD6339F1C90080BAF72CB1i64,
  0x0C350000000000000i64,
  0xF0200000000000009DC5ADA82B70B59Di64,
  0x2F236D04753D5B4FEE50B7025C36A08i64,
  0xED4C0226B55E6F86CDE6FD5E09ABCF26i64,
  0x84DB8346B786151CA6539930BF6BFF45i64,
  0xB8A2392BA45A9B2865B86925B9BC5C2i64,
  0x1B2BA1518094DA04D910F7FF28069DA4i64,
  0x387AC8D1970027B2AF58416654A6BABBi64,
  0x5CEAECFED289E5D28DA471A9DE737E24i64,
  0xFABAF3FEAA5334AE4D5E82392A40515i64,
  0x3D6A751F3B936243B8DA1662E7B00A17i64,
  0xF37801E0C43EBC895527A5202DF0CCBi64
}; // weak
__int64 qword_14612F650[28] =
{
  1i64,
  5i64,
  25i64,
  125i64,
  625i64,
  3125i64,
  15625i64,
  78125i64,
  390625i64,
  1953125i64,
  9765625i64,
  48828125i64,
  244140625i64,
  1220703125i64,
  6103515625i64,
  30517578125i64,
  152587890625i64,
  762939453125i64,
  3814697265625i64,
  19073486328125i64,
  95367431640625i64,
  476837158203125i64,
  2384185791015625i64,
  11920928955078125i64,
  59604644775390625i64,
  298023223876953125i64,
  1490116119384765625i64,
  0i64
}; // weak
int dword_14612F730[40] =
{
  1342182400,
  1409564928,
  1409369429,
  1435845653,
  1410422101,
  1,
  1342177280,
  1064960,
  1409351684,
  83902465,
  1431655748,
  1096045909,
  1409549649,
  356799813,
  1364546836,
  268435477,
  1052928,
  17825813,
  0,
  0,
  0,
  0,
  71632148,
  1161904400,
  1431654725,
  1347698768,
  352584021,
  285557056,
  1343296788,
  289739860,
  4195649,
  0,
  1431655504,
  268789073,
  268779537,
  1431638036,
  1766933845,
  85266697,
  1398101,
  0
}; // weak
_UNKNOWN unk_14612F950; // weak
void *InitFunctionBase::`vftable' = &purecall; // weak
void *InitFunction::`vftable' = &sub_1461A3110; // weak
_UNKNOWN unk_146132880; // weak
__int64 (__fastcall *off_1461328E0)() = &TlsCallback_1; // weak
void *type_info::`vftable' = &sub_1461A7FF0; // weak
__int64 (__fastcall *off_1461328F8)() = &TlsCallback_0; // weak
void (*qword_146134C50[2])(void) = { NULL, NULL }; // weak
void (*qword_146134C60[2])(void) = { NULL, NULL }; // weak
const _ThrowInfo _TI3_AVbad_array_new_length_std__ = { 0u, 102115328, 0, 101988008 }; // idb
const _ThrowInfo _TI3_AVformat_error_v8_fmt__ = { 0u, 102115328, 0, 101988192 }; // idb
const _ThrowInfo _TI2_AVbad_cast_std__ = { 0u, 102115328, 0, 101988296 }; // idb
const _ThrowInfo _TI3_AVparse_error_detail_json_abi_v3_11_2_nlohmann__ = { 0u, 102264240, 0, 101988392 }; // idb
const _ThrowInfo _TI3_AVtype_error_detail_json_abi_v3_11_2_nlohmann__ = { 0u, 102264240, 0, 101988536 }; // idb
const _ThrowInfo _TI3_AVother_error_detail_json_abi_v3_11_2_nlohmann__ = { 0u, 102264240, 0, 101988640 }; // idb
const _ThrowInfo _TI3_AVout_of_range_detail_json_abi_v3_11_2_nlohmann__ = { 0u, 102264240, 0, 101988744 }; // idb
const _ThrowInfo _TI3_AVinvalid_iterator_detail_json_abi_v3_11_2_nlohmann__ = { 0u, 102264240, 0, 101988848 }; // idb
const _ThrowInfo _TI2_AVbad_alloc_std__ = { 0u, 102115328, 0, 101988952 }; // idb
_UNKNOWN loc_1461486FA; // weak
__int64 qword_146148740[16] =
{
  8158064640682241944i64,
  -1606136187322303537i64,
  8158064640682241944i64,
  -1606136187322303537i64,
  6480981066509632091i64,
  -6116909922501295452i64,
  6480981066509632091i64,
  -6116909922501295452i64,
  1334009978109274776i64,
  6128411470023722430i64,
  1334009978109274776i64,
  6128411470023722430i64,
  -9160688885620122252i64,
  -4495734319865919833i64,
  -9160688885620122252i64,
  -4495734319865919833i64
}; // weak
__int64 qword_1461487C0[48] =
{
  -1171420208383170111i64,
  2597628982895680966i64,
  -1171420208383170111i64,
  2597628982895680966i64,
  5365058922554666095i64,
  8573033837115779548i64,
  5365058922554666095i64,
  8573033837115779548i64,
  -6327057827470880430i64,
  -4658551843909851192i64,
  -6327057827470880430i64,
  -4658551843909851192i64,
  -3051310485054944269i64,
  1452737877275992913i64,
  -3051310485054944269i64,
  1452737877275992913i64,
  3322285675184065157i64,
  5996557280394112508i64,
  3322285675184065157i64,
  5996557280394112508i64,
  8532644243977171796i64,
  -7894198244907759314i64,
  8532644243977171796i64,
  -7894198244907759314i64,
  -6333637450904115039i64,
  -4076793798895891600i64,
  -6333637450904115039i64,
  -4076793798895891600i64,
  -2983346522951587815i64,
  1182934259129529733i64,
  -2983346522951587815i64,
  1182934259129529733i64,
  2177327726902690070i64,
  3796741972107491148i64,
  2177327726902690070i64,
  3796741972107491148i64,
  5681478165690322099i64,
  7507060719877933647i64,
  5681478165690322099i64,
  7507060719877933647i64,
  8693463986056692462i64,
  -8302665152423495660i64,
  8693463986056692462i64,
  -8302665152423495660i64,
  -6606660894350966790i64,
  -4147400797850065929i64,
  -6606660894350966790i64,
  -4147400797850065929i64
}; // weak
__m256 ymmword_146148940 =
{
  {
    ?flt,
    1.5636842e-36,
    4.1238743e-34,
    1.0866475e-31,
    ?flt,
    1.5636842e-36,
    4.1238743e-34,
    1.0866475e-31
  }
}; // weak
_UNKNOWN loc_146148A32; // weak
_UNKNOWN loc_146148D86; // weak
_UNKNOWN loc_14614AC96; // weak
__int64 qword_1461A4C50[4] =
{
  281629805332636i64,
  15803439529696512i64,
  -3689348814741962752i64,
  -3689348814741910324i64
}; // weak
__int64 qword_1461AE4B0[4] =
{
  5216857178790565259i64,
  -5116089175214062453i64,
  -3455383206327484176i64,
  -3689348594919152663i64
}; // weak
__int64 qword_1461AE4D0[4] =
{
  5216857178788468107i64,
  -5116089175214062453i64,
  -3455383206327484136i64,
  -3689348594919160855i64
}; // weak


//----- (0000000146147030) ----------------------------------------------------
__int64 __fastcall sub_146147030(__int64 a1)
{
  __m128i v1; // xmm0
  unsigned int v8; // r11d
  BOOL v9; // eax
  int v10; // r9d
  BOOL v11; // r10d
  int v12; // r10d
  unsigned int v18; // r10d
  unsigned __int8 v29; // r10
  unsigned int v35; // r10d
  __int64 v43; // r9
  unsigned int v44; // r10d
  int v50; // eax

  _RAX = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  __asm { cpuid }
  v8 = _RAX;
  v9 = _RCX != 1818588270;
  v10 = v9 || (_DWORD)_RDX != 1231384169 || (_DWORD)_RBX != 1970169159;
  if ( !v10 )
    goto LABEL_8;
  LOBYTE(v9) = (_DWORD)_RBX != 1752462657;
  v11 = v9;
  LOBYTE(v9) = (_DWORD)_RDX != 1769238117;
  v12 = v9 || v11;
  LOBYTE(v9) = (_DWORD)_RCX != 1145913699;
  if ( v9 | v12 )
    goto LABEL_8;
  _RAX = 0x80000000i64;
  __asm { cpuid }
  if ( (unsigned int)_RAX < 0x80000001 )
    goto LABEL_8;
  v18 = _RAX;
  _RAX = 2147483649i64;
  __asm { cpuid }
  v10 = ((unsigned __int16)_RCX | (unsigned __int16)v10) & 0x801;
  if ( v18 < 0x80000008 )
  {
LABEL_8:
    v35 = -1;
    if ( v8 >= 4 )
    {
      _RAX = 4i64;
      __asm { cpuid }
      v35 = ((unsigned int)_RAX >> 14) & 0xFFF;
    }
    _RAX = 1i64;
    __asm { cpuid }
    v1 = _mm_cvtsi32_si128(_RAX);
    LODWORD(_RDX) = _RDX & 0xBFEFFFFF;
    if ( !v10 )
    {
      LODWORD(_RDX) = _RDX | 0x40000000;
      BYTE1(_RAX) &= 0xFu;
      if ( BYTE1(_RAX) == 15 )
        LODWORD(_RDX) = _RDX | 0x100000;
      if ( BYTE1(_RAX) == 6 )
      {
        LODWORD(_RAX) = _RAX & 0xFFF0FF0;
        if ( (_DWORD)_RAX == 329328 || (_DWORD)_RAX == 525904 )
          LODWORD(_RCX) = _RCX & 0xFBFFFFFF;
      }
    }
    if ( (_RDX & 0x10000000) != 0 )
    {
      LODWORD(_RDX) = _RDX & 0xEFFFFFFF;
      if ( v35 )
      {
        LODWORD(_RDX) = _RDX | 0x10000000;
        if ( BYTE2(_RBX) <= 1u )
          LODWORD(_RDX) = _RDX & 0xEFFFFFFF;
      }
    }
  }
  else
  {
    _RAX = 2147483656i64;
    __asm { cpuid }
    v29 = _RCX + 1;
    _RAX = 1i64;
    __asm { cpuid }
    if ( (_RDX & 0x10000000) != 0 && BYTE2(_RBX) <= v29 )
      LODWORD(_RDX) = _RDX & 0xEFFFFFFF;
  }
  v43 = _RCX & 0xFFFFF7FF | v10 & 0x800;
  v44 = _RDX;
  if ( v8 >= 7 )
  {
    _RAX = 7i64;
    __asm { cpuid }
    if ( (v43 & 0x4000000) == 0 )
      LODWORD(_RBX) = _RBX & 0xFFF7FFFF;
    LODWORD(_RAX) = _mm_cvtsi128_si32(v1) & 0xFFF0FF0;
    if ( (_DWORD)_RAX == 329296 )
      LODWORD(_RBX) = _RBX & 0xFFFEFFFF;
    *(_DWORD *)(a1 + 8) = _RBX;
    *(_DWORD *)(a1 + 12) = _RCX;
  }
  if ( (v43 & 0x8000000) == 0 )
    goto LABEL_30;
  __asm { xgetbv }
  v50 = _RAX & 0xE6;
  if ( v50 != 230 )
  {
    *(_DWORD *)(a1 + 8) &= 0x3FDEFFFFu;
    if ( (v50 & 6) != 6 )
    {
LABEL_30:
      v43 = (unsigned int)v43 & 0xEFFFE7FF;
      *(_DWORD *)(a1 + 8) &= 0x3FDEFFDFu;
    }
  }
  return (v43 << 32) | v44;
}
// 1461471C5: variable 'v1' is possibly undefined

//----- (0000000146147240) ----------------------------------------------------
__int64 __fastcall sub_146147240(_BYTE *a1, unsigned __int64 a2)
{
  __int64 result; // rax

  result = 0i64;
  if ( a2 < 0xF )
  {
    if ( !a2 )
      return result;
    goto LABEL_3;
  }
  while ( ((unsigned __int8)a1 & 7) != 0 )
  {
    *a1 = 0;
    --a2;
    ++a1;
  }
  do
  {
    *(_QWORD *)a1 = 0i64;
    a2 -= 8i64;
    a1 += 8;
  }
  while ( (a2 & 0xFFFFFFFFFFFFFFF8ui64) != 0 );
  while ( a2 )
  {
LABEL_3:
    *a1 = 0;
    --a2;
    ++a1;
  }
  return result;
}

//----- (0000000146147500) ----------------------------------------------------
__int64 __fastcall sub_146147500(_DWORD *a1, unsigned int *a2, __int64 a3)
{
  unsigned int *v4; // rsi
  __int64 result; // rax
  int v6; // ebx
  int v7; // ecx
  int v8; // edx
  int v9; // r8d
  int v10; // r9d
  int v11; // r10d
  int v12; // r11d
  int v13; // r12d
  int v14; // edx
  int v15; // r11d
  int v16; // r12d
  int v17; // ecx
  int v18; // r10d
  int v19; // r12d
  int v20; // ebx
  int v21; // r9d
  int v22; // r12d
  int v23; // eax
  int v24; // r8d
  int v25; // r12d
  int v26; // r11d
  int v27; // edx
  int v28; // r12d
  int v29; // r10d
  int v30; // ecx
  int v31; // r12d
  int v32; // r9d
  int v33; // ebx
  int v34; // r12d
  int v35; // r8d
  int v36; // eax
  int v37; // r12d
  int v38; // edx
  int v39; // r11d
  int v40; // r12d
  int v41; // ecx
  int v42; // r10d
  int v43; // r12d
  int v44; // ebx
  int v45; // r9d
  int v46; // r12d
  int v47; // eax
  int v48; // r8d
  int v49; // r12d
  int v50; // r11d
  int v51; // edx
  int v52; // r12d
  int v53; // r10d
  int v54; // ecx
  int v55; // r12d
  int v56; // r9d
  int v57; // ebx
  int v58; // edi
  int v59; // r14d
  int v60; // r12d
  int v61; // r8d
  int v62; // eax
  __int64 *v63; // rbp
  int v64; // eax
  int v65; // r12d
  int v66; // edx
  _DWORD *v67; // rbp
  int v68; // r11d
  int v69; // r12d
  int v70; // ecx
  int v71; // r10d
  int v72; // r12d
  int v73; // ebx
  int v74; // r9d
  int v75; // r12d
  int v76; // eax
  int v77; // r8d
  int v78; // r12d
  int v79; // r11d
  int v80; // edx
  int v81; // r12d
  int v82; // r10d
  int v83; // ecx
  int v84; // r12d
  int v85; // r9d
  int v86; // ebx
  int v87; // r12d
  int v88; // r8d
  int v89; // eax
  int v90; // r12d
  int v91; // edx
  int v92; // r11d
  int v93; // r12d
  int v94; // ecx
  int v95; // r10d
  int v96; // r12d
  int v97; // ebx
  int v98; // r9d
  int v99; // r12d
  int v100; // eax
  int v101; // r8d
  int v102; // r12d
  int v103; // r12d
  int v104; // r12d
  int v105; // r12d
  unsigned __int32 v106; // [rsp+0h] [rbp-90h]
  unsigned __int32 v107; // [rsp+4h] [rbp-8Ch]
  unsigned __int64 v108; // [rsp+8h] [rbp-88h]
  unsigned __int64 v109; // [rsp+10h] [rbp-80h]
  unsigned __int32 v110; // [rsp+18h] [rbp-78h]
  unsigned __int32 v111; // [rsp+1Ch] [rbp-74h]
  unsigned __int32 v112; // [rsp+20h] [rbp-70h]
  unsigned __int32 v113; // [rsp+24h] [rbp-6Ch]
  unsigned __int32 v114; // [rsp+28h] [rbp-68h]
  unsigned __int32 v115; // [rsp+2Ch] [rbp-64h]
  unsigned __int32 v116; // [rsp+30h] [rbp-60h]
  unsigned __int32 v117; // [rsp+34h] [rbp-5Ch]
  unsigned __int32 v118; // [rsp+38h] [rbp-58h]
  unsigned __int32 v119; // [rsp+3Ch] [rbp-54h]
  unsigned __int64 v121; // [rsp+50h] [rbp-40h]

  v4 = a2;
  if ( (*(&dword_14611B450 + 2) & 0x20000000) != 0 )
    JUMPOUT(0x146148A16i64);
  if ( (*(&dword_14611B450 + 2) & 0x128) == 296 )
    JUMPOUT(0x14614AC96i64);
  if ( (dword_14611B450 & 0x40000000 | *(&dword_14611B450 + 1) & 0x10000200) == 1342177792 )
    JUMPOUT(0x146149D16i64);
  if ( (*(&dword_14611B450 + 1) & 0x200) != 0 )
    JUMPOUT(0x146148DD6i64);
  v121 = (unsigned __int64)&a2[16 * a3];
  LODWORD(result) = *a1;
  v6 = a1[1];
  v7 = a1[2];
  v8 = a1[3];
  v9 = a1[4];
  v10 = a1[5];
  v11 = a1[6];
  v12 = a1[7];
  do
  {
    v106 = _byteswap_ulong(*v4);
    v13 = __ROR4__(v9 ^ __ROR4__(v9 ^ __ROR4__(v9, 14), 5), 6) + (v11 ^ v9 & (v11 ^ v10)) + v12 + v106 + 1116352408;
    v14 = v13 + v8;
    v15 = __ROR4__(result ^ __ROR4__(result ^ __ROR4__(result, 9), 11), 2) + v13 + ((v6 ^ result) & (v7 ^ v6) ^ v6);
    v107 = _byteswap_ulong(v4[1]);
    v16 = __ROR4__(v14 ^ __ROR4__(v14 ^ __ROR4__(v14, 14), 5), 6)
        + HIDWORD(qword_146148740[0])
        + (v10 ^ v14 & (v10 ^ v9))
        + v11
        + v107;
    v17 = v16 + v7;
    v18 = __ROR4__(v15 ^ __ROR4__(v15 ^ __ROR4__(v15, 9), 11), 2) + v16 + ((result ^ v15) & (v6 ^ result) ^ result);
    v108 = _byteswap_uint64(__PAIR64__(v4[2], v4[3]));
    v19 = __ROR4__(v17 ^ __ROR4__(v17 ^ __ROR4__(v17, 14), 5), 6)
        + LODWORD(qword_146148740[1])
        + (v9 ^ v17 & (v9 ^ v14))
        + v10
        + v108;
    v20 = v19 + v6;
    v21 = __ROR4__(v18 ^ __ROR4__(v18 ^ __ROR4__(v18, 9), 11), 2) + v19 + ((v15 ^ v18) & (result ^ v15) ^ v15);
    v22 = __ROR4__(v20 ^ __ROR4__(v20 ^ __ROR4__(v20, 14), 5), 6)
        + HIDWORD(qword_146148740[1])
        + (v14 ^ v20 & (v14 ^ v17))
        + v9
        + HIDWORD(v108);
    v23 = v22 + result;
    v24 = __ROR4__(v21 ^ __ROR4__(v21 ^ __ROR4__(v21, 9), 11), 2) + v22 + ((v18 ^ v21) & (v15 ^ v18) ^ v18);
    v109 = _byteswap_uint64(__PAIR64__(v4[4], v4[5]));
    v25 = __ROR4__(v23 ^ __ROR4__(v23 ^ __ROR4__(v23, 14), 5), 6)
        + LODWORD(qword_146148740[4])
        + (v17 ^ v23 & (v17 ^ v20))
        + v14
        + v109;
    v26 = v25 + v15;
    v27 = __ROR4__(v24 ^ __ROR4__(v24 ^ __ROR4__(v24, 9), 11), 2) + v25 + ((v21 ^ v24) & (v18 ^ v21) ^ v21);
    v28 = __ROR4__(v26 ^ __ROR4__(v26 ^ __ROR4__(v26, 14), 5), 6)
        + HIDWORD(qword_146148740[4])
        + (v20 ^ v26 & (v20 ^ v23))
        + v17
        + HIDWORD(v109);
    v29 = v28 + v18;
    v30 = __ROR4__(v27 ^ __ROR4__(v27 ^ __ROR4__(v27, 9), 11), 2) + v28 + ((v24 ^ v27) & (v21 ^ v24) ^ v24);
    v110 = _byteswap_ulong(v4[6]);
    v31 = __ROR4__(v29 ^ __ROR4__(v29 ^ __ROR4__(v29, 14), 5), 6)
        + LODWORD(qword_146148740[5])
        + (v23 ^ v29 & (v23 ^ v26))
        + v20
        + v110;
    v32 = v31 + v21;
    v33 = __ROR4__(v30 ^ __ROR4__(v30 ^ __ROR4__(v30, 9), 11), 2) + v31 + ((v27 ^ v30) & (v24 ^ v27) ^ v27);
    v111 = _byteswap_ulong(v4[7]);
    v34 = __ROR4__(v32 ^ __ROR4__(v32 ^ __ROR4__(v32, 14), 5), 6)
        + HIDWORD(qword_146148740[5])
        + (v26 ^ v32 & (v26 ^ v29))
        + v23
        + v111;
    v35 = v34 + v24;
    v36 = __ROR4__(v33 ^ __ROR4__(v33 ^ __ROR4__(v33, 9), 11), 2) + v34 + ((v30 ^ v33) & (v27 ^ v30) ^ v30);
    v112 = _byteswap_ulong(v4[8]);
    v37 = __ROR4__(v35 ^ __ROR4__(v35 ^ __ROR4__(v35, 14), 5), 6)
        + LODWORD(qword_146148740[8])
        + (v29 ^ v35 & (v29 ^ v32))
        + v26
        + v112;
    v38 = v37 + v27;
    v39 = __ROR4__(v36 ^ __ROR4__(v36 ^ __ROR4__(v36, 9), 11), 2) + v37 + ((v33 ^ v36) & (v30 ^ v33) ^ v33);
    v113 = _byteswap_ulong(v4[9]);
    v40 = __ROR4__(v38 ^ __ROR4__(v38 ^ __ROR4__(v38, 14), 5), 6)
        + HIDWORD(qword_146148740[8])
        + (v32 ^ v38 & (v32 ^ v35))
        + v29
        + v113;
    v41 = v40 + v30;
    v42 = __ROR4__(v39 ^ __ROR4__(v39 ^ __ROR4__(v39, 9), 11), 2) + v40 + ((v36 ^ v39) & (v33 ^ v36) ^ v36);
    v114 = _byteswap_ulong(v4[10]);
    v43 = __ROR4__(v41 ^ __ROR4__(v41 ^ __ROR4__(v41, 14), 5), 6)
        + LODWORD(qword_146148740[9])
        + (v35 ^ v41 & (v35 ^ v38))
        + v32
        + v114;
    v44 = v43 + v33;
    v45 = __ROR4__(v42 ^ __ROR4__(v42 ^ __ROR4__(v42, 9), 11), 2) + v43 + ((v39 ^ v42) & (v36 ^ v39) ^ v39);
    v115 = _byteswap_ulong(v4[11]);
    v46 = __ROR4__(v44 ^ __ROR4__(v44 ^ __ROR4__(v44, 14), 5), 6)
        + HIDWORD(qword_146148740[9])
        + (v38 ^ v44 & (v38 ^ v41))
        + v35
        + v115;
    v47 = v46 + v36;
    v48 = __ROR4__(v45 ^ __ROR4__(v45 ^ __ROR4__(v45, 9), 11), 2) + v46 + ((v42 ^ v45) & (v39 ^ v42) ^ v42);
    v116 = _byteswap_ulong(v4[12]);
    v49 = __ROR4__(v47 ^ __ROR4__(v47 ^ __ROR4__(v47, 14), 5), 6)
        + LODWORD(qword_146148740[12])
        + (v41 ^ v47 & (v41 ^ v44))
        + v38
        + v116;
    v50 = v49 + v39;
    v51 = __ROR4__(v48 ^ __ROR4__(v48 ^ __ROR4__(v48, 9), 11), 2) + v49 + ((v45 ^ v48) & (v42 ^ v45) ^ v45);
    v117 = _byteswap_ulong(v4[13]);
    v52 = __ROR4__(v50 ^ __ROR4__(v50 ^ __ROR4__(v50, 14), 5), 6)
        + HIDWORD(qword_146148740[12])
        + (v44 ^ v50 & (v44 ^ v47))
        + v41
        + v117;
    v53 = v52 + v42;
    v54 = __ROR4__(v51 ^ __ROR4__(v51 ^ __ROR4__(v51, 9), 11), 2) + v52 + ((v48 ^ v51) & (v45 ^ v48) ^ v48);
    v118 = _byteswap_ulong(v4[14]);
    v55 = __ROR4__(v53 ^ __ROR4__(v53 ^ __ROR4__(v53, 14), 5), 6)
        + LODWORD(qword_146148740[13])
        + (v47 ^ v53 & (v47 ^ v50))
        + v44
        + v118;
    v56 = v55 + v45;
    v57 = __ROR4__(v54 ^ __ROR4__(v54 ^ __ROR4__(v54, 9), 11), 2) + v55 + ((v51 ^ v54) & (v48 ^ v51) ^ v51);
    v119 = _byteswap_ulong(v4[15]);
    v58 = v54 ^ v57;
    v59 = __ROR4__(v57 ^ __ROR4__(v57 ^ __ROR4__(v57, 9), 11), 2);
    v60 = __ROR4__(v56 ^ __ROR4__(v56 ^ __ROR4__(v56, 14), 5), 6)
        + HIDWORD(qword_146148740[13])
        + (v50 ^ v56 & (v50 ^ v53))
        + v47
        + v119;
    v61 = v60 + v48;
    v62 = v60 + ((v54 ^ v57) & (v51 ^ v54) ^ v54);
    v63 = &qword_146148740[16];
    do
    {
      v64 = v59 + v62;
      v106 += ((v118 >> 10) ^ __ROR4__(v118 ^ __ROR4__(v118, 2), 17))
            + v113
            + (__ROR4__(v107 ^ __ROR4__(v107, 11), 7) ^ (v107 >> 3));
      v65 = __ROR4__(v61 ^ __ROR4__(v61 ^ __ROR4__(v61, 14), 5), 6)
          + *(_DWORD *)v63
          + (v53 ^ v61 & (v53 ^ v56))
          + v50
          + v106;
      v66 = v65 + v51;
      v67 = (_DWORD *)v63 + 1;
      v68 = __ROR4__(v64 ^ __ROR4__(v64 ^ __ROR4__(v64, 9), 11), 2) + v65 + ((v57 ^ v64) & v58 ^ v57);
      v107 += ((v119 >> 10) ^ __ROR4__(v119 ^ __ROR4__(v119, 2), 17))
            + v114
            + (__ROR4__(v108 ^ __ROR4__(v108, 11), 7) ^ ((unsigned int)v108 >> 3));
      v69 = __ROR4__(v66 ^ __ROR4__(v66 ^ __ROR4__(v66, 14), 5), 6) + *v67 + (v56 ^ v66 & (v56 ^ v61)) + v53 + v107;
      v70 = v69 + v54;
      ++v67;
      v71 = __ROR4__(v68 ^ __ROR4__(v68 ^ __ROR4__(v68, 9), 11), 2) + v69 + ((v64 ^ v68) & (v57 ^ v64) ^ v64);
      LODWORD(v108) = ((v106 >> 10) ^ __ROR4__(v106 ^ __ROR4__(v106, 2), 17))
                    + v108
                    + v115
                    + (__ROR4__(HIDWORD(v108) ^ __ROR4__(HIDWORD(v108), 11), 7) ^ (HIDWORD(v108) >> 3));
      v72 = __ROR4__(v70 ^ __ROR4__(v70 ^ __ROR4__(v70, 14), 5), 6) + *v67 + (v61 ^ v70 & (v61 ^ v66)) + v56 + v108;
      v73 = v72 + v57;
      ++v67;
      v74 = __ROR4__(v71 ^ __ROR4__(v71 ^ __ROR4__(v71, 9), 11), 2) + v72 + ((v68 ^ v71) & (v64 ^ v68) ^ v68);
      HIDWORD(v108) += ((v107 >> 10) ^ __ROR4__(v107 ^ __ROR4__(v107, 2), 17))
                     + v116
                     + (__ROR4__(v109 ^ __ROR4__(v109, 11), 7) ^ ((unsigned int)v109 >> 3));
      v75 = __ROR4__(v73 ^ __ROR4__(v73 ^ __ROR4__(v73, 14), 5), 6)
          + *v67
          + (v66 ^ v73 & (v66 ^ v70))
          + v61
          + HIDWORD(v108);
      v76 = v75 + v64;
      v67 += 5;
      v77 = __ROR4__(v74 ^ __ROR4__(v74 ^ __ROR4__(v74, 9), 11), 2) + v75 + ((v71 ^ v74) & (v68 ^ v71) ^ v71);
      LODWORD(v109) = (((unsigned int)v108 >> 10) ^ __ROR4__(v108 ^ __ROR4__(v108, 2), 17))
                    + v109
                    + v117
                    + (__ROR4__(HIDWORD(v109) ^ __ROR4__(HIDWORD(v109), 11), 7) ^ (HIDWORD(v109) >> 3));
      v78 = __ROR4__(v76 ^ __ROR4__(v76 ^ __ROR4__(v76, 14), 5), 6) + *v67 + (v70 ^ v76 & (v70 ^ v73)) + v66 + v109;
      v79 = v78 + v68;
      ++v67;
      v80 = __ROR4__(v77 ^ __ROR4__(v77 ^ __ROR4__(v77, 9), 11), 2) + v78 + ((v74 ^ v77) & (v71 ^ v74) ^ v74);
      HIDWORD(v109) += ((HIDWORD(v108) >> 10) ^ __ROR4__(HIDWORD(v108) ^ __ROR4__(HIDWORD(v108), 2), 17))
                     + v118
                     + (__ROR4__(v110 ^ __ROR4__(v110, 11), 7) ^ (v110 >> 3));
      v81 = __ROR4__(v79 ^ __ROR4__(v79 ^ __ROR4__(v79, 14), 5), 6)
          + *v67
          + (v73 ^ v79 & (v73 ^ v76))
          + v70
          + HIDWORD(v109);
      v82 = v81 + v71;
      ++v67;
      v83 = __ROR4__(v80 ^ __ROR4__(v80 ^ __ROR4__(v80, 9), 11), 2) + v81 + ((v77 ^ v80) & (v74 ^ v77) ^ v77);
      v110 += (((unsigned int)v109 >> 10) ^ __ROR4__(v109 ^ __ROR4__(v109, 2), 17))
            + v119
            + (__ROR4__(v111 ^ __ROR4__(v111, 11), 7) ^ (v111 >> 3));
      v84 = __ROR4__(v82 ^ __ROR4__(v82 ^ __ROR4__(v82, 14), 5), 6) + *v67 + (v76 ^ v82 & (v76 ^ v79)) + v73 + v110;
      v85 = v84 + v74;
      ++v67;
      v86 = __ROR4__(v83 ^ __ROR4__(v83 ^ __ROR4__(v83, 9), 11), 2) + v84 + ((v80 ^ v83) & (v77 ^ v80) ^ v80);
      v111 += ((HIDWORD(v109) >> 10) ^ __ROR4__(HIDWORD(v109) ^ __ROR4__(HIDWORD(v109), 2), 17))
            + v106
            + (__ROR4__(v112 ^ __ROR4__(v112, 11), 7) ^ (v112 >> 3));
      v87 = __ROR4__(v85 ^ __ROR4__(v85 ^ __ROR4__(v85, 14), 5), 6) + *v67 + (v79 ^ v85 & (v79 ^ v82)) + v76 + v111;
      v88 = v87 + v77;
      v67 += 5;
      v89 = __ROR4__(v86 ^ __ROR4__(v86 ^ __ROR4__(v86, 9), 11), 2) + v87 + ((v83 ^ v86) & (v80 ^ v83) ^ v83);
      v112 += ((v110 >> 10) ^ __ROR4__(v110 ^ __ROR4__(v110, 2), 17))
            + v107
            + (__ROR4__(v113 ^ __ROR4__(v113, 11), 7) ^ (v113 >> 3));
      v90 = __ROR4__(v88 ^ __ROR4__(v88 ^ __ROR4__(v88, 14), 5), 6) + *v67 + (v82 ^ v88 & (v82 ^ v85)) + v79 + v112;
      v91 = v90 + v80;
      ++v67;
      v92 = __ROR4__(v89 ^ __ROR4__(v89 ^ __ROR4__(v89, 9), 11), 2) + v90 + ((v86 ^ v89) & (v83 ^ v86) ^ v86);
      v113 += ((v111 >> 10) ^ __ROR4__(v111 ^ __ROR4__(v111, 2), 17))
            + v108
            + (__ROR4__(v114 ^ __ROR4__(v114, 11), 7) ^ (v114 >> 3));
      v93 = __ROR4__(v91 ^ __ROR4__(v91 ^ __ROR4__(v91, 14), 5), 6) + *v67 + (v85 ^ v91 & (v85 ^ v88)) + v82 + v113;
      v94 = v93 + v83;
      ++v67;
      v95 = __ROR4__(v92 ^ __ROR4__(v92 ^ __ROR4__(v92, 9), 11), 2) + v93 + ((v89 ^ v92) & (v86 ^ v89) ^ v89);
      v114 += ((v112 >> 10) ^ __ROR4__(v112 ^ __ROR4__(v112, 2), 17))
            + HIDWORD(v108)
            + (__ROR4__(v115 ^ __ROR4__(v115, 11), 7) ^ (v115 >> 3));
      v96 = __ROR4__(v94 ^ __ROR4__(v94 ^ __ROR4__(v94, 14), 5), 6) + *v67 + (v88 ^ v94 & (v88 ^ v91)) + v85 + v114;
      v97 = v96 + v86;
      ++v67;
      v98 = __ROR4__(v95 ^ __ROR4__(v95 ^ __ROR4__(v95, 9), 11), 2) + v96 + ((v92 ^ v95) & (v89 ^ v92) ^ v92);
      v115 += ((v113 >> 10) ^ __ROR4__(v113 ^ __ROR4__(v113, 2), 17))
            + v109
            + (__ROR4__(v116 ^ __ROR4__(v116, 11), 7) ^ (v116 >> 3));
      v99 = __ROR4__(v97 ^ __ROR4__(v97 ^ __ROR4__(v97, 14), 5), 6) + *v67 + (v91 ^ v97 & (v91 ^ v94)) + v88 + v115;
      v100 = v99 + v89;
      v67 += 5;
      v101 = __ROR4__(v98 ^ __ROR4__(v98 ^ __ROR4__(v98, 9), 11), 2) + v99 + ((v95 ^ v98) & (v92 ^ v95) ^ v95);
      v116 += ((v114 >> 10) ^ __ROR4__(v114 ^ __ROR4__(v114, 2), 17))
            + HIDWORD(v109)
            + (__ROR4__(v117 ^ __ROR4__(v117, 11), 7) ^ (v117 >> 3));
      v102 = __ROR4__(v100 ^ __ROR4__(v100 ^ __ROR4__(v100, 14), 5), 6) + *v67 + (v94 ^ v100 & (v94 ^ v97)) + v91 + v116;
      v50 = v102 + v92;
      ++v67;
      v51 = __ROR4__(v101 ^ __ROR4__(v101 ^ __ROR4__(v101, 9), 11), 2) + v102 + ((v98 ^ v101) & (v95 ^ v98) ^ v98);
      v117 += ((v115 >> 10) ^ __ROR4__(v115 ^ __ROR4__(v115, 2), 17))
            + v110
            + (__ROR4__(v118 ^ __ROR4__(v118, 11), 7) ^ (v118 >> 3));
      v103 = __ROR4__(v50 ^ __ROR4__(v50 ^ __ROR4__(v50, 14), 5), 6) + *v67 + (v97 ^ v50 & (v97 ^ v100)) + v94 + v117;
      v53 = v103 + v95;
      ++v67;
      v54 = __ROR4__(v51 ^ __ROR4__(v51 ^ __ROR4__(v51, 9), 11), 2) + v103 + ((v101 ^ v51) & (v98 ^ v101) ^ v101);
      v118 += ((v116 >> 10) ^ __ROR4__(v116 ^ __ROR4__(v116, 2), 17))
            + v111
            + (__ROR4__(v119 ^ __ROR4__(v119, 11), 7) ^ (v119 >> 3));
      v104 = __ROR4__(v53 ^ __ROR4__(v53 ^ __ROR4__(v53, 14), 5), 6) + *v67 + (v100 ^ v53 & (v100 ^ v50)) + v97 + v118;
      v56 = v104 + v98;
      ++v67;
      v57 = __ROR4__(v54 ^ __ROR4__(v54 ^ __ROR4__(v54, 9), 11), 2) + v104 + ((v51 ^ v54) & (v101 ^ v51) ^ v51);
      v119 += ((v117 >> 10) ^ __ROR4__(v117 ^ __ROR4__(v117, 2), 17))
            + v112
            + (__ROR4__(v106 ^ __ROR4__(v106, 11), 7) ^ (v106 >> 3));
      v58 = v54 ^ v57;
      v59 = __ROR4__(v57 ^ __ROR4__(v57 ^ __ROR4__(v57, 9), 11), 2);
      v105 = __ROR4__(v56 ^ __ROR4__(v56 ^ __ROR4__(v56, 14), 5), 6) + *v67 + (v50 ^ v56 & (v50 ^ v53)) + v100 + v119;
      v61 = v105 + v101;
      v62 = v105 + ((v54 ^ v57) & (v51 ^ v54) ^ v54);
      v63 = (__int64 *)(v67 + 5);
    }
    while ( *((_BYTE *)v63 + 3) );
    v4 += 16;
    result = (unsigned int)(*a1 + v59 + v62);
    v6 = a1[1] + v57;
    v7 = a1[2] + v54;
    v8 = a1[3] + v51;
    v9 = a1[4] + v61;
    v10 = a1[5] + v56;
    v11 = a1[6] + v53;
    v12 = a1[7] + v50;
    *a1 = result;
    a1[1] = v6;
    a1[2] = v7;
    a1[3] = v8;
    a1[4] = v9;
    a1[5] = v10;
    a1[6] = v11;
    a1[7] = v12;
  }
  while ( (unsigned __int64)v4 < v121 );
  return result;
}
// 14614752F: control flows out of bounds to 146148A16
// 146147543: control flows out of bounds to 14614AC96
// 146147561: control flows out of bounds to 146149D16
// 14614756E: control flows out of bounds to 146148DD6
// 146147500: could not find valid save-restore pair for rdi
// 146147500: could not find valid save-restore pair for rsi
// 14611B450: using guessed type int dword_14611B450;
// 146148740: using guessed type __int64 qword_146148740[16];

//----- (0000000146148A0D) ----------------------------------------------------
__int64 __fastcall sub_146148A0D(__m128i *a1, const __m128i *a2, __int64 a3)
{
  __int64 result; // rax
  __int128 v4; // xmm6
  __int128 v5; // xmm7
  __int128 v6; // xmm8
  __int128 v7; // xmm9
  __int128 v8; // xmm10
  __m128i v11; // xmm1
  __m128i si128; // xmm7
  __m128i v13; // xmm0
  __m128i v14; // xmm2
  __m128i v15; // xmm8
  __m128i v19; // xmm6
  __m128i v21; // xmm10
  __m128i v23; // xmm9
  __m128i v93; // xmm2

  *(_OWORD *)(result - 88) = v4;
  *(_OWORD *)(result - 72) = v5;
  *(_OWORD *)(result - 56) = v6;
  *(_OWORD *)(result - 40) = v7;
  *(_OWORD *)(result - 24) = v8;
  v11 = _mm_loadu_si128(a1);
  si128 = _mm_load_si128((const __m128i *)&qword_1461487C0[48]);
  v13 = _mm_shuffle_epi32(v11, 27);
  v14 = _mm_shuffle_epi32(_mm_loadu_si128(a1 + 1), 27);
  v15 = si128;
  _XMM1 = _mm_alignr_epi8(_mm_shuffle_epi32(v11, 177), v14, 8);
  _XMM2 = _mm_unpacklo_epi64(v14, v13);
  do
  {
    _XMM3 = _mm_shuffle_epi8(_mm_loadu_si128(a2), si128);
    v19 = _mm_loadu_si128(a2 + 3);
    _XMM4 = _mm_shuffle_epi8(_mm_loadu_si128(a2 + 1), si128);
    v21 = _XMM2;
    __asm { sha256rnds2 xmm2, xmm1, xmm0 }
    v23 = _XMM1;
    __asm { sha256rnds2 xmm1, xmm2, xmm0 }
    _XMM5 = _mm_shuffle_epi8(_mm_loadu_si128(a2 + 2), si128);
    __asm { sha256rnds2 xmm2, xmm1, xmm0 }
    a2 += 4;
    __asm
    {
      sha256msg1 xmm3, xmm4
      sha256rnds2 xmm1, xmm2, xmm0
    }
    _XMM6 = _mm_shuffle_epi8(v19, si128);
    __asm { sha256rnds2 xmm2, xmm1, xmm0 }
    _XMM3 = _mm_add_epi32(_XMM3, _mm_alignr_epi8(_XMM6, _XMM5, 4));
    __asm
    {
      sha256msg1 xmm4, xmm5
      sha256rnds2 xmm1, xmm2, xmm0
      sha256msg2 xmm3, xmm6
      sha256rnds2 xmm2, xmm1, xmm0
    }
    _XMM4 = _mm_add_epi32(_XMM4, _mm_alignr_epi8(_XMM3, _XMM6, 4));
    __asm
    {
      sha256msg1 xmm5, xmm6
      sha256rnds2 xmm1, xmm2, xmm0
      sha256msg2 xmm4, xmm3
      sha256rnds2 xmm2, xmm1, xmm0
    }
    _XMM5 = _mm_add_epi32(_XMM5, _mm_alignr_epi8(_XMM4, _XMM3, 4));
    __asm
    {
      sha256msg1 xmm6, xmm3
      sha256rnds2 xmm1, xmm2, xmm0
      sha256msg2 xmm5, xmm4
      sha256rnds2 xmm2, xmm1, xmm0
    }
    _XMM6 = _mm_add_epi32(_XMM6, _mm_alignr_epi8(_XMM5, _XMM4, 4));
    __asm
    {
      sha256msg1 xmm3, xmm4
      sha256rnds2 xmm1, xmm2, xmm0
      sha256msg2 xmm6, xmm5
      sha256rnds2 xmm2, xmm1, xmm0
    }
    _XMM3 = _mm_add_epi32(_XMM3, _mm_alignr_epi8(_XMM6, _XMM5, 4));
    __asm
    {
      sha256msg1 xmm4, xmm5
      sha256rnds2 xmm1, xmm2, xmm0
      sha256msg2 xmm3, xmm6
      sha256rnds2 xmm2, xmm1, xmm0
    }
    _XMM4 = _mm_add_epi32(_XMM4, _mm_alignr_epi8(_XMM3, _XMM6, 4));
    __asm
    {
      sha256msg1 xmm5, xmm6
      sha256rnds2 xmm1, xmm2, xmm0
      sha256msg2 xmm4, xmm3
      sha256rnds2 xmm2, xmm1, xmm0
    }
    _XMM5 = _mm_add_epi32(_XMM5, _mm_alignr_epi8(_XMM4, _XMM3, 4));
    __asm
    {
      sha256msg1 xmm6, xmm3
      sha256rnds2 xmm1, xmm2, xmm0
      sha256msg2 xmm5, xmm4
      sha256rnds2 xmm2, xmm1, xmm0
    }
    _XMM6 = _mm_add_epi32(_XMM6, _mm_alignr_epi8(_XMM5, _XMM4, 4));
    __asm
    {
      sha256msg1 xmm3, xmm4
      sha256rnds2 xmm1, xmm2, xmm0
      sha256msg2 xmm6, xmm5
      sha256rnds2 xmm2, xmm1, xmm0
    }
    _XMM3 = _mm_add_epi32(_XMM3, _mm_alignr_epi8(_XMM6, _XMM5, 4));
    __asm
    {
      sha256msg1 xmm4, xmm5
      sha256rnds2 xmm1, xmm2, xmm0
      sha256msg2 xmm3, xmm6
      sha256rnds2 xmm2, xmm1, xmm0
    }
    _XMM4 = _mm_add_epi32(_XMM4, _mm_alignr_epi8(_XMM3, _XMM6, 4));
    __asm
    {
      sha256msg1 xmm5, xmm6
      sha256rnds2 xmm1, xmm2, xmm0
      sha256msg2 xmm4, xmm3
      sha256rnds2 xmm2, xmm1, xmm0
    }
    _XMM5 = _mm_add_epi32(_XMM5, _mm_alignr_epi8(_XMM4, _XMM3, 4));
    __asm
    {
      sha256msg1 xmm6, xmm3
      sha256rnds2 xmm1, xmm2, xmm0
      sha256msg2 xmm5, xmm4
      sha256rnds2 xmm2, xmm1, xmm0
      sha256rnds2 xmm1, xmm2, xmm0
    }
    _XMM6 = _mm_add_epi32(_XMM6, _mm_alignr_epi8(_XMM5, _XMM4, 4));
    __asm
    {
      sha256rnds2 xmm2, xmm1, xmm0
      sha256msg2 xmm6, xmm5
    }
    si128 = v15;
    __asm
    {
      sha256rnds2 xmm1, xmm2, xmm0
      sha256rnds2 xmm2, xmm1, xmm0
    }
    --a3;
    __asm { sha256rnds2 xmm1, xmm2, xmm0 }
    _XMM2 = _mm_add_epi32(_XMM2, v21);
    _XMM1 = _mm_add_epi32(_XMM1, v23);
  }
  while ( a3 );
  v93 = _mm_shuffle_epi32(_XMM2, 177);
  *a1 = _mm_unpackhi_epi64(_mm_shuffle_epi32(_XMM1, 177), v93);
  a1[1] = _mm_alignr_epi8(v93, _mm_shuffle_epi32(_XMM1, 27), 8);
  return result;
}
// 146148A0D: could not find valid save-restore pair for rdi
// 146148A0D: could not find valid save-restore pair for rsi
// 146148A1B: variable 'v4' is possibly undefined
// 146148A1B: variable 'result' is possibly undefined
// 146148A1F: variable 'v5' is possibly undefined
// 146148A23: variable 'v6' is possibly undefined
// 146148A28: variable 'v7' is possibly undefined
// 146148A2D: variable 'v8' is possibly undefined
// 1461487C0: using guessed type __int64 qword_1461487C0[48];

//----- (0000000146148DCD) ----------------------------------------------------
__int64 __fastcall sub_146148DCD(_DWORD *a1, const __m128i *a2, __int64 a3)
{
  const __m128i *v4; // rsi
  __int64 result; // rax
  int v6; // ebx
  int v7; // ecx
  int v8; // edx
  int v9; // r8d
  int v10; // r9d
  int v11; // r10d
  __int32 v12; // r11d
  __m128i si128; // xmm7
  __m128i v14; // xmm0
  const __m128i *v15; // rbp
  __m128i v16; // xmm1
  __m128i v17; // xmm2
  __m128i v18; // xmm3
  int v19; // r14d
  int v20; // edi
  int v21; // r13d
  __m128i v22; // xmm5
  __m128i v23; // xmm4
  __int32 v24; // r11d
  __int32 v25; // edx
  __m128i v26; // xmm6
  __m128i v27; // xmm5
  int v28; // r11d
  __m128i v29; // xmm4
  __m128i v30; // xmm6
  __m128i v31; // xmm7
  int v32; // r10d
  int v33; // ecx
  __m128i v34; // xmm6
  int v35; // r10d
  __m128i v36; // xmm0
  int v37; // r9d
  int v38; // ebx
  __m128i v39; // xmm6
  __m128i v40; // xmm7
  __m128i v41; // xmm6
  int v42; // r9d
  int v43; // r8d
  int v44; // eax
  int v45; // r8d
  __m128i v46; // xmm5
  __m128i v47; // xmm4
  __int32 v48; // edx
  __int32 v49; // r11d
  __m128i v50; // xmm6
  __m128i v51; // xmm5
  int v52; // edx
  __m128i v53; // xmm4
  __m128i v54; // xmm6
  __m128i v55; // xmm7
  int v56; // ecx
  int v57; // r10d
  __m128i v58; // xmm6
  int v59; // ecx
  __m128i v60; // xmm1
  int v61; // ebx
  int v62; // r9d
  __m128i v63; // xmm6
  __m128i v64; // xmm7
  __m128i v65; // xmm6
  int v66; // ebx
  int v67; // eax
  int v68; // r8d
  int v69; // eax
  __m128i v70; // xmm5
  __m128i v71; // xmm4
  __int32 v72; // r11d
  __int32 v73; // edx
  __m128i v74; // xmm6
  __m128i v75; // xmm5
  int v76; // r11d
  __m128i v77; // xmm4
  __m128i v78; // xmm6
  __m128i v79; // xmm7
  int v80; // r10d
  int v81; // ecx
  __m128i v82; // xmm6
  int v83; // r10d
  __m128i v84; // xmm2
  int v85; // r9d
  int v86; // ebx
  __m128i v87; // xmm6
  __m128i v88; // xmm7
  __m128i v89; // xmm6
  int v90; // r9d
  int v91; // r8d
  int v92; // eax
  int v93; // r8d
  __m128i v94; // xmm5
  __m128i v95; // xmm4
  __int32 v96; // edx
  __m128i v97; // xmm6
  __m128i v98; // xmm5
  __m128i v99; // xmm4
  __m128i v100; // xmm6
  __m128i v101; // xmm7
  int v102; // ecx
  __m128i v103; // xmm6
  __m128i v104; // xmm3
  int v105; // ebx
  __m128i v106; // xmm6
  __m128i v107; // xmm7
  __m128i v108; // xmm6
  int v109; // eax
  __int32 v110; // r11d
  __int32 v111; // edx
  int v112; // r11d
  int v113; // r10d
  int v114; // ecx
  int v115; // r10d
  int v116; // r9d
  int v117; // ebx
  int v118; // r9d
  int v119; // r8d
  int v120; // eax
  int v121; // r8d
  __int32 v122; // edx
  __int32 v123; // r11d
  int v124; // edx
  int v125; // ecx
  int v126; // r10d
  int v127; // ecx
  int v128; // ebx
  int v129; // r9d
  int v130; // ebx
  int v131; // eax
  int v132; // r8d
  int v133; // eax
  __int32 v134; // r11d
  __int32 v135; // edx
  int v136; // r11d
  int v137; // r10d
  int v138; // ecx
  int v139; // r10d
  int v140; // r9d
  int v141; // ebx
  int v142; // r9d
  int v143; // r8d
  int v144; // eax
  int v145; // r8d
  __int32 v146; // edx
  __int32 v147; // r11d
  int v148; // edx
  int v149; // ecx
  int v150; // r10d
  int v151; // ecx
  int v152; // ebx
  int v153; // r9d
  int v154; // ebx
  int v155; // eax
  int v156; // r8d
  __m128i v157; // [rsp+0h] [rbp-D0h]
  __m128i v158; // [rsp+10h] [rbp-C0h]
  __m128i v159; // [rsp+20h] [rbp-B0h]
  __m128i v160; // [rsp+30h] [rbp-A0h]
  unsigned __int64 v162; // [rsp+50h] [rbp-80h]

  v4 = a2;
  v162 = (unsigned __int64)&a2[4 * a3];
  LODWORD(result) = *a1;
  v6 = a1[1];
  v7 = a1[2];
  v8 = a1[3];
  v9 = a1[4];
  v10 = a1[5];
  v11 = a1[6];
  v12 = a1[7];
  do
  {
    si128 = _mm_load_si128((const __m128i *)&ymmword_146148940);
    v14 = _mm_shuffle_epi8(_mm_loadu_si128(v4), si128);
    v15 = (const __m128i *)qword_146148740;
    v16 = _mm_shuffle_epi8(_mm_loadu_si128(v4 + 1), si128);
    v17 = _mm_shuffle_epi8(_mm_loadu_si128(v4 + 2), si128);
    v18 = _mm_shuffle_epi8(_mm_loadu_si128(v4 + 3), si128);
    v157 = _mm_add_epi32(_mm_load_si128((const __m128i *)qword_146148740), v14);
    v19 = result;
    v158 = _mm_add_epi32(_mm_load_si128((const __m128i *)&qword_146148740[4]), v16);
    v159 = _mm_add_epi32(_mm_load_si128((const __m128i *)&qword_146148740[8]), v17);
    v20 = v7 ^ v6;
    v160 = _mm_add_epi32(_mm_load_si128((const __m128i *)&qword_146148740[12]), v18);
    v21 = v9;
    do
    {
      v15 += 8;
      v22 = _mm_alignr_epi8(v16, v14, 4);
      v23 = _mm_srli_epi32(v22, 3u);
      v24 = __ROR4__(v9 ^ __ROR4__(v9 ^ __ROR4__(v21, 14), 5), 6) + (v11 ^ v9 & (v11 ^ v10)) + v157.m128i_i32[0] + v12;
      v25 = v24 + v8;
      v26 = _mm_srli_epi32(v22, 7u);
      v27 = _mm_slli_epi32(v22, 0xEu);
      v28 = (v6 ^ (v6 ^ v19) & v20) + v24 + __ROR4__(v19 ^ __ROR4__(v19 ^ __ROR4__(v19, 9), 11), 2);
      v29 = _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v23, v26), v27), _mm_srli_epi32(v26, 0xBu));
      v30 = _mm_shuffle_epi32(v18, 250);
      v31 = _mm_srli_epi32(v30, 0xAu);
      v32 = __ROR4__(v25 ^ __ROR4__(v25 ^ __ROR4__(v25, 14), 5), 6) + (v10 ^ v25 & (v10 ^ v9)) + v157.m128i_i32[1] + v11;
      v33 = v32 + v7;
      v34 = _mm_srli_epi64(v30, 0x11u);
      v35 = (v19 ^ (v19 ^ v28) & (v6 ^ v19)) + v32 + __ROR4__(v28 ^ __ROR4__(v28 ^ __ROR4__(v28, 9), 11), 2);
      v36 = _mm_add_epi32(
              _mm_add_epi32(
                _mm_add_epi32(v14, _mm_alignr_epi8(v18, v17, 4)),
                _mm_xor_si128(v29, _mm_slli_epi32(v27, 0xBu))),
              _mm_srli_si128(_mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v31, v34), _mm_srli_epi64(v34, 2u)), 128), 8));
      v37 = __ROR4__(v33 ^ __ROR4__(v33 ^ __ROR4__(v33, 14), 5), 6) + (v9 ^ v33 & (v9 ^ v25)) + v157.m128i_i32[2] + v10;
      v38 = v37 + v6;
      v39 = _mm_shuffle_epi32(v36, 80);
      v40 = _mm_srli_epi32(v39, 0xAu);
      v41 = _mm_srli_epi64(v39, 0x11u);
      v42 = (v28 ^ (v28 ^ v35) & (v19 ^ v28)) + v37 + __ROR4__(v35 ^ __ROR4__(v35 ^ __ROR4__(v35, 9), 11), 2);
      v43 = __ROR4__(v38 ^ __ROR4__(v38 ^ __ROR4__(v38, 14), 5), 6) + (v25 ^ v38 & (v25 ^ v33)) + v157.m128i_i32[3] + v9;
      v14 = _mm_add_epi32(
              v36,
              _mm_slli_si128(_mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v40, v41), _mm_srli_epi64(v41, 2u)), 8), 8));
      v44 = v43 + v19;
      v157 = _mm_add_epi32(_mm_load_si128(v15), v14);
      v45 = (v35 ^ (v35 ^ v42) & (v28 ^ v35)) + v43 + __ROR4__(v42 ^ __ROR4__(v42 ^ __ROR4__(v42, 9), 11), 2);
      v46 = _mm_alignr_epi8(v17, v16, 4);
      v47 = _mm_srli_epi32(v46, 3u);
      v48 = __ROR4__(v44 ^ __ROR4__(v44 ^ __ROR4__(v44, 14), 5), 6)
          + (v33 ^ v44 & (v33 ^ v38))
          + v158.m128i_i32[0]
          + v25;
      v49 = v48 + v28;
      v50 = _mm_srli_epi32(v46, 7u);
      v51 = _mm_slli_epi32(v46, 0xEu);
      v52 = (v42 ^ (v42 ^ v45) & (v35 ^ v42)) + v48 + __ROR4__(v45 ^ __ROR4__(v45 ^ __ROR4__(v45, 9), 11), 2);
      v53 = _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v47, v50), v51), _mm_srli_epi32(v50, 0xBu));
      v54 = _mm_shuffle_epi32(v14, 250);
      v55 = _mm_srli_epi32(v54, 0xAu);
      v56 = __ROR4__(v49 ^ __ROR4__(v49 ^ __ROR4__(v49, 14), 5), 6)
          + (v38 ^ v49 & (v38 ^ v44))
          + v158.m128i_i32[1]
          + v33;
      v57 = v56 + v35;
      v58 = _mm_srli_epi64(v54, 0x11u);
      v59 = (v45 ^ (v45 ^ v52) & (v42 ^ v45)) + v56 + __ROR4__(v52 ^ __ROR4__(v52 ^ __ROR4__(v52, 9), 11), 2);
      v60 = _mm_add_epi32(
              _mm_add_epi32(
                _mm_add_epi32(v16, _mm_alignr_epi8(v14, v18, 4)),
                _mm_xor_si128(v53, _mm_slli_epi32(v51, 0xBu))),
              _mm_srli_si128(_mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v55, v58), _mm_srli_epi64(v58, 2u)), 128), 8));
      v61 = __ROR4__(v57 ^ __ROR4__(v57 ^ __ROR4__(v57, 14), 5), 6)
          + (v44 ^ v57 & (v44 ^ v49))
          + v158.m128i_i32[2]
          + v38;
      v62 = v61 + v42;
      v63 = _mm_shuffle_epi32(v60, 80);
      v64 = _mm_srli_epi32(v63, 0xAu);
      v65 = _mm_srli_epi64(v63, 0x11u);
      v66 = (v52 ^ (v52 ^ v59) & (v45 ^ v52)) + v61 + __ROR4__(v59 ^ __ROR4__(v59 ^ __ROR4__(v59, 9), 11), 2);
      v67 = __ROR4__(v62 ^ __ROR4__(v62 ^ __ROR4__(v62, 14), 5), 6)
          + (v49 ^ v62 & (v49 ^ v57))
          + v158.m128i_i32[3]
          + v44;
      v16 = _mm_add_epi32(
              v60,
              _mm_slli_si128(_mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v64, v65), _mm_srli_epi64(v65, 2u)), 8), 8));
      v68 = v67 + v45;
      v158 = _mm_add_epi32(_mm_load_si128(v15 + 2), v16);
      v69 = (v59 ^ (v59 ^ v66) & (v52 ^ v59)) + v67 + __ROR4__(v66 ^ __ROR4__(v66 ^ __ROR4__(v66, 9), 11), 2);
      v70 = _mm_alignr_epi8(v18, v17, 4);
      v71 = _mm_srli_epi32(v70, 3u);
      v72 = __ROR4__(v68 ^ __ROR4__(v68 ^ __ROR4__(v68, 14), 5), 6)
          + (v57 ^ v68 & (v57 ^ v62))
          + v159.m128i_i32[0]
          + v49;
      v73 = v72 + v52;
      v74 = _mm_srli_epi32(v70, 7u);
      v75 = _mm_slli_epi32(v70, 0xEu);
      v76 = (v66 ^ (v66 ^ v69) & (v59 ^ v66)) + v72 + __ROR4__(v69 ^ __ROR4__(v69 ^ __ROR4__(v69, 9), 11), 2);
      v77 = _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v71, v74), v75), _mm_srli_epi32(v74, 0xBu));
      v78 = _mm_shuffle_epi32(v16, 250);
      v79 = _mm_srli_epi32(v78, 0xAu);
      v80 = __ROR4__(v73 ^ __ROR4__(v73 ^ __ROR4__(v73, 14), 5), 6)
          + (v62 ^ v73 & (v62 ^ v68))
          + v159.m128i_i32[1]
          + v57;
      v81 = v80 + v59;
      v82 = _mm_srli_epi64(v78, 0x11u);
      v83 = (v69 ^ (v69 ^ v76) & (v66 ^ v69)) + v80 + __ROR4__(v76 ^ __ROR4__(v76 ^ __ROR4__(v76, 9), 11), 2);
      v84 = _mm_add_epi32(
              _mm_add_epi32(
                _mm_add_epi32(v17, _mm_alignr_epi8(v16, v14, 4)),
                _mm_xor_si128(v77, _mm_slli_epi32(v75, 0xBu))),
              _mm_srli_si128(_mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v79, v82), _mm_srli_epi64(v82, 2u)), 128), 8));
      v85 = __ROR4__(v81 ^ __ROR4__(v81 ^ __ROR4__(v81, 14), 5), 6)
          + (v68 ^ v81 & (v68 ^ v73))
          + v159.m128i_i32[2]
          + v62;
      v86 = v85 + v66;
      v87 = _mm_shuffle_epi32(v84, 80);
      v88 = _mm_srli_epi32(v87, 0xAu);
      v89 = _mm_srli_epi64(v87, 0x11u);
      v90 = (v76 ^ (v76 ^ v83) & (v69 ^ v76)) + v85 + __ROR4__(v83 ^ __ROR4__(v83 ^ __ROR4__(v83, 9), 11), 2);
      v91 = __ROR4__(v86 ^ __ROR4__(v86 ^ __ROR4__(v86, 14), 5), 6)
          + (v73 ^ v86 & (v73 ^ v81))
          + v159.m128i_i32[3]
          + v68;
      v17 = _mm_add_epi32(
              v84,
              _mm_slli_si128(_mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v88, v89), _mm_srli_epi64(v89, 2u)), 8), 8));
      v92 = v91 + v69;
      v159 = _mm_add_epi32(_mm_load_si128(v15 + 4), v17);
      v93 = (v83 ^ (v83 ^ v90) & (v76 ^ v83)) + v91 + __ROR4__(v90 ^ __ROR4__(v90 ^ __ROR4__(v90, 9), 11), 2);
      v94 = _mm_alignr_epi8(v14, v18, 4);
      v95 = _mm_srli_epi32(v94, 3u);
      v96 = __ROR4__(v92 ^ __ROR4__(v92 ^ __ROR4__(v92, 14), 5), 6)
          + (v81 ^ v92 & (v81 ^ v86))
          + v160.m128i_i32[0]
          + v73;
      v12 = v96 + v76;
      v97 = _mm_srli_epi32(v94, 7u);
      v98 = _mm_slli_epi32(v94, 0xEu);
      v8 = (v90 ^ (v90 ^ v93) & (v83 ^ v90)) + v96 + __ROR4__(v93 ^ __ROR4__(v93 ^ __ROR4__(v93, 9), 11), 2);
      v99 = _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v95, v97), v98), _mm_srli_epi32(v97, 0xBu));
      v100 = _mm_shuffle_epi32(v17, 250);
      v101 = _mm_srli_epi32(v100, 0xAu);
      v102 = __ROR4__(v12 ^ __ROR4__(v12 ^ __ROR4__(v12, 14), 5), 6)
           + (v86 ^ v12 & (v86 ^ v92))
           + v160.m128i_i32[1]
           + v81;
      v11 = v102 + v83;
      v103 = _mm_srli_epi64(v100, 0x11u);
      v7 = (v93 ^ (v93 ^ v8) & (v90 ^ v93)) + v102 + __ROR4__(v8 ^ __ROR4__(v8 ^ __ROR4__(v8, 9), 11), 2);
      v104 = _mm_add_epi32(
               _mm_add_epi32(
                 _mm_add_epi32(v18, _mm_alignr_epi8(v17, v16, 4)),
                 _mm_xor_si128(v99, _mm_slli_epi32(v98, 0xBu))),
               _mm_srli_si128(
                 _mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v101, v103), _mm_srli_epi64(v103, 2u)), 128),
                 8));
      v105 = __ROR4__(v11 ^ __ROR4__(v11 ^ __ROR4__(v11, 14), 5), 6)
           + (v92 ^ v11 & (v92 ^ v12))
           + v160.m128i_i32[2]
           + v86;
      v10 = v105 + v90;
      v106 = _mm_shuffle_epi32(v104, 80);
      v107 = _mm_srli_epi32(v106, 0xAu);
      v108 = _mm_srli_epi64(v106, 0x11u);
      v6 = (v8 ^ (v8 ^ v7) & (v93 ^ v8)) + v105 + __ROR4__(v7 ^ __ROR4__(v7 ^ __ROR4__(v7, 9), 11), 2);
      v20 = v7 ^ v6;
      v109 = __ROR4__(v10 ^ __ROR4__(v10 ^ __ROR4__(v10, 14), 5), 6)
           + (v12 ^ v10 & (v12 ^ v11))
           + v160.m128i_i32[3]
           + v92;
      v18 = _mm_add_epi32(
              v104,
              _mm_slli_si128(
                _mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v107, v108), _mm_srli_epi64(v108, 2u)), 8),
                8));
      v9 = v109 + v93;
      v21 = v9;
      v19 = (v7 ^ (v7 ^ v6) & (v8 ^ v7)) + v109 + __ROR4__(v6 ^ __ROR4__(v6 ^ __ROR4__(v6, 9), 11), 2);
      v160 = _mm_add_epi32(_mm_load_si128(v15 + 6), v18);
    }
    while ( v15[8].m128i_i8[3] );
    v110 = __ROR4__(v9 ^ __ROR4__(v9 ^ __ROR4__(v9, 14), 5), 6) + (v11 ^ v9 & (v11 ^ v10)) + v157.m128i_i32[0] + v12;
    v111 = v110 + v8;
    v112 = (v6 ^ (v6 ^ v19) & v20) + v110 + __ROR4__(v19 ^ __ROR4__(v19 ^ __ROR4__(v19, 9), 11), 2);
    v113 = __ROR4__(v111 ^ __ROR4__(v111 ^ __ROR4__(v111, 14), 5), 6)
         + (v10 ^ v111 & (v10 ^ v9))
         + v157.m128i_i32[1]
         + v11;
    v114 = v113 + v7;
    v115 = (v19 ^ (v19 ^ v112) & (v6 ^ v19)) + v113 + __ROR4__(v112 ^ __ROR4__(v112 ^ __ROR4__(v112, 9), 11), 2);
    v116 = __ROR4__(v114 ^ __ROR4__(v114 ^ __ROR4__(v114, 14), 5), 6)
         + (v9 ^ v114 & (v9 ^ v111))
         + v157.m128i_i32[2]
         + v10;
    v117 = v116 + v6;
    v118 = (v112 ^ (v112 ^ v115) & (v19 ^ v112)) + v116 + __ROR4__(v115 ^ __ROR4__(v115 ^ __ROR4__(v115, 9), 11), 2);
    v119 = __ROR4__(v117 ^ __ROR4__(v117 ^ __ROR4__(v117, 14), 5), 6)
         + (v111 ^ v117 & (v111 ^ v114))
         + v157.m128i_i32[3]
         + v9;
    v120 = v119 + v19;
    v121 = (v115 ^ (v115 ^ v118) & (v112 ^ v115)) + v119 + __ROR4__(v118 ^ __ROR4__(v118 ^ __ROR4__(v118, 9), 11), 2);
    v122 = __ROR4__(v120 ^ __ROR4__(v120 ^ __ROR4__(v120, 14), 5), 6)
         + (v114 ^ v120 & (v114 ^ v117))
         + v158.m128i_i32[0]
         + v111;
    v123 = v122 + v112;
    v124 = (v118 ^ (v118 ^ v121) & (v115 ^ v118)) + v122 + __ROR4__(v121 ^ __ROR4__(v121 ^ __ROR4__(v121, 9), 11), 2);
    v125 = __ROR4__(v123 ^ __ROR4__(v123 ^ __ROR4__(v123, 14), 5), 6)
         + (v117 ^ v123 & (v117 ^ v120))
         + v158.m128i_i32[1]
         + v114;
    v126 = v125 + v115;
    v127 = (v121 ^ (v121 ^ v124) & (v118 ^ v121)) + v125 + __ROR4__(v124 ^ __ROR4__(v124 ^ __ROR4__(v124, 9), 11), 2);
    v128 = __ROR4__(v126 ^ __ROR4__(v126 ^ __ROR4__(v126, 14), 5), 6)
         + (v120 ^ v126 & (v120 ^ v123))
         + v158.m128i_i32[2]
         + v117;
    v129 = v128 + v118;
    v130 = (v124 ^ (v124 ^ v127) & (v121 ^ v124)) + v128 + __ROR4__(v127 ^ __ROR4__(v127 ^ __ROR4__(v127, 9), 11), 2);
    v131 = __ROR4__(v129 ^ __ROR4__(v129 ^ __ROR4__(v129, 14), 5), 6)
         + (v123 ^ v129 & (v123 ^ v126))
         + v158.m128i_i32[3]
         + v120;
    v132 = v131 + v121;
    v133 = (v127 ^ (v127 ^ v130) & (v124 ^ v127)) + v131 + __ROR4__(v130 ^ __ROR4__(v130 ^ __ROR4__(v130, 9), 11), 2);
    v134 = __ROR4__(v132 ^ __ROR4__(v132 ^ __ROR4__(v132, 14), 5), 6)
         + (v126 ^ v132 & (v126 ^ v129))
         + v159.m128i_i32[0]
         + v123;
    v135 = v134 + v124;
    v136 = (v130 ^ (v130 ^ v133) & (v127 ^ v130)) + v134 + __ROR4__(v133 ^ __ROR4__(v133 ^ __ROR4__(v133, 9), 11), 2);
    v137 = __ROR4__(v135 ^ __ROR4__(v135 ^ __ROR4__(v135, 14), 5), 6)
         + (v129 ^ v135 & (v129 ^ v132))
         + v159.m128i_i32[1]
         + v126;
    v138 = v137 + v127;
    v139 = (v133 ^ (v133 ^ v136) & (v130 ^ v133)) + v137 + __ROR4__(v136 ^ __ROR4__(v136 ^ __ROR4__(v136, 9), 11), 2);
    v140 = __ROR4__(v138 ^ __ROR4__(v138 ^ __ROR4__(v138, 14), 5), 6)
         + (v132 ^ v138 & (v132 ^ v135))
         + v159.m128i_i32[2]
         + v129;
    v141 = v140 + v130;
    v142 = (v136 ^ (v136 ^ v139) & (v133 ^ v136)) + v140 + __ROR4__(v139 ^ __ROR4__(v139 ^ __ROR4__(v139, 9), 11), 2);
    v143 = __ROR4__(v141 ^ __ROR4__(v141 ^ __ROR4__(v141, 14), 5), 6)
         + (v135 ^ v141 & (v135 ^ v138))
         + v159.m128i_i32[3]
         + v132;
    v144 = v143 + v133;
    v145 = (v139 ^ (v139 ^ v142) & (v136 ^ v139)) + v143 + __ROR4__(v142 ^ __ROR4__(v142 ^ __ROR4__(v142, 9), 11), 2);
    v146 = __ROR4__(v144 ^ __ROR4__(v144 ^ __ROR4__(v144, 14), 5), 6)
         + (v138 ^ v144 & (v138 ^ v141))
         + v160.m128i_i32[0]
         + v135;
    v147 = v146 + v136;
    v148 = (v142 ^ (v142 ^ v145) & (v139 ^ v142)) + v146 + __ROR4__(v145 ^ __ROR4__(v145 ^ __ROR4__(v145, 9), 11), 2);
    v149 = __ROR4__(v147 ^ __ROR4__(v147 ^ __ROR4__(v147, 14), 5), 6)
         + (v141 ^ v147 & (v141 ^ v144))
         + v160.m128i_i32[1]
         + v138;
    v150 = v149 + v139;
    v151 = (v145 ^ (v145 ^ v148) & (v142 ^ v145)) + v149 + __ROR4__(v148 ^ __ROR4__(v148 ^ __ROR4__(v148, 9), 11), 2);
    v152 = __ROR4__(v150 ^ __ROR4__(v150 ^ __ROR4__(v150, 14), 5), 6)
         + (v144 ^ v150 & (v144 ^ v147))
         + v160.m128i_i32[2]
         + v141;
    v153 = v152 + v142;
    v154 = (v148 ^ (v148 ^ v151) & (v145 ^ v148)) + v152 + __ROR4__(v151 ^ __ROR4__(v151 ^ __ROR4__(v151, 9), 11), 2);
    v155 = __ROR4__(v153 ^ __ROR4__(v153 ^ __ROR4__(v153, 14), 5), 6)
         + (v147 ^ v153 & (v147 ^ v150))
         + v160.m128i_i32[3]
         + v144;
    v156 = v155 + v145;
    result = *a1
           + (v151 ^ (v151 ^ v154) & (v148 ^ (unsigned int)v151))
           + v155
           + __ROR4__(v154 ^ __ROR4__(v154 ^ __ROR4__(v154, 9), 11), 2);
    v4 += 4;
    v6 = a1[1] + v154;
    v7 = a1[2] + v151;
    v8 = a1[3] + v148;
    v9 = a1[4] + v156;
    v10 = a1[5] + v153;
    v11 = a1[6] + v150;
    v12 = a1[7] + v147;
    *a1 = result;
    a1[1] = v6;
    a1[2] = v7;
    a1[3] = v8;
    a1[4] = v9;
    a1[5] = v10;
    a1[6] = v11;
    a1[7] = v12;
  }
  while ( (unsigned __int64)v4 < v162 );
  return result;
}
// 146148DCD: could not find valid save-restore pair for rdi
// 146148DCD: could not find valid save-restore pair for rsi
// 146148740: using guessed type __int64 qword_146148740[16];
// 146148940: using guessed type __m256 ymmword_146148940;

//----- (0000000146149D0D) ----------------------------------------------------
__int64 __fastcall sub_146149D0D(_DWORD *a1, unsigned __int64 a2, __int64 a3)
{
  __int64 result; // rax
  int v6; // ebx
  int v7; // ecx
  int v8; // edx
  int v9; // r8d
  int v10; // r9d
  int v11; // r10d
  int v12; // r11d
  __int64 *v21; // rbp
  int v29; // r14d
  int v30; // edi
  int v31; // r13d
  int v33; // r13d
  unsigned __int64 v34; // rt0
  int v35; // eax
  int v37; // r14d
  int v40; // r13d
  int v42; // r14d
  int v45; // r11d
  int v47; // edx
  int v49; // r14d
  int v50; // r13d
  int v52; // r11d
  int v53; // r14d
  int v56; // r13d
  int v59; // r14d
  int v62; // r10d
  int v64; // ecx
  int v66; // r14d
  int v67; // r13d
  int v68; // r10d
  int v70; // r14d
  int v73; // r13d
  int v75; // r14d
  int v78; // r9d
  int v80; // ebx
  int v82; // r14d
  int v84; // r13d
  int v85; // r9d
  int v87; // r14d
  int v89; // r13d
  int v90; // r14d
  int v91; // r8d
  int v92; // eax
  int v93; // r14d
  int v95; // r13d
  int v96; // r8d
  int v98; // r14d
  int v101; // r13d
  int v103; // r14d
  int v106; // edx
  int v108; // r11d
  int v110; // r14d
  int v111; // r13d
  int v113; // edx
  int v114; // r14d
  int v117; // r13d
  int v120; // r14d
  int v123; // ecx
  int v125; // r10d
  int v127; // r14d
  int v128; // r13d
  int v129; // ecx
  int v131; // r14d
  int v134; // r13d
  int v136; // r14d
  int v139; // ebx
  int v141; // r9d
  int v143; // r14d
  int v145; // r13d
  int v146; // ebx
  int v148; // r14d
  int v150; // r13d
  int v151; // r14d
  int v152; // eax
  int v153; // r8d
  int v154; // r14d
  int v156; // r13d
  int v157; // eax
  int v159; // r14d
  int v162; // r13d
  int v164; // r14d
  int v167; // r11d
  int v169; // edx
  int v171; // r14d
  int v172; // r13d
  int v174; // r11d
  int v175; // r14d
  int v178; // r13d
  int v181; // r14d
  int v184; // r10d
  int v186; // ecx
  int v188; // r14d
  int v189; // r13d
  int v190; // r10d
  int v192; // r14d
  int v195; // r13d
  int v197; // r14d
  int v200; // r9d
  int v202; // ebx
  int v204; // r14d
  int v206; // r13d
  int v207; // r9d
  int v209; // r14d
  int v211; // r13d
  int v212; // r14d
  int v213; // r8d
  int v214; // eax
  int v215; // r14d
  int v217; // r13d
  int v218; // r8d
  int v220; // r14d
  int v223; // r13d
  int v225; // r14d
  int v228; // edx
  int v231; // r14d
  int v232; // r13d
  int v234; // r14d
  int v237; // r13d
  int v240; // r14d
  int v243; // ecx
  int v246; // r14d
  int v247; // r13d
  int v249; // r14d
  int v252; // r13d
  int v254; // r14d
  int v257; // ebx
  int v260; // r14d
  int v262; // r13d
  int v264; // r14d
  int v266; // r13d
  int v267; // r14d
  int v268; // eax
  int v269; // r13d
  unsigned __int64 v270; // rt0
  int v271; // eax
  int v272; // r14d
  int v273; // r13d
  int v274; // r14d
  int v275; // r11d
  int v276; // edx
  int v277; // r14d
  int v278; // r13d
  int v279; // r11d
  int v280; // r14d
  int v281; // r13d
  int v282; // r14d
  int v283; // r10d
  int v284; // ecx
  int v285; // r14d
  int v286; // r13d
  int v287; // r10d
  int v288; // r14d
  int v289; // r13d
  int v290; // r14d
  int v291; // r9d
  int v292; // ebx
  int v293; // r14d
  int v294; // r13d
  int v295; // r9d
  int v296; // r14d
  int v297; // r13d
  int v298; // r14d
  int v299; // r8d
  int v300; // eax
  int v301; // r14d
  int v302; // r13d
  int v303; // r8d
  int v304; // r14d
  int v305; // r13d
  int v306; // r14d
  int v307; // edx
  int v308; // r11d
  int v309; // r14d
  int v310; // r13d
  int v311; // edx
  int v312; // r14d
  int v313; // r13d
  int v314; // r14d
  int v315; // ecx
  int v316; // r10d
  int v317; // r14d
  int v318; // r13d
  int v319; // ecx
  int v320; // r14d
  int v321; // r13d
  int v322; // r14d
  int v323; // ebx
  int v324; // r9d
  int v325; // r14d
  int v326; // r13d
  int v327; // ebx
  int v328; // r14d
  int v329; // r13d
  int v330; // r14d
  int v331; // eax
  int v332; // r8d
  int v333; // r14d
  int v334; // r13d
  int v335; // eax
  int v336; // r14d
  int v337; // r13d
  int v338; // r14d
  int v339; // r11d
  int v340; // edx
  int v341; // r14d
  int v342; // r13d
  int v343; // r11d
  int v344; // r14d
  int v345; // r13d
  int v346; // r14d
  int v347; // r10d
  int v348; // ecx
  int v349; // r14d
  int v350; // r13d
  int v351; // r10d
  int v352; // r14d
  int v353; // r13d
  int v354; // r14d
  int v355; // r9d
  int v356; // ebx
  int v357; // r14d
  int v358; // r13d
  int v359; // r9d
  int v360; // r14d
  int v361; // r13d
  int v362; // r14d
  int v363; // r8d
  int v364; // eax
  int v365; // r14d
  int v366; // r13d
  int v367; // r8d
  int v368; // r14d
  int v369; // r13d
  int v370; // r14d
  int v371; // edx
  int v372; // r11d
  int v373; // r14d
  int v374; // r13d
  int v375; // edx
  int v376; // r14d
  int v377; // r13d
  int v378; // r14d
  int v379; // ecx
  int v380; // r10d
  int v381; // r14d
  int v382; // r13d
  int v383; // ecx
  int v384; // r14d
  int v385; // r13d
  int v386; // r14d
  int v387; // ebx
  int v388; // r9d
  int v389; // r14d
  int v390; // r13d
  int v391; // ebx
  int v392; // r14d
  int v393; // r13d
  int v394; // r14d
  int v395; // eax
  int v396; // r8d
  __int128 v397; // [rsp+0h] [rbp-D0h]
  __int128 v398; // [rsp+10h] [rbp-C0h]
  __int128 v399; // [rsp+20h] [rbp-B0h]
  __int128 v400; // [rsp+30h] [rbp-A0h]
  unsigned __int64 v402; // [rsp+50h] [rbp-80h]

  _RSI = a2;
  v402 = a2 + (a3 << 6);
  __asm { vzeroupper }
  LODWORD(result) = *a1;
  v6 = a1[1];
  v7 = a1[2];
  v8 = a1[3];
  v9 = a1[4];
  v10 = a1[5];
  v11 = a1[6];
  v12 = a1[7];
  __asm
  {
    vmovdqa xmm8, xmmword ptr cs:ymmword_146148960
    vmovdqa xmm9, xmmword ptr cs:ymmword_146148980
  }
  do
  {
    __asm
    {
      vmovdqa xmm7, xmmword ptr cs:ymmword_146148940
      vmovdqu xmm0, xmmword ptr [rsi]
      vmovdqu xmm1, xmmword ptr [rsi+10h]
      vmovdqu xmm2, xmmword ptr [rsi+20h]
      vmovdqu xmm3, xmmword ptr [rsi+30h]
      vpshufb xmm0, xmm0, xmm7
    }
    v21 = qword_146148740;
    __asm
    {
      vpshufb xmm1, xmm1, xmm7
      vpshufb xmm2, xmm2, xmm7
      vpaddd  xmm4, xmm0, xmmword ptr [rbp+0]
      vpshufb xmm3, xmm3, xmm7
      vpaddd  xmm5, xmm1, xmmword ptr [rbp+20h]
      vpaddd  xmm6, xmm2, xmmword ptr [rbp+40h]
      vpaddd  xmm7, xmm3, xmmword ptr [rbp+60h]
      vmovdqa [rsp+0D0h+var_D0], xmm4
    }
    v29 = result;
    __asm
    {
      vmovdqa [rsp+0D0h+var_C0], xmm5
      vmovdqa [rsp+0D0h+var_B0], xmm6
    }
    v30 = v7 ^ v6;
    __asm { vmovdqa [rsp+0D0h+var_A0], xmm7 }
    v31 = v9;
    do
    {
      v21 += 16;
      __asm { vpalignr xmm4, xmm1, xmm0, 4 }
      LODWORD(v34) = v31;
      HIDWORD(v34) = v31;
      v33 = v34 >> 14;
      v35 = v29;
      __asm { vpalignr xmm7, xmm3, xmm2, 4 }
      LODWORD(v34) = v29;
      HIDWORD(v34) = v29;
      v37 = v34 >> 9;
      __asm { vpsrld  xmm6, xmm4, 7 }
      LODWORD(v34) = v9 ^ v33;
      HIDWORD(v34) = v9 ^ v33;
      __asm { vpaddd  xmm0, xmm0, xmm7 }
      v40 = v9 ^ (v34 >> 5);
      __asm { vpsrld  xmm7, xmm4, 3 }
      LODWORD(v34) = v35 ^ v37;
      HIDWORD(v34) = v35 ^ v37;
      v42 = v34 >> 11;
      __asm { vpslld  xmm5, xmm4, 0Eh }
      LODWORD(v34) = v40;
      HIDWORD(v34) = v40;
      __asm { vpxor   xmm4, xmm7, xmm6 }
      v45 = (v34 >> 6) + (v11 ^ v9 & (v11 ^ v10)) + v397 + v12;
      __asm { vpshufd xmm7, xmm3, 0FAh }
      LODWORD(v34) = v35 ^ v42;
      HIDWORD(v34) = v35 ^ v42;
      v47 = v45 + v8;
      __asm { vpsrld  xmm6, xmm6, 0Bh }
      v49 = (v6 ^ (v6 ^ v35) & v30) + v45 + (v34 >> 2);
      LODWORD(v34) = v47;
      HIDWORD(v34) = v47;
      v50 = v34 >> 14;
      __asm { vpxor   xmm4, xmm4, xmm5 }
      v52 = v49;
      LODWORD(v34) = v49;
      HIDWORD(v34) = v49;
      v53 = v34 >> 9;
      __asm { vpslld  xmm5, xmm5, 0Bh }
      LODWORD(v34) = v47 ^ v50;
      HIDWORD(v34) = v47 ^ v50;
      __asm { vpxor   xmm4, xmm4, xmm6 }
      v56 = v47 ^ (v34 >> 5);
      __asm
      {
        vpsrld  xmm6, xmm7, 0Ah
        vpxor   xmm4, xmm4, xmm5
      }
      LODWORD(v34) = v52 ^ v53;
      HIDWORD(v34) = v52 ^ v53;
      v59 = v34 >> 11;
      __asm { vpsrlq  xmm7, xmm7, 11h }
      LODWORD(v34) = v56;
      HIDWORD(v34) = v56;
      __asm { vpaddd  xmm0, xmm0, xmm4 }
      v62 = (v34 >> 6) + (v10 ^ v47 & (v10 ^ v9)) + DWORD1(v397) + v11;
      LODWORD(v34) = v52 ^ v59;
      HIDWORD(v34) = v52 ^ v59;
      __asm { vpxor   xmm6, xmm6, xmm7 }
      v64 = v62 + v7;
      __asm { vpsrlq  xmm7, xmm7, 2 }
      v66 = (v35 ^ (v35 ^ v52) & (v6 ^ v35)) + v62 + (v34 >> 2);
      LODWORD(v34) = v64;
      HIDWORD(v34) = v64;
      v67 = v34 >> 14;
      v68 = v66;
      __asm { vpxor   xmm6, xmm6, xmm7 }
      LODWORD(v34) = v66;
      HIDWORD(v34) = v66;
      v70 = v34 >> 9;
      __asm { vpshufb xmm6, xmm6, xmm8 }
      LODWORD(v34) = v64 ^ v67;
      HIDWORD(v34) = v64 ^ v67;
      __asm { vpaddd  xmm0, xmm0, xmm6 }
      v73 = v64 ^ (v34 >> 5);
      __asm { vpshufd xmm7, xmm0, 50h ; 'P' }
      LODWORD(v34) = v68 ^ v70;
      HIDWORD(v34) = v68 ^ v70;
      v75 = v34 >> 11;
      __asm { vpsrld  xmm6, xmm7, 0Ah }
      LODWORD(v34) = v73;
      HIDWORD(v34) = v73;
      __asm { vpsrlq  xmm7, xmm7, 11h }
      v78 = (v34 >> 6) + (v9 ^ v64 & (v9 ^ v47)) + DWORD2(v397) + v10;
      __asm { vpxor   xmm6, xmm6, xmm7 }
      LODWORD(v34) = v68 ^ v75;
      HIDWORD(v34) = v68 ^ v75;
      v80 = v78 + v6;
      __asm { vpsrlq  xmm7, xmm7, 2 }
      v82 = (v52 ^ (v52 ^ v68) & (v35 ^ v52)) + v78 + (v34 >> 2);
      __asm { vpxor   xmm6, xmm6, xmm7 }
      LODWORD(v34) = v80;
      HIDWORD(v34) = v80;
      v84 = v34 >> 14;
      v85 = v82;
      __asm { vpshufb xmm6, xmm6, xmm9 }
      LODWORD(v34) = v82;
      HIDWORD(v34) = v82;
      v87 = v34 >> 9;
      __asm { vpaddd  xmm0, xmm0, xmm6 }
      LODWORD(v34) = v80 ^ v84;
      HIDWORD(v34) = v80 ^ v84;
      __asm { vpaddd  xmm6, xmm0, xmmword ptr [rbp+0] }
      v89 = v80 ^ (v34 >> 5);
      LODWORD(v34) = v85 ^ v87;
      HIDWORD(v34) = v85 ^ v87;
      v90 = v34 >> 11;
      LODWORD(v34) = v89;
      HIDWORD(v34) = v89;
      v91 = (v34 >> 6) + (v47 ^ v80 & (v47 ^ v64)) + HIDWORD(v397) + v9;
      LODWORD(v34) = v85 ^ v90;
      HIDWORD(v34) = v85 ^ v90;
      v92 = v91 + v35;
      v93 = (v68 ^ (v68 ^ v85) & (v52 ^ v68)) + v91 + (v34 >> 2);
      __asm
      {
        vmovdqa [rsp+0D0h+var_D0], xmm6
        vpalignr xmm4, xmm2, xmm1, 4
      }
      LODWORD(v34) = v92;
      HIDWORD(v34) = v92;
      v95 = v34 >> 14;
      v96 = v93;
      __asm { vpalignr xmm7, xmm0, xmm3, 4 }
      LODWORD(v34) = v93;
      HIDWORD(v34) = v93;
      v98 = v34 >> 9;
      __asm { vpsrld  xmm6, xmm4, 7 }
      LODWORD(v34) = v92 ^ v95;
      HIDWORD(v34) = v92 ^ v95;
      __asm { vpaddd  xmm1, xmm1, xmm7 }
      v101 = v92 ^ (v34 >> 5);
      __asm { vpsrld  xmm7, xmm4, 3 }
      LODWORD(v34) = v96 ^ v98;
      HIDWORD(v34) = v96 ^ v98;
      v103 = v34 >> 11;
      __asm { vpslld  xmm5, xmm4, 0Eh }
      LODWORD(v34) = v101;
      HIDWORD(v34) = v101;
      __asm { vpxor   xmm4, xmm7, xmm6 }
      v106 = (v34 >> 6) + (v64 ^ v92 & (v64 ^ v80)) + v398 + v47;
      __asm { vpshufd xmm7, xmm0, 0FAh }
      LODWORD(v34) = v96 ^ v103;
      HIDWORD(v34) = v96 ^ v103;
      v108 = v106 + v52;
      __asm { vpsrld  xmm6, xmm6, 0Bh }
      v110 = (v85 ^ (v85 ^ v96) & (v68 ^ v85)) + v106 + (v34 >> 2);
      LODWORD(v34) = v108;
      HIDWORD(v34) = v108;
      v111 = v34 >> 14;
      __asm { vpxor   xmm4, xmm4, xmm5 }
      v113 = v110;
      LODWORD(v34) = v110;
      HIDWORD(v34) = v110;
      v114 = v34 >> 9;
      __asm { vpslld  xmm5, xmm5, 0Bh }
      LODWORD(v34) = v108 ^ v111;
      HIDWORD(v34) = v108 ^ v111;
      __asm { vpxor   xmm4, xmm4, xmm6 }
      v117 = v108 ^ (v34 >> 5);
      __asm
      {
        vpsrld  xmm6, xmm7, 0Ah
        vpxor   xmm4, xmm4, xmm5
      }
      LODWORD(v34) = v113 ^ v114;
      HIDWORD(v34) = v113 ^ v114;
      v120 = v34 >> 11;
      __asm { vpsrlq  xmm7, xmm7, 11h }
      LODWORD(v34) = v117;
      HIDWORD(v34) = v117;
      __asm { vpaddd  xmm1, xmm1, xmm4 }
      v123 = (v34 >> 6) + (v80 ^ v108 & (v80 ^ v92)) + DWORD1(v398) + v64;
      LODWORD(v34) = v113 ^ v120;
      HIDWORD(v34) = v113 ^ v120;
      __asm { vpxor   xmm6, xmm6, xmm7 }
      v125 = v123 + v68;
      __asm { vpsrlq  xmm7, xmm7, 2 }
      v127 = (v96 ^ (v96 ^ v113) & (v85 ^ v96)) + v123 + (v34 >> 2);
      LODWORD(v34) = v125;
      HIDWORD(v34) = v125;
      v128 = v34 >> 14;
      v129 = v127;
      __asm { vpxor   xmm6, xmm6, xmm7 }
      LODWORD(v34) = v127;
      HIDWORD(v34) = v127;
      v131 = v34 >> 9;
      __asm { vpshufb xmm6, xmm6, xmm8 }
      LODWORD(v34) = v125 ^ v128;
      HIDWORD(v34) = v125 ^ v128;
      __asm { vpaddd  xmm1, xmm1, xmm6 }
      v134 = v125 ^ (v34 >> 5);
      __asm { vpshufd xmm7, xmm1, 50h ; 'P' }
      LODWORD(v34) = v129 ^ v131;
      HIDWORD(v34) = v129 ^ v131;
      v136 = v34 >> 11;
      __asm { vpsrld  xmm6, xmm7, 0Ah }
      LODWORD(v34) = v134;
      HIDWORD(v34) = v134;
      __asm { vpsrlq  xmm7, xmm7, 11h }
      v139 = (v34 >> 6) + (v92 ^ v125 & (v92 ^ v108)) + DWORD2(v398) + v80;
      __asm { vpxor   xmm6, xmm6, xmm7 }
      LODWORD(v34) = v129 ^ v136;
      HIDWORD(v34) = v129 ^ v136;
      v141 = v139 + v85;
      __asm { vpsrlq  xmm7, xmm7, 2 }
      v143 = (v113 ^ (v113 ^ v129) & (v96 ^ v113)) + v139 + (v34 >> 2);
      __asm { vpxor   xmm6, xmm6, xmm7 }
      LODWORD(v34) = v141;
      HIDWORD(v34) = v141;
      v145 = v34 >> 14;
      v146 = v143;
      __asm { vpshufb xmm6, xmm6, xmm9 }
      LODWORD(v34) = v143;
      HIDWORD(v34) = v143;
      v148 = v34 >> 9;
      __asm { vpaddd  xmm1, xmm1, xmm6 }
      LODWORD(v34) = v141 ^ v145;
      HIDWORD(v34) = v141 ^ v145;
      __asm { vpaddd  xmm6, xmm1, xmmword ptr [rbp+20h] }
      v150 = v141 ^ (v34 >> 5);
      LODWORD(v34) = v146 ^ v148;
      HIDWORD(v34) = v146 ^ v148;
      v151 = v34 >> 11;
      LODWORD(v34) = v150;
      HIDWORD(v34) = v150;
      v152 = (v34 >> 6) + (v108 ^ v141 & (v108 ^ v125)) + HIDWORD(v398) + v92;
      LODWORD(v34) = v146 ^ v151;
      HIDWORD(v34) = v146 ^ v151;
      v153 = v152 + v96;
      v154 = (v129 ^ (v129 ^ v146) & (v113 ^ v129)) + v152 + (v34 >> 2);
      __asm
      {
        vmovdqa [rsp+0D0h+var_C0], xmm6
        vpalignr xmm4, xmm3, xmm2, 4
      }
      LODWORD(v34) = v153;
      HIDWORD(v34) = v153;
      v156 = v34 >> 14;
      v157 = v154;
      __asm { vpalignr xmm7, xmm1, xmm0, 4 }
      LODWORD(v34) = v154;
      HIDWORD(v34) = v154;
      v159 = v34 >> 9;
      __asm { vpsrld  xmm6, xmm4, 7 }
      LODWORD(v34) = v153 ^ v156;
      HIDWORD(v34) = v153 ^ v156;
      __asm { vpaddd  xmm2, xmm2, xmm7 }
      v162 = v153 ^ (v34 >> 5);
      __asm { vpsrld  xmm7, xmm4, 3 }
      LODWORD(v34) = v157 ^ v159;
      HIDWORD(v34) = v157 ^ v159;
      v164 = v34 >> 11;
      __asm { vpslld  xmm5, xmm4, 0Eh }
      LODWORD(v34) = v162;
      HIDWORD(v34) = v162;
      __asm { vpxor   xmm4, xmm7, xmm6 }
      v167 = (v34 >> 6) + (v125 ^ v153 & (v125 ^ v141)) + v399 + v108;
      __asm { vpshufd xmm7, xmm1, 0FAh }
      LODWORD(v34) = v157 ^ v164;
      HIDWORD(v34) = v157 ^ v164;
      v169 = v167 + v113;
      __asm { vpsrld  xmm6, xmm6, 0Bh }
      v171 = (v146 ^ (v146 ^ v157) & (v129 ^ v146)) + v167 + (v34 >> 2);
      LODWORD(v34) = v169;
      HIDWORD(v34) = v169;
      v172 = v34 >> 14;
      __asm { vpxor   xmm4, xmm4, xmm5 }
      v174 = v171;
      LODWORD(v34) = v171;
      HIDWORD(v34) = v171;
      v175 = v34 >> 9;
      __asm { vpslld  xmm5, xmm5, 0Bh }
      LODWORD(v34) = v169 ^ v172;
      HIDWORD(v34) = v169 ^ v172;
      __asm { vpxor   xmm4, xmm4, xmm6 }
      v178 = v169 ^ (v34 >> 5);
      __asm
      {
        vpsrld  xmm6, xmm7, 0Ah
        vpxor   xmm4, xmm4, xmm5
      }
      LODWORD(v34) = v174 ^ v175;
      HIDWORD(v34) = v174 ^ v175;
      v181 = v34 >> 11;
      __asm { vpsrlq  xmm7, xmm7, 11h }
      LODWORD(v34) = v178;
      HIDWORD(v34) = v178;
      __asm { vpaddd  xmm2, xmm2, xmm4 }
      v184 = (v34 >> 6) + (v141 ^ v169 & (v141 ^ v153)) + DWORD1(v399) + v125;
      LODWORD(v34) = v174 ^ v181;
      HIDWORD(v34) = v174 ^ v181;
      __asm { vpxor   xmm6, xmm6, xmm7 }
      v186 = v184 + v129;
      __asm { vpsrlq  xmm7, xmm7, 2 }
      v188 = (v157 ^ (v157 ^ v174) & (v146 ^ v157)) + v184 + (v34 >> 2);
      LODWORD(v34) = v186;
      HIDWORD(v34) = v186;
      v189 = v34 >> 14;
      v190 = v188;
      __asm { vpxor   xmm6, xmm6, xmm7 }
      LODWORD(v34) = v188;
      HIDWORD(v34) = v188;
      v192 = v34 >> 9;
      __asm { vpshufb xmm6, xmm6, xmm8 }
      LODWORD(v34) = v186 ^ v189;
      HIDWORD(v34) = v186 ^ v189;
      __asm { vpaddd  xmm2, xmm2, xmm6 }
      v195 = v186 ^ (v34 >> 5);
      __asm { vpshufd xmm7, xmm2, 50h ; 'P' }
      LODWORD(v34) = v190 ^ v192;
      HIDWORD(v34) = v190 ^ v192;
      v197 = v34 >> 11;
      __asm { vpsrld  xmm6, xmm7, 0Ah }
      LODWORD(v34) = v195;
      HIDWORD(v34) = v195;
      __asm { vpsrlq  xmm7, xmm7, 11h }
      v200 = (v34 >> 6) + (v153 ^ v186 & (v153 ^ v169)) + DWORD2(v399) + v141;
      __asm { vpxor   xmm6, xmm6, xmm7 }
      LODWORD(v34) = v190 ^ v197;
      HIDWORD(v34) = v190 ^ v197;
      v202 = v200 + v146;
      __asm { vpsrlq  xmm7, xmm7, 2 }
      v204 = (v174 ^ (v174 ^ v190) & (v157 ^ v174)) + v200 + (v34 >> 2);
      __asm { vpxor   xmm6, xmm6, xmm7 }
      LODWORD(v34) = v202;
      HIDWORD(v34) = v202;
      v206 = v34 >> 14;
      v207 = v204;
      __asm { vpshufb xmm6, xmm6, xmm9 }
      LODWORD(v34) = v204;
      HIDWORD(v34) = v204;
      v209 = v34 >> 9;
      __asm { vpaddd  xmm2, xmm2, xmm6 }
      LODWORD(v34) = v202 ^ v206;
      HIDWORD(v34) = v202 ^ v206;
      __asm { vpaddd  xmm6, xmm2, xmmword ptr [rbp+40h] }
      v211 = v202 ^ (v34 >> 5);
      LODWORD(v34) = v207 ^ v209;
      HIDWORD(v34) = v207 ^ v209;
      v212 = v34 >> 11;
      LODWORD(v34) = v211;
      HIDWORD(v34) = v211;
      v213 = (v34 >> 6) + (v169 ^ v202 & (v169 ^ v186)) + HIDWORD(v399) + v153;
      LODWORD(v34) = v207 ^ v212;
      HIDWORD(v34) = v207 ^ v212;
      v214 = v213 + v157;
      v215 = (v190 ^ (v190 ^ v207) & (v174 ^ v190)) + v213 + (v34 >> 2);
      __asm
      {
        vmovdqa [rsp+0D0h+var_B0], xmm6
        vpalignr xmm4, xmm0, xmm3, 4
      }
      LODWORD(v34) = v214;
      HIDWORD(v34) = v214;
      v217 = v34 >> 14;
      v218 = v215;
      __asm { vpalignr xmm7, xmm2, xmm1, 4 }
      LODWORD(v34) = v215;
      HIDWORD(v34) = v215;
      v220 = v34 >> 9;
      __asm { vpsrld  xmm6, xmm4, 7 }
      LODWORD(v34) = v214 ^ v217;
      HIDWORD(v34) = v214 ^ v217;
      __asm { vpaddd  xmm3, xmm3, xmm7 }
      v223 = v214 ^ (v34 >> 5);
      __asm { vpsrld  xmm7, xmm4, 3 }
      LODWORD(v34) = v218 ^ v220;
      HIDWORD(v34) = v218 ^ v220;
      v225 = v34 >> 11;
      __asm { vpslld  xmm5, xmm4, 0Eh }
      LODWORD(v34) = v223;
      HIDWORD(v34) = v223;
      __asm { vpxor   xmm4, xmm7, xmm6 }
      v228 = (v34 >> 6) + (v186 ^ v214 & (v186 ^ v202)) + v400 + v169;
      __asm { vpshufd xmm7, xmm2, 0FAh }
      LODWORD(v34) = v218 ^ v225;
      HIDWORD(v34) = v218 ^ v225;
      v12 = v228 + v174;
      __asm { vpsrld  xmm6, xmm6, 0Bh }
      v231 = (v207 ^ (v207 ^ v218) & (v190 ^ v207)) + v228 + (v34 >> 2);
      LODWORD(v34) = v12;
      HIDWORD(v34) = v12;
      v232 = v34 >> 14;
      __asm { vpxor   xmm4, xmm4, xmm5 }
      v8 = v231;
      LODWORD(v34) = v231;
      HIDWORD(v34) = v231;
      v234 = v34 >> 9;
      __asm { vpslld  xmm5, xmm5, 0Bh }
      LODWORD(v34) = v12 ^ v232;
      HIDWORD(v34) = v12 ^ v232;
      __asm { vpxor   xmm4, xmm4, xmm6 }
      v237 = v12 ^ (v34 >> 5);
      __asm
      {
        vpsrld  xmm6, xmm7, 0Ah
        vpxor   xmm4, xmm4, xmm5
      }
      LODWORD(v34) = v8 ^ v234;
      HIDWORD(v34) = v8 ^ v234;
      v240 = v34 >> 11;
      __asm { vpsrlq  xmm7, xmm7, 11h }
      LODWORD(v34) = v237;
      HIDWORD(v34) = v237;
      __asm { vpaddd  xmm3, xmm3, xmm4 }
      v243 = (v34 >> 6) + (v202 ^ v12 & (v202 ^ v214)) + DWORD1(v400) + v186;
      LODWORD(v34) = v8 ^ v240;
      HIDWORD(v34) = v8 ^ v240;
      __asm { vpxor   xmm6, xmm6, xmm7 }
      v11 = v243 + v190;
      __asm { vpsrlq  xmm7, xmm7, 2 }
      v246 = (v218 ^ (v218 ^ v8) & (v207 ^ v218)) + v243 + (v34 >> 2);
      LODWORD(v34) = v11;
      HIDWORD(v34) = v11;
      v247 = v34 >> 14;
      v7 = v246;
      __asm { vpxor   xmm6, xmm6, xmm7 }
      LODWORD(v34) = v246;
      HIDWORD(v34) = v246;
      v249 = v34 >> 9;
      __asm { vpshufb xmm6, xmm6, xmm8 }
      LODWORD(v34) = v11 ^ v247;
      HIDWORD(v34) = v11 ^ v247;
      __asm { vpaddd  xmm3, xmm3, xmm6 }
      v252 = v11 ^ (v34 >> 5);
      __asm { vpshufd xmm7, xmm3, 50h ; 'P' }
      LODWORD(v34) = v7 ^ v249;
      HIDWORD(v34) = v7 ^ v249;
      v254 = v34 >> 11;
      __asm { vpsrld  xmm6, xmm7, 0Ah }
      LODWORD(v34) = v252;
      HIDWORD(v34) = v252;
      __asm { vpsrlq  xmm7, xmm7, 11h }
      v257 = (v34 >> 6) + (v214 ^ v11 & (v214 ^ v12)) + DWORD2(v400) + v202;
      __asm { vpxor   xmm6, xmm6, xmm7 }
      LODWORD(v34) = v7 ^ v254;
      HIDWORD(v34) = v7 ^ v254;
      v10 = v257 + v207;
      __asm { vpsrlq  xmm7, xmm7, 2 }
      v260 = (v8 ^ (v8 ^ v7) & (v218 ^ v8)) + v257 + (v34 >> 2);
      __asm { vpxor   xmm6, xmm6, xmm7 }
      LODWORD(v34) = v10;
      HIDWORD(v34) = v10;
      v262 = v34 >> 14;
      v6 = v260;
      __asm { vpshufb xmm6, xmm6, xmm9 }
      LODWORD(v34) = v260;
      HIDWORD(v34) = v260;
      v264 = v34 >> 9;
      __asm { vpaddd  xmm3, xmm3, xmm6 }
      LODWORD(v34) = v10 ^ v262;
      HIDWORD(v34) = v10 ^ v262;
      __asm { vpaddd  xmm6, xmm3, xmmword ptr [rbp+60h] }
      v266 = v10 ^ (v34 >> 5);
      LODWORD(v34) = v6 ^ v264;
      HIDWORD(v34) = v6 ^ v264;
      v267 = v34 >> 11;
      v30 = v7 ^ v6;
      LODWORD(v34) = v266;
      HIDWORD(v34) = v266;
      v268 = (v34 >> 6) + (v12 ^ v10 & (v12 ^ v11)) + HIDWORD(v400) + v214;
      LODWORD(v34) = v6 ^ v267;
      HIDWORD(v34) = v6 ^ v267;
      v9 = v268 + v218;
      v31 = v9;
      v29 = (v7 ^ (v7 ^ v6) & (v8 ^ v7)) + v268 + (v34 >> 2);
      __asm { vmovdqa [rsp+0D0h+var_A0], xmm6 }
    }
    while ( *((_BYTE *)v21 + 131) );
    LODWORD(v270) = v9;
    HIDWORD(v270) = v9;
    v269 = v270 >> 14;
    v271 = v29;
    LODWORD(v270) = v29;
    HIDWORD(v270) = v29;
    v272 = v270 >> 9;
    LODWORD(v270) = v9 ^ v269;
    HIDWORD(v270) = v9 ^ v269;
    v273 = v9 ^ (v270 >> 5);
    LODWORD(v270) = v271 ^ v272;
    HIDWORD(v270) = v271 ^ v272;
    v274 = v270 >> 11;
    LODWORD(v270) = v273;
    HIDWORD(v270) = v273;
    v275 = (v270 >> 6) + (v11 ^ v9 & (v11 ^ v10)) + v397 + v12;
    LODWORD(v270) = v271 ^ v274;
    HIDWORD(v270) = v271 ^ v274;
    v276 = v275 + v8;
    v277 = (v6 ^ (v6 ^ v271) & v30) + v275 + (v270 >> 2);
    LODWORD(v270) = v276;
    HIDWORD(v270) = v276;
    v278 = v270 >> 14;
    v279 = v277;
    LODWORD(v270) = v277;
    HIDWORD(v270) = v277;
    v280 = v270 >> 9;
    LODWORD(v270) = v276 ^ v278;
    HIDWORD(v270) = v276 ^ v278;
    v281 = v276 ^ (v270 >> 5);
    LODWORD(v270) = v279 ^ v280;
    HIDWORD(v270) = v279 ^ v280;
    v282 = v270 >> 11;
    LODWORD(v270) = v281;
    HIDWORD(v270) = v281;
    v283 = (v270 >> 6) + (v10 ^ v276 & (v10 ^ v9)) + DWORD1(v397) + v11;
    LODWORD(v270) = v279 ^ v282;
    HIDWORD(v270) = v279 ^ v282;
    v284 = v283 + v7;
    v285 = (v271 ^ (v271 ^ v279) & (v6 ^ v271)) + v283 + (v270 >> 2);
    LODWORD(v270) = v284;
    HIDWORD(v270) = v284;
    v286 = v270 >> 14;
    v287 = v285;
    LODWORD(v270) = v285;
    HIDWORD(v270) = v285;
    v288 = v270 >> 9;
    LODWORD(v270) = v284 ^ v286;
    HIDWORD(v270) = v284 ^ v286;
    v289 = v284 ^ (v270 >> 5);
    LODWORD(v270) = v287 ^ v288;
    HIDWORD(v270) = v287 ^ v288;
    v290 = v270 >> 11;
    LODWORD(v270) = v289;
    HIDWORD(v270) = v289;
    v291 = (v270 >> 6) + (v9 ^ v284 & (v9 ^ v276)) + DWORD2(v397) + v10;
    LODWORD(v270) = v287 ^ v290;
    HIDWORD(v270) = v287 ^ v290;
    v292 = v291 + v6;
    v293 = (v279 ^ (v279 ^ v287) & (v271 ^ v279)) + v291 + (v270 >> 2);
    LODWORD(v270) = v292;
    HIDWORD(v270) = v292;
    v294 = v270 >> 14;
    v295 = v293;
    LODWORD(v270) = v293;
    HIDWORD(v270) = v293;
    v296 = v270 >> 9;
    LODWORD(v270) = v292 ^ v294;
    HIDWORD(v270) = v292 ^ v294;
    v297 = v292 ^ (v270 >> 5);
    LODWORD(v270) = v295 ^ v296;
    HIDWORD(v270) = v295 ^ v296;
    v298 = v270 >> 11;
    LODWORD(v270) = v297;
    HIDWORD(v270) = v297;
    v299 = (v270 >> 6) + (v276 ^ v292 & (v276 ^ v284)) + HIDWORD(v397) + v9;
    LODWORD(v270) = v295 ^ v298;
    HIDWORD(v270) = v295 ^ v298;
    v300 = v299 + v271;
    v301 = (v287 ^ (v287 ^ v295) & (v279 ^ v287)) + v299 + (v270 >> 2);
    LODWORD(v270) = v300;
    HIDWORD(v270) = v300;
    v302 = v270 >> 14;
    v303 = v301;
    LODWORD(v270) = v301;
    HIDWORD(v270) = v301;
    v304 = v270 >> 9;
    LODWORD(v270) = v300 ^ v302;
    HIDWORD(v270) = v300 ^ v302;
    v305 = v300 ^ (v270 >> 5);
    LODWORD(v270) = v303 ^ v304;
    HIDWORD(v270) = v303 ^ v304;
    v306 = v270 >> 11;
    LODWORD(v270) = v305;
    HIDWORD(v270) = v305;
    v307 = (v270 >> 6) + (v284 ^ v300 & (v284 ^ v292)) + v398 + v276;
    LODWORD(v270) = v303 ^ v306;
    HIDWORD(v270) = v303 ^ v306;
    v308 = v307 + v279;
    v309 = (v295 ^ (v295 ^ v303) & (v287 ^ v295)) + v307 + (v270 >> 2);
    LODWORD(v270) = v308;
    HIDWORD(v270) = v308;
    v310 = v270 >> 14;
    v311 = v309;
    LODWORD(v270) = v309;
    HIDWORD(v270) = v309;
    v312 = v270 >> 9;
    LODWORD(v270) = v308 ^ v310;
    HIDWORD(v270) = v308 ^ v310;
    v313 = v308 ^ (v270 >> 5);
    LODWORD(v270) = v311 ^ v312;
    HIDWORD(v270) = v311 ^ v312;
    v314 = v270 >> 11;
    LODWORD(v270) = v313;
    HIDWORD(v270) = v313;
    v315 = (v270 >> 6) + (v292 ^ v308 & (v292 ^ v300)) + DWORD1(v398) + v284;
    LODWORD(v270) = v311 ^ v314;
    HIDWORD(v270) = v311 ^ v314;
    v316 = v315 + v287;
    v317 = (v303 ^ (v303 ^ v311) & (v295 ^ v303)) + v315 + (v270 >> 2);
    LODWORD(v270) = v316;
    HIDWORD(v270) = v316;
    v318 = v270 >> 14;
    v319 = v317;
    LODWORD(v270) = v317;
    HIDWORD(v270) = v317;
    v320 = v270 >> 9;
    LODWORD(v270) = v316 ^ v318;
    HIDWORD(v270) = v316 ^ v318;
    v321 = v316 ^ (v270 >> 5);
    LODWORD(v270) = v319 ^ v320;
    HIDWORD(v270) = v319 ^ v320;
    v322 = v270 >> 11;
    LODWORD(v270) = v321;
    HIDWORD(v270) = v321;
    v323 = (v270 >> 6) + (v300 ^ v316 & (v300 ^ v308)) + DWORD2(v398) + v292;
    LODWORD(v270) = v319 ^ v322;
    HIDWORD(v270) = v319 ^ v322;
    v324 = v323 + v295;
    v325 = (v311 ^ (v311 ^ v319) & (v303 ^ v311)) + v323 + (v270 >> 2);
    LODWORD(v270) = v324;
    HIDWORD(v270) = v324;
    v326 = v270 >> 14;
    v327 = v325;
    LODWORD(v270) = v325;
    HIDWORD(v270) = v325;
    v328 = v270 >> 9;
    LODWORD(v270) = v324 ^ v326;
    HIDWORD(v270) = v324 ^ v326;
    v329 = v324 ^ (v270 >> 5);
    LODWORD(v270) = v327 ^ v328;
    HIDWORD(v270) = v327 ^ v328;
    v330 = v270 >> 11;
    LODWORD(v270) = v329;
    HIDWORD(v270) = v329;
    v331 = (v270 >> 6) + (v308 ^ v324 & (v308 ^ v316)) + HIDWORD(v398) + v300;
    LODWORD(v270) = v327 ^ v330;
    HIDWORD(v270) = v327 ^ v330;
    v332 = v331 + v303;
    v333 = (v319 ^ (v319 ^ v327) & (v311 ^ v319)) + v331 + (v270 >> 2);
    LODWORD(v270) = v332;
    HIDWORD(v270) = v332;
    v334 = v270 >> 14;
    v335 = v333;
    LODWORD(v270) = v333;
    HIDWORD(v270) = v333;
    v336 = v270 >> 9;
    LODWORD(v270) = v332 ^ v334;
    HIDWORD(v270) = v332 ^ v334;
    v337 = v332 ^ (v270 >> 5);
    LODWORD(v270) = v335 ^ v336;
    HIDWORD(v270) = v335 ^ v336;
    v338 = v270 >> 11;
    LODWORD(v270) = v337;
    HIDWORD(v270) = v337;
    v339 = (v270 >> 6) + (v316 ^ v332 & (v316 ^ v324)) + v399 + v308;
    LODWORD(v270) = v335 ^ v338;
    HIDWORD(v270) = v335 ^ v338;
    v340 = v339 + v311;
    v341 = (v327 ^ (v327 ^ v335) & (v319 ^ v327)) + v339 + (v270 >> 2);
    LODWORD(v270) = v340;
    HIDWORD(v270) = v340;
    v342 = v270 >> 14;
    v343 = v341;
    LODWORD(v270) = v341;
    HIDWORD(v270) = v341;
    v344 = v270 >> 9;
    LODWORD(v270) = v340 ^ v342;
    HIDWORD(v270) = v340 ^ v342;
    v345 = v340 ^ (v270 >> 5);
    LODWORD(v270) = v343 ^ v344;
    HIDWORD(v270) = v343 ^ v344;
    v346 = v270 >> 11;
    LODWORD(v270) = v345;
    HIDWORD(v270) = v345;
    v347 = (v270 >> 6) + (v324 ^ v340 & (v324 ^ v332)) + DWORD1(v399) + v316;
    LODWORD(v270) = v343 ^ v346;
    HIDWORD(v270) = v343 ^ v346;
    v348 = v347 + v319;
    v349 = (v335 ^ (v335 ^ v343) & (v327 ^ v335)) + v347 + (v270 >> 2);
    LODWORD(v270) = v348;
    HIDWORD(v270) = v348;
    v350 = v270 >> 14;
    v351 = v349;
    LODWORD(v270) = v349;
    HIDWORD(v270) = v349;
    v352 = v270 >> 9;
    LODWORD(v270) = v348 ^ v350;
    HIDWORD(v270) = v348 ^ v350;
    v353 = v348 ^ (v270 >> 5);
    LODWORD(v270) = v351 ^ v352;
    HIDWORD(v270) = v351 ^ v352;
    v354 = v270 >> 11;
    LODWORD(v270) = v353;
    HIDWORD(v270) = v353;
    v355 = (v270 >> 6) + (v332 ^ v348 & (v332 ^ v340)) + DWORD2(v399) + v324;
    LODWORD(v270) = v351 ^ v354;
    HIDWORD(v270) = v351 ^ v354;
    v356 = v355 + v327;
    v357 = (v343 ^ (v343 ^ v351) & (v335 ^ v343)) + v355 + (v270 >> 2);
    LODWORD(v270) = v356;
    HIDWORD(v270) = v356;
    v358 = v270 >> 14;
    v359 = v357;
    LODWORD(v270) = v357;
    HIDWORD(v270) = v357;
    v360 = v270 >> 9;
    LODWORD(v270) = v356 ^ v358;
    HIDWORD(v270) = v356 ^ v358;
    v361 = v356 ^ (v270 >> 5);
    LODWORD(v270) = v359 ^ v360;
    HIDWORD(v270) = v359 ^ v360;
    v362 = v270 >> 11;
    LODWORD(v270) = v361;
    HIDWORD(v270) = v361;
    v363 = (v270 >> 6) + (v340 ^ v356 & (v340 ^ v348)) + HIDWORD(v399) + v332;
    LODWORD(v270) = v359 ^ v362;
    HIDWORD(v270) = v359 ^ v362;
    v364 = v363 + v335;
    v365 = (v351 ^ (v351 ^ v359) & (v343 ^ v351)) + v363 + (v270 >> 2);
    LODWORD(v270) = v364;
    HIDWORD(v270) = v364;
    v366 = v270 >> 14;
    v367 = v365;
    LODWORD(v270) = v365;
    HIDWORD(v270) = v365;
    v368 = v270 >> 9;
    LODWORD(v270) = v364 ^ v366;
    HIDWORD(v270) = v364 ^ v366;
    v369 = v364 ^ (v270 >> 5);
    LODWORD(v270) = v367 ^ v368;
    HIDWORD(v270) = v367 ^ v368;
    v370 = v270 >> 11;
    LODWORD(v270) = v369;
    HIDWORD(v270) = v369;
    v371 = (v270 >> 6) + (v348 ^ v364 & (v348 ^ v356)) + v400 + v340;
    LODWORD(v270) = v367 ^ v370;
    HIDWORD(v270) = v367 ^ v370;
    v372 = v371 + v343;
    v373 = (v359 ^ (v359 ^ v367) & (v351 ^ v359)) + v371 + (v270 >> 2);
    LODWORD(v270) = v372;
    HIDWORD(v270) = v372;
    v374 = v270 >> 14;
    v375 = v373;
    LODWORD(v270) = v373;
    HIDWORD(v270) = v373;
    v376 = v270 >> 9;
    LODWORD(v270) = v372 ^ v374;
    HIDWORD(v270) = v372 ^ v374;
    v377 = v372 ^ (v270 >> 5);
    LODWORD(v270) = v375 ^ v376;
    HIDWORD(v270) = v375 ^ v376;
    v378 = v270 >> 11;
    LODWORD(v270) = v377;
    HIDWORD(v270) = v377;
    v379 = (v270 >> 6) + (v356 ^ v372 & (v356 ^ v364)) + DWORD1(v400) + v348;
    LODWORD(v270) = v375 ^ v378;
    HIDWORD(v270) = v375 ^ v378;
    v380 = v379 + v351;
    v381 = (v367 ^ (v367 ^ v375) & (v359 ^ v367)) + v379 + (v270 >> 2);
    LODWORD(v270) = v380;
    HIDWORD(v270) = v380;
    v382 = v270 >> 14;
    v383 = v381;
    LODWORD(v270) = v381;
    HIDWORD(v270) = v381;
    v384 = v270 >> 9;
    LODWORD(v270) = v380 ^ v382;
    HIDWORD(v270) = v380 ^ v382;
    v385 = v380 ^ (v270 >> 5);
    LODWORD(v270) = v383 ^ v384;
    HIDWORD(v270) = v383 ^ v384;
    v386 = v270 >> 11;
    LODWORD(v270) = v385;
    HIDWORD(v270) = v385;
    v387 = (v270 >> 6) + (v364 ^ v380 & (v364 ^ v372)) + DWORD2(v400) + v356;
    LODWORD(v270) = v383 ^ v386;
    HIDWORD(v270) = v383 ^ v386;
    v388 = v387 + v359;
    v389 = (v375 ^ (v375 ^ v383) & (v367 ^ v375)) + v387 + (v270 >> 2);
    LODWORD(v270) = v388;
    HIDWORD(v270) = v388;
    v390 = v270 >> 14;
    v391 = v389;
    LODWORD(v270) = v389;
    HIDWORD(v270) = v389;
    v392 = v270 >> 9;
    LODWORD(v270) = v388 ^ v390;
    HIDWORD(v270) = v388 ^ v390;
    v393 = v388 ^ (v270 >> 5);
    LODWORD(v270) = v391 ^ v392;
    HIDWORD(v270) = v391 ^ v392;
    v394 = v270 >> 11;
    LODWORD(v270) = v393;
    HIDWORD(v270) = v393;
    v395 = (v270 >> 6) + (v372 ^ v388 & (v372 ^ v380)) + HIDWORD(v400) + v364;
    LODWORD(v270) = v391 ^ v394;
    HIDWORD(v270) = v391 ^ v394;
    v396 = v395 + v367;
    result = *a1 + (v383 ^ (v383 ^ v391) & (v375 ^ v383)) + v395 + (unsigned int)(v270 >> 2);
    _RSI += 64i64;
    v6 = a1[1] + v391;
    v7 = a1[2] + v383;
    v8 = a1[3] + v375;
    v9 = a1[4] + v396;
    v10 = a1[5] + v388;
    v11 = a1[6] + v380;
    v12 = a1[7] + v372;
    *a1 = result;
    a1[1] = v6;
    a1[2] = v7;
    a1[3] = v8;
    a1[4] = v9;
    a1[5] = v10;
    a1[6] = v11;
    a1[7] = v12;
  }
  while ( _RSI < v402 );
  __asm { vzeroupper }
  return result;
}
// 146149D0D: could not find valid save-restore pair for rdi
// 146149D0D: could not find valid save-restore pair for rsi
// 146148740: using guessed type __int64 qword_146148740[16];
// 146148940: using guessed type __m256 ymmword_146148940;

//----- (000000014614AC8D) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_14614AC8D(
        _DWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        int a5,
        char a6,
        __int64 a7,
        _DWORD *a8,
        int a9,
        unsigned __int64 a10)
{
  __int64 v10; // rbx
  __int64 v11; // rbp
  __int64 v12; // r12
  __int64 v13; // r13
  __int64 v14; // r14
  __int64 v15; // r15
  __int128 v16; // xmm6
  __int128 v17; // xmm7
  __int128 v18; // xmm8
  __int128 v19; // xmm9
  __int128 v24; // rdi
  __int64 result; // rax
  int v27; // ebx
  int v28; // ecx
  int v29; // edx
  __int32 v30; // r8d
  __int32 v31; // r9d
  __int32 v32; // r10d
  __int32 v33; // r11d
  int v49; // r14d
  int v50; // edi
  __int32 v51; // r12d
  __int64 *v52; // rbp
  int v55; // eax
  __int32 v59; // r11d
  __int32 v61; // edx
  int v66; // r11d
  __int32 v70; // r10d
  __int32 v72; // ecx
  int v77; // r10d
  __int32 v81; // r9d
  __int32 v83; // ebx
  int v88; // r9d
  __int32 v91; // r8d
  int v93; // eax
  int v96; // r8d
  __int32 v100; // edx
  __int32 v102; // r11d
  int v107; // edx
  __int32 v111; // ecx
  __int32 v113; // r10d
  int v118; // ecx
  __int32 v122; // ebx
  __int32 v124; // r9d
  int v129; // ebx
  __int32 v132; // eax
  __int32 v134; // r8d
  int v137; // eax
  __int32 v141; // r11d
  __int32 v143; // edx
  int v148; // r11d
  __int32 v152; // r10d
  __int32 v154; // ecx
  int v159; // r10d
  __int32 v163; // r9d
  __int32 v165; // ebx
  int v170; // r9d
  __int32 v173; // r8d
  __int32 v175; // eax
  int v178; // r8d
  __int32 v182; // edx
  __int32 v191; // ecx
  __int32 v200; // ebx
  __int32 v208; // eax
  int v210; // eax
  __int32 v211; // r11d
  __int32 v212; // edx
  int v213; // r11d
  __int32 v214; // r10d
  __int32 v215; // ecx
  int v216; // r10d
  __int32 v217; // r9d
  __int32 v218; // ebx
  int v219; // r9d
  __int32 v220; // r8d
  int v221; // eax
  int v222; // r8d
  __int32 v223; // edx
  __int32 v224; // r11d
  int v225; // edx
  __int32 v226; // ecx
  __int32 v227; // r10d
  int v228; // ecx
  __int32 v229; // ebx
  __int32 v230; // r9d
  int v231; // ebx
  __int32 v232; // eax
  __int32 v233; // r8d
  int v234; // eax
  __int32 v235; // r11d
  __int32 v236; // edx
  int v237; // r11d
  __int32 v238; // r10d
  __int32 v239; // ecx
  int v240; // r10d
  __int32 v241; // r9d
  __int32 v242; // ebx
  int v243; // r9d
  __int32 v244; // r8d
  __int32 v245; // eax
  int v246; // r8d
  __int32 v247; // edx
  __int32 v248; // r11d
  int v249; // edx
  __int32 v250; // ecx
  __int32 v251; // r10d
  int v252; // ecx
  __int32 v253; // ebx
  __int32 v254; // r9d
  int v255; // ebx
  __int32 v256; // eax
  __int32 v257; // r8d
  void **v258; // rbp
  int v259; // ebx
  int v260; // ecx
  int v261; // edx
  int v262; // r8d
  int v263; // r9d
  int v264; // r10d
  int v265; // r11d
  int v266; // r14d
  int v267; // edi
  int v268; // r12d
  int v269; // eax
  int v270; // r11d
  int v271; // edx
  int v272; // r11d
  int v273; // r10d
  int v274; // ecx
  int v275; // r10d
  int v276; // r9d
  int v277; // ebx
  int v278; // r9d
  int v279; // r8d
  int v280; // eax
  int v281; // r8d
  int v282; // edx
  int v283; // ecx
  int v284; // ebx
  int v285; // eax
  __m256i v286; // [rsp-30h] [rbp-1C0h] BYREF
  __m256i v287; // [rsp-10h] [rbp-1A0h]
  __m256i v288; // [rsp+10h] [rbp-180h]
  __m256i v289; // [rsp+30h] [rbp-160h]
  __m256i v290; // [rsp+50h] [rbp-140h]
  __m256i v291; // [rsp+70h] [rbp-120h]
  __m256i v292; // [rsp+90h] [rbp-100h]
  __m256i v293; // [rsp+B0h] [rbp-E0h]
  __int128 v294; // [rsp+D0h] [rbp-C0h]
  __m256 v295; // [rsp+E0h] [rbp-B0h]
  __int128 v296; // [rsp+100h] [rbp-90h]
  __int128 v297; // [rsp+110h] [rbp-80h]
  __int128 v298; // [rsp+120h] [rbp-70h]
  __int64 v299; // [rsp+130h] [rbp-60h]
  __int64 v300; // [rsp+138h] [rbp-58h]
  __int64 v301; // [rsp+140h] [rbp-50h]
  __int64 v302; // [rsp+148h] [rbp-48h]
  __int64 v303; // [rsp+150h] [rbp-40h]
  __int64 v304; // [rsp+158h] [rbp-38h]
  __int64 v305; // [rsp+160h] [rbp-30h] BYREF
  void *retaddr; // [rsp+190h] [rbp+0h] BYREF

  *(_QWORD *)&v24 = a1;
  *((_QWORD *)&v24 + 1) = a2;
  v304 = v10;
  v303 = v11;
  v302 = v12;
  v301 = v13;
  v300 = v14;
  v299 = v15;
  v294 = v24;
  *(_QWORD *)v295.m256_f32 = a2 + (a3 << 6);
  *(_QWORD *)&v295.m256_f32[2] = &v305;
  *(_OWORD *)&v295.m256_f32[4] = v16;
  v296 = v17;
  v297 = v18;
  v298 = v19;
  __asm { vzeroupper }
  _RSI = a2 + 64;
  LODWORD(result) = *a1;
  v27 = a1[1];
  v28 = a1[2];
  v29 = *(_DWORD *)(v24 + 12);
  v30 = *(_DWORD *)(v24 + 16);
  v31 = *(_DWORD *)(v24 + 20);
  v32 = *(_DWORD *)(v24 + 24);
  v33 = *(_DWORD *)(v24 + 28);
  __asm
  {
    vmovdqa ymm8, cs:ymmword_146148960
    vmovdqa ymm9, cs:ymmword_146148980
  }
  do
  {
    __asm
    {
      vmovdqa ymm7, cs:ymmword_146148940
      vmovdqu xmm0, xmmword ptr [rsi-40h]
      vmovdqu xmm1, xmmword ptr [rsi-30h]
      vmovdqu xmm2, xmmword ptr [rsi-20h]
      vmovdqu xmm3, xmmword ptr [rsi-10h]
      vinserti128 ymm0, ymm0, xmmword ptr [r12], 1
      vinserti128 ymm1, ymm1, xmmword ptr [r12+10h], 1
      vpshufb ymm0, ymm0, ymm7
      vinserti128 ymm2, ymm2, xmmword ptr [r12+20h], 1
      vpshufb ymm1, ymm1, ymm7
      vinserti128 ymm3, ymm3, xmmword ptr [r12+30h], 1
      vpshufb ymm2, ymm2, ymm7
      vpaddd  ymm4, ymm0, ymmword ptr [rbp+0]
      vpshufb ymm3, ymm3, ymm7
      vpaddd  ymm5, ymm1, ymmword ptr [rbp+20h]
      vpaddd  ymm6, ymm2, ymmword ptr [rbp+40h]
      vpaddd  ymm7, ymm3, ymmword ptr [rbp+60h]
      vmovdqa [rsp+0D0h+var_D0], ymm4
    }
    v49 = 0;
    __asm
    {
      vmovdqa [rsp+0D0h+var_B0], ymm5
      vmovdqa [rsp+110h+var_110], ymm6
    }
    v50 = v28 ^ v27;
    __asm { vmovdqa [rsp+110h+var_F0], ymm7 }
    v51 = v31;
    v52 = &qword_146148740[16];
    do
    {
      __asm
      {
        vpalignr ymm4, ymm1, ymm0, 4
        vpalignr ymm7, ymm3, ymm2, 4
      }
      v55 = result + v49;
      __asm
      {
        vpsrld  ymm6, ymm4, 7
        vpaddd  ymm0, ymm0, ymm7
        vpsrld  ymm7, ymm4, 3
      }
      v59 = v292.m256i_i32[0]
          + v33
          + (v30 & v51)
          + (v32 & ~v30)
          + (__ROR4__(v30, 6) ^ __ROR4__(v30, 11) ^ __ROR4__(v30, 25));
      __asm { vpslld  ymm5, ymm4, 0Eh }
      v61 = v29 + v59;
      __asm
      {
        vpxor   ymm4, ymm7, ymm6
        vpshufd ymm7, ymm3, 0FAh
        vpsrld  ymm6, ymm6, 0Bh
        vpxor   ymm4, ymm4, ymm5
      }
      v66 = v59 + (v27 ^ (v27 ^ v55) & v50) + (__ROR4__(v55, 2) ^ __ROR4__(v55, 22) ^ __ROR4__(v55, 13));
      __asm
      {
        vpslld  ymm5, ymm5, 0Bh
        vpxor   ymm4, ymm4, ymm6
        vpsrld  ymm6, ymm7, 0Ah
      }
      v70 = v292.m256i_i32[1]
          + v32
          + (v61 & v30)
          + (v31 & ~v61)
          + (__ROR4__(v61, 6) ^ __ROR4__(v61, 11) ^ __ROR4__(v61, 25));
      __asm { vpxor   ymm4, ymm4, ymm5 }
      v72 = v28 + v70;
      __asm
      {
        vpsrlq  ymm7, ymm7, 11h
        vpaddd  ymm0, ymm0, ymm4
        vpxor   ymm6, ymm6, ymm7
        vpsrlq  ymm7, ymm7, 2
      }
      v77 = v70 + (v55 ^ (v55 ^ v66) & (v27 ^ v55)) + (__ROR4__(v66, 2) ^ __ROR4__(v66, 22) ^ __ROR4__(v66, 13));
      __asm
      {
        vpxor   ymm6, ymm6, ymm7
        vpshufb ymm6, ymm6, ymm8
        vpaddd  ymm0, ymm0, ymm6
      }
      v81 = v292.m256i_i32[2]
          + v31
          + (v72 & v61)
          + (v30 & ~v72)
          + (__ROR4__(v72, 6) ^ __ROR4__(v72, 11) ^ __ROR4__(v72, 25));
      __asm { vpshufd ymm7, ymm0, 50h ; 'P' }
      v83 = v27 + v81;
      __asm
      {
        vpsrld  ymm6, ymm7, 0Ah
        vpsrlq  ymm7, ymm7, 11h
        vpxor   ymm6, ymm6, ymm7
        vpsrlq  ymm7, ymm7, 2
      }
      v88 = v81 + (v66 ^ (v66 ^ v77) & (v55 ^ v66)) + (__ROR4__(v77, 2) ^ __ROR4__(v77, 22) ^ __ROR4__(v77, 13));
      __asm
      {
        vpxor   ymm6, ymm6, ymm7
        vpshufb ymm6, ymm6, ymm9
        vpaddd  ymm0, ymm0, ymm6
      }
      v91 = v292.m256i_i32[3]
          + v30
          + (v83 & v72)
          + (v61 & ~v83)
          + (__ROR4__(v83, 6) ^ __ROR4__(v83, 11) ^ __ROR4__(v83, 25));
      __asm { vpaddd  ymm6, ymm0, ymmword ptr [rbp+0] }
      v93 = v55 + v91;
      __asm
      {
        vmovdqa [rsp+150h+var_150], ymm6
        vpalignr ymm4, ymm2, ymm1, 4
        vpalignr ymm7, ymm0, ymm3, 4
      }
      v96 = v91 + (v77 ^ (v77 ^ v88) & (v66 ^ v77)) + (__ROR4__(v88, 2) ^ __ROR4__(v88, 22) ^ __ROR4__(v88, 13));
      __asm
      {
        vpsrld  ymm6, ymm4, 7
        vpaddd  ymm1, ymm1, ymm7
        vpsrld  ymm7, ymm4, 3
      }
      v100 = v293.m256i_i32[0]
           + v61
           + (v93 & v83)
           + (v72 & ~v93)
           + (__ROR4__(v93, 6) ^ __ROR4__(v93, 11) ^ __ROR4__(v93, 25));
      __asm { vpslld  ymm5, ymm4, 0Eh }
      v102 = v66 + v100;
      __asm
      {
        vpxor   ymm4, ymm7, ymm6
        vpshufd ymm7, ymm0, 0FAh
        vpsrld  ymm6, ymm6, 0Bh
        vpxor   ymm4, ymm4, ymm5
      }
      v107 = v100 + (v88 ^ (v88 ^ v96) & (v77 ^ v88)) + (__ROR4__(v96, 2) ^ __ROR4__(v96, 22) ^ __ROR4__(v96, 13));
      __asm
      {
        vpslld  ymm5, ymm5, 0Bh
        vpxor   ymm4, ymm4, ymm6
        vpsrld  ymm6, ymm7, 0Ah
      }
      v111 = v293.m256i_i32[1]
           + v72
           + (v102 & v93)
           + (v83 & ~v102)
           + (__ROR4__(v102, 6) ^ __ROR4__(v102, 11) ^ __ROR4__(v102, 25));
      __asm { vpxor   ymm4, ymm4, ymm5 }
      v113 = v77 + v111;
      __asm
      {
        vpsrlq  ymm7, ymm7, 11h
        vpaddd  ymm1, ymm1, ymm4
        vpxor   ymm6, ymm6, ymm7
        vpsrlq  ymm7, ymm7, 2
      }
      v118 = v111 + (v96 ^ (v96 ^ v107) & (v88 ^ v96)) + (__ROR4__(v107, 2) ^ __ROR4__(v107, 22) ^ __ROR4__(v107, 13));
      __asm
      {
        vpxor   ymm6, ymm6, ymm7
        vpshufb ymm6, ymm6, ymm8
        vpaddd  ymm1, ymm1, ymm6
      }
      v122 = v293.m256i_i32[2]
           + v83
           + (v113 & v102)
           + (v93 & ~v113)
           + (__ROR4__(v113, 6) ^ __ROR4__(v113, 11) ^ __ROR4__(v113, 25));
      __asm { vpshufd ymm7, ymm1, 50h ; 'P' }
      v124 = v88 + v122;
      __asm
      {
        vpsrld  ymm6, ymm7, 0Ah
        vpsrlq  ymm7, ymm7, 11h
        vpxor   ymm6, ymm6, ymm7
        vpsrlq  ymm7, ymm7, 2
      }
      v129 = v122
           + (v107 ^ (v107 ^ v118) & (v96 ^ v107))
           + (__ROR4__(v118, 2) ^ __ROR4__(v118, 22) ^ __ROR4__(v118, 13));
      __asm
      {
        vpxor   ymm6, ymm6, ymm7
        vpshufb ymm6, ymm6, ymm9
        vpaddd  ymm1, ymm1, ymm6
      }
      v132 = v293.m256i_i32[3]
           + v93
           + (v124 & v113)
           + (v102 & ~v124)
           + (__ROR4__(v124, 6) ^ __ROR4__(v124, 11) ^ __ROR4__(v124, 25));
      __asm { vpaddd  ymm6, ymm1, ymmword ptr [rbp+20h] }
      v134 = v96 + v132;
      __asm
      {
        vmovdqa [rsp+150h+var_130], ymm6
        vpalignr ymm4, ymm3, ymm2, 4
        vpalignr ymm7, ymm1, ymm0, 4
      }
      v137 = v132
           + (v118 ^ (v118 ^ v129) & (v107 ^ v118))
           + (__ROR4__(v129, 2) ^ __ROR4__(v129, 22) ^ __ROR4__(v129, 13));
      __asm
      {
        vpsrld  ymm6, ymm4, 7
        vpaddd  ymm2, ymm2, ymm7
        vpsrld  ymm7, ymm4, 3
      }
      v141 = v290.m256i_i32[0]
           + v102
           + (v134 & v124)
           + (v113 & ~v134)
           + (__ROR4__(v134, 6) ^ __ROR4__(v134, 11) ^ __ROR4__(v134, 25));
      __asm { vpslld  ymm5, ymm4, 0Eh }
      v143 = v107 + v141;
      __asm
      {
        vpxor   ymm4, ymm7, ymm6
        vpshufd ymm7, ymm1, 0FAh
        vpsrld  ymm6, ymm6, 0Bh
        vpxor   ymm4, ymm4, ymm5
      }
      v148 = v141
           + (v129 ^ (v129 ^ v137) & (v118 ^ v129))
           + (__ROR4__(v137, 2) ^ __ROR4__(v137, 22) ^ __ROR4__(v137, 13));
      __asm
      {
        vpslld  ymm5, ymm5, 0Bh
        vpxor   ymm4, ymm4, ymm6
        vpsrld  ymm6, ymm7, 0Ah
      }
      v152 = v290.m256i_i32[1]
           + v113
           + (v143 & v134)
           + (v124 & ~v143)
           + (__ROR4__(v143, 6) ^ __ROR4__(v143, 11) ^ __ROR4__(v143, 25));
      __asm { vpxor   ymm4, ymm4, ymm5 }
      v154 = v118 + v152;
      __asm
      {
        vpsrlq  ymm7, ymm7, 11h
        vpaddd  ymm2, ymm2, ymm4
        vpxor   ymm6, ymm6, ymm7
        vpsrlq  ymm7, ymm7, 2
      }
      v159 = v152
           + (v137 ^ (v137 ^ v148) & (v129 ^ v137))
           + (__ROR4__(v148, 2) ^ __ROR4__(v148, 22) ^ __ROR4__(v148, 13));
      __asm
      {
        vpxor   ymm6, ymm6, ymm7
        vpshufb ymm6, ymm6, ymm8
        vpaddd  ymm2, ymm2, ymm6
      }
      v163 = v290.m256i_i32[2]
           + v124
           + (v154 & v143)
           + (v134 & ~v154)
           + (__ROR4__(v154, 6) ^ __ROR4__(v154, 11) ^ __ROR4__(v154, 25));
      __asm { vpshufd ymm7, ymm2, 50h ; 'P' }
      v165 = v129 + v163;
      __asm
      {
        vpsrld  ymm6, ymm7, 0Ah
        vpsrlq  ymm7, ymm7, 11h
        vpxor   ymm6, ymm6, ymm7
        vpsrlq  ymm7, ymm7, 2
      }
      v170 = v163
           + (v148 ^ (v148 ^ v159) & (v137 ^ v148))
           + (__ROR4__(v159, 2) ^ __ROR4__(v159, 22) ^ __ROR4__(v159, 13));
      __asm
      {
        vpxor   ymm6, ymm6, ymm7
        vpshufb ymm6, ymm6, ymm9
        vpaddd  ymm2, ymm2, ymm6
      }
      v173 = v290.m256i_i32[3]
           + v134
           + (v165 & v154)
           + (v143 & ~v165)
           + (__ROR4__(v165, 6) ^ __ROR4__(v165, 11) ^ __ROR4__(v165, 25));
      __asm { vpaddd  ymm6, ymm2, ymmword ptr [rbp+40h] }
      v175 = v137 + v173;
      __asm
      {
        vmovdqa [rsp+190h+var_190], ymm6
        vpalignr ymm4, ymm0, ymm3, 4
        vpalignr ymm7, ymm2, ymm1, 4
      }
      v178 = v173
           + (v159 ^ (v159 ^ v170) & (v148 ^ v159))
           + (__ROR4__(v170, 2) ^ __ROR4__(v170, 22) ^ __ROR4__(v170, 13));
      __asm
      {
        vpsrld  ymm6, ymm4, 7
        vpaddd  ymm3, ymm3, ymm7
        vpsrld  ymm7, ymm4, 3
      }
      v182 = v291.m256i_i32[0]
           + v143
           + (v175 & v165)
           + (v154 & ~v175)
           + (__ROR4__(v175, 6) ^ __ROR4__(v175, 11) ^ __ROR4__(v175, 25));
      __asm { vpslld  ymm5, ymm4, 0Eh }
      v33 = v148 + v182;
      __asm
      {
        vpxor   ymm4, ymm7, ymm6
        vpshufd ymm7, ymm2, 0FAh
        vpsrld  ymm6, ymm6, 0Bh
        vpxor   ymm4, ymm4, ymm5
      }
      v29 = v182
          + (v170 ^ (v170 ^ v178) & (v159 ^ v170))
          + (__ROR4__(v178, 2) ^ __ROR4__(v178, 22) ^ __ROR4__(v178, 13));
      __asm
      {
        vpslld  ymm5, ymm5, 0Bh
        vpxor   ymm4, ymm4, ymm6
        vpsrld  ymm6, ymm7, 0Ah
      }
      v191 = v291.m256i_i32[1]
           + v154
           + (v33 & v175)
           + (v165 & ~v33)
           + (__ROR4__(v33, 6) ^ __ROR4__(v33, 11) ^ __ROR4__(v33, 25));
      __asm { vpxor   ymm4, ymm4, ymm5 }
      v32 = v159 + v191;
      __asm
      {
        vpsrlq  ymm7, ymm7, 11h
        vpaddd  ymm3, ymm3, ymm4
        vpxor   ymm6, ymm6, ymm7
        vpsrlq  ymm7, ymm7, 2
      }
      v28 = v191 + (v178 ^ (v178 ^ v29) & (v170 ^ v178)) + (__ROR4__(v29, 2) ^ __ROR4__(v29, 22) ^ __ROR4__(v29, 13));
      __asm
      {
        vpxor   ymm6, ymm6, ymm7
        vpshufb ymm6, ymm6, ymm8
        vpaddd  ymm3, ymm3, ymm6
      }
      v200 = v291.m256i_i32[2]
           + v165
           + (v32 & v33)
           + (v175 & ~v32)
           + (__ROR4__(v32, 6) ^ __ROR4__(v32, 11) ^ __ROR4__(v32, 25));
      __asm { vpshufd ymm7, ymm3, 50h ; 'P' }
      v31 = v170 + v200;
      __asm
      {
        vpsrld  ymm6, ymm7, 0Ah
        vpsrlq  ymm7, ymm7, 11h
        vpxor   ymm6, ymm6, ymm7
        vpsrlq  ymm7, ymm7, 2
      }
      v27 = v200 + (v29 ^ (v29 ^ v28) & (v178 ^ v29)) + (__ROR4__(v28, 2) ^ __ROR4__(v28, 22) ^ __ROR4__(v28, 13));
      __asm
      {
        vpxor   ymm6, ymm6, ymm7
        vpshufb ymm6, ymm6, ymm9
        vpaddd  ymm3, ymm3, ymm6
      }
      v208 = v291.m256i_i32[3]
           + v175
           + (v31 & v32)
           + (v33 & ~v31)
           + (__ROR4__(v31, 6) ^ __ROR4__(v31, 11) ^ __ROR4__(v31, 25));
      v50 = v28 ^ v27;
      __asm { vpaddd  ymm6, ymm3, ymmword ptr [rbp+60h] }
      v30 = v178 + v208;
      v49 = __ROR4__(v27, 2) ^ __ROR4__(v27, 22) ^ __ROR4__(v27, 13);
      LODWORD(result) = v208 + (v28 ^ (v28 ^ v27) & (v29 ^ v28));
      v51 = v31;
      __asm { vmovdqa [rsp+190h+var_170], ymm6 }
      v52 += 16;
    }
    while ( *((_BYTE *)v52 + 3) );
    v210 = result + v49;
    v211 = v288.m256i_i32[0]
         + v33
         + (v30 & v31)
         + (v32 & ~v30)
         + (__ROR4__(v30, 6) ^ __ROR4__(v30, 11) ^ __ROR4__(v30, 25));
    v212 = v29 + v211;
    v213 = v211 + (v27 ^ (v27 ^ v210) & v50) + (__ROR4__(v210, 2) ^ __ROR4__(v210, 22) ^ __ROR4__(v210, 13));
    v214 = v288.m256i_i32[1]
         + v32
         + (v212 & v30)
         + (v31 & ~v212)
         + (__ROR4__(v212, 6) ^ __ROR4__(v212, 11) ^ __ROR4__(v212, 25));
    v215 = v28 + v214;
    v216 = v214 + (v210 ^ (v210 ^ v213) & (v27 ^ v210)) + (__ROR4__(v213, 2) ^ __ROR4__(v213, 22) ^ __ROR4__(v213, 13));
    v217 = v288.m256i_i32[2]
         + v31
         + (v215 & v212)
         + (v30 & ~v215)
         + (__ROR4__(v215, 6) ^ __ROR4__(v215, 11) ^ __ROR4__(v215, 25));
    v218 = v27 + v217;
    v219 = v217 + (v213 ^ (v213 ^ v216) & (v210 ^ v213)) + (__ROR4__(v216, 2) ^ __ROR4__(v216, 22) ^ __ROR4__(v216, 13));
    v220 = v288.m256i_i32[3]
         + v30
         + (v218 & v215)
         + (v212 & ~v218)
         + (__ROR4__(v218, 6) ^ __ROR4__(v218, 11) ^ __ROR4__(v218, 25));
    v221 = v210 + v220;
    v222 = v220 + (v216 ^ (v216 ^ v219) & (v213 ^ v216)) + (__ROR4__(v219, 2) ^ __ROR4__(v219, 22) ^ __ROR4__(v219, 13));
    v223 = v289.m256i_i32[0]
         + v212
         + (v221 & v218)
         + (v215 & ~v221)
         + (__ROR4__(v221, 6) ^ __ROR4__(v221, 11) ^ __ROR4__(v221, 25));
    v224 = v213 + v223;
    v225 = v223 + (v219 ^ (v219 ^ v222) & (v216 ^ v219)) + (__ROR4__(v222, 2) ^ __ROR4__(v222, 22) ^ __ROR4__(v222, 13));
    v226 = v289.m256i_i32[1]
         + v215
         + (v224 & v221)
         + (v218 & ~v224)
         + (__ROR4__(v224, 6) ^ __ROR4__(v224, 11) ^ __ROR4__(v224, 25));
    v227 = v216 + v226;
    v228 = v226 + (v222 ^ (v222 ^ v225) & (v219 ^ v222)) + (__ROR4__(v225, 2) ^ __ROR4__(v225, 22) ^ __ROR4__(v225, 13));
    v229 = v289.m256i_i32[2]
         + v218
         + (v227 & v224)
         + (v221 & ~v227)
         + (__ROR4__(v227, 6) ^ __ROR4__(v227, 11) ^ __ROR4__(v227, 25));
    v230 = v219 + v229;
    v231 = v229 + (v225 ^ (v225 ^ v228) & (v222 ^ v225)) + (__ROR4__(v228, 2) ^ __ROR4__(v228, 22) ^ __ROR4__(v228, 13));
    v232 = v289.m256i_i32[3]
         + v221
         + (v230 & v227)
         + (v224 & ~v230)
         + (__ROR4__(v230, 6) ^ __ROR4__(v230, 11) ^ __ROR4__(v230, 25));
    v233 = v222 + v232;
    v234 = v232 + (v228 ^ (v228 ^ v231) & (v225 ^ v228)) + (__ROR4__(v231, 2) ^ __ROR4__(v231, 22) ^ __ROR4__(v231, 13));
    v235 = v286.m256i_i32[0]
         + v224
         + (v233 & v230)
         + (v227 & ~v233)
         + (__ROR4__(v233, 6) ^ __ROR4__(v233, 11) ^ __ROR4__(v233, 25));
    v236 = v225 + v235;
    v237 = v235 + (v231 ^ (v231 ^ v234) & (v228 ^ v231)) + (__ROR4__(v234, 2) ^ __ROR4__(v234, 22) ^ __ROR4__(v234, 13));
    v238 = v286.m256i_i32[1]
         + v227
         + (v236 & v233)
         + (v230 & ~v236)
         + (__ROR4__(v236, 6) ^ __ROR4__(v236, 11) ^ __ROR4__(v236, 25));
    v239 = v228 + v238;
    v240 = v238 + (v234 ^ (v234 ^ v237) & (v231 ^ v234)) + (__ROR4__(v237, 2) ^ __ROR4__(v237, 22) ^ __ROR4__(v237, 13));
    v241 = v286.m256i_i32[2]
         + v230
         + (v239 & v236)
         + (v233 & ~v239)
         + (__ROR4__(v239, 6) ^ __ROR4__(v239, 11) ^ __ROR4__(v239, 25));
    v242 = v231 + v241;
    v243 = v241 + (v237 ^ (v237 ^ v240) & (v234 ^ v237)) + (__ROR4__(v240, 2) ^ __ROR4__(v240, 22) ^ __ROR4__(v240, 13));
    v244 = v286.m256i_i32[3]
         + v233
         + (v242 & v239)
         + (v236 & ~v242)
         + (__ROR4__(v242, 6) ^ __ROR4__(v242, 11) ^ __ROR4__(v242, 25));
    v245 = v234 + v244;
    v246 = v244 + (v240 ^ (v240 ^ v243) & (v237 ^ v240)) + (__ROR4__(v243, 2) ^ __ROR4__(v243, 22) ^ __ROR4__(v243, 13));
    v247 = v287.m256i_i32[0]
         + v236
         + (v245 & v242)
         + (v239 & ~v245)
         + (__ROR4__(v245, 6) ^ __ROR4__(v245, 11) ^ __ROR4__(v245, 25));
    v248 = v237 + v247;
    v249 = v247 + (v243 ^ (v243 ^ v246) & (v240 ^ v243)) + (__ROR4__(v246, 2) ^ __ROR4__(v246, 22) ^ __ROR4__(v246, 13));
    v250 = v287.m256i_i32[1]
         + v239
         + (v248 & v245)
         + (v242 & ~v248)
         + (__ROR4__(v248, 6) ^ __ROR4__(v248, 11) ^ __ROR4__(v248, 25));
    v251 = v240 + v250;
    v252 = v250 + (v246 ^ (v246 ^ v249) & (v243 ^ v246)) + (__ROR4__(v249, 2) ^ __ROR4__(v249, 22) ^ __ROR4__(v249, 13));
    v253 = v287.m256i_i32[2]
         + v242
         + (v251 & v248)
         + (v245 & ~v251)
         + (__ROR4__(v251, 6) ^ __ROR4__(v251, 11) ^ __ROR4__(v251, 25));
    v254 = v243 + v253;
    v255 = v253 + (v249 ^ (v249 ^ v252) & (v246 ^ v249)) + (__ROR4__(v252, 2) ^ __ROR4__(v252, 22) ^ __ROR4__(v252, 13));
    v256 = v287.m256i_i32[3]
         + v245
         + (v254 & v251)
         + (v248 & ~v254)
         + (__ROR4__(v254, 6) ^ __ROR4__(v254, 11) ^ __ROR4__(v254, 25));
    v257 = v246 + v256;
    v258 = &retaddr;
    result = *a8
           + (__ROR4__(v255, 2) ^ __ROR4__(v255, 22) ^ __ROR4__(v255, 13))
           + v256
           + (v252 ^ (v252 ^ v255) & (v249 ^ (unsigned int)v252));
    v259 = a8[1] + v255;
    v260 = a8[2] + v252;
    v261 = a8[3] + v249;
    v262 = a8[4] + v257;
    v263 = a8[5] + v254;
    v264 = a8[6] + v251;
    v265 = a8[7] + v248;
    *a8 = result;
    a8[1] = v259;
    a8[2] = v260;
    a8[3] = v261;
    a8[4] = v262;
    a8[5] = v263;
    a8[6] = v264;
    a8[7] = v265;
    if ( _RSI == a10 )
      break;
    v266 = 0;
    v267 = v260 ^ v259;
    v268 = v263;
    do
    {
      v269 = result + v266;
      v270 = *((_DWORD *)v258 + 4)
           + v265
           + (v262 & v268)
           + (v264 & ~v262)
           + (__ROR4__(v262, 6) ^ __ROR4__(v262, 11) ^ __ROR4__(v262, 25));
      v271 = v261 + v270;
      v272 = v270 + (v259 ^ (v259 ^ v269) & v267) + (__ROR4__(v269, 2) ^ __ROR4__(v269, 22) ^ __ROR4__(v269, 13));
      v273 = *((_DWORD *)v258 + 5)
           + v264
           + (v271 & v262)
           + (v263 & ~v271)
           + (__ROR4__(v271, 6) ^ __ROR4__(v271, 11) ^ __ROR4__(v271, 25));
      v274 = v260 + v273;
      v275 = v273
           + (v269 ^ (v269 ^ v272) & (v259 ^ v269))
           + (__ROR4__(v272, 2) ^ __ROR4__(v272, 22) ^ __ROR4__(v272, 13));
      v276 = *((_DWORD *)v258 + 6)
           + v263
           + (v274 & v271)
           + (v262 & ~v274)
           + (__ROR4__(v274, 6) ^ __ROR4__(v274, 11) ^ __ROR4__(v274, 25));
      v277 = v259 + v276;
      v278 = v276
           + (v272 ^ (v272 ^ v275) & (v269 ^ v272))
           + (__ROR4__(v275, 2) ^ __ROR4__(v275, 22) ^ __ROR4__(v275, 13));
      v279 = *((_DWORD *)v258 + 7)
           + v262
           + (v277 & v274)
           + (v271 & ~v277)
           + (__ROR4__(v277, 6) ^ __ROR4__(v277, 11) ^ __ROR4__(v277, 25));
      v280 = v269 + v279;
      v281 = v279
           + (v275 ^ (v275 ^ v278) & (v272 ^ v275))
           + (__ROR4__(v278, 2) ^ __ROR4__(v278, 22) ^ __ROR4__(v278, 13));
      v282 = *((_DWORD *)v258 + 12)
           + v271
           + (v280 & v277)
           + (v274 & ~v280)
           + (__ROR4__(v280, 6) ^ __ROR4__(v280, 11) ^ __ROR4__(v280, 25));
      v265 = v272 + v282;
      v261 = v282
           + (v278 ^ (v278 ^ v281) & (v275 ^ v278))
           + (__ROR4__(v281, 2) ^ __ROR4__(v281, 22) ^ __ROR4__(v281, 13));
      v283 = *((_DWORD *)v258 + 13)
           + v274
           + (v265 & v280)
           + (v277 & ~v265)
           + (__ROR4__(v265, 6) ^ __ROR4__(v265, 11) ^ __ROR4__(v265, 25));
      v264 = v275 + v283;
      v260 = v283
           + (v281 ^ (v281 ^ v261) & (v278 ^ v281))
           + (__ROR4__(v261, 2) ^ __ROR4__(v261, 22) ^ __ROR4__(v261, 13));
      v284 = *((_DWORD *)v258 + 14)
           + v277
           + (v264 & v265)
           + (v280 & ~v264)
           + (__ROR4__(v264, 6) ^ __ROR4__(v264, 11) ^ __ROR4__(v264, 25));
      v263 = v278 + v284;
      v259 = v284
           + (v261 ^ (v261 ^ v260) & (v281 ^ v261))
           + (__ROR4__(v260, 2) ^ __ROR4__(v260, 22) ^ __ROR4__(v260, 13));
      v285 = *((_DWORD *)v258 + 15)
           + v280
           + (v263 & v264)
           + (v265 & ~v263)
           + (__ROR4__(v263, 6) ^ __ROR4__(v263, 11) ^ __ROR4__(v263, 25));
      v267 = v260 ^ v259;
      v262 = v281 + v285;
      v266 = __ROR4__(v259, 2) ^ __ROR4__(v259, 22) ^ __ROR4__(v259, 13);
      LODWORD(result) = v285 + (v260 ^ (v260 ^ v259) & (v261 ^ v260));
      v268 = v263;
      v258 -= 8;
    }
    while ( v258 >= (void **)&v286 );
    result = (unsigned int)(*a8 + v266 + result);
    v27 = a8[1] + v259;
    v28 = a8[2] + v260;
    v29 = a8[3] + v261;
    v30 = a8[4] + v262;
    v31 = a8[5] + v263;
    _RSI += 128i64;
    v32 = a8[6] + v264;
    v33 = a8[7] + v265;
    *a8 = result;
    a8[1] = v27;
    a8[2] = v28;
    a8[3] = v29;
    a8[4] = v30;
    a8[5] = v31;
    a8[6] = v32;
    a8[7] = v33;
  }
  while ( _RSI <= a10 );
  __asm { vzeroupper }
  return result;
}
// 14614C03C: positive sp value 30 has been found
// 14614AC8D: could not find valid save-restore pair for rdi
// 14614AC8D: could not find valid save-restore pair for rsi
// 14614AC99: variable 'v10' is possibly undefined
// 14614AC9A: variable 'v11' is possibly undefined
// 14614AC9B: variable 'v12' is possibly undefined
// 14614AC9D: variable 'v13' is possibly undefined
// 14614AC9F: variable 'v14' is possibly undefined
// 14614ACA1: variable 'v15' is possibly undefined
// 14614ACD4: variable 'v16' is possibly undefined
// 14614ACD9: variable 'v17' is possibly undefined
// 14614ACDE: variable 'v18' is possibly undefined
// 14614ACE7: variable 'v19' is possibly undefined
// 146148740: using guessed type __int64 qword_146148740[16];
// 146148940: using guessed type __m256 ymmword_146148940;

//----- (000000014614C0E0) ----------------------------------------------------
__int64 __fastcall sub_14614C0E0(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4)
{
  unsigned __int64 v4; // kr00_8
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rbx
  __int64 v7; // rsi
  unsigned int *v8; // r11
  unsigned __int64 v9; // rsi
  unsigned __int64 v10; // rbx
  __int64 v11; // rbp
  __int64 v12; // r12
  __int64 v13; // r13
  __int64 v14; // r14
  __int64 v15; // r15
  __int64 v16; // rdi
  __int64 v17; // rsi
  __int64 result; // rax

  v4 = __readeflags();
  v5 = a3[15];
  v6 = a3[31];
  v7 = *(_QWORD *)(a4 + 8);
  v8 = *(unsigned int **)(a4 + 56);
  if ( v6 >= v7 + (unsigned __int64)*v8 )
  {
    v5 = a3[19];
    if ( v6 < v7 + (unsigned __int64)v8[1] )
    {
      if ( v6 >= (unsigned __int64)&loc_14614AC96 )
        v5 = (v5 & 0xFFFFFFFFFFFFFC00ui64) + 448;
      v9 = v5;
      v5 = *(_QWORD *)(v5 + 88);
      v10 = *(_QWORD *)(v5 - 8);
      v11 = *(_QWORD *)(v5 - 16);
      v12 = *(_QWORD *)(v5 - 24);
      v13 = *(_QWORD *)(v5 - 32);
      v14 = *(_QWORD *)(v5 - 40);
      v15 = *(_QWORD *)(v5 - 48);
      a3[18] = v10;
      a3[20] = v11;
      a3[27] = v12;
      a3[28] = v13;
      a3[29] = v14;
      a3[30] = v15;
      if ( v10 >= (unsigned __int64)&loc_1461486FA )
        qmemcpy(a3 + 64, (const void *)(v9 + 96), 0x40ui64);
    }
  }
  v16 = *(_QWORD *)(v5 + 8);
  v17 = *(_QWORD *)(v5 + 16);
  a3[19] = v5;
  a3[21] = v17;
  a3[22] = v16;
  qmemcpy(*(void **)(a4 + 40), a3, 0x4D0ui64);
  RtlVirtualUnwind(
    0,
    *(_QWORD *)(a4 + 8),
    *(_QWORD *)a4,
    *(PRUNTIME_FUNCTION *)(a4 + 16),
    *(PCONTEXT *)(a4 + 40),
    (PVOID *)(a4 + 56),
    (PULONG64)(a4 + 24),
    0i64);
  result = 1i64;
  __writeeflags(v4);
  return result;
}

//----- (000000014614C230) ----------------------------------------------------
void __fastcall sub_14614C230(__int64 a1, __int64 a2, _QWORD *a3)
{
  unsigned __int64 v3; // rbx

  __readeflags();
  v3 = a3[31];
  if ( v3 >= (unsigned __int64)&loc_146148A32 && v3 < (unsigned __int64)&loc_146148D86 )
    qmemcpy(a3 + 64, (const void *)(a3[15] - 88i64), 0x50ui64);
  JUMPOUT(0x14614C1ADi64);
}
// 14614C280: control flows out of bounds to 14614C1AD

//----- (000000014614C290) ----------------------------------------------------
int sub_14614C290()
{
  _QWORD *v0; // rsi
  __int64 *v1; // rbx
  __int64 v2; // rax
  void *v3; // rdi
  _OWORD *v4; // rax
  __int128 v6; // [rsp+20h] [rbp-98h] BYREF
  __int64 v7[2]; // [rsp+30h] [rbp-88h] BYREF
  int v8; // [rsp+40h] [rbp-78h]
  int v9; // [rsp+44h] [rbp-74h]
  __int64 v10; // [rsp+48h] [rbp-70h]
  void **v11; // [rsp+50h] [rbp-68h] BYREF
  __int64 v12; // [rsp+58h] [rbp-60h]
  __int64 v13; // [rsp+60h] [rbp-58h]
  __int64 v14; // [rsp+78h] [rbp-40h]
  char v15[32]; // [rsp+80h] [rbp-38h] BYREF

  v13 = -2i64;
  v7[0] = (__int64)"rdr3";
  v7[1] = 4i64;
  v8 = 1491;
  v9 = HIDWORD(v14);
  v10 = 50i64;
  v0 = operator new(0x40ui64);
  *v0 = v0;
  v0[1] = v0;
  v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
  Block = v0;
  v1 = v7;
  do
  {
    v2 = sub_14615A770((__int64 *)&Block, (__int64)v15, v0, (__int64)v1);
    v6 = *(_OWORD *)v2;
    v14 = *(_QWORD *)(v2 + 16);
    if ( !(_BYTE)v14 )
    {
      if ( qword_14610A960 == 0x3FFFFFFFFFFFFFFi64 )
        unknown_libname_3();
      v3 = Block;
      v11 = &Block;
      v12 = 0i64;
      v4 = operator new(0x40ui64);
      v4[2] = *(_OWORD *)v1;
      v4[3] = *((_OWORD *)v1 + 1);
      *(_QWORD *)v4 = v3;
      *((_QWORD *)v4 + 1) = v3;
      *((_QWORD *)v4 + 2) = v3;
      *((_WORD *)v4 + 12) = 0;
      v12 = 0i64;
      sub_146165130(&Block, (__int64)&v6, (__int64)v4);
    }
    v1 += 4;
  }
  while ( v1 != (__int64 *)&v11 );
  return atexit(sub_1461AE2C0);
}
// 14610A960: using guessed type __int64 qword_14610A960;
// 1461653B0: using guessed type void __noreturn unknown_libname_3(void);
// 14614C290: using guessed type char var_38[32];

//----- (000000014614C400) ----------------------------------------------------
int sub_14614C400()
{
  return atexit(sub_1461AE330);
}

//----- (000000014614C410) ----------------------------------------------------
int sub_14614C410()
{
  return atexit(sub_1461AE3E0);
}

//----- (000000014614C420) ----------------------------------------------------
void sub_14614C420()
{
  qword_14610AA88 = GetTickCount64();
  GetSystemTime(&stru_14610AA90);
}
// 14610AA88: using guessed type __int64 qword_14610AA88;
// 14610AA90: using guessed type struct _SYSTEMTIME stru_14610AA90;

//----- (000000014614C450) ----------------------------------------------------
FARPROC sub_14614C450()
{
  HMODULE ModuleHandleW; // rax
  FARPROC result; // rax

  ModuleHandleW = GetModuleHandleW(L"kernel32.dll");
  result = GetProcAddress(ModuleHandleW, "GetThreadDescription");
  qword_14610A9F0 = (__int64)result;
  return result;
}
// 14610A9F0: using guessed type __int64 qword_14610A9F0;

//----- (000000014614C480) ----------------------------------------------------
void *sub_14614C480()
{
  void *result; // rax

  result = operator new(0x268ui64);
  if ( result )
  {
    result = (void *)sub_146170930((__int64)result, 0xC0ui64);
    qword_14610A9F8 = (__int64)result;
  }
  else
  {
    qword_14610A9F8 = 0i64;
  }
  return result;
}
// 14610A9F8: using guessed type __int64 qword_14610A9F8;

//----- (000000014614C4D0) ----------------------------------------------------
HANDLE sub_14614C4D0()
{
  return CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)StartAddress, 0i64, 0, 0i64);
}

//----- (000000014614C500) ----------------------------------------------------
int sub_14614C500()
{
  return atexit((void (__cdecl *)())sub_1461AE570);
}
// 1461AE570: using guessed type __int64 sub_1461AE570();

//----- (000000014614C510) ----------------------------------------------------
int sub_14614C510()
{
  _QWORD *v0; // rsi
  __int64 *v1; // rbx
  __int64 v2; // rax
  void *v3; // rdi
  _OWORD *v4; // rax
  __int128 v6; // [rsp+20h] [rbp-98h] BYREF
  __int64 v7[2]; // [rsp+30h] [rbp-88h] BYREF
  int v8; // [rsp+40h] [rbp-78h]
  int v9; // [rsp+44h] [rbp-74h]
  __int64 v10; // [rsp+48h] [rbp-70h]
  void **v11; // [rsp+50h] [rbp-68h] BYREF
  __int64 v12; // [rsp+58h] [rbp-60h]
  __int64 v13; // [rsp+60h] [rbp-58h]
  __int64 v14; // [rsp+78h] [rbp-40h]
  char v15[32]; // [rsp+80h] [rbp-38h] BYREF

  v13 = -2i64;
  v7[0] = (__int64)"rdr3";
  v7[1] = 4i64;
  v8 = 1491;
  v9 = HIDWORD(v14);
  v10 = 50i64;
  v0 = operator new(0x40ui64);
  *v0 = v0;
  v0[1] = v0;
  v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
  qword_14610AAA0 = v0;
  v1 = v7;
  do
  {
    v2 = sub_14615A770((__int64 *)&qword_14610AAA0, (__int64)v15, v0, (__int64)v1);
    v6 = *(_OWORD *)v2;
    v14 = *(_QWORD *)(v2 + 16);
    if ( !(_BYTE)v14 )
    {
      if ( qword_14610AAA8 == 0x3FFFFFFFFFFFFFFi64 )
        unknown_libname_3();
      v3 = qword_14610AAA0;
      v11 = &qword_14610AAA0;
      v12 = 0i64;
      v4 = operator new(0x40ui64);
      v4[2] = *(_OWORD *)v1;
      v4[3] = *((_OWORD *)v1 + 1);
      *(_QWORD *)v4 = v3;
      *((_QWORD *)v4 + 1) = v3;
      *((_QWORD *)v4 + 2) = v3;
      *((_WORD *)v4 + 12) = 0;
      v12 = 0i64;
      sub_146165130(&qword_14610AAA0, (__int64)&v6, (__int64)v4);
    }
    v1 += 4;
  }
  while ( v1 != (__int64 *)&v11 );
  return atexit(sub_1461AE5F0);
}
// 14610AAA8: using guessed type __int64 qword_14610AAA8;
// 1461653B0: using guessed type void __noreturn unknown_libname_3(void);
// 14614C510: using guessed type char var_38[32];

//----- (000000014614C680) ----------------------------------------------------
int sub_14614C680()
{
  _QWORD *v0; // rax
  __int64 v1; // r8
  __int64 v2; // r9
  __int64 v3; // r8
  __m128i si128; // xmm7
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // r8
  __int64 v28; // r9
  __int64 v29; // rax
  __int64 v30; // rax
  __int64 v31; // r8
  __int64 v32; // r9
  __int64 v33; // rax
  __int64 v34; // rax
  __int64 v35; // r8
  __int64 v36; // r9
  __int64 v37; // rax
  __int64 v38; // rax
  __int64 v39; // r8
  __int64 v40; // r9
  __int64 v41; // rax
  __int64 v42; // rax
  __int64 v43; // r8
  __int64 v44; // r9
  __int64 v45; // rax
  __int64 v46; // rax
  __int64 v47; // r8
  __int64 v48; // r9
  __int64 v49; // rax
  __int64 v50; // rax
  __int64 v51; // r8
  __int64 v52; // r9
  __int64 v53; // rax
  __int64 v54; // rax
  __int64 v55; // r8
  __int64 v56; // r9
  __int64 v57; // r8
  __int64 v58; // r9
  __int64 v59; // r8
  __m128i v60; // xmm6
  __int64 v61; // rax
  __int64 v62; // rax
  __int64 v63; // r8
  __int64 v64; // r9
  __int64 v65; // rax
  __int64 v66; // rax
  __int64 v67; // r8
  __int64 v68; // r9
  __int64 v69; // rax
  __int64 v70; // rax
  __int64 v71; // r8
  __int64 v72; // r9
  __int64 v73; // rax
  __int64 v74; // rax
  __int64 v75; // r8
  __int64 v76; // r9
  __int64 v77; // rax
  __int64 v78; // rax
  __int64 v79; // r8
  __int64 v80; // r9
  __int64 v81; // rax
  __int64 v82; // rax
  __int64 v83; // r8
  __int64 v84; // r9
  __int64 v85; // rax
  __int64 v86; // rax
  __int64 v87; // r8
  __int64 v88; // r9
  __int64 v89; // rax
  __int64 v90; // rax
  __int64 v91; // r8
  __int64 v92; // r9
  __int64 v93; // r8
  __int64 v94; // r9
  __int64 v95; // r8
  __int64 v96; // r8
  __int64 v97; // r9
  __int64 v98; // r8
  __int64 v99; // rax
  __int64 v100; // rax
  __int64 v101; // r8
  __int64 v102; // r9
  _QWORD *v103; // rbx
  __int64 v104; // r9
  __int64 v105; // r9
  __int64 v106; // r9
  __int64 v107; // r9
  __int64 v108; // r9
  __int64 v109; // r9
  __int64 v110; // r9
  __int64 v111; // r9
  __int64 v112; // r9
  __int64 v113; // r9
  __int64 v114; // r9
  __int64 v115; // r9
  __int64 v116; // r9
  __int64 v117; // r9
  __int64 v118; // r9
  __int64 v119; // r9
  __int64 v120; // r9
  __int64 v121; // r9
  __int64 v122; // r9
  __int64 v123; // r9
  __int64 v124; // r9
  __int64 v125; // r9
  __int64 v126; // r9
  __int64 v127; // r9
  __int64 v128; // r9
  __int64 v129; // r9
  __int64 v130; // r9
  __int64 v131; // r9
  __int64 v132; // r9
  __int64 v133; // r9
  __int64 v134; // r9
  __int64 v135; // r9
  __int64 v136; // r9
  __int128 v138; // [rsp+30h] [rbp-D0h] BYREF
  __int128 v139; // [rsp+40h] [rbp-C0h] BYREF
  char v140; // [rsp+50h] [rbp-B0h] BYREF
  char v141; // [rsp+51h] [rbp-AFh] BYREF
  char v142; // [rsp+52h] [rbp-AEh] BYREF
  char v143; // [rsp+53h] [rbp-ADh] BYREF
  char v144; // [rsp+54h] [rbp-ACh] BYREF
  char v145; // [rsp+55h] [rbp-ABh] BYREF
  char v146[2]; // [rsp+56h] [rbp-AAh] BYREF
  int v147; // [rsp+58h] [rbp-A8h] BYREF
  int v148; // [rsp+5Ch] [rbp-A4h] BYREF
  int v149; // [rsp+60h] [rbp-A0h] BYREF
  int v150; // [rsp+64h] [rbp-9Ch] BYREF
  int v151; // [rsp+68h] [rbp-98h] BYREF
  int v152; // [rsp+6Ch] [rbp-94h] BYREF
  int v153; // [rsp+70h] [rbp-90h] BYREF
  int v154; // [rsp+74h] [rbp-8Ch] BYREF
  int v155; // [rsp+78h] [rbp-88h] BYREF
  int v156; // [rsp+7Ch] [rbp-84h] BYREF
  int v157; // [rsp+80h] [rbp-80h] BYREF
  int v158; // [rsp+84h] [rbp-7Ch] BYREF
  int v159; // [rsp+88h] [rbp-78h] BYREF
  const char *v160; // [rsp+90h] [rbp-70h] BYREF
  __int64 v161; // [rsp+98h] [rbp-68h] BYREF
  const char *v162; // [rsp+A0h] [rbp-60h] BYREF
  const char *v163; // [rsp+A8h] [rbp-58h] BYREF
  void *v164[2]; // [rsp+B0h] [rbp-50h] BYREF
  void *v165[2]; // [rsp+C0h] [rbp-40h] BYREF
  void *v166[2]; // [rsp+D0h] [rbp-30h] BYREF
  void *v167[2]; // [rsp+E0h] [rbp-20h] BYREF
  void *v168[2]; // [rsp+F0h] [rbp-10h] BYREF
  void *v169[2]; // [rsp+100h] [rbp+0h] BYREF
  void *v170[2]; // [rsp+110h] [rbp+10h] BYREF
  void *v171[2]; // [rsp+120h] [rbp+20h] BYREF
  void *v172[2]; // [rsp+130h] [rbp+30h] BYREF
  void *v173[2]; // [rsp+140h] [rbp+40h] BYREF
  void *v174[2]; // [rsp+150h] [rbp+50h] BYREF
  void *v175[2]; // [rsp+160h] [rbp+60h] BYREF
  void *v176[2]; // [rsp+170h] [rbp+70h] BYREF
  void *v177[4]; // [rsp+180h] [rbp+80h] BYREF
  const char *v178; // [rsp+1A0h] [rbp+A0h] BYREF
  const char *v179; // [rsp+1B0h] [rbp+B0h] BYREF
  const char *v180; // [rsp+1C0h] [rbp+C0h] BYREF
  const char *v181; // [rsp+1D0h] [rbp+D0h] BYREF
  const char *v182; // [rsp+1E0h] [rbp+E0h] BYREF
  const char *v183; // [rsp+1F0h] [rbp+F0h] BYREF
  const char *v184; // [rsp+200h] [rbp+100h] BYREF
  const char *v185; // [rsp+210h] [rbp+110h] BYREF
  const char *v186; // [rsp+220h] [rbp+120h] BYREF
  const char *v187; // [rsp+230h] [rbp+130h] BYREF
  const char *v188; // [rsp+240h] [rbp+140h] BYREF
  const char *v189; // [rsp+250h] [rbp+150h] BYREF
  const char *v190; // [rsp+260h] [rbp+160h] BYREF
  const char *v191; // [rsp+270h] [rbp+170h] BYREF
  const char *v192; // [rsp+280h] [rbp+180h] BYREF
  const char *v193; // [rsp+290h] [rbp+190h] BYREF
  const char *v194; // [rsp+2A0h] [rbp+1A0h] BYREF
  const char *v195; // [rsp+2B0h] [rbp+1B0h] BYREF
  const char *v196; // [rsp+2C0h] [rbp+1C0h] BYREF
  const char *v197; // [rsp+2D0h] [rbp+1D0h] BYREF
  const char *v198; // [rsp+2E0h] [rbp+1E0h] BYREF
  const char *v199; // [rsp+2F0h] [rbp+1F0h] BYREF
  const char *v200; // [rsp+300h] [rbp+200h] BYREF
  const char *v201; // [rsp+310h] [rbp+210h] BYREF
  const char *v202; // [rsp+320h] [rbp+220h] BYREF
  const char *v203; // [rsp+330h] [rbp+230h] BYREF
  const char *v204; // [rsp+340h] [rbp+240h] BYREF
  const char *v205; // [rsp+350h] [rbp+250h] BYREF
  const char *v206; // [rsp+360h] [rbp+260h] BYREF
  const char *v207; // [rsp+370h] [rbp+270h] BYREF
  const char *v208; // [rsp+380h] [rbp+280h] BYREF
  const char *v209; // [rsp+390h] [rbp+290h] BYREF
  const char *v210; // [rsp+3A0h] [rbp+2A0h] BYREF
  const char *v211; // [rsp+3B0h] [rbp+2B0h] BYREF
  const char *v212; // [rsp+3C0h] [rbp+2C0h] BYREF
  const char *v213; // [rsp+3D0h] [rbp+2D0h] BYREF
  const char *v214; // [rsp+3E0h] [rbp+2E0h] BYREF
  const char *v215; // [rsp+3F0h] [rbp+2F0h] BYREF
  const char *v216; // [rsp+400h] [rbp+300h] BYREF
  const char *v217; // [rsp+410h] [rbp+310h] BYREF
  const char *v218; // [rsp+420h] [rbp+320h] BYREF
  const char *v219; // [rsp+430h] [rbp+330h] BYREF
  const char *v220; // [rsp+440h] [rbp+340h] BYREF
  const char *v221; // [rsp+450h] [rbp+350h] BYREF
  const char *v222; // [rsp+460h] [rbp+360h] BYREF
  const char *v223; // [rsp+470h] [rbp+370h] BYREF
  const char *v224; // [rsp+480h] [rbp+380h] BYREF
  const char *v225; // [rsp+490h] [rbp+390h] BYREF
  const char *v226; // [rsp+4A0h] [rbp+3A0h] BYREF
  const char *v227; // [rsp+4B0h] [rbp+3B0h] BYREF
  const char *v228; // [rsp+4C0h] [rbp+3C0h] BYREF
  const char *v229; // [rsp+4D0h] [rbp+3D0h] BYREF
  const char *v230; // [rsp+4E0h] [rbp+3E0h] BYREF
  const char *v231; // [rsp+4F0h] [rbp+3F0h] BYREF
  const char *v232; // [rsp+500h] [rbp+400h] BYREF
  const char *v233; // [rsp+510h] [rbp+410h] BYREF
  const char *v234; // [rsp+520h] [rbp+420h] BYREF
  const char *v235; // [rsp+530h] [rbp+430h] BYREF
  const char *v236; // [rsp+540h] [rbp+440h] BYREF
  const char *v237; // [rsp+550h] [rbp+450h] BYREF
  const char *v238; // [rsp+560h] [rbp+460h] BYREF
  const char *v239; // [rsp+570h] [rbp+470h] BYREF
  const char *v240; // [rsp+580h] [rbp+480h] BYREF
  const char *v241; // [rsp+590h] [rbp+490h] BYREF
  const char *v242; // [rsp+5A0h] [rbp+4A0h] BYREF
  const char *v243; // [rsp+5B0h] [rbp+4B0h] BYREF
  const char *v244; // [rsp+5C0h] [rbp+4C0h] BYREF
  const char *v245; // [rsp+5D0h] [rbp+4D0h] BYREF
  const char *v246; // [rsp+5E0h] [rbp+4E0h] BYREF
  const char *v247; // [rsp+5F0h] [rbp+4F0h] BYREF
  const char *v248; // [rsp+600h] [rbp+500h] BYREF
  const char *v249; // [rsp+610h] [rbp+510h] BYREF
  const char *v250; // [rsp+620h] [rbp+520h] BYREF
  const char *v251; // [rsp+630h] [rbp+530h] BYREF
  const char *v252; // [rsp+640h] [rbp+540h] BYREF
  const char *v253; // [rsp+650h] [rbp+550h] BYREF
  const char *v254; // [rsp+660h] [rbp+560h] BYREF
  const char *v255; // [rsp+670h] [rbp+570h] BYREF
  const char *v256; // [rsp+680h] [rbp+580h] BYREF
  const char *v257; // [rsp+690h] [rbp+590h] BYREF
  const char *v258; // [rsp+6A0h] [rbp+5A0h] BYREF
  const char *v259; // [rsp+6B0h] [rbp+5B0h] BYREF
  const char *v260; // [rsp+6C0h] [rbp+5C0h] BYREF
  const char *v261; // [rsp+6D0h] [rbp+5D0h] BYREF
  const char *v262; // [rsp+6E0h] [rbp+5E0h] BYREF
  const char *v263; // [rsp+6F0h] [rbp+5F0h] BYREF
  const char *v264; // [rsp+700h] [rbp+600h] BYREF
  const char *v265; // [rsp+710h] [rbp+610h] BYREF
  const char *v266; // [rsp+720h] [rbp+620h] BYREF
  const char *v267; // [rsp+730h] [rbp+630h] BYREF
  const char *v268; // [rsp+740h] [rbp+640h] BYREF
  const char *v269; // [rsp+750h] [rbp+650h] BYREF
  const char *v270; // [rsp+760h] [rbp+660h] BYREF
  const char *v271; // [rsp+770h] [rbp+670h] BYREF
  const char *v272; // [rsp+780h] [rbp+680h] BYREF
  const char *v273; // [rsp+790h] [rbp+690h] BYREF
  const char *v274; // [rsp+7A0h] [rbp+6A0h] BYREF
  const char *v275; // [rsp+7B0h] [rbp+6B0h] BYREF
  const char *v276; // [rsp+7C0h] [rbp+6C0h] BYREF
  const char *v277; // [rsp+7D0h] [rbp+6D0h] BYREF
  const char *v278; // [rsp+7E0h] [rbp+6E0h] BYREF
  const char *v279; // [rsp+7F0h] [rbp+6F0h] BYREF
  const char *v280; // [rsp+800h] [rbp+700h] BYREF
  const char *v281; // [rsp+810h] [rbp+710h] BYREF
  const char *v282; // [rsp+820h] [rbp+720h] BYREF
  const char *v283; // [rsp+830h] [rbp+730h] BYREF
  const char *v284; // [rsp+840h] [rbp+740h] BYREF
  const char *v285; // [rsp+850h] [rbp+750h] BYREF
  const char *v286; // [rsp+860h] [rbp+760h] BYREF
  const char *v287; // [rsp+870h] [rbp+770h] BYREF
  const char *v288; // [rsp+880h] [rbp+780h] BYREF
  const char *v289; // [rsp+890h] [rbp+790h] BYREF
  const char *v290; // [rsp+8A0h] [rbp+7A0h] BYREF
  const char *v291; // [rsp+8B0h] [rbp+7B0h] BYREF
  const char *v292; // [rsp+8C0h] [rbp+7C0h] BYREF
  const char *v293; // [rsp+8D0h] [rbp+7D0h] BYREF
  const char *v294; // [rsp+8E0h] [rbp+7E0h] BYREF
  const char *v295; // [rsp+8F0h] [rbp+7F0h] BYREF
  const char *v296; // [rsp+900h] [rbp+800h] BYREF
  const char *v297; // [rsp+910h] [rbp+810h] BYREF
  const char *v298; // [rsp+920h] [rbp+820h] BYREF
  const char *v299; // [rsp+930h] [rbp+830h] BYREF
  const char *v300; // [rsp+940h] [rbp+840h] BYREF
  const char *v301; // [rsp+950h] [rbp+850h] BYREF
  const char *v302; // [rsp+960h] [rbp+860h] BYREF
  const char *v303; // [rsp+970h] [rbp+870h] BYREF
  const char *v304; // [rsp+980h] [rbp+880h] BYREF
  const char *v305; // [rsp+990h] [rbp+890h] BYREF
  const char *v306; // [rsp+9A0h] [rbp+8A0h] BYREF
  const char *v307; // [rsp+9B0h] [rbp+8B0h] BYREF
  const char *v308; // [rsp+9C0h] [rbp+8C0h] BYREF
  const char *v309; // [rsp+9D0h] [rbp+8D0h] BYREF
  const char *v310; // [rsp+9E0h] [rbp+8E0h] BYREF
  const char *v311; // [rsp+9F0h] [rbp+8F0h] BYREF
  const char *v312; // [rsp+A00h] [rbp+900h] BYREF
  const char *v313; // [rsp+A10h] [rbp+910h] BYREF
  const char *v314; // [rsp+A20h] [rbp+920h] BYREF
  const char *v315; // [rsp+A30h] [rbp+930h] BYREF
  const char *v316; // [rsp+A40h] [rbp+940h] BYREF
  const char *v317; // [rsp+A50h] [rbp+950h] BYREF
  const char *v318; // [rsp+A60h] [rbp+960h] BYREF
  const char *v319; // [rsp+A70h] [rbp+970h] BYREF
  const char *v320; // [rsp+A80h] [rbp+980h] BYREF
  const char *v321; // [rsp+A90h] [rbp+990h] BYREF
  const char *v322; // [rsp+AA0h] [rbp+9A0h] BYREF
  const char *v323; // [rsp+AB0h] [rbp+9B0h] BYREF
  const char *v324; // [rsp+AC0h] [rbp+9C0h] BYREF
  const char *v325; // [rsp+AD0h] [rbp+9D0h] BYREF
  const char *v326; // [rsp+AE0h] [rbp+9E0h] BYREF
  const char *v327; // [rsp+AF0h] [rbp+9F0h] BYREF
  const char *v328; // [rsp+B00h] [rbp+A00h] BYREF
  const char *v329; // [rsp+B10h] [rbp+A10h] BYREF
  const char *v330; // [rsp+B20h] [rbp+A20h] BYREF
  const char *v331; // [rsp+B30h] [rbp+A30h] BYREF
  const char *v332; // [rsp+B40h] [rbp+A40h] BYREF
  const char *v333; // [rsp+B50h] [rbp+A50h] BYREF
  const char *v334; // [rsp+B60h] [rbp+A60h] BYREF
  const char *v335; // [rsp+B70h] [rbp+A70h] BYREF
  const char *v336; // [rsp+B80h] [rbp+A80h] BYREF
  const char *v337; // [rsp+B90h] [rbp+A90h] BYREF
  const char *v338; // [rsp+BA0h] [rbp+AA0h] BYREF
  const char *v339; // [rsp+BB0h] [rbp+AB0h] BYREF
  const char *v340; // [rsp+BC0h] [rbp+AC0h] BYREF
  const char *v341; // [rsp+BD0h] [rbp+AD0h] BYREF
  const char *v342; // [rsp+BE0h] [rbp+AE0h] BYREF
  const char *v343; // [rsp+BF0h] [rbp+AF0h] BYREF
  const char *v344; // [rsp+C00h] [rbp+B00h] BYREF
  const char *v345; // [rsp+C10h] [rbp+B10h] BYREF
  const char *v346; // [rsp+C20h] [rbp+B20h] BYREF
  const char *v347; // [rsp+C30h] [rbp+B30h] BYREF
  const char *v348; // [rsp+C40h] [rbp+B40h] BYREF
  const char *v349; // [rsp+C50h] [rbp+B50h] BYREF
  const char *v350; // [rsp+C60h] [rbp+B60h] BYREF
  const char *v351; // [rsp+C70h] [rbp+B70h] BYREF
  const char *v352; // [rsp+C80h] [rbp+B80h] BYREF
  const char *v353; // [rsp+C90h] [rbp+B90h] BYREF
  const char *v354; // [rsp+CA0h] [rbp+BA0h] BYREF
  const char *v355; // [rsp+CB0h] [rbp+BB0h] BYREF
  const char *v356; // [rsp+CC0h] [rbp+BC0h] BYREF
  const char *v357; // [rsp+CD0h] [rbp+BD0h] BYREF
  const char *v358; // [rsp+CE0h] [rbp+BE0h] BYREF
  const char *v359; // [rsp+CF0h] [rbp+BF0h] BYREF
  const char *v360; // [rsp+D00h] [rbp+C00h] BYREF
  const char *v361; // [rsp+D10h] [rbp+C10h] BYREF
  const char *v362; // [rsp+D20h] [rbp+C20h] BYREF
  const char *v363; // [rsp+D30h] [rbp+C30h] BYREF
  const char *v364; // [rsp+D40h] [rbp+C40h] BYREF
  const char *v365; // [rsp+D50h] [rbp+C50h] BYREF
  const char *v366; // [rsp+D60h] [rbp+C60h] BYREF
  const char *v367; // [rsp+D70h] [rbp+C70h] BYREF
  const char *v368; // [rsp+D80h] [rbp+C80h] BYREF
  const char *v369; // [rsp+D90h] [rbp+C90h] BYREF
  const char *v370; // [rsp+DA0h] [rbp+CA0h] BYREF
  const char *v371; // [rsp+DB0h] [rbp+CB0h] BYREF
  const char *v372; // [rsp+DC0h] [rbp+CC0h] BYREF
  const char *v373; // [rsp+DD0h] [rbp+CD0h] BYREF
  const char *v374; // [rsp+DE0h] [rbp+CE0h] BYREF
  const char *v375; // [rsp+DF0h] [rbp+CF0h] BYREF
  const char *v376; // [rsp+E00h] [rbp+D00h] BYREF
  const char *v377; // [rsp+E10h] [rbp+D10h] BYREF
  const char *v378; // [rsp+E20h] [rbp+D20h] BYREF
  const char *v379; // [rsp+E30h] [rbp+D30h] BYREF
  const char *v380; // [rsp+E40h] [rbp+D40h] BYREF
  const char *v381; // [rsp+E50h] [rbp+D50h] BYREF
  const char *v382; // [rsp+E60h] [rbp+D60h] BYREF
  const char *v383; // [rsp+E70h] [rbp+D70h] BYREF
  const char *v384; // [rsp+E80h] [rbp+D80h] BYREF
  const char *v385; // [rsp+E90h] [rbp+D90h] BYREF
  const char *v386; // [rsp+EA0h] [rbp+DA0h] BYREF
  const char *v387; // [rsp+EB0h] [rbp+DB0h] BYREF
  const char *v388; // [rsp+EC0h] [rbp+DC0h] BYREF
  const char *v389; // [rsp+ED0h] [rbp+DD0h] BYREF
  const char *v390; // [rsp+EE0h] [rbp+DE0h] BYREF
  const char *v391; // [rsp+EF0h] [rbp+DF0h] BYREF
  const char *v392; // [rsp+F00h] [rbp+E00h] BYREF
  const char *v393; // [rsp+F10h] [rbp+E10h] BYREF
  const char *v394; // [rsp+F20h] [rbp+E20h] BYREF
  const char *v395; // [rsp+F30h] [rbp+E30h] BYREF
  const char *v396; // [rsp+F40h] [rbp+E40h] BYREF
  const char *v397; // [rsp+F50h] [rbp+E50h] BYREF
  const char *v398; // [rsp+F60h] [rbp+E60h] BYREF
  const char *v399; // [rsp+F70h] [rbp+E70h] BYREF
  const char *v400; // [rsp+F80h] [rbp+E80h] BYREF
  const char *v401; // [rsp+F90h] [rbp+E90h] BYREF
  const char *v402; // [rsp+FA0h] [rbp+EA0h] BYREF
  const char *v403; // [rsp+FB0h] [rbp+EB0h] BYREF
  const char *v404; // [rsp+FC0h] [rbp+EC0h] BYREF
  const char *v405; // [rsp+FD0h] [rbp+ED0h] BYREF
  const char *v406; // [rsp+FE0h] [rbp+EE0h] BYREF
  const char *v407; // [rsp+FF0h] [rbp+EF0h] BYREF
  const char *v408; // [rsp+1000h] [rbp+F00h] BYREF
  const char *v409; // [rsp+1010h] [rbp+F10h] BYREF
  const char *v410; // [rsp+1020h] [rbp+F20h] BYREF
  const char *v411; // [rsp+1030h] [rbp+F30h] BYREF
  const char *v412; // [rsp+1040h] [rbp+F40h] BYREF
  const char *v413; // [rsp+1050h] [rbp+F50h] BYREF
  const char *v414; // [rsp+1060h] [rbp+F60h] BYREF
  const char *v415; // [rsp+1070h] [rbp+F70h] BYREF
  const char *v416; // [rsp+1080h] [rbp+F80h] BYREF
  const char *v417; // [rsp+1090h] [rbp+F90h] BYREF
  const char *v418; // [rsp+10A0h] [rbp+FA0h] BYREF
  const char *v419; // [rsp+10B0h] [rbp+FB0h] BYREF
  const char *v420; // [rsp+10C0h] [rbp+FC0h] BYREF
  const char *v421; // [rsp+10D0h] [rbp+FD0h] BYREF
  const char *v422; // [rsp+10E0h] [rbp+FE0h] BYREF
  const char *v423; // [rsp+10F0h] [rbp+FF0h] BYREF
  const char *v424; // [rsp+1100h] [rbp+1000h] BYREF
  const char *v425; // [rsp+1110h] [rbp+1010h] BYREF
  const char *v426; // [rsp+1120h] [rbp+1020h] BYREF
  const char *v427; // [rsp+1130h] [rbp+1030h] BYREF
  const char *v428; // [rsp+1140h] [rbp+1040h] BYREF
  const char *v429; // [rsp+1150h] [rbp+1050h] BYREF
  const char *v430; // [rsp+1160h] [rbp+1060h] BYREF
  const char *v431; // [rsp+1170h] [rbp+1070h] BYREF
  const char *v432; // [rsp+1180h] [rbp+1080h] BYREF
  const char *v433; // [rsp+1190h] [rbp+1090h] BYREF
  const char *v434; // [rsp+11A0h] [rbp+10A0h] BYREF
  const char *v435; // [rsp+11B0h] [rbp+10B0h] BYREF
  const char *v436; // [rsp+11C0h] [rbp+10C0h] BYREF
  const char *v437; // [rsp+11D0h] [rbp+10D0h] BYREF
  const char *v438; // [rsp+11E0h] [rbp+10E0h] BYREF
  const char *v439; // [rsp+11F0h] [rbp+10F0h] BYREF
  const char *v440; // [rsp+1200h] [rbp+1100h] BYREF
  const char *v441; // [rsp+1210h] [rbp+1110h] BYREF
  const char *v442; // [rsp+1220h] [rbp+1120h] BYREF
  const char *v443; // [rsp+1230h] [rbp+1130h] BYREF
  const char *v444; // [rsp+1240h] [rbp+1140h] BYREF
  const char *v445; // [rsp+1250h] [rbp+1150h] BYREF
  const char *v446; // [rsp+1260h] [rbp+1160h] BYREF
  const char *v447; // [rsp+1270h] [rbp+1170h] BYREF
  const char *v448; // [rsp+1280h] [rbp+1180h] BYREF
  const char *v449; // [rsp+1290h] [rbp+1190h] BYREF
  const char *v450; // [rsp+12A0h] [rbp+11A0h] BYREF
  const char *v451; // [rsp+12B0h] [rbp+11B0h] BYREF
  const char *v452; // [rsp+12C0h] [rbp+11C0h] BYREF
  const char *v453; // [rsp+12D0h] [rbp+11D0h] BYREF
  const char *v454; // [rsp+12E0h] [rbp+11E0h] BYREF
  const char *v455; // [rsp+12F0h] [rbp+11F0h] BYREF
  const char *v456; // [rsp+1300h] [rbp+1200h] BYREF
  const char *v457; // [rsp+1310h] [rbp+1210h] BYREF
  const char *v458; // [rsp+1320h] [rbp+1220h] BYREF
  const char *v459; // [rsp+1330h] [rbp+1230h] BYREF
  const char *v460; // [rsp+1340h] [rbp+1240h] BYREF
  const char *v461; // [rsp+1350h] [rbp+1250h] BYREF
  const char *v462; // [rsp+1360h] [rbp+1260h] BYREF
  const char *v463; // [rsp+1370h] [rbp+1270h] BYREF
  const char *v464; // [rsp+1380h] [rbp+1280h] BYREF
  const char *v465; // [rsp+1390h] [rbp+1290h] BYREF
  const char *v466; // [rsp+13A0h] [rbp+12A0h] BYREF
  const char *v467; // [rsp+13B0h] [rbp+12B0h] BYREF
  const char *v468; // [rsp+13C0h] [rbp+12C0h] BYREF
  const char *v469; // [rsp+13D0h] [rbp+12D0h] BYREF
  const char *v470; // [rsp+13E0h] [rbp+12E0h] BYREF
  const char *v471; // [rsp+13F0h] [rbp+12F0h] BYREF
  const char *v472; // [rsp+1400h] [rbp+1300h] BYREF
  const char *v473; // [rsp+1410h] [rbp+1310h] BYREF
  const char *v474; // [rsp+1420h] [rbp+1320h] BYREF
  const char *v475; // [rsp+1430h] [rbp+1330h] BYREF
  const char *v476; // [rsp+1440h] [rbp+1340h] BYREF
  const char *v477; // [rsp+1450h] [rbp+1350h] BYREF
  const char *v478; // [rsp+1460h] [rbp+1360h] BYREF
  const char *v479; // [rsp+1470h] [rbp+1370h] BYREF
  const char *v480; // [rsp+1480h] [rbp+1380h] BYREF
  const char *v481; // [rsp+1490h] [rbp+1390h] BYREF
  const char *v482; // [rsp+14A0h] [rbp+13A0h] BYREF
  const char *v483; // [rsp+14B0h] [rbp+13B0h] BYREF
  const char *v484; // [rsp+14C0h] [rbp+13C0h] BYREF
  const char *v485; // [rsp+14D0h] [rbp+13D0h] BYREF
  const char *v486; // [rsp+14E0h] [rbp+13E0h] BYREF
  const char *v487; // [rsp+14F0h] [rbp+13F0h] BYREF
  const char *v488; // [rsp+1500h] [rbp+1400h] BYREF
  const char *v489; // [rsp+1510h] [rbp+1410h] BYREF
  const char *v490; // [rsp+1520h] [rbp+1420h] BYREF
  const char *v491; // [rsp+1530h] [rbp+1430h] BYREF
  const char *v492; // [rsp+1540h] [rbp+1440h] BYREF
  const char *v493; // [rsp+1550h] [rbp+1450h] BYREF
  const char *v494; // [rsp+1560h] [rbp+1460h] BYREF
  const char *v495; // [rsp+1570h] [rbp+1470h] BYREF
  const char *v496; // [rsp+1580h] [rbp+1480h] BYREF
  const char *v497; // [rsp+1590h] [rbp+1490h] BYREF
  const char *v498; // [rsp+15A0h] [rbp+14A0h] BYREF
  const char *v499; // [rsp+15B0h] [rbp+14B0h] BYREF
  const char *v500; // [rsp+15C0h] [rbp+14C0h] BYREF
  const char *v501; // [rsp+15D0h] [rbp+14D0h] BYREF
  const char *v502; // [rsp+15E0h] [rbp+14E0h] BYREF
  const char *v503; // [rsp+15F0h] [rbp+14F0h] BYREF
  const char *v504; // [rsp+1600h] [rbp+1500h] BYREF
  const char *v505; // [rsp+1610h] [rbp+1510h] BYREF
  const char *v506; // [rsp+1620h] [rbp+1520h] BYREF
  const char *v507; // [rsp+1630h] [rbp+1530h] BYREF
  const char *v508; // [rsp+1640h] [rbp+1540h] BYREF
  const char *v509; // [rsp+1650h] [rbp+1550h] BYREF
  const char *v510; // [rsp+1660h] [rbp+1560h] BYREF
  const char *v511; // [rsp+1670h] [rbp+1570h] BYREF
  const char *v512; // [rsp+1680h] [rbp+1580h] BYREF
  const char *v513; // [rsp+1690h] [rbp+1590h] BYREF
  const char *v514; // [rsp+16A0h] [rbp+15A0h] BYREF
  const char *v515; // [rsp+16B0h] [rbp+15B0h] BYREF
  const char *v516; // [rsp+16C0h] [rbp+15C0h] BYREF
  const char *v517; // [rsp+16D0h] [rbp+15D0h] BYREF
  const char *v518; // [rsp+16E0h] [rbp+15E0h] BYREF
  const char *v519; // [rsp+16F0h] [rbp+15F0h] BYREF
  const char *v520; // [rsp+1700h] [rbp+1600h] BYREF
  const char *v521; // [rsp+1710h] [rbp+1610h] BYREF
  const char *v522; // [rsp+1720h] [rbp+1620h] BYREF
  const char *v523; // [rsp+1730h] [rbp+1630h] BYREF
  const char *v524; // [rsp+1740h] [rbp+1640h] BYREF
  const char *v525; // [rsp+1750h] [rbp+1650h] BYREF
  const char *v526; // [rsp+1760h] [rbp+1660h] BYREF
  const char *v527; // [rsp+1770h] [rbp+1670h] BYREF
  const char *v528; // [rsp+1780h] [rbp+1680h] BYREF
  const char *v529; // [rsp+1790h] [rbp+1690h] BYREF
  const char *v530; // [rsp+17A0h] [rbp+16A0h] BYREF
  const char *v531; // [rsp+17B0h] [rbp+16B0h] BYREF
  const char *v532; // [rsp+17C0h] [rbp+16C0h] BYREF
  const char *v533; // [rsp+17D0h] [rbp+16D0h] BYREF
  const char *v534; // [rsp+17E0h] [rbp+16E0h] BYREF
  const char *v535; // [rsp+17F0h] [rbp+16F0h] BYREF
  const char *v536; // [rsp+1800h] [rbp+1700h] BYREF
  const char *v537; // [rsp+1810h] [rbp+1710h] BYREF
  const char *v538; // [rsp+1820h] [rbp+1720h] BYREF
  const char *v539; // [rsp+1830h] [rbp+1730h] BYREF
  const char *v540; // [rsp+1840h] [rbp+1740h] BYREF
  const char *v541; // [rsp+1850h] [rbp+1750h] BYREF
  const char *v542; // [rsp+1860h] [rbp+1760h] BYREF
  const char *v543; // [rsp+1870h] [rbp+1770h] BYREF
  const char *v544; // [rsp+1880h] [rbp+1780h] BYREF
  const char *v545; // [rsp+1890h] [rbp+1790h] BYREF
  const char *v546; // [rsp+18A0h] [rbp+17A0h] BYREF
  const char *v547; // [rsp+18B0h] [rbp+17B0h] BYREF
  const char *v548; // [rsp+18C0h] [rbp+17C0h] BYREF
  const char *v549; // [rsp+18D0h] [rbp+17D0h] BYREF
  const char *v550; // [rsp+18E0h] [rbp+17E0h] BYREF
  const char *v551; // [rsp+18F0h] [rbp+17F0h] BYREF
  const char *v552; // [rsp+1900h] [rbp+1800h] BYREF
  const char *v553; // [rsp+1910h] [rbp+1810h] BYREF
  const char *v554; // [rsp+1920h] [rbp+1820h] BYREF
  const char *v555; // [rsp+1930h] [rbp+1830h] BYREF
  const char *v556; // [rsp+1940h] [rbp+1840h] BYREF
  const char *v557; // [rsp+1950h] [rbp+1850h] BYREF
  const char *v558; // [rsp+1960h] [rbp+1860h] BYREF
  const char *v559; // [rsp+1970h] [rbp+1870h] BYREF
  const char *v560; // [rsp+1980h] [rbp+1880h] BYREF
  const char *v561; // [rsp+1990h] [rbp+1890h] BYREF
  const char *v562; // [rsp+19A0h] [rbp+18A0h] BYREF
  const char *v563; // [rsp+19B0h] [rbp+18B0h] BYREF
  const char *v564; // [rsp+19C0h] [rbp+18C0h] BYREF
  const char *v565; // [rsp+19D0h] [rbp+18D0h] BYREF
  const char *v566; // [rsp+19E0h] [rbp+18E0h] BYREF
  const char *v567; // [rsp+19F0h] [rbp+18F0h] BYREF
  const char *v568; // [rsp+1A00h] [rbp+1900h] BYREF
  const char *v569; // [rsp+1A10h] [rbp+1910h] BYREF
  const char *v570; // [rsp+1A20h] [rbp+1920h] BYREF
  const char *v571; // [rsp+1A30h] [rbp+1930h] BYREF
  const char *v572; // [rsp+1A40h] [rbp+1940h] BYREF
  const char *v573; // [rsp+1A50h] [rbp+1950h] BYREF
  const char *v574; // [rsp+1A60h] [rbp+1960h] BYREF
  const char *v575; // [rsp+1A70h] [rbp+1970h] BYREF
  const char *v576; // [rsp+1A80h] [rbp+1980h] BYREF
  const char *v577; // [rsp+1A90h] [rbp+1990h] BYREF
  const char *v578; // [rsp+1AA0h] [rbp+19A0h] BYREF
  const char *v579; // [rsp+1AB0h] [rbp+19B0h] BYREF
  const char *v580; // [rsp+1AC0h] [rbp+19C0h] BYREF
  const char *v581; // [rsp+1AD0h] [rbp+19D0h] BYREF
  const char *v582; // [rsp+1AE0h] [rbp+19E0h] BYREF
  const char *v583; // [rsp+1AF0h] [rbp+19F0h] BYREF
  const char *v584; // [rsp+1B00h] [rbp+1A00h] BYREF
  const char *v585; // [rsp+1B10h] [rbp+1A10h] BYREF
  const char *v586; // [rsp+1B20h] [rbp+1A20h] BYREF
  const char *v587; // [rsp+1B30h] [rbp+1A30h] BYREF
  const char *v588; // [rsp+1B40h] [rbp+1A40h] BYREF
  const char *v589; // [rsp+1B50h] [rbp+1A50h] BYREF
  const char *v590; // [rsp+1B60h] [rbp+1A60h] BYREF
  const char *v591; // [rsp+1B70h] [rbp+1A70h] BYREF
  const char *v592; // [rsp+1B80h] [rbp+1A80h] BYREF
  const char *v593; // [rsp+1B90h] [rbp+1A90h] BYREF
  const char *v594; // [rsp+1BA0h] [rbp+1AA0h] BYREF
  const char *v595; // [rsp+1BB0h] [rbp+1AB0h] BYREF
  const char *v596; // [rsp+1BC0h] [rbp+1AC0h] BYREF
  const char *v597; // [rsp+1BD0h] [rbp+1AD0h] BYREF
  const char *v598; // [rsp+1BE0h] [rbp+1AE0h] BYREF
  const char *v599; // [rsp+1BF0h] [rbp+1AF0h] BYREF
  const char *v600; // [rsp+1C00h] [rbp+1B00h] BYREF
  const char *v601; // [rsp+1C10h] [rbp+1B10h] BYREF
  const char *v602; // [rsp+1C20h] [rbp+1B20h] BYREF
  const char *v603; // [rsp+1C30h] [rbp+1B30h] BYREF
  const char *v604; // [rsp+1C40h] [rbp+1B40h] BYREF
  const char *v605; // [rsp+1C50h] [rbp+1B50h] BYREF
  const char *v606; // [rsp+1C60h] [rbp+1B60h] BYREF
  const char *v607; // [rsp+1C70h] [rbp+1B70h] BYREF
  const char *v608; // [rsp+1C80h] [rbp+1B80h] BYREF
  const char *v609; // [rsp+1C90h] [rbp+1B90h] BYREF
  const char *v610; // [rsp+1CA0h] [rbp+1BA0h] BYREF
  const char *v611; // [rsp+1CB0h] [rbp+1BB0h] BYREF
  const char *v612; // [rsp+1CC0h] [rbp+1BC0h] BYREF
  const char *v613; // [rsp+1CD0h] [rbp+1BD0h] BYREF
  const char *v614; // [rsp+1CE0h] [rbp+1BE0h] BYREF
  const char *v615; // [rsp+1CF0h] [rbp+1BF0h] BYREF
  const char *v616; // [rsp+1D00h] [rbp+1C00h] BYREF
  const char *v617; // [rsp+1D10h] [rbp+1C10h] BYREF
  const char *v618; // [rsp+1D20h] [rbp+1C20h] BYREF
  const char *v619; // [rsp+1D30h] [rbp+1C30h] BYREF
  const char *v620; // [rsp+1D40h] [rbp+1C40h] BYREF
  const char *v621; // [rsp+1D50h] [rbp+1C50h] BYREF
  const char *v622; // [rsp+1D60h] [rbp+1C60h] BYREF
  const char *v623; // [rsp+1D70h] [rbp+1C70h] BYREF
  const char *v624; // [rsp+1D80h] [rbp+1C80h] BYREF
  const char *v625; // [rsp+1D90h] [rbp+1C90h] BYREF
  const char *v626; // [rsp+1DA0h] [rbp+1CA0h] BYREF
  const char *v627; // [rsp+1DB0h] [rbp+1CB0h] BYREF
  const char *v628; // [rsp+1DC0h] [rbp+1CC0h] BYREF
  const char *v629; // [rsp+1DD0h] [rbp+1CD0h] BYREF
  const char *v630; // [rsp+1DE0h] [rbp+1CE0h] BYREF
  const char *v631; // [rsp+1DF0h] [rbp+1CF0h] BYREF
  const char *v632; // [rsp+1E00h] [rbp+1D00h] BYREF
  const char *v633; // [rsp+1E10h] [rbp+1D10h] BYREF
  const char *v634; // [rsp+1E20h] [rbp+1D20h] BYREF
  const char *v635; // [rsp+1E30h] [rbp+1D30h] BYREF
  const char *v636; // [rsp+1E40h] [rbp+1D40h] BYREF
  const char *v637; // [rsp+1E50h] [rbp+1D50h] BYREF
  char v638[24]; // [rsp+1E60h] [rbp+1D60h] BYREF
  char v639[24]; // [rsp+1E78h] [rbp+1D78h] BYREF
  char v640[24]; // [rsp+1E90h] [rbp+1D90h] BYREF
  char v641[24]; // [rsp+1EA8h] [rbp+1DA8h] BYREF
  char v642[24]; // [rsp+1EC0h] [rbp+1DC0h] BYREF
  char v643[24]; // [rsp+1ED8h] [rbp+1DD8h] BYREF
  char v644[24]; // [rsp+1EF0h] [rbp+1DF0h] BYREF
  char v645[24]; // [rsp+1F08h] [rbp+1E08h] BYREF
  char v646[24]; // [rsp+1F20h] [rbp+1E20h] BYREF
  char v647[24]; // [rsp+1F38h] [rbp+1E38h] BYREF
  char v648[24]; // [rsp+1F50h] [rbp+1E50h] BYREF
  char v649[24]; // [rsp+1F68h] [rbp+1E68h] BYREF
  char v650[24]; // [rsp+1F80h] [rbp+1E80h] BYREF
  char v651[24]; // [rsp+1F98h] [rbp+1E98h] BYREF
  char v652[24]; // [rsp+1FB0h] [rbp+1EB0h] BYREF
  char v653[24]; // [rsp+1FC8h] [rbp+1EC8h] BYREF
  char v654[24]; // [rsp+1FE0h] [rbp+1EE0h] BYREF
  char v655[24]; // [rsp+1FF8h] [rbp+1EF8h] BYREF
  char v656[24]; // [rsp+2010h] [rbp+1F10h] BYREF
  char v657[24]; // [rsp+2028h] [rbp+1F28h] BYREF
  char v658[24]; // [rsp+2040h] [rbp+1F40h] BYREF
  char v659[24]; // [rsp+2058h] [rbp+1F58h] BYREF
  char v660[24]; // [rsp+2070h] [rbp+1F70h] BYREF
  char v661[24]; // [rsp+2088h] [rbp+1F88h] BYREF
  char v662[24]; // [rsp+20A0h] [rbp+1FA0h] BYREF
  char v663[24]; // [rsp+20B8h] [rbp+1FB8h] BYREF
  char v664[24]; // [rsp+20D0h] [rbp+1FD0h] BYREF
  char v665[24]; // [rsp+20E8h] [rbp+1FE8h] BYREF
  char v666[24]; // [rsp+2100h] [rbp+2000h] BYREF
  char v667[24]; // [rsp+2118h] [rbp+2018h] BYREF
  char v668[24]; // [rsp+2130h] [rbp+2030h] BYREF
  char v669[24]; // [rsp+2148h] [rbp+2048h] BYREF
  char v670[24]; // [rsp+2160h] [rbp+2060h] BYREF
  char v671[24]; // [rsp+2178h] [rbp+2078h] BYREF
  char v672[24]; // [rsp+2190h] [rbp+2090h] BYREF
  char v673[24]; // [rsp+21A8h] [rbp+20A8h] BYREF
  char v674[24]; // [rsp+21C0h] [rbp+20C0h] BYREF
  char v675[24]; // [rsp+21D8h] [rbp+20D8h] BYREF
  char v676[24]; // [rsp+21F0h] [rbp+20F0h] BYREF
  char v677[24]; // [rsp+2208h] [rbp+2108h] BYREF
  char v678[24]; // [rsp+2220h] [rbp+2120h] BYREF
  char v679[24]; // [rsp+2238h] [rbp+2138h] BYREF
  char v680[24]; // [rsp+2250h] [rbp+2150h] BYREF
  char v681[24]; // [rsp+2268h] [rbp+2168h] BYREF
  __int128 v682; // [rsp+2280h] [rbp+2180h] BYREF
  __int128 v683; // [rsp+2290h] [rbp+2190h]
  _QWORD v684[2]; // [rsp+22A0h] [rbp+21A0h] BYREF
  __m128i v685; // [rsp+22B0h] [rbp+21B0h]
  _QWORD v686[2]; // [rsp+22C0h] [rbp+21C0h] BYREF
  __m128i v687; // [rsp+22D0h] [rbp+21D0h]
  __int128 v688; // [rsp+22E0h] [rbp+21E0h] BYREF
  __m128i v689; // [rsp+22F0h] [rbp+21F0h]
  __int128 v690[2]; // [rsp+2300h] [rbp+2200h] BYREF
  __int128 v691; // [rsp+2320h] [rbp+2220h] BYREF
  __m128i v692; // [rsp+2330h] [rbp+2230h]
  __int128 v693; // [rsp+2340h] [rbp+2240h] BYREF
  __m128i v694; // [rsp+2350h] [rbp+2250h]
  __int128 v695; // [rsp+2360h] [rbp+2260h] BYREF
  __m128i v696; // [rsp+2370h] [rbp+2270h]
  __int128 v697; // [rsp+2380h] [rbp+2280h] BYREF
  __m128i v698; // [rsp+2390h] [rbp+2290h]
  __int128 v699; // [rsp+23A0h] [rbp+22A0h] BYREF
  __m128i v700; // [rsp+23B0h] [rbp+22B0h]
  __int128 v701; // [rsp+23C0h] [rbp+22C0h] BYREF
  __m128i v702; // [rsp+23D0h] [rbp+22D0h]
  __int128 v703; // [rsp+23E0h] [rbp+22E0h] BYREF
  __m128i v704; // [rsp+23F0h] [rbp+22F0h]
  __int128 v705; // [rsp+2400h] [rbp+2300h] BYREF
  __m128i v706; // [rsp+2410h] [rbp+2310h]
  __int128 v707; // [rsp+2420h] [rbp+2320h] BYREF
  __m128i v708; // [rsp+2430h] [rbp+2330h]
  __int128 v709; // [rsp+2440h] [rbp+2340h] BYREF
  __m128i v710; // [rsp+2450h] [rbp+2350h]
  __int128 v711; // [rsp+2460h] [rbp+2360h] BYREF
  __m128i v712; // [rsp+2470h] [rbp+2370h]
  __int128 v713; // [rsp+2480h] [rbp+2380h] BYREF
  __m128i v714; // [rsp+2490h] [rbp+2390h]
  __int128 v715; // [rsp+24A0h] [rbp+23A0h] BYREF
  __m128i v716; // [rsp+24B0h] [rbp+23B0h]
  __int128 v717; // [rsp+24C0h] [rbp+23C0h] BYREF
  __m128i v718; // [rsp+24D0h] [rbp+23D0h]
  __int128 v719; // [rsp+24E0h] [rbp+23E0h] BYREF
  __m128i v720; // [rsp+24F0h] [rbp+23F0h]
  __int128 v721; // [rsp+2500h] [rbp+2400h] BYREF
  __m128i v722; // [rsp+2510h] [rbp+2410h]
  __int128 v723; // [rsp+2520h] [rbp+2420h] BYREF
  __m128i v724; // [rsp+2530h] [rbp+2430h]
  __int128 v725; // [rsp+2540h] [rbp+2440h] BYREF
  __m128i v726; // [rsp+2550h] [rbp+2450h]
  __int128 v727; // [rsp+2560h] [rbp+2460h] BYREF
  __m128i v728; // [rsp+2570h] [rbp+2470h]
  __int128 v729; // [rsp+2580h] [rbp+2480h] BYREF
  __m128i v730; // [rsp+2590h] [rbp+2490h]
  __int128 v731; // [rsp+25A0h] [rbp+24A0h] BYREF
  __m128i v732; // [rsp+25B0h] [rbp+24B0h]
  __int128 v733[2]; // [rsp+25C0h] [rbp+24C0h] BYREF
  const char *v734; // [rsp+25E0h] [rbp+24E0h] BYREF
  _QWORD *v735; // [rsp+25E8h] [rbp+24E8h]
  __int128 v736; // [rsp+25F0h] [rbp+24F0h]
  const char *v737; // [rsp+2600h] [rbp+2500h]
  __int64 v738; // [rsp+2608h] [rbp+2508h]
  __int64 v739; // [rsp+2610h] [rbp+2510h]
  __int64 v740; // [rsp+2618h] [rbp+2518h]
  __int64 v741[3]; // [rsp+2620h] [rbp+2520h] BYREF
  __int128 v742; // [rsp+2638h] [rbp+2538h]
  __int64 v743; // [rsp+2648h] [rbp+2548h]
  __int64 v744; // [rsp+2650h] [rbp+2550h]
  const char *v745; // [rsp+2660h] [rbp+2560h] BYREF
  _QWORD v746[7]; // [rsp+2668h] [rbp+2568h] BYREF
  __int64 v747[3]; // [rsp+26A0h] [rbp+25A0h] BYREF
  __int128 v748; // [rsp+26B8h] [rbp+25B8h]
  __int64 v749; // [rsp+26C8h] [rbp+25C8h]
  __int64 v750; // [rsp+26D0h] [rbp+25D0h]
  const char *v751; // [rsp+26E0h] [rbp+25E0h] BYREF
  _QWORD v752[7]; // [rsp+26E8h] [rbp+25E8h] BYREF
  __int64 v753[3]; // [rsp+2720h] [rbp+2620h] BYREF
  __int128 v754; // [rsp+2738h] [rbp+2638h]
  __int64 v755; // [rsp+2748h] [rbp+2648h]
  __int64 v756; // [rsp+2750h] [rbp+2650h]
  const char *v757; // [rsp+2760h] [rbp+2660h] BYREF
  _QWORD v758[7]; // [rsp+2768h] [rbp+2668h] BYREF
  __int64 v759[3]; // [rsp+27A0h] [rbp+26A0h] BYREF
  __int128 v760; // [rsp+27B8h] [rbp+26B8h]
  __int64 v761; // [rsp+27C8h] [rbp+26C8h]
  __int64 v762; // [rsp+27D0h] [rbp+26D0h]
  _QWORD v763[4]; // [rsp+27E0h] [rbp+26E0h] BYREF
  _QWORD v764[4]; // [rsp+2800h] [rbp+2700h] BYREF
  _QWORD v765[4]; // [rsp+2820h] [rbp+2720h] BYREF
  _QWORD v766[4]; // [rsp+2840h] [rbp+2740h] BYREF
  _QWORD v767[4]; // [rsp+2860h] [rbp+2760h] BYREF
  _QWORD v768[4]; // [rsp+2880h] [rbp+2780h] BYREF
  _QWORD v769[4]; // [rsp+28A0h] [rbp+27A0h] BYREF
  _QWORD v770[4]; // [rsp+28C0h] [rbp+27C0h] BYREF
  _QWORD v771[4]; // [rsp+28E0h] [rbp+27E0h] BYREF
  _QWORD v772[4]; // [rsp+2900h] [rbp+2800h] BYREF
  _QWORD v773[4]; // [rsp+2920h] [rbp+2820h] BYREF
  _QWORD v774[4]; // [rsp+2940h] [rbp+2840h] BYREF
  _QWORD v775[4]; // [rsp+2960h] [rbp+2860h] BYREF
  _QWORD v776[4]; // [rsp+2980h] [rbp+2880h] BYREF
  _QWORD v777[4]; // [rsp+29A0h] [rbp+28A0h] BYREF
  _QWORD v778[4]; // [rsp+29C0h] [rbp+28C0h] BYREF
  _QWORD v779[4]; // [rsp+29E0h] [rbp+28E0h] BYREF
  _QWORD v780[4]; // [rsp+2A00h] [rbp+2900h] BYREF
  _QWORD v781[4]; // [rsp+2A20h] [rbp+2920h] BYREF
  _QWORD v782[4]; // [rsp+2A40h] [rbp+2940h] BYREF
  _QWORD v783[4]; // [rsp+2A60h] [rbp+2960h] BYREF
  _QWORD v784[4]; // [rsp+2A80h] [rbp+2980h] BYREF
  _QWORD v785[4]; // [rsp+2AA0h] [rbp+29A0h] BYREF
  _QWORD v786[4]; // [rsp+2AC0h] [rbp+29C0h] BYREF
  _QWORD v787[4]; // [rsp+2AE0h] [rbp+29E0h] BYREF
  _QWORD v788[4]; // [rsp+2B00h] [rbp+2A00h] BYREF
  _QWORD v789[4]; // [rsp+2B20h] [rbp+2A20h] BYREF
  _QWORD v790[4]; // [rsp+2B40h] [rbp+2A40h] BYREF
  _QWORD v791[4]; // [rsp+2B60h] [rbp+2A60h] BYREF
  _QWORD v792[4]; // [rsp+2B80h] [rbp+2A80h] BYREF
  _QWORD v793[4]; // [rsp+2BA0h] [rbp+2AA0h] BYREF
  _QWORD v794[4]; // [rsp+2BC0h] [rbp+2AC0h] BYREF
  _QWORD v795[4]; // [rsp+2BE0h] [rbp+2AE0h] BYREF
  _QWORD v796[4]; // [rsp+2C00h] [rbp+2B00h] BYREF
  _QWORD v797[4]; // [rsp+2C20h] [rbp+2B20h] BYREF
  _QWORD v798[4]; // [rsp+2C40h] [rbp+2B40h] BYREF
  _QWORD v799[4]; // [rsp+2C60h] [rbp+2B60h] BYREF
  _QWORD v800[4]; // [rsp+2C80h] [rbp+2B80h] BYREF
  _QWORD v801[4]; // [rsp+2CA0h] [rbp+2BA0h] BYREF
  _QWORD v802[4]; // [rsp+2CC0h] [rbp+2BC0h] BYREF
  _QWORD v803[4]; // [rsp+2CE0h] [rbp+2BE0h] BYREF
  _QWORD v804[4]; // [rsp+2D00h] [rbp+2C00h] BYREF
  _QWORD v805[4]; // [rsp+2D20h] [rbp+2C20h] BYREF
  _QWORD v806[4]; // [rsp+2D40h] [rbp+2C40h] BYREF
  _QWORD v807[4]; // [rsp+2D60h] [rbp+2C60h] BYREF
  _QWORD v808[4]; // [rsp+2D80h] [rbp+2C80h] BYREF
  _QWORD v809[4]; // [rsp+2DA0h] [rbp+2CA0h] BYREF
  _QWORD v810[4]; // [rsp+2DC0h] [rbp+2CC0h] BYREF
  _QWORD v811[4]; // [rsp+2DE0h] [rbp+2CE0h] BYREF
  _QWORD v812[4]; // [rsp+2E00h] [rbp+2D00h] BYREF
  _QWORD v813[4]; // [rsp+2E20h] [rbp+2D20h] BYREF
  _QWORD v814[4]; // [rsp+2E40h] [rbp+2D40h] BYREF
  _QWORD v815[4]; // [rsp+2E60h] [rbp+2D60h] BYREF
  _QWORD v816[4]; // [rsp+2E80h] [rbp+2D80h] BYREF
  _QWORD v817[4]; // [rsp+2EA0h] [rbp+2DA0h] BYREF
  _QWORD v818[4]; // [rsp+2EC0h] [rbp+2DC0h] BYREF
  _QWORD v819[4]; // [rsp+2EE0h] [rbp+2DE0h] BYREF
  _QWORD v820[4]; // [rsp+2F00h] [rbp+2E00h] BYREF
  _QWORD v821[4]; // [rsp+2F20h] [rbp+2E20h] BYREF
  _QWORD v822[4]; // [rsp+2F40h] [rbp+2E40h] BYREF
  _QWORD v823[4]; // [rsp+2F60h] [rbp+2E60h] BYREF
  _QWORD v824[4]; // [rsp+2F80h] [rbp+2E80h] BYREF
  _QWORD v825[4]; // [rsp+2FA0h] [rbp+2EA0h] BYREF
  _QWORD v826[4]; // [rsp+2FC0h] [rbp+2EC0h] BYREF
  _QWORD v827[4]; // [rsp+2FE0h] [rbp+2EE0h] BYREF
  _QWORD v828[4]; // [rsp+3000h] [rbp+2F00h] BYREF
  _QWORD v829[4]; // [rsp+3020h] [rbp+2F20h] BYREF
  _QWORD v830[4]; // [rsp+3040h] [rbp+2F40h] BYREF
  _QWORD v831[4]; // [rsp+3060h] [rbp+2F60h] BYREF
  _QWORD v832[4]; // [rsp+3080h] [rbp+2F80h] BYREF
  _QWORD v833[4]; // [rsp+30A0h] [rbp+2FA0h] BYREF
  _QWORD v834[4]; // [rsp+30C0h] [rbp+2FC0h] BYREF
  _QWORD v835[4]; // [rsp+30E0h] [rbp+2FE0h] BYREF
  _QWORD v836[4]; // [rsp+3100h] [rbp+3000h] BYREF
  _QWORD v837[4]; // [rsp+3120h] [rbp+3020h] BYREF
  _QWORD v838[4]; // [rsp+3140h] [rbp+3040h] BYREF
  _QWORD v839[4]; // [rsp+3160h] [rbp+3060h] BYREF
  _QWORD v840[4]; // [rsp+3180h] [rbp+3080h] BYREF
  _QWORD v841[4]; // [rsp+31A0h] [rbp+30A0h] BYREF
  _QWORD v842[4]; // [rsp+31C0h] [rbp+30C0h] BYREF
  _QWORD v843[4]; // [rsp+31E0h] [rbp+30E0h] BYREF
  _QWORD v844[4]; // [rsp+3200h] [rbp+3100h] BYREF
  _QWORD v845[4]; // [rsp+3220h] [rbp+3120h] BYREF
  _QWORD v846[4]; // [rsp+3240h] [rbp+3140h] BYREF
  _QWORD v847[4]; // [rsp+3260h] [rbp+3160h] BYREF
  _QWORD v848[4]; // [rsp+3280h] [rbp+3180h] BYREF
  _QWORD v849[4]; // [rsp+32A0h] [rbp+31A0h] BYREF
  _QWORD v850[4]; // [rsp+32C0h] [rbp+31C0h] BYREF
  _QWORD v851[4]; // [rsp+32E0h] [rbp+31E0h] BYREF
  _QWORD v852[4]; // [rsp+3300h] [rbp+3200h] BYREF
  _QWORD v853[4]; // [rsp+3320h] [rbp+3220h] BYREF
  _QWORD v854[4]; // [rsp+3340h] [rbp+3240h] BYREF
  _QWORD v855[4]; // [rsp+3360h] [rbp+3260h] BYREF
  _QWORD v856[4]; // [rsp+3380h] [rbp+3280h] BYREF
  _QWORD v857[4]; // [rsp+33A0h] [rbp+32A0h] BYREF
  _QWORD v858[4]; // [rsp+33C0h] [rbp+32C0h] BYREF
  _QWORD v859[4]; // [rsp+33E0h] [rbp+32E0h] BYREF
  _QWORD v860[4]; // [rsp+3400h] [rbp+3300h] BYREF
  _QWORD v861[4]; // [rsp+3420h] [rbp+3320h] BYREF
  _QWORD v862[4]; // [rsp+3440h] [rbp+3340h] BYREF
  _QWORD v863[4]; // [rsp+3460h] [rbp+3360h] BYREF
  _QWORD v864[4]; // [rsp+3480h] [rbp+3380h] BYREF
  _QWORD v865[4]; // [rsp+34A0h] [rbp+33A0h] BYREF
  _QWORD v866[4]; // [rsp+34C0h] [rbp+33C0h] BYREF
  _QWORD v867[4]; // [rsp+34E0h] [rbp+33E0h] BYREF
  _QWORD v868[4]; // [rsp+3500h] [rbp+3400h] BYREF
  _QWORD v869[4]; // [rsp+3520h] [rbp+3420h] BYREF
  _QWORD v870[4]; // [rsp+3540h] [rbp+3440h] BYREF
  _QWORD v871[4]; // [rsp+3560h] [rbp+3460h] BYREF
  _QWORD v872[4]; // [rsp+3580h] [rbp+3480h] BYREF
  _QWORD v873[4]; // [rsp+35A0h] [rbp+34A0h] BYREF
  _QWORD v874[4]; // [rsp+35C0h] [rbp+34C0h] BYREF
  _QWORD v875[4]; // [rsp+35E0h] [rbp+34E0h] BYREF
  _QWORD v876[4]; // [rsp+3600h] [rbp+3500h] BYREF
  _QWORD v877[4]; // [rsp+3620h] [rbp+3520h] BYREF
  _QWORD v878[4]; // [rsp+3640h] [rbp+3540h] BYREF
  _QWORD v879[4]; // [rsp+3660h] [rbp+3560h] BYREF
  _QWORD v880[4]; // [rsp+3680h] [rbp+3580h] BYREF
  _QWORD v881[4]; // [rsp+36A0h] [rbp+35A0h] BYREF
  _QWORD v882[4]; // [rsp+36C0h] [rbp+35C0h] BYREF
  _QWORD v883[4]; // [rsp+36E0h] [rbp+35E0h] BYREF
  _QWORD v884[4]; // [rsp+3700h] [rbp+3600h] BYREF
  _QWORD v885[4]; // [rsp+3720h] [rbp+3620h] BYREF
  _QWORD v886[4]; // [rsp+3740h] [rbp+3640h] BYREF
  _QWORD v887[4]; // [rsp+3760h] [rbp+3660h] BYREF
  _QWORD v888[4]; // [rsp+3780h] [rbp+3680h] BYREF
  _QWORD v889[4]; // [rsp+37A0h] [rbp+36A0h] BYREF
  _QWORD v890[4]; // [rsp+37C0h] [rbp+36C0h] BYREF
  _QWORD v891[4]; // [rsp+37E0h] [rbp+36E0h] BYREF
  _QWORD v892[4]; // [rsp+3800h] [rbp+3700h] BYREF
  _QWORD v893[4]; // [rsp+3820h] [rbp+3720h] BYREF
  _QWORD v894[4]; // [rsp+3840h] [rbp+3740h] BYREF
  _QWORD v895[4]; // [rsp+3860h] [rbp+3760h] BYREF
  _QWORD v896[4]; // [rsp+3880h] [rbp+3780h] BYREF
  _QWORD v897[4]; // [rsp+38A0h] [rbp+37A0h] BYREF
  _QWORD v898[4]; // [rsp+38C0h] [rbp+37C0h] BYREF
  _QWORD v899[4]; // [rsp+38E0h] [rbp+37E0h] BYREF
  _QWORD v900[4]; // [rsp+3900h] [rbp+3800h] BYREF
  _QWORD v901[4]; // [rsp+3920h] [rbp+3820h] BYREF
  _QWORD v902[4]; // [rsp+3940h] [rbp+3840h] BYREF
  _QWORD v903[4]; // [rsp+3960h] [rbp+3860h] BYREF
  _QWORD v904[4]; // [rsp+3980h] [rbp+3880h] BYREF
  _QWORD v905[4]; // [rsp+39A0h] [rbp+38A0h] BYREF
  _QWORD v906[4]; // [rsp+39C0h] [rbp+38C0h] BYREF
  _QWORD v907[4]; // [rsp+39E0h] [rbp+38E0h] BYREF
  _QWORD v908[4]; // [rsp+3A00h] [rbp+3900h] BYREF
  _QWORD v909[4]; // [rsp+3A20h] [rbp+3920h] BYREF
  _QWORD v910[4]; // [rsp+3A40h] [rbp+3940h] BYREF
  _QWORD v911[4]; // [rsp+3A60h] [rbp+3960h] BYREF
  _QWORD v912[4]; // [rsp+3A80h] [rbp+3980h] BYREF
  _QWORD v913[4]; // [rsp+3AA0h] [rbp+39A0h] BYREF
  _QWORD v914[4]; // [rsp+3AC0h] [rbp+39C0h] BYREF
  _QWORD v915[4]; // [rsp+3AE0h] [rbp+39E0h] BYREF
  _QWORD v916[4]; // [rsp+3B00h] [rbp+3A00h] BYREF
  _QWORD v917[4]; // [rsp+3B20h] [rbp+3A20h] BYREF
  _QWORD v918[4]; // [rsp+3B40h] [rbp+3A40h] BYREF
  _QWORD v919[4]; // [rsp+3B60h] [rbp+3A60h] BYREF
  _QWORD v920[4]; // [rsp+3B80h] [rbp+3A80h] BYREF
  _QWORD v921[4]; // [rsp+3BA0h] [rbp+3AA0h] BYREF
  _QWORD v922[4]; // [rsp+3BC0h] [rbp+3AC0h] BYREF
  _QWORD v923[4]; // [rsp+3BE0h] [rbp+3AE0h] BYREF
  _QWORD v924[4]; // [rsp+3C00h] [rbp+3B00h] BYREF
  _QWORD v925[4]; // [rsp+3C20h] [rbp+3B20h] BYREF
  _QWORD v926[4]; // [rsp+3C40h] [rbp+3B40h] BYREF
  _QWORD v927[4]; // [rsp+3C60h] [rbp+3B60h] BYREF
  _QWORD v928[4]; // [rsp+3C80h] [rbp+3B80h] BYREF
  _QWORD v929[4]; // [rsp+3CA0h] [rbp+3BA0h] BYREF
  _QWORD v930[4]; // [rsp+3CC0h] [rbp+3BC0h] BYREF
  _QWORD v931[4]; // [rsp+3CE0h] [rbp+3BE0h] BYREF
  _QWORD v932[4]; // [rsp+3D00h] [rbp+3C00h] BYREF
  _QWORD v933[4]; // [rsp+3D20h] [rbp+3C20h] BYREF
  _QWORD v934[4]; // [rsp+3D40h] [rbp+3C40h] BYREF
  _QWORD v935[4]; // [rsp+3D60h] [rbp+3C60h] BYREF
  _QWORD v936[4]; // [rsp+3D80h] [rbp+3C80h] BYREF
  _QWORD v937[4]; // [rsp+3DA0h] [rbp+3CA0h] BYREF
  _QWORD v938[4]; // [rsp+3DC0h] [rbp+3CC0h] BYREF
  _QWORD v939[4]; // [rsp+3DE0h] [rbp+3CE0h] BYREF
  _QWORD v940[4]; // [rsp+3E00h] [rbp+3D00h] BYREF
  _QWORD v941[4]; // [rsp+3E20h] [rbp+3D20h] BYREF
  _QWORD v942[4]; // [rsp+3E40h] [rbp+3D40h] BYREF
  _QWORD v943[4]; // [rsp+3E60h] [rbp+3D60h] BYREF
  _QWORD v944[4]; // [rsp+3E80h] [rbp+3D80h] BYREF
  _QWORD v945[4]; // [rsp+3EA0h] [rbp+3DA0h] BYREF
  _QWORD v946[4]; // [rsp+3EC0h] [rbp+3DC0h] BYREF
  _QWORD v947[4]; // [rsp+3EE0h] [rbp+3DE0h] BYREF
  _QWORD v948[4]; // [rsp+3F00h] [rbp+3E00h] BYREF
  _QWORD v949[4]; // [rsp+3F20h] [rbp+3E20h] BYREF
  _QWORD v950[4]; // [rsp+3F40h] [rbp+3E40h] BYREF
  _QWORD v951[4]; // [rsp+3F60h] [rbp+3E60h] BYREF
  _QWORD v952[4]; // [rsp+3F80h] [rbp+3E80h] BYREF
  _QWORD v953[4]; // [rsp+3FA0h] [rbp+3EA0h] BYREF
  _QWORD v954[4]; // [rsp+3FC0h] [rbp+3EC0h] BYREF
  _QWORD v955[4]; // [rsp+3FE0h] [rbp+3EE0h] BYREF
  _QWORD v956[4]; // [rsp+4000h] [rbp+3F00h] BYREF
  _QWORD v957[4]; // [rsp+4020h] [rbp+3F20h] BYREF
  _QWORD v958[4]; // [rsp+4040h] [rbp+3F40h] BYREF
  _QWORD v959[4]; // [rsp+4060h] [rbp+3F60h] BYREF
  _QWORD v960[4]; // [rsp+4080h] [rbp+3F80h] BYREF
  _QWORD v961[4]; // [rsp+40A0h] [rbp+3FA0h] BYREF
  _QWORD v962[4]; // [rsp+40C0h] [rbp+3FC0h] BYREF
  _QWORD v963[4]; // [rsp+40E0h] [rbp+3FE0h] BYREF
  _QWORD v964[4]; // [rsp+4100h] [rbp+4000h] BYREF
  _QWORD v965[4]; // [rsp+4120h] [rbp+4020h] BYREF
  _QWORD v966[4]; // [rsp+4140h] [rbp+4040h] BYREF
  _QWORD v967[4]; // [rsp+4160h] [rbp+4060h] BYREF
  _QWORD v968[4]; // [rsp+4180h] [rbp+4080h] BYREF
  _QWORD v969[4]; // [rsp+41A0h] [rbp+40A0h] BYREF
  _QWORD v970[4]; // [rsp+41C0h] [rbp+40C0h] BYREF
  _QWORD v971[4]; // [rsp+41E0h] [rbp+40E0h] BYREF
  _QWORD v972[4]; // [rsp+4200h] [rbp+4100h] BYREF
  _QWORD v973[4]; // [rsp+4220h] [rbp+4120h] BYREF
  _QWORD v974[4]; // [rsp+4240h] [rbp+4140h] BYREF
  _QWORD v975[4]; // [rsp+4260h] [rbp+4160h] BYREF
  _QWORD v976[4]; // [rsp+4280h] [rbp+4180h] BYREF
  _QWORD v977[4]; // [rsp+42A0h] [rbp+41A0h] BYREF
  _QWORD v978[4]; // [rsp+42C0h] [rbp+41C0h] BYREF
  _QWORD v979[4]; // [rsp+42E0h] [rbp+41E0h] BYREF
  _QWORD v980[4]; // [rsp+4300h] [rbp+4200h] BYREF
  _QWORD v981[4]; // [rsp+4320h] [rbp+4220h] BYREF
  _QWORD v982[4]; // [rsp+4340h] [rbp+4240h] BYREF
  _QWORD v983[4]; // [rsp+4360h] [rbp+4260h] BYREF
  _QWORD v984[4]; // [rsp+4380h] [rbp+4280h] BYREF
  _QWORD v985[4]; // [rsp+43A0h] [rbp+42A0h] BYREF
  _QWORD v986[4]; // [rsp+43C0h] [rbp+42C0h] BYREF
  _QWORD v987[4]; // [rsp+43E0h] [rbp+42E0h] BYREF
  _QWORD v988[4]; // [rsp+4400h] [rbp+4300h] BYREF
  _QWORD v989[4]; // [rsp+4420h] [rbp+4320h] BYREF
  _QWORD v990[4]; // [rsp+4440h] [rbp+4340h] BYREF
  _QWORD v991[4]; // [rsp+4460h] [rbp+4360h] BYREF
  _QWORD v992[4]; // [rsp+4480h] [rbp+4380h] BYREF
  _QWORD v993[4]; // [rsp+44A0h] [rbp+43A0h] BYREF
  _QWORD v994[4]; // [rsp+44C0h] [rbp+43C0h] BYREF
  _QWORD v995[4]; // [rsp+44E0h] [rbp+43E0h] BYREF
  _QWORD v996[4]; // [rsp+4500h] [rbp+4400h] BYREF
  _QWORD v997[4]; // [rsp+4520h] [rbp+4420h] BYREF
  _QWORD v998[4]; // [rsp+4540h] [rbp+4440h] BYREF
  _QWORD v999[4]; // [rsp+4560h] [rbp+4460h] BYREF
  _QWORD v1000[4]; // [rsp+4580h] [rbp+4480h] BYREF
  _QWORD v1001[4]; // [rsp+45A0h] [rbp+44A0h] BYREF
  _QWORD v1002[4]; // [rsp+45C0h] [rbp+44C0h] BYREF
  _QWORD v1003[4]; // [rsp+45E0h] [rbp+44E0h] BYREF
  _QWORD v1004[4]; // [rsp+4600h] [rbp+4500h] BYREF
  _QWORD v1005[4]; // [rsp+4620h] [rbp+4520h] BYREF
  _QWORD v1006[4]; // [rsp+4640h] [rbp+4540h] BYREF
  _QWORD v1007[4]; // [rsp+4660h] [rbp+4560h] BYREF
  _QWORD v1008[4]; // [rsp+4680h] [rbp+4580h] BYREF
  _QWORD v1009[4]; // [rsp+46A0h] [rbp+45A0h] BYREF
  _QWORD v1010[4]; // [rsp+46C0h] [rbp+45C0h] BYREF
  _QWORD v1011[4]; // [rsp+46E0h] [rbp+45E0h] BYREF
  _QWORD v1012[4]; // [rsp+4700h] [rbp+4600h] BYREF
  _QWORD v1013[4]; // [rsp+4720h] [rbp+4620h] BYREF
  _QWORD v1014[4]; // [rsp+4740h] [rbp+4640h] BYREF
  _QWORD v1015[4]; // [rsp+4760h] [rbp+4660h] BYREF
  _QWORD v1016[4]; // [rsp+4780h] [rbp+4680h] BYREF
  _QWORD v1017[4]; // [rsp+47A0h] [rbp+46A0h] BYREF
  _QWORD v1018[4]; // [rsp+47C0h] [rbp+46C0h] BYREF
  _QWORD v1019[4]; // [rsp+47E0h] [rbp+46E0h] BYREF
  _QWORD v1020[4]; // [rsp+4800h] [rbp+4700h] BYREF
  _QWORD v1021[4]; // [rsp+4820h] [rbp+4720h] BYREF
  _QWORD v1022[4]; // [rsp+4840h] [rbp+4740h] BYREF
  _QWORD v1023[4]; // [rsp+4860h] [rbp+4760h] BYREF
  _QWORD v1024[4]; // [rsp+4880h] [rbp+4780h] BYREF
  __int128 v1025; // [rsp+48A0h] [rbp+47A0h] BYREF
  int v1026; // [rsp+48B0h] [rbp+47B0h]
  __int128 v1027; // [rsp+48B4h] [rbp+47B4h]
  int v1028; // [rsp+48C4h] [rbp+47C4h]
  char v1029[32]; // [rsp+48C8h] [rbp+47C8h] BYREF
  __int64 v1030; // [rsp+48E8h] [rbp+47E8h]
  __int128 v1031; // [rsp+48F0h] [rbp+47F0h]
  int v1032; // [rsp+4900h] [rbp+4800h]
  __int128 v1033; // [rsp+4904h] [rbp+4804h]
  int v1034; // [rsp+4914h] [rbp+4814h]
  char v1035[32]; // [rsp+4918h] [rbp+4818h] BYREF
  __int64 v1036; // [rsp+4938h] [rbp+4838h]
  __int128 v1037; // [rsp+4940h] [rbp+4840h]
  int v1038; // [rsp+4950h] [rbp+4850h]
  __int128 v1039; // [rsp+4954h] [rbp+4854h]
  int v1040; // [rsp+4964h] [rbp+4864h]
  char v1041[32]; // [rsp+4968h] [rbp+4868h] BYREF
  __int64 v1042; // [rsp+4988h] [rbp+4888h]
  __int128 v1043; // [rsp+4990h] [rbp+4890h]
  int v1044; // [rsp+49A0h] [rbp+48A0h]
  __int128 v1045; // [rsp+49A4h] [rbp+48A4h]
  int v1046; // [rsp+49B4h] [rbp+48B4h]
  char v1047[32]; // [rsp+49B8h] [rbp+48B8h] BYREF
  __int64 v1048; // [rsp+49D8h] [rbp+48D8h]
  __int128 v1049; // [rsp+49E0h] [rbp+48E0h]
  int v1050; // [rsp+49F0h] [rbp+48F0h]
  __int128 v1051; // [rsp+49F4h] [rbp+48F4h]
  int v1052; // [rsp+4A04h] [rbp+4904h]
  char v1053[32]; // [rsp+4A08h] [rbp+4908h] BYREF
  __int64 v1054; // [rsp+4A28h] [rbp+4928h]
  __int128 v1055; // [rsp+4A30h] [rbp+4930h]
  int v1056; // [rsp+4A40h] [rbp+4940h]
  __int128 v1057; // [rsp+4A44h] [rbp+4944h]
  int v1058; // [rsp+4A54h] [rbp+4954h]
  char v1059[32]; // [rsp+4A58h] [rbp+4958h] BYREF
  __int64 v1060; // [rsp+4A78h] [rbp+4978h]
  __int128 v1061; // [rsp+4A80h] [rbp+4980h]
  int v1062; // [rsp+4A90h] [rbp+4990h]
  __int128 v1063; // [rsp+4A94h] [rbp+4994h]
  int v1064; // [rsp+4AA4h] [rbp+49A4h]
  char v1065[32]; // [rsp+4AA8h] [rbp+49A8h] BYREF
  __int64 v1066; // [rsp+4AC8h] [rbp+49C8h]
  __int128 v1067; // [rsp+4AD0h] [rbp+49D0h]
  int v1068; // [rsp+4AE0h] [rbp+49E0h]
  __int128 v1069; // [rsp+4AE4h] [rbp+49E4h]
  int v1070; // [rsp+4AF4h] [rbp+49F4h]
  char v1071[32]; // [rsp+4AF8h] [rbp+49F8h] BYREF
  __int64 v1072; // [rsp+4B18h] [rbp+4A18h]
  __int128 v1073; // [rsp+4B20h] [rbp+4A20h] BYREF
  int v1074; // [rsp+4B30h] [rbp+4A30h]
  __int128 v1075; // [rsp+4B34h] [rbp+4A34h]
  int v1076; // [rsp+4B44h] [rbp+4A44h]
  char v1077[32]; // [rsp+4B48h] [rbp+4A48h] BYREF
  __int64 v1078; // [rsp+4B68h] [rbp+4A68h]
  __int128 v1079; // [rsp+4B70h] [rbp+4A70h]
  int v1080; // [rsp+4B80h] [rbp+4A80h]
  __int128 v1081; // [rsp+4B84h] [rbp+4A84h]
  int v1082; // [rsp+4B94h] [rbp+4A94h]
  char v1083[32]; // [rsp+4B98h] [rbp+4A98h] BYREF
  __int64 v1084; // [rsp+4BB8h] [rbp+4AB8h]
  __int128 v1085; // [rsp+4BC0h] [rbp+4AC0h]
  int v1086; // [rsp+4BD0h] [rbp+4AD0h]
  __int128 v1087; // [rsp+4BD4h] [rbp+4AD4h]
  int v1088; // [rsp+4BE4h] [rbp+4AE4h]
  char v1089[32]; // [rsp+4BE8h] [rbp+4AE8h] BYREF
  __int64 v1090; // [rsp+4C08h] [rbp+4B08h]
  __int128 v1091; // [rsp+4C10h] [rbp+4B10h]
  int v1092; // [rsp+4C20h] [rbp+4B20h]
  __int128 v1093; // [rsp+4C24h] [rbp+4B24h]
  int v1094; // [rsp+4C34h] [rbp+4B34h]
  char v1095[32]; // [rsp+4C38h] [rbp+4B38h] BYREF
  __int64 v1096; // [rsp+4C58h] [rbp+4B58h]
  __int128 v1097; // [rsp+4C60h] [rbp+4B60h]
  int v1098; // [rsp+4C70h] [rbp+4B70h]
  __int128 v1099; // [rsp+4C74h] [rbp+4B74h]
  int v1100; // [rsp+4C84h] [rbp+4B84h]
  char v1101[32]; // [rsp+4C88h] [rbp+4B88h] BYREF
  __int64 v1102; // [rsp+4CA8h] [rbp+4BA8h]
  __int128 v1103; // [rsp+4CB0h] [rbp+4BB0h]
  int v1104; // [rsp+4CC0h] [rbp+4BC0h]
  __int128 v1105; // [rsp+4CC4h] [rbp+4BC4h]
  int v1106; // [rsp+4CD4h] [rbp+4BD4h]
  char v1107[32]; // [rsp+4CD8h] [rbp+4BD8h] BYREF
  __int64 v1108; // [rsp+4CF8h] [rbp+4BF8h]
  __int128 v1109; // [rsp+4D00h] [rbp+4C00h]
  int v1110; // [rsp+4D10h] [rbp+4C10h]
  __int128 v1111; // [rsp+4D14h] [rbp+4C14h]
  int v1112; // [rsp+4D24h] [rbp+4C24h]
  char v1113[32]; // [rsp+4D28h] [rbp+4C28h] BYREF
  __int64 v1114; // [rsp+4D48h] [rbp+4C48h]
  __int128 v1115; // [rsp+4D50h] [rbp+4C50h]
  int v1116; // [rsp+4D60h] [rbp+4C60h]
  __int128 v1117; // [rsp+4D64h] [rbp+4C64h]
  int v1118; // [rsp+4D74h] [rbp+4C74h]
  char v1119[32]; // [rsp+4D78h] [rbp+4C78h] BYREF
  __int64 v1120; // [rsp+4D98h] [rbp+4C98h]
  __int128 v1121; // [rsp+4DA0h] [rbp+4CA0h]
  int v1122; // [rsp+4DB0h] [rbp+4CB0h]
  __int128 v1123; // [rsp+4DB4h] [rbp+4CB4h]
  int v1124; // [rsp+4DC4h] [rbp+4CC4h]
  char v1125[32]; // [rsp+4DC8h] [rbp+4CC8h] BYREF
  __int64 v1126; // [rsp+4DE8h] [rbp+4CE8h]
  __int128 v1127; // [rsp+4DF0h] [rbp+4CF0h]
  int v1128; // [rsp+4E00h] [rbp+4D00h]
  __int128 v1129; // [rsp+4E04h] [rbp+4D04h]
  int v1130; // [rsp+4E14h] [rbp+4D14h]
  char v1131[32]; // [rsp+4E18h] [rbp+4D18h] BYREF
  __int64 v1132; // [rsp+4E38h] [rbp+4D38h]
  __int128 v1133; // [rsp+4E40h] [rbp+4D40h]
  int v1134; // [rsp+4E50h] [rbp+4D50h]
  __int128 v1135; // [rsp+4E54h] [rbp+4D54h]
  int v1136; // [rsp+4E64h] [rbp+4D64h]
  char v1137[32]; // [rsp+4E68h] [rbp+4D68h] BYREF
  __int64 v1138; // [rsp+4E88h] [rbp+4D88h]
  __int128 v1139; // [rsp+4E90h] [rbp+4D90h]
  int v1140; // [rsp+4EA0h] [rbp+4DA0h]
  __int128 v1141; // [rsp+4EA4h] [rbp+4DA4h]
  int v1142; // [rsp+4EB4h] [rbp+4DB4h]
  char v1143[32]; // [rsp+4EB8h] [rbp+4DB8h] BYREF
  __int64 v1144; // [rsp+4ED8h] [rbp+4DD8h]
  __int128 v1145; // [rsp+4EE0h] [rbp+4DE0h]
  int v1146; // [rsp+4EF0h] [rbp+4DF0h]
  __int128 v1147; // [rsp+4EF4h] [rbp+4DF4h]
  int v1148; // [rsp+4F04h] [rbp+4E04h]
  char v1149[32]; // [rsp+4F08h] [rbp+4E08h] BYREF
  __int64 v1150; // [rsp+4F28h] [rbp+4E28h]
  int v1151; // [rsp+4F30h] [rbp+4E30h] BYREF
  __int64 v1152; // [rsp+4F38h] [rbp+4E38h] BYREF
  char v1153[24]; // [rsp+4F48h] [rbp+4E48h] BYREF
  char v1154[24]; // [rsp+4F60h] [rbp+4E60h] BYREF
  char v1155[24]; // [rsp+4F78h] [rbp+4E78h] BYREF
  char v1156[24]; // [rsp+4F90h] [rbp+4E90h] BYREF
  char v1157[24]; // [rsp+4FA8h] [rbp+4EA8h] BYREF
  char v1158[24]; // [rsp+4FC0h] [rbp+4EC0h] BYREF
  char v1159[24]; // [rsp+4FD8h] [rbp+4ED8h] BYREF
  char v1160[24]; // [rsp+4FF0h] [rbp+4EF0h] BYREF
  char v1161[24]; // [rsp+5008h] [rbp+4F08h] BYREF
  char v1162[16]; // [rsp+5020h] [rbp+4F20h] BYREF
  char v1163[24]; // [rsp+5038h] [rbp+4F38h] BYREF
  char v1164[24]; // [rsp+5050h] [rbp+4F50h] BYREF
  char v1165[24]; // [rsp+5068h] [rbp+4F68h] BYREF
  _QWORD v1166[16]; // [rsp+5080h] [rbp+4F80h] BYREF
  _QWORD v1167[16]; // [rsp+5100h] [rbp+5000h] BYREF
  _QWORD v1168[16]; // [rsp+5180h] [rbp+5080h] BYREF
  _QWORD v1169[16]; // [rsp+5200h] [rbp+5100h] BYREF
  _QWORD v1170[16]; // [rsp+5280h] [rbp+5180h] BYREF
  _QWORD v1171[16]; // [rsp+5300h] [rbp+5200h] BYREF
  _QWORD v1172[16]; // [rsp+5380h] [rbp+5280h] BYREF
  _QWORD v1173[16]; // [rsp+5400h] [rbp+5300h] BYREF
  _QWORD v1174[16]; // [rsp+5480h] [rbp+5380h] BYREF
  _QWORD v1175[16]; // [rsp+5500h] [rbp+5400h] BYREF
  _QWORD v1176[16]; // [rsp+5580h] [rbp+5480h] BYREF
  _QWORD v1177[16]; // [rsp+5600h] [rbp+5500h] BYREF
  _QWORD v1178[16]; // [rsp+5680h] [rbp+5580h] BYREF
  _QWORD v1179[16]; // [rsp+5700h] [rbp+5600h] BYREF
  _QWORD v1180[16]; // [rsp+5780h] [rbp+5680h] BYREF
  _QWORD v1181[16]; // [rsp+5800h] [rbp+5700h] BYREF
  _QWORD v1182[16]; // [rsp+5880h] [rbp+5780h] BYREF
  _QWORD v1183[16]; // [rsp+5900h] [rbp+5800h] BYREF
  _QWORD v1184[16]; // [rsp+5980h] [rbp+5880h] BYREF
  _QWORD v1185[16]; // [rsp+5A00h] [rbp+5900h] BYREF
  _QWORD v1186[16]; // [rsp+5A80h] [rbp+5980h] BYREF
  _QWORD v1187[16]; // [rsp+5B00h] [rbp+5A00h] BYREF
  _QWORD v1188[16]; // [rsp+5B80h] [rbp+5A80h] BYREF
  _QWORD v1189[16]; // [rsp+5C00h] [rbp+5B00h] BYREF
  _QWORD v1190[16]; // [rsp+5C80h] [rbp+5B80h] BYREF
  _QWORD v1191[16]; // [rsp+5D00h] [rbp+5C00h] BYREF
  _QWORD v1192[16]; // [rsp+5D80h] [rbp+5C80h] BYREF
  _QWORD v1193[16]; // [rsp+5E00h] [rbp+5D00h] BYREF
  _QWORD v1194[16]; // [rsp+5E80h] [rbp+5D80h] BYREF
  _QWORD v1195[16]; // [rsp+5F00h] [rbp+5E00h] BYREF
  _QWORD v1196[16]; // [rsp+5F80h] [rbp+5E80h] BYREF
  _QWORD v1197[16]; // [rsp+6000h] [rbp+5F00h] BYREF
  _QWORD v1198[16]; // [rsp+6080h] [rbp+5F80h] BYREF
  __int128 v1199; // [rsp+6100h] [rbp+6000h] BYREF
  int v1200; // [rsp+6110h] [rbp+6010h]
  __int128 v1201; // [rsp+6114h] [rbp+6014h]
  int v1202; // [rsp+6124h] [rbp+6024h]
  char v1203[32]; // [rsp+6128h] [rbp+6028h] BYREF
  __int64 v1204; // [rsp+6148h] [rbp+6048h]
  char v1205[80]; // [rsp+6150h] [rbp+6050h] BYREF
  char v1206[80]; // [rsp+61A0h] [rbp+60A0h] BYREF
  char v1207[16]; // [rsp+61F0h] [rbp+60F0h] BYREF
  char v1208[80]; // [rsp+6240h] [rbp+6140h] BYREF
  char v1209[80]; // [rsp+6290h] [rbp+6190h] BYREF
  char v1210[80]; // [rsp+62E0h] [rbp+61E0h] BYREF
  char v1211[80]; // [rsp+6330h] [rbp+6230h] BYREF
  char v1212[80]; // [rsp+6380h] [rbp+6280h] BYREF
  char v1213[80]; // [rsp+63D0h] [rbp+62D0h] BYREF
  char v1214[80]; // [rsp+6420h] [rbp+6320h] BYREF
  char v1215[80]; // [rsp+6470h] [rbp+6370h] BYREF
  char v1216[80]; // [rsp+64C0h] [rbp+63C0h] BYREF
  char v1217[32]; // [rsp+6510h] [rbp+6410h] BYREF
  __int64 v1218[15]; // [rsp+6530h] [rbp+6430h] BYREF
  char v1219[32]; // [rsp+65A8h] [rbp+64A8h] BYREF
  __int64 v1220[9]; // [rsp+65C8h] [rbp+64C8h] BYREF
  char v1221[32]; // [rsp+6640h] [rbp+6540h] BYREF
  __int64 v1222[15]; // [rsp+6660h] [rbp+6560h] BYREF
  char v1223; // [rsp+66D8h] [rbp+65D8h] BYREF
  char v1224[80]; // [rsp+66E0h] [rbp+65E0h] BYREF
  char v1225[80]; // [rsp+6730h] [rbp+6630h] BYREF
  char v1226[80]; // [rsp+6780h] [rbp+6680h] BYREF
  char v1227[16]; // [rsp+67D0h] [rbp+66D0h] BYREF
  char v1228[80]; // [rsp+6820h] [rbp+6720h] BYREF
  char v1229[80]; // [rsp+6870h] [rbp+6770h] BYREF
  char v1230[80]; // [rsp+68C0h] [rbp+67C0h] BYREF
  char v1231[80]; // [rsp+6910h] [rbp+6810h] BYREF
  char v1232[80]; // [rsp+6960h] [rbp+6860h] BYREF
  char v1233[80]; // [rsp+69B0h] [rbp+68B0h] BYREF
  char v1234[80]; // [rsp+6A00h] [rbp+6900h] BYREF
  char v1235[16]; // [rsp+6A50h] [rbp+6950h] BYREF
  char v1236[80]; // [rsp+6AA0h] [rbp+69A0h] BYREF
  char v1237[80]; // [rsp+6AF0h] [rbp+69F0h] BYREF
  char v1238[80]; // [rsp+6B40h] [rbp+6A40h] BYREF
  char v1239[80]; // [rsp+6B90h] [rbp+6A90h] BYREF
  char v1240[80]; // [rsp+6BE0h] [rbp+6AE0h] BYREF
  char v1241[80]; // [rsp+6C30h] [rbp+6B30h] BYREF
  char v1242[80]; // [rsp+6C80h] [rbp+6B80h] BYREF
  char v1243[16]; // [rsp+6CD0h] [rbp+6BD0h] BYREF
  char v1244[80]; // [rsp+6D20h] [rbp+6C20h] BYREF
  char v1245[80]; // [rsp+6D70h] [rbp+6C70h] BYREF
  char v1246[80]; // [rsp+6DC0h] [rbp+6CC0h] BYREF
  char v1247[80]; // [rsp+6E10h] [rbp+6D10h] BYREF
  char v1248[80]; // [rsp+6E60h] [rbp+6D60h] BYREF
  char v1249[80]; // [rsp+6EB0h] [rbp+6DB0h] BYREF
  char v1250[80]; // [rsp+6F00h] [rbp+6E00h] BYREF
  char v1251[16]; // [rsp+6F50h] [rbp+6E50h] BYREF
  char v1252[80]; // [rsp+6FA0h] [rbp+6EA0h] BYREF
  char v1253[80]; // [rsp+6FF0h] [rbp+6EF0h] BYREF
  char v1254[80]; // [rsp+7040h] [rbp+6F40h] BYREF
  char v1255[80]; // [rsp+7090h] [rbp+6F90h] BYREF
  char v1256[80]; // [rsp+70E0h] [rbp+6FE0h] BYREF
  char v1257[80]; // [rsp+7130h] [rbp+7030h] BYREF
  char v1258[80]; // [rsp+7180h] [rbp+7080h] BYREF
  char v1259[16]; // [rsp+71D0h] [rbp+70D0h] BYREF
  char v1260[80]; // [rsp+7220h] [rbp+7120h] BYREF
  char v1261[80]; // [rsp+7270h] [rbp+7170h] BYREF
  char v1262[80]; // [rsp+72C0h] [rbp+71C0h] BYREF
  char v1263[80]; // [rsp+7310h] [rbp+7210h] BYREF
  char v1264[80]; // [rsp+7360h] [rbp+7260h] BYREF
  char v1265[80]; // [rsp+73B0h] [rbp+72B0h] BYREF
  char v1266[80]; // [rsp+7400h] [rbp+7300h] BYREF
  char v1267[16]; // [rsp+7450h] [rbp+7350h] BYREF
  char v1268[80]; // [rsp+74A0h] [rbp+73A0h] BYREF
  char v1269[80]; // [rsp+74F0h] [rbp+73F0h] BYREF
  char v1270[80]; // [rsp+7540h] [rbp+7440h] BYREF
  char v1271[80]; // [rsp+7590h] [rbp+7490h] BYREF
  char v1272[80]; // [rsp+75E0h] [rbp+74E0h] BYREF
  char v1273[80]; // [rsp+7630h] [rbp+7530h] BYREF
  char v1274[80]; // [rsp+7680h] [rbp+7580h] BYREF
  char v1275[16]; // [rsp+76D0h] [rbp+75D0h] BYREF
  char v1276[80]; // [rsp+7720h] [rbp+7620h] BYREF
  char v1277[80]; // [rsp+7770h] [rbp+7670h] BYREF
  char v1278[80]; // [rsp+77C0h] [rbp+76C0h] BYREF
  char v1279[80]; // [rsp+7810h] [rbp+7710h] BYREF
  char v1280[80]; // [rsp+7860h] [rbp+7760h] BYREF
  char v1281[80]; // [rsp+78B0h] [rbp+77B0h] BYREF
  char v1282[80]; // [rsp+7900h] [rbp+7800h] BYREF
  char v1283[16]; // [rsp+7950h] [rbp+7850h] BYREF
  char v1284[80]; // [rsp+79A0h] [rbp+78A0h] BYREF
  char v1285[80]; // [rsp+79F0h] [rbp+78F0h] BYREF
  char v1286[80]; // [rsp+7A40h] [rbp+7940h] BYREF
  char v1287[80]; // [rsp+7A90h] [rbp+7990h] BYREF
  char v1288[152]; // [rsp+7AE0h] [rbp+79E0h] BYREF
  char v1289[104]; // [rsp+7B78h] [rbp+7A78h] BYREF
  char v1290[152]; // [rsp+7C10h] [rbp+7B10h] BYREF
  char v1291[104]; // [rsp+7CA8h] [rbp+7BA8h] BYREF
  char v1292[152]; // [rsp+7D40h] [rbp+7C40h] BYREF
  char v1293[104]; // [rsp+7DD8h] [rbp+7CD8h] BYREF
  char v1294[152]; // [rsp+7E70h] [rbp+7D70h] BYREF
  char v1295[104]; // [rsp+7F08h] [rbp+7E08h] BYREF
  char v1296[152]; // [rsp+7FA0h] [rbp+7EA0h] BYREF
  char v1297[104]; // [rsp+8038h] [rbp+7F38h] BYREF
  char v1298[32]; // [rsp+80D0h] [rbp+7FD0h] BYREF
  __int64 v1299[15]; // [rsp+80F0h] [rbp+7FF0h] BYREF
  char v1300[104]; // [rsp+8168h] [rbp+8068h] BYREF
  char v1301[152]; // [rsp+8200h] [rbp+8100h] BYREF
  char v1302; // [rsp+8298h] [rbp+8198h] BYREF
  char v1303[80]; // [rsp+82A0h] [rbp+81A0h] BYREF
  char v1304[80]; // [rsp+82F0h] [rbp+81F0h] BYREF
  char v1305[80]; // [rsp+8340h] [rbp+8240h] BYREF
  char v1306[16]; // [rsp+8390h] [rbp+8290h] BYREF
  char v1307[80]; // [rsp+83E0h] [rbp+82E0h] BYREF
  char v1308[80]; // [rsp+8430h] [rbp+8330h] BYREF
  char v1309[80]; // [rsp+8480h] [rbp+8380h] BYREF
  char v1310[80]; // [rsp+84D0h] [rbp+83D0h] BYREF
  char v1311[80]; // [rsp+8520h] [rbp+8420h] BYREF
  char v1312[80]; // [rsp+8570h] [rbp+8470h] BYREF
  char v1313[80]; // [rsp+85C0h] [rbp+84C0h] BYREF
  char v1314[80]; // [rsp+8610h] [rbp+8510h] BYREF
  char v1315[80]; // [rsp+8660h] [rbp+8560h] BYREF
  char v1316[80]; // [rsp+86B0h] [rbp+85B0h] BYREF
  char v1317[80]; // [rsp+8700h] [rbp+8600h] BYREF
  char v1318[16]; // [rsp+8750h] [rbp+8650h] BYREF
  char v1319[80]; // [rsp+87A0h] [rbp+86A0h] BYREF
  char v1320[80]; // [rsp+87F0h] [rbp+86F0h] BYREF
  char v1321[80]; // [rsp+8840h] [rbp+8740h] BYREF
  char v1322[80]; // [rsp+8890h] [rbp+8790h] BYREF
  char v1323[80]; // [rsp+88E0h] [rbp+87E0h] BYREF
  char v1324[80]; // [rsp+8930h] [rbp+8830h] BYREF
  char v1325[80]; // [rsp+8980h] [rbp+8880h] BYREF
  char v1326[80]; // [rsp+89D0h] [rbp+88D0h] BYREF
  char v1327[80]; // [rsp+8A20h] [rbp+8920h] BYREF
  char v1328[80]; // [rsp+8A70h] [rbp+8970h] BYREF
  char v1329[80]; // [rsp+8AC0h] [rbp+89C0h] BYREF
  char v1330[16]; // [rsp+8B10h] [rbp+8A10h] BYREF
  char v1331[80]; // [rsp+8B60h] [rbp+8A60h] BYREF
  char v1332[80]; // [rsp+8BB0h] [rbp+8AB0h] BYREF
  char v1333[80]; // [rsp+8C00h] [rbp+8B00h] BYREF
  char v1334[80]; // [rsp+8C50h] [rbp+8B50h] BYREF
  char v1335[80]; // [rsp+8CA0h] [rbp+8BA0h] BYREF
  char v1336[80]; // [rsp+8CF0h] [rbp+8BF0h] BYREF
  char v1337[80]; // [rsp+8D40h] [rbp+8C40h] BYREF
  char v1338[80]; // [rsp+8D90h] [rbp+8C90h] BYREF
  char v1339[80]; // [rsp+8DE0h] [rbp+8CE0h] BYREF
  char v1340[80]; // [rsp+8E30h] [rbp+8D30h] BYREF
  char v1341[80]; // [rsp+8E80h] [rbp+8D80h] BYREF
  char v1342[80]; // [rsp+8ED0h] [rbp+8DD0h] BYREF
  char v1343[16]; // [rsp+8F20h] [rbp+8E20h] BYREF
  char v1344[80]; // [rsp+8F70h] [rbp+8E70h] BYREF
  char v1345[80]; // [rsp+8FC0h] [rbp+8EC0h] BYREF
  char v1346[80]; // [rsp+9010h] [rbp+8F10h] BYREF
  char v1347[80]; // [rsp+9060h] [rbp+8F60h] BYREF
  char v1348[80]; // [rsp+90B0h] [rbp+8FB0h] BYREF
  char v1349[80]; // [rsp+9100h] [rbp+9000h] BYREF
  char v1350[80]; // [rsp+9150h] [rbp+9050h] BYREF
  char v1351[80]; // [rsp+91A0h] [rbp+90A0h] BYREF
  char v1352[80]; // [rsp+91F0h] [rbp+90F0h] BYREF
  char v1353[80]; // [rsp+9240h] [rbp+9140h] BYREF
  char v1354[80]; // [rsp+9290h] [rbp+9190h] BYREF
  char v1355[80]; // [rsp+92E0h] [rbp+91E0h] BYREF
  char v1356[16]; // [rsp+9330h] [rbp+9230h] BYREF
  char v1357[80]; // [rsp+9380h] [rbp+9280h] BYREF
  char v1358[80]; // [rsp+93D0h] [rbp+92D0h] BYREF
  char v1359[80]; // [rsp+9420h] [rbp+9320h] BYREF
  char v1360[80]; // [rsp+9470h] [rbp+9370h] BYREF
  char v1361[80]; // [rsp+94C0h] [rbp+93C0h] BYREF
  char v1362[80]; // [rsp+9510h] [rbp+9410h] BYREF
  char v1363[80]; // [rsp+9560h] [rbp+9460h] BYREF
  char v1364[80]; // [rsp+95B0h] [rbp+94B0h] BYREF
  char v1365[80]; // [rsp+9600h] [rbp+9500h] BYREF
  char v1366[80]; // [rsp+9650h] [rbp+9550h] BYREF
  char v1367[80]; // [rsp+96A0h] [rbp+95A0h] BYREF
  char v1368[80]; // [rsp+96F0h] [rbp+95F0h] BYREF
  char v1369[16]; // [rsp+9740h] [rbp+9640h] BYREF
  char v1370[80]; // [rsp+9790h] [rbp+9690h] BYREF
  char v1371[80]; // [rsp+97E0h] [rbp+96E0h] BYREF
  char v1372[80]; // [rsp+9830h] [rbp+9730h] BYREF
  char v1373[80]; // [rsp+9880h] [rbp+9780h] BYREF
  char v1374[80]; // [rsp+98D0h] [rbp+97D0h] BYREF
  char v1375[80]; // [rsp+9920h] [rbp+9820h] BYREF
  char v1376[80]; // [rsp+9970h] [rbp+9870h] BYREF
  char v1377[80]; // [rsp+99C0h] [rbp+98C0h] BYREF
  char v1378[80]; // [rsp+9A10h] [rbp+9910h] BYREF
  char v1379[80]; // [rsp+9A60h] [rbp+9960h] BYREF
  char v1380[80]; // [rsp+9AB0h] [rbp+99B0h] BYREF
  char v1381[80]; // [rsp+9B00h] [rbp+9A00h] BYREF
  char v1382[16]; // [rsp+9B50h] [rbp+9A50h] BYREF
  char v1383[80]; // [rsp+9BA0h] [rbp+9AA0h] BYREF
  char v1384[80]; // [rsp+9BF0h] [rbp+9AF0h] BYREF
  char v1385[80]; // [rsp+9C40h] [rbp+9B40h] BYREF
  char v1386[80]; // [rsp+9C90h] [rbp+9B90h] BYREF
  char v1387[80]; // [rsp+9CE0h] [rbp+9BE0h] BYREF
  char v1388[80]; // [rsp+9D30h] [rbp+9C30h] BYREF
  char v1389[80]; // [rsp+9D80h] [rbp+9C80h] BYREF
  char v1390[80]; // [rsp+9DD0h] [rbp+9CD0h] BYREF
  char v1391[80]; // [rsp+9E20h] [rbp+9D20h] BYREF
  char v1392[80]; // [rsp+9E70h] [rbp+9D70h] BYREF
  char v1393[80]; // [rsp+9EC0h] [rbp+9DC0h] BYREF
  char v1394[80]; // [rsp+9F10h] [rbp+9E10h] BYREF
  char v1395[16]; // [rsp+9F60h] [rbp+9E60h] BYREF
  char v1396[80]; // [rsp+9FB0h] [rbp+9EB0h] BYREF
  char v1397[80]; // [rsp+A000h] [rbp+9F00h] BYREF
  char v1398[80]; // [rsp+A050h] [rbp+9F50h] BYREF
  char v1399[80]; // [rsp+A0A0h] [rbp+9FA0h] BYREF
  char v1400[80]; // [rsp+A0F0h] [rbp+9FF0h] BYREF
  char v1401[80]; // [rsp+A140h] [rbp+A040h] BYREF
  char v1402[80]; // [rsp+A190h] [rbp+A090h] BYREF
  char v1403[80]; // [rsp+A1E0h] [rbp+A0E0h] BYREF
  char v1404[80]; // [rsp+A230h] [rbp+A130h] BYREF
  char v1405[80]; // [rsp+A280h] [rbp+A180h] BYREF
  char v1406[80]; // [rsp+A2D0h] [rbp+A1D0h] BYREF
  char v1407[80]; // [rsp+A320h] [rbp+A220h] BYREF
  char v1408[16]; // [rsp+A370h] [rbp+A270h] BYREF
  char v1409[80]; // [rsp+A3C0h] [rbp+A2C0h] BYREF
  char v1410[80]; // [rsp+A410h] [rbp+A310h] BYREF
  char v1411[80]; // [rsp+A460h] [rbp+A360h] BYREF
  char v1412[80]; // [rsp+A4B0h] [rbp+A3B0h] BYREF
  char v1413[80]; // [rsp+A500h] [rbp+A400h] BYREF
  char v1414[80]; // [rsp+A550h] [rbp+A450h] BYREF
  char v1415[80]; // [rsp+A5A0h] [rbp+A4A0h] BYREF
  char v1416[80]; // [rsp+A5F0h] [rbp+A4F0h] BYREF
  char v1417[80]; // [rsp+A640h] [rbp+A540h] BYREF
  char v1418[80]; // [rsp+A690h] [rbp+A590h] BYREF
  char v1419[80]; // [rsp+A6E0h] [rbp+A5E0h] BYREF
  char v1420[80]; // [rsp+A730h] [rbp+A630h] BYREF
  char v1421[16]; // [rsp+A780h] [rbp+A680h] BYREF
  char v1422[80]; // [rsp+A7D0h] [rbp+A6D0h] BYREF
  char v1423[80]; // [rsp+A820h] [rbp+A720h] BYREF
  char v1424[80]; // [rsp+A870h] [rbp+A770h] BYREF
  char v1425[80]; // [rsp+A8C0h] [rbp+A7C0h] BYREF
  char v1426[80]; // [rsp+A910h] [rbp+A810h] BYREF
  char v1427[80]; // [rsp+A960h] [rbp+A860h] BYREF
  char v1428[80]; // [rsp+A9B0h] [rbp+A8B0h] BYREF
  char v1429[80]; // [rsp+AA00h] [rbp+A900h] BYREF
  char v1430[80]; // [rsp+AA50h] [rbp+A950h] BYREF
  char v1431[80]; // [rsp+AAA0h] [rbp+A9A0h] BYREF
  char v1432[80]; // [rsp+AAF0h] [rbp+A9F0h] BYREF
  char v1433[80]; // [rsp+AB40h] [rbp+AA40h] BYREF
  char v1434[16]; // [rsp+AB90h] [rbp+AA90h] BYREF
  char v1435[80]; // [rsp+ABE0h] [rbp+AAE0h] BYREF
  char v1436[80]; // [rsp+AC30h] [rbp+AB30h] BYREF
  char v1437[80]; // [rsp+AC80h] [rbp+AB80h] BYREF
  char v1438[80]; // [rsp+ACD0h] [rbp+ABD0h] BYREF
  char v1439[80]; // [rsp+AD20h] [rbp+AC20h] BYREF
  char v1440[80]; // [rsp+AD70h] [rbp+AC70h] BYREF
  char v1441[80]; // [rsp+ADC0h] [rbp+ACC0h] BYREF
  char v1442[80]; // [rsp+AE10h] [rbp+AD10h] BYREF
  char v1443[80]; // [rsp+AE60h] [rbp+AD60h] BYREF
  char v1444[80]; // [rsp+AEB0h] [rbp+ADB0h] BYREF
  char v1445[80]; // [rsp+AF00h] [rbp+AE00h] BYREF
  char v1446[80]; // [rsp+AF50h] [rbp+AE50h] BYREF
  char v1447[16]; // [rsp+AFA0h] [rbp+AEA0h] BYREF
  char v1448[80]; // [rsp+AFF0h] [rbp+AEF0h] BYREF
  char v1449[80]; // [rsp+B040h] [rbp+AF40h] BYREF
  char v1450[80]; // [rsp+B090h] [rbp+AF90h] BYREF
  char v1451[80]; // [rsp+B0E0h] [rbp+AFE0h] BYREF
  char v1452[80]; // [rsp+B130h] [rbp+B030h] BYREF
  char v1453[80]; // [rsp+B180h] [rbp+B080h] BYREF
  char v1454[80]; // [rsp+B1D0h] [rbp+B0D0h] BYREF
  char v1455[80]; // [rsp+B220h] [rbp+B120h] BYREF
  char v1456[80]; // [rsp+B270h] [rbp+B170h] BYREF
  char v1457[152]; // [rsp+B2C0h] [rbp+B1C0h] BYREF
  char v1458[104]; // [rsp+B358h] [rbp+B258h] BYREF
  char v1459[152]; // [rsp+B3F0h] [rbp+B2F0h] BYREF
  char v1460; // [rsp+B488h] [rbp+B388h] BYREF
  char v1461[152]; // [rsp+B490h] [rbp+B390h] BYREF
  char v1462[104]; // [rsp+B528h] [rbp+B428h] BYREF
  char v1463[152]; // [rsp+B5C0h] [rbp+B4C0h] BYREF
  char v1464; // [rsp+B658h] [rbp+B558h] BYREF
  char v1465[152]; // [rsp+B660h] [rbp+B560h] BYREF
  char v1466[104]; // [rsp+B6F8h] [rbp+B5F8h] BYREF
  char v1467[152]; // [rsp+B790h] [rbp+B690h] BYREF
  char v1468; // [rsp+B828h] [rbp+B728h] BYREF
  char v1469[152]; // [rsp+B830h] [rbp+B730h] BYREF
  char v1470[104]; // [rsp+B8C8h] [rbp+B7C8h] BYREF
  char v1471[152]; // [rsp+B960h] [rbp+B860h] BYREF
  char v1472; // [rsp+B9F8h] [rbp+B8F8h] BYREF
  char v1473[152]; // [rsp+BA00h] [rbp+B900h] BYREF
  char v1474[104]; // [rsp+BA98h] [rbp+B998h] BYREF
  char v1475[152]; // [rsp+BB30h] [rbp+BA30h] BYREF
  char v1476; // [rsp+BBC8h] [rbp+BAC8h] BYREF
  char v1477[152]; // [rsp+BBD0h] [rbp+BAD0h] BYREF
  char v1478[104]; // [rsp+BC68h] [rbp+BB68h] BYREF
  char v1479[152]; // [rsp+BD00h] [rbp+BC00h] BYREF
  char v1480; // [rsp+BD98h] [rbp+BC98h] BYREF
  char v1481[152]; // [rsp+BDA0h] [rbp+BCA0h] BYREF
  char v1482[104]; // [rsp+BE38h] [rbp+BD38h] BYREF
  char v1483[152]; // [rsp+BED0h] [rbp+BDD0h] BYREF
  char v1484; // [rsp+BF68h] [rbp+BE68h] BYREF

  v177[2] = (void *)-2i64;
  v734 = "GTA5.exe";
  v735 = 0i64;
  v736 = 0i64;
  v0 = sub_14615A5E0(8ui64);
  v735 = v0;
  *((_QWORD *)&v736 + 1) = v0 + 1;
  *v0 = "360198195282249ed7a4f8504d3b509457b06c6c";
  *(_QWORD *)&v736 = v0 + 1;
  v737 = "https://content.cfx.re/mirrors/patches_fivem/3407/GTA5.exe";
  v738 = 0i64;
  v739 = 54341608i64;
  v740 = 54341608i64;
  v138 = 0i64;
  sub_146178CB0(v741, (__int64 *)&v138, (__int64)&v140);
  v742 = 0i64;
  v743 = 0i64;
  v744 = 7i64;
  LOWORD(v742) = 0;
  *((_QWORD *)&v733[0] + 1) = 0i64;
  v733[1] = (__int128)_mm_load_si128((const __m128i *)&xmmword_14612A920);
  strcpy((char *)v733, "GTA5.exe");
  sub_146170E60((__int64)v1217, (__int64)v733, v1, v2);
  sub_146178F20(v1218, &v734, v3);
  v731 = 0i64;
  v732 = 0i64;
  *(_QWORD *)&v731 = sub_14615A5E0(0x60ui64);
  si128 = _mm_load_si128((const __m128i *)&xmmword_14612A950);
  v732 = si128;
  strcpy((char *)v731, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_1604_to_3407.update.rpf.hdiff");
  *(_QWORD *)&v138 = "fc941d698834e30e40a06a40f6a35b1b18e1c50c";
  *((_QWORD *)&v138 + 1) = 40i64;
  v5 = sub_146176D40((__int64)v638, &v138);
  v1073 = *(_OWORD *)v5;
  v1074 = *(_DWORD *)(v5 + 16);
  *(_QWORD *)&v138 = "f6cdcdec5e3e993a31f45acc96b638283c474f53";
  *((_QWORD *)&v138 + 1) = 40i64;
  v6 = sub_146176D40((__int64)v639, &v138);
  v1075 = *(_OWORD *)v6;
  v1076 = *(_DWORD *)(v6 + 16);
  sub_146170E60((__int64)v1077, (__int64)&v731, v7, v8);
  v1078 = 942349219i64;
  v729 = 0i64;
  v730 = 0i64;
  *(_QWORD *)&v729 = sub_14615A5E0(0x60ui64);
  v730 = si128;
  strcpy((char *)v729, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_2060_to_3407.update.rpf.hdiff");
  *(_QWORD *)&v138 = "736f1cb26e59167f302c22385463d231cce302d3";
  *((_QWORD *)&v138 + 1) = 40i64;
  v9 = sub_146176D40((__int64)v640, &v138);
  v1079 = *(_OWORD *)v9;
  v1080 = *(_DWORD *)(v9 + 16);
  *(_QWORD *)&v138 = "f6cdcdec5e3e993a31f45acc96b638283c474f53";
  *((_QWORD *)&v138 + 1) = 40i64;
  v10 = sub_146176D40((__int64)v641, &v138);
  v1081 = *(_OWORD *)v10;
  v1082 = *(_DWORD *)(v10 + 16);
  sub_146170E60((__int64)v1083, (__int64)&v729, v11, v12);
  v1084 = 714530091i64;
  v727 = 0i64;
  v728 = 0i64;
  *(_QWORD *)&v727 = sub_14615A5E0(0x60ui64);
  v728 = si128;
  strcpy((char *)v727, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_2189_to_3407.update.rpf.hdiff");
  *(_QWORD *)&v138 = "fe387dbc0f700d690b53d44ce1226c624c24b8fc";
  *((_QWORD *)&v138 + 1) = 40i64;
  v13 = sub_146176D40((__int64)v642, &v138);
  v1085 = *(_OWORD *)v13;
  v1086 = *(_DWORD *)(v13 + 16);
  *(_QWORD *)&v138 = "f6cdcdec5e3e993a31f45acc96b638283c474f53";
  *((_QWORD *)&v138 + 1) = 40i64;
  v14 = sub_146176D40((__int64)v643, &v138);
  v1087 = *(_OWORD *)v14;
  v1088 = *(_DWORD *)(v14 + 16);
  sub_146170E60((__int64)v1089, (__int64)&v727, v15, v16);
  v1090 = 673138604i64;
  v725 = 0i64;
  v726 = 0i64;
  *(_QWORD *)&v725 = sub_14615A5E0(0x60ui64);
  v726 = si128;
  strcpy((char *)v725, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_2372_to_3407.update.rpf.hdiff");
  *(_QWORD *)&v138 = "1824cdbc27c3e0eaa86920a38751322727872831";
  *((_QWORD *)&v138 + 1) = 40i64;
  v17 = sub_146176D40((__int64)v644, &v138);
  v1091 = *(_OWORD *)v17;
  v1092 = *(_DWORD *)(v17 + 16);
  *(_QWORD *)&v138 = "f6cdcdec5e3e993a31f45acc96b638283c474f53";
  *((_QWORD *)&v138 + 1) = 40i64;
  v18 = sub_146176D40((__int64)v645, &v138);
  v1093 = *(_OWORD *)v18;
  v1094 = *(_DWORD *)(v18 + 16);
  sub_146170E60((__int64)v1095, (__int64)&v725, v19, v20);
  v1096 = 656589671i64;
  v723 = 0i64;
  v724 = 0i64;
  *(_QWORD *)&v723 = sub_14615A5E0(0x60ui64);
  v724 = si128;
  strcpy((char *)v723, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_2545_to_3407.update.rpf.hdiff");
  *(_QWORD *)&v138 = "2993b3c30f61cbbb8dbce859604d7fb717ff8dae";
  *((_QWORD *)&v138 + 1) = 40i64;
  v21 = sub_146176D40((__int64)v646, &v138);
  v1097 = *(_OWORD *)v21;
  v1098 = *(_DWORD *)(v21 + 16);
  *(_QWORD *)&v138 = "f6cdcdec5e3e993a31f45acc96b638283c474f53";
  *((_QWORD *)&v138 + 1) = 40i64;
  v22 = sub_146176D40((__int64)v647, &v138);
  v1099 = *(_OWORD *)v22;
  v1100 = *(_DWORD *)(v22 + 16);
  sub_146170E60((__int64)v1101, (__int64)&v723, v23, v24);
  v1102 = 518336416i64;
  v721 = 0i64;
  v722 = 0i64;
  *(_QWORD *)&v721 = sub_14615A5E0(0x60ui64);
  v722 = si128;
  strcpy((char *)v721, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_2612_to_3407.update.rpf.hdiff");
  *(_QWORD *)&v138 = "80f9bd028e5bc781f641fe210a88579eff827989";
  *((_QWORD *)&v138 + 1) = 40i64;
  v25 = sub_146176D40((__int64)v648, &v138);
  v1103 = *(_OWORD *)v25;
  v1104 = *(_DWORD *)(v25 + 16);
  *(_QWORD *)&v138 = "f6cdcdec5e3e993a31f45acc96b638283c474f53";
  *((_QWORD *)&v138 + 1) = 40i64;
  v26 = sub_146176D40((__int64)v649, &v138);
  v1105 = *(_OWORD *)v26;
  v1106 = *(_DWORD *)(v26 + 16);
  sub_146170E60((__int64)v1107, (__int64)&v721, v27, v28);
  v1108 = 518335629i64;
  v719 = 0i64;
  v720 = 0i64;
  *(_QWORD *)&v719 = sub_14615A5E0(0x60ui64);
  v720 = si128;
  strcpy((char *)v719, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_2699_to_3407.update.rpf.hdiff");
  *(_QWORD *)&v138 = "86d88c5ea36e67683a138c0e690c42fe288205fa";
  *((_QWORD *)&v138 + 1) = 40i64;
  v29 = sub_146176D40((__int64)v650, &v138);
  v1109 = *(_OWORD *)v29;
  v1110 = *(_DWORD *)(v29 + 16);
  *(_QWORD *)&v138 = "f6cdcdec5e3e993a31f45acc96b638283c474f53";
  *((_QWORD *)&v138 + 1) = 40i64;
  v30 = sub_146176D40((__int64)v651, &v138);
  v1111 = *(_OWORD *)v30;
  v1112 = *(_DWORD *)(v30 + 16);
  sub_146170E60((__int64)v1113, (__int64)&v719, v31, v32);
  v1114 = 473523013i64;
  v717 = 0i64;
  v718 = 0i64;
  *(_QWORD *)&v717 = sub_14615A5E0(0x60ui64);
  v718 = si128;
  strcpy((char *)v717, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_2802_to_3407.update.rpf.hdiff");
  *(_QWORD *)&v138 = "66388a381347511b7b28aaf91741615e45008e8b";
  *((_QWORD *)&v138 + 1) = 40i64;
  v33 = sub_146176D40((__int64)v652, &v138);
  v1115 = *(_OWORD *)v33;
  v1116 = *(_DWORD *)(v33 + 16);
  *(_QWORD *)&v138 = "f6cdcdec5e3e993a31f45acc96b638283c474f53";
  *((_QWORD *)&v138 + 1) = 40i64;
  v34 = sub_146176D40((__int64)v653, &v138);
  v1117 = *(_OWORD *)v34;
  v1118 = *(_DWORD *)(v34 + 16);
  sub_146170E60((__int64)v1119, (__int64)&v717, v35, v36);
  v1120 = 416908267i64;
  v715 = 0i64;
  v716 = 0i64;
  *(_QWORD *)&v715 = sub_14615A5E0(0x60ui64);
  v716 = si128;
  strcpy((char *)v715, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_2944_to_3407.update.rpf.hdiff");
  *(_QWORD *)&v138 = "abc628b0ae04e68f88e0581f3572d26dbaed84d2";
  *((_QWORD *)&v138 + 1) = 40i64;
  v37 = sub_146176D40((__int64)v654, &v138);
  v1121 = *(_OWORD *)v37;
  v1122 = *(_DWORD *)(v37 + 16);
  *(_QWORD *)&v138 = "f6cdcdec5e3e993a31f45acc96b638283c474f53";
  *((_QWORD *)&v138 + 1) = 40i64;
  v38 = sub_146176D40((__int64)v655, &v138);
  v1123 = *(_OWORD *)v38;
  v1124 = *(_DWORD *)(v38 + 16);
  sub_146170E60((__int64)v1125, (__int64)&v715, v39, v40);
  v1126 = 403895326i64;
  v713 = 0i64;
  v714 = 0i64;
  *(_QWORD *)&v713 = sub_14615A5E0(0x60ui64);
  v714 = si128;
  strcpy((char *)v713, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_3095_to_3407.update.rpf.hdiff");
  *(_QWORD *)&v138 = "fd46de4495d32f0533b8b3ae72507b829e8650f3";
  *((_QWORD *)&v138 + 1) = 40i64;
  v41 = sub_146176D40((__int64)v656, &v138);
  v1127 = *(_OWORD *)v41;
  v1128 = *(_DWORD *)(v41 + 16);
  *(_QWORD *)&v138 = "f6cdcdec5e3e993a31f45acc96b638283c474f53";
  *((_QWORD *)&v138 + 1) = 40i64;
  v42 = sub_146176D40((__int64)v657, &v138);
  v1129 = *(_OWORD *)v42;
  v1130 = *(_DWORD *)(v42 + 16);
  sub_146170E60((__int64)v1131, (__int64)&v713, v43, v44);
  v1132 = 75132778i64;
  v711 = 0i64;
  v712 = 0i64;
  *(_QWORD *)&v711 = sub_14615A5E0(0x60ui64);
  v712 = si128;
  strcpy((char *)v711, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_3179_to_3407.update.rpf.hdiff");
  *(_QWORD *)&v138 = "fd46de4495d32f0533b8b3ae72507b829e8650f3";
  *((_QWORD *)&v138 + 1) = 40i64;
  v45 = sub_146176D40((__int64)v658, &v138);
  v1133 = *(_OWORD *)v45;
  v1134 = *(_DWORD *)(v45 + 16);
  *(_QWORD *)&v138 = "f6cdcdec5e3e993a31f45acc96b638283c474f53";
  *((_QWORD *)&v138 + 1) = 40i64;
  v46 = sub_146176D40((__int64)v659, &v138);
  v1135 = *(_OWORD *)v46;
  v1136 = *(_DWORD *)(v46 + 16);
  sub_146170E60((__int64)v1137, (__int64)&v711, v47, v48);
  v1138 = 75132778i64;
  v709 = 0i64;
  v710 = 0i64;
  *(_QWORD *)&v709 = sub_14615A5E0(0x60ui64);
  v710 = si128;
  strcpy((char *)v709, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_3258_to_3407.update.rpf.hdiff");
  *(_QWORD *)&v138 = "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270";
  *((_QWORD *)&v138 + 1) = 40i64;
  v49 = sub_146176D40((__int64)v660, &v138);
  v1139 = *(_OWORD *)v49;
  v1140 = *(_DWORD *)(v49 + 16);
  *(_QWORD *)&v138 = "f6cdcdec5e3e993a31f45acc96b638283c474f53";
  *((_QWORD *)&v138 + 1) = 40i64;
  v50 = sub_146176D40((__int64)v661, &v138);
  v1141 = *(_OWORD *)v50;
  v1142 = *(_DWORD *)(v50 + 16);
  sub_146170E60((__int64)v1143, (__int64)&v709, v51, v52);
  v1144 = 61660313i64;
  v707 = 0i64;
  v708 = 0i64;
  *(_QWORD *)&v707 = sub_14615A5E0(0x60ui64);
  v708 = si128;
  strcpy((char *)v707, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_3323_to_3407.update.rpf.hdiff");
  *(_QWORD *)&v138 = "3633a58585791b30281cec14f90f5ac1e2bfdc57";
  *((_QWORD *)&v138 + 1) = 40i64;
  v53 = sub_146176D40((__int64)v662, &v138);
  v1145 = *(_OWORD *)v53;
  v1146 = *(_DWORD *)(v53 + 16);
  *(_QWORD *)&v138 = "f6cdcdec5e3e993a31f45acc96b638283c474f53";
  *((_QWORD *)&v138 + 1) = 40i64;
  v54 = sub_146176D40((__int64)v663, &v138);
  v1147 = *(_OWORD *)v54;
  v1148 = *(_DWORD *)(v54 + 16);
  sub_146170E60((__int64)v1149, (__int64)&v707, v55, v56);
  v1150 = 61640641i64;
  v757 = "update/update.rpf";
  v163 = "f6cdcdec5e3e993a31f45acc96b638283c474f53";
  *(_QWORD *)&v138 = &v163;
  *((_QWORD *)&v138 + 1) = v164;
  sub_146178AE0(v758, (__int64)&v138, (__int64)&v141);
  v758[3] = "https://content.cfx.re/mirrors/patches_fivem/3407/update.rpf";
  v758[4] = 0i64;
  v758[5] = 1432735744i64;
  v758[6] = 1432735744i64;
  *(_QWORD *)&v138 = &v1073;
  *((_QWORD *)&v138 + 1) = &v1151;
  sub_146178CB0(v759, (__int64 *)&v138, (__int64)&v142);
  v760 = 0i64;
  v761 = 0i64;
  v762 = 7i64;
  LOWORD(v760) = 0;
  v686[1] = 26224i64;
  v687 = _mm_load_si128((const __m128i *)&xmmword_14612A930);
  v686[0] = 0x722E657461647075i64;
  sub_146170E60((__int64)v1219, (__int64)v686, v57, v58);
  sub_146178F20(v1220, &v757, v59);
  v705 = 0i64;
  v706 = 0i64;
  *(_QWORD *)&v705 = sub_14615A5E0(0x60ui64);
  v60 = _mm_load_si128((const __m128i *)&xmmword_14612A960);
  v706 = v60;
  strcpy((char *)v705, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_2612_to_3407.update2.rpf.hdiff");
  *(_QWORD *)&v138 = "c993e2d14cce9462fa8ba056f3406d60050a1c92";
  *((_QWORD *)&v138 + 1) = 40i64;
  v61 = sub_146176D40((__int64)v664, &v138);
  v1025 = *(_OWORD *)v61;
  v1026 = *(_DWORD *)(v61 + 16);
  *(_QWORD *)&v138 = "b379e1752718ea1d799194b8aa70b58b28cd8c5f";
  *((_QWORD *)&v138 + 1) = 40i64;
  v62 = sub_146176D40((__int64)v665, &v138);
  v1027 = *(_OWORD *)v62;
  v1028 = *(_DWORD *)(v62 + 16);
  sub_146170E60((__int64)v1029, (__int64)&v705, v63, v64);
  v1030 = 369334200i64;
  v703 = 0i64;
  v704 = 0i64;
  *(_QWORD *)&v703 = sub_14615A5E0(0x60ui64);
  v704 = v60;
  strcpy((char *)v703, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_2699_to_3407.update2.rpf.hdiff");
  *(_QWORD *)&v138 = "414a04256bf0b00b78324478508a6beaea1ef5a7";
  *((_QWORD *)&v138 + 1) = 40i64;
  v65 = sub_146176D40((__int64)v666, &v138);
  v1031 = *(_OWORD *)v65;
  v1032 = *(_DWORD *)(v65 + 16);
  *(_QWORD *)&v138 = "b379e1752718ea1d799194b8aa70b58b28cd8c5f";
  *((_QWORD *)&v138 + 1) = 40i64;
  v66 = sub_146176D40((__int64)v667, &v138);
  v1033 = *(_OWORD *)v66;
  v1034 = *(_DWORD *)(v66 + 16);
  sub_146170E60((__int64)v1035, (__int64)&v703, v67, v68);
  v1036 = 367631685i64;
  v701 = 0i64;
  v702 = 0i64;
  *(_QWORD *)&v701 = sub_14615A5E0(0x60ui64);
  v702 = v60;
  strcpy((char *)v701, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_2802_to_3407.update2.rpf.hdiff");
  *(_QWORD *)&v138 = "c7de68bdc56ec4577bd4fce5d85cca9a4d529839";
  *((_QWORD *)&v138 + 1) = 40i64;
  v69 = sub_146176D40((__int64)v668, &v138);
  v1037 = *(_OWORD *)v69;
  v1038 = *(_DWORD *)(v69 + 16);
  *(_QWORD *)&v138 = "b379e1752718ea1d799194b8aa70b58b28cd8c5f";
  *((_QWORD *)&v138 + 1) = 40i64;
  v70 = sub_146176D40((__int64)v669, &v138);
  v1039 = *(_OWORD *)v70;
  v1040 = *(_DWORD *)(v70 + 16);
  sub_146170E60((__int64)v1041, (__int64)&v701, v71, v72);
  v1042 = 367337281i64;
  v699 = 0i64;
  v700 = 0i64;
  *(_QWORD *)&v699 = sub_14615A5E0(0x60ui64);
  v700 = v60;
  strcpy((char *)v699, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_2944_to_3407.update2.rpf.hdiff");
  *(_QWORD *)&v138 = "a3181d68a532950da5c584100b35f79eaca7c884";
  *((_QWORD *)&v138 + 1) = 40i64;
  v73 = sub_146176D40((__int64)v670, &v138);
  v1043 = *(_OWORD *)v73;
  v1044 = *(_DWORD *)(v73 + 16);
  *(_QWORD *)&v138 = "b379e1752718ea1d799194b8aa70b58b28cd8c5f";
  *((_QWORD *)&v138 + 1) = 40i64;
  v74 = sub_146176D40((__int64)v671, &v138);
  v1045 = *(_OWORD *)v74;
  v1046 = *(_DWORD *)(v74 + 16);
  sub_146170E60((__int64)v1047, (__int64)&v699, v75, v76);
  v1048 = 367059221i64;
  v697 = 0i64;
  v698 = 0i64;
  *(_QWORD *)&v697 = sub_14615A5E0(0x60ui64);
  v698 = v60;
  strcpy((char *)v697, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_3095_to_3407.update2.rpf.hdiff");
  *(_QWORD *)&v138 = "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6";
  *((_QWORD *)&v138 + 1) = 40i64;
  v77 = sub_146176D40((__int64)v672, &v138);
  v1049 = *(_OWORD *)v77;
  v1050 = *(_DWORD *)(v77 + 16);
  *(_QWORD *)&v138 = "b379e1752718ea1d799194b8aa70b58b28cd8c5f";
  *((_QWORD *)&v138 + 1) = 40i64;
  v78 = sub_146176D40((__int64)v673, &v138);
  v1051 = *(_OWORD *)v78;
  v1052 = *(_DWORD *)(v78 + 16);
  sub_146170E60((__int64)v1053, (__int64)&v697, v79, v80);
  v1054 = 364900867i64;
  v695 = 0i64;
  v696 = 0i64;
  *(_QWORD *)&v695 = sub_14615A5E0(0x60ui64);
  v696 = v60;
  strcpy((char *)v695, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_3179_to_3407.update2.rpf.hdiff");
  *(_QWORD *)&v138 = "cfea3456309664bf8762e3bce5957211f3ee8b39";
  *((_QWORD *)&v138 + 1) = 40i64;
  v81 = sub_146176D40((__int64)v674, &v138);
  v1055 = *(_OWORD *)v81;
  v1056 = *(_DWORD *)(v81 + 16);
  *(_QWORD *)&v138 = "b379e1752718ea1d799194b8aa70b58b28cd8c5f";
  *((_QWORD *)&v138 + 1) = 40i64;
  v82 = sub_146176D40((__int64)v675, &v138);
  v1057 = *(_OWORD *)v82;
  v1058 = *(_DWORD *)(v82 + 16);
  sub_146170E60((__int64)v1059, (__int64)&v695, v83, v84);
  v1060 = 364900652i64;
  v693 = 0i64;
  v694 = 0i64;
  *(_QWORD *)&v693 = sub_14615A5E0(0x60ui64);
  v694 = v60;
  strcpy((char *)v693, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_3258_to_3407.update2.rpf.hdiff");
  *(_QWORD *)&v138 = "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248";
  *((_QWORD *)&v138 + 1) = 40i64;
  v85 = sub_146176D40((__int64)v676, &v138);
  v1061 = *(_OWORD *)v85;
  v1062 = *(_DWORD *)(v85 + 16);
  *(_QWORD *)&v138 = "b379e1752718ea1d799194b8aa70b58b28cd8c5f";
  *((_QWORD *)&v138 + 1) = 40i64;
  v86 = sub_146176D40((__int64)v677, &v138);
  v1063 = *(_OWORD *)v86;
  v1064 = *(_DWORD *)(v86 + 16);
  sub_146170E60((__int64)v1065, (__int64)&v693, v87, v88);
  v1066 = 364379838i64;
  v691 = 0i64;
  v692 = 0i64;
  *(_QWORD *)&v691 = sub_14615A5E0(0x60ui64);
  v692 = v60;
  strcpy((char *)v691, "https://content.cfx.re/mirrors/patches_fivem/3407/diffs/from_3323_to_3407.update2.rpf.hdiff");
  *(_QWORD *)&v138 = "f2007adb84a8fc9e4481d58faf88ffca3af754c5";
  *((_QWORD *)&v138 + 1) = 40i64;
  v89 = sub_146176D40((__int64)v678, &v138);
  v1067 = *(_OWORD *)v89;
  v1068 = *(_DWORD *)(v89 + 16);
  *(_QWORD *)&v138 = "b379e1752718ea1d799194b8aa70b58b28cd8c5f";
  *((_QWORD *)&v138 + 1) = 40i64;
  v90 = sub_146176D40((__int64)v679, &v138);
  v1069 = *(_OWORD *)v90;
  v1070 = *(_DWORD *)(v90 + 16);
  sub_146170E60((__int64)v1071, (__int64)&v691, v91, v92);
  v1072 = 364385726i64;
  v751 = "update/update2.rpf";
  v162 = "b379e1752718ea1d799194b8aa70b58b28cd8c5f";
  *(_QWORD *)&v138 = &v162;
  *((_QWORD *)&v138 + 1) = &v163;
  sub_146178AE0(v752, (__int64)&v138, (__int64)&v143);
  v752[3] = "https://content.cfx.re/mirrors/patches_fivem/3407/update2.rpf";
  v752[4] = 0i64;
  v752[5] = 440010752i64;
  v752[6] = 440010752i64;
  *(_QWORD *)&v138 = &v1025;
  *((_QWORD *)&v138 + 1) = &v1073;
  sub_146178CB0(v753, (__int64 *)&v138, (__int64)&v144);
  v754 = 0i64;
  v755 = 0i64;
  v756 = 7i64;
  LOWORD(v754) = 0;
  v685 = _mm_load_si128((const __m128i *)&xmmword_14612A940);
  v684[0] = 0x2E32657461647075i64;
  v684[1] = 6713458i64;
  sub_146170E60((__int64)v1221, (__int64)v684, v93, v94);
  sub_146178F20(v1222, &v751, v95);
  *(_QWORD *)&v138 = v1217;
  *((_QWORD *)&v138 + 1) = &v1223;
  sub_1461788D0((__int64 *)v176, (__int64 *)&v138);
  v1151 = 3407;
  sub_1461787F0(&v1152, v176);
  v745 = "GTA5.exe";
  v160 = "059bcf06de5a683ad39f8d24543cae80a988b4cb";
  *(_QWORD *)&v138 = &v160;
  *((_QWORD *)&v138 + 1) = &v161;
  sub_146178AE0(v746, (__int64)&v138, (__int64)&v145);
  v746[3] = "https://content.cfx.re/mirrors/patches_fivem/3323/GTA5.exe";
  v746[4] = 0i64;
  v746[5] = 57496560i64;
  v746[6] = 57496560i64;
  v138 = 0i64;
  sub_146178CB0(v747, (__int64 *)&v138, (__int64)v146);
  v748 = 0i64;
  v749 = 0i64;
  v750 = 7i64;
  LOWORD(v748) = 0;
  v690[1] = (__int128)_mm_load_si128((const __m128i *)&xmmword_14612A920);
  v690[0] = 0x6578652E35415447ui64;
  sub_146170E60((__int64)v1298, (__int64)v690, v96, v97);
  sub_146178F20(v1299, &v745, v98);
  v688 = 0i64;
  v689 = 0i64;
  *(_QWORD *)&v688 = sub_14615A5E0(0x60ui64);
  v689 = si128;
  strcpy((char *)v688, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_1604_to_3323.update.rpf.hdiff");
  *(_QWORD *)&v138 = "fc941d698834e30e40a06a40f6a35b1b18e1c50c";
  *((_QWORD *)&v138 + 1) = 40i64;
  v99 = sub_146176D40((__int64)v680, &v138);
  v1199 = *(_OWORD *)v99;
  v1200 = *(_DWORD *)(v99 + 16);
  *(_QWORD *)&v138 = "3633a58585791b30281cec14f90f5ac1e2bfdc57";
  *((_QWORD *)&v138 + 1) = 40i64;
  v100 = sub_146176D40((__int64)v681, &v138);
  v1201 = *(_OWORD *)v100;
  v1202 = *(_DWORD *)(v100 + 16);
  sub_146170E60((__int64)v1203, (__int64)&v688, v101, v102);
  v1204 = 932235268i64;
  v682 = 0i64;
  v683 = 0i64;
  v161 = std::string::_Calculate_growth(90i64, 15i64, 0x7FFFFFFFFFFFFFFFi64);
  v103 = sub_146176F80((__int64)&v682, &v161);
  *(_QWORD *)&v682 = v103;
  *(_QWORD *)&v683 = 90i64;
  *((_QWORD *)&v683 + 1) = v161;
  std::_Char_traits<char,int>::copy(
    v103,
    "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_2060_to_3323.update.rpf.hdiff",
    90i64);
  *((_BYTE *)v103 + 90) = 0;
  v138 = *(_OWORD *)sub_146178670(&v178, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  v139 = *(_OWORD *)sub_146178670(&v179, "736f1cb26e59167f302c22385463d231cce302d3");
  sub_146178DD0((__int64)v1205, &v139, &v138, (__int64)&v682, 704310918i64);
  sub_146178620(v1020, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_2189_to_3323.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v180, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  v138 = *(_OWORD *)sub_146178670(&v181, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  sub_146178DD0((__int64)v1206, &v138, &v139, (__int64)v1020, 663014659i64);
  sub_146178620(v1019, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_2372_to_3323.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v182, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  v138 = *(_OWORD *)sub_146178670(&v183, "1824cdbc27c3e0eaa86920a38751322727872831");
  sub_146178DD0((__int64)v1207, &v138, &v139, (__int64)v1019, 646437484i64);
  sub_146178620(v1018, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_2545_to_3323.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v184, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  v138 = *(_OWORD *)sub_146178670(&v185, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  sub_146178DD0((__int64)v1208, &v138, &v139, (__int64)v1018, 507689034i64);
  sub_146178620(v1017, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_2612_to_3323.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v186, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  v138 = *(_OWORD *)sub_146178670(&v187, "80f9bd028e5bc781f641fe210a88579eff827989");
  sub_146178DD0((__int64)v1209, &v138, &v139, (__int64)v1017, 507688645i64);
  sub_146178620(v1016, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_2699_to_3323.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v188, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  v138 = *(_OWORD *)sub_146178670(&v189, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  sub_146178DD0((__int64)v1210, &v138, &v139, (__int64)v1016, 462961012i64);
  sub_146178620(v1015, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_2802_to_3323.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v190, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  v138 = *(_OWORD *)sub_146178670(&v191, "66388a381347511b7b28aaf91741615e45008e8b");
  sub_146178DD0((__int64)v1211, &v138, &v139, (__int64)v1015, 406279747i64);
  sub_146178620(v1014, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_2944_to_3323.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v192, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  v138 = *(_OWORD *)sub_146178670(&v193, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  sub_146178DD0((__int64)v1212, &v138, &v139, (__int64)v1014, 393108441i64);
  sub_146178620(v1013, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_3095_to_3323.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v194, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  v138 = *(_OWORD *)sub_146178670(&v195, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1213, &v138, &v139, (__int64)v1013, 63784896i64);
  sub_146178620(v1012, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_3179_to_3323.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v196, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  v138 = *(_OWORD *)sub_146178670(&v197, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1214, &v138, &v139, (__int64)v1012, 63784896i64);
  sub_146178620(v1011, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_3258_to_3323.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v198, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  v138 = *(_OWORD *)sub_146178670(&v199, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  sub_146178DD0((__int64)v1215, &v138, &v139, (__int64)v1011, 232538i64);
  sub_146178620(v1010, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_3407_to_3323.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v200, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  v138 = *(_OWORD *)sub_146178670(&v201, "f6cdcdec5e3e993a31f45acc96b638283c474f53");
  sub_146178DD0((__int64)v1216, &v138, &v139, (__int64)v1010, 52320836i64);
  *(_QWORD *)&v138 = &v1199;
  *((_QWORD *)&v138 + 1) = v1217;
  sub_146178FA0(
    (__int64)v1195,
    (__int64)"update/update.rpf",
    (__int64)"3633a58585791b30281cec14f90f5ac1e2bfdc57",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/3323/update.rpf",
    1423288320i64,
    &v138);
  sub_146178620(v1009, (const char *)&qword_1461212B8);
  sub_146176D00((__int64)v1300, (__int64)v1009, v1195, v104);
  sub_146178620(v1008, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_2612_to_3323.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v202, "f2007adb84a8fc9e4481d58faf88ffca3af754c5");
  v138 = *(_OWORD *)sub_146178670(&v203, "c993e2d14cce9462fa8ba056f3406d60050a1c92");
  sub_146178DD0((__int64)v1272, &v138, &v139, (__int64)v1008, 345380507i64);
  sub_146178620(v1007, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_2699_to_3323.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v204, "f2007adb84a8fc9e4481d58faf88ffca3af754c5");
  v138 = *(_OWORD *)sub_146178670(&v205, "414a04256bf0b00b78324478508a6beaea1ef5a7");
  sub_146178DD0((__int64)v1273, &v138, &v139, (__int64)v1007, 343671960i64);
  sub_146178620(v1006, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_2802_to_3323.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v206, "f2007adb84a8fc9e4481d58faf88ffca3af754c5");
  v138 = *(_OWORD *)sub_146178670(&v207, "c7de68bdc56ec4577bd4fce5d85cca9a4d529839");
  sub_146178DD0((__int64)v1274, &v138, &v139, (__int64)v1006, 343371839i64);
  sub_146178620(v1005, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_2944_to_3323.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v208, "f2007adb84a8fc9e4481d58faf88ffca3af754c5");
  v138 = *(_OWORD *)sub_146178670(&v209, "a3181d68a532950da5c584100b35f79eaca7c884");
  sub_146178DD0((__int64)v1275, &v138, &v139, (__int64)v1005, 343112220i64);
  sub_146178620(v1004, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_3095_to_3323.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v210, "f2007adb84a8fc9e4481d58faf88ffca3af754c5");
  v138 = *(_OWORD *)sub_146178670(&v211, "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6");
  sub_146178DD0((__int64)v1276, &v138, &v139, (__int64)v1004, 340833331i64);
  sub_146178620(v1003, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_3179_to_3323.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v212, "f2007adb84a8fc9e4481d58faf88ffca3af754c5");
  v138 = *(_OWORD *)sub_146178670(&v213, "cfea3456309664bf8762e3bce5957211f3ee8b39");
  sub_146178DD0((__int64)v1277, &v138, &v139, (__int64)v1003, 340835870i64);
  sub_146178620(v1002, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_3258_to_3323.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v214, "f2007adb84a8fc9e4481d58faf88ffca3af754c5");
  v138 = *(_OWORD *)sub_146178670(&v215, "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248");
  sub_146178DD0((__int64)v1278, &v138, &v139, (__int64)v1002, 327858356i64);
  sub_146178620(v1001, "https://content.cfx.re/mirrors/patches_fivem/3323/diffs/from_3407_to_3323.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v216, "f2007adb84a8fc9e4481d58faf88ffca3af754c5");
  v138 = *(_OWORD *)sub_146178670(&v217, "b379e1752718ea1d799194b8aa70b58b28cd8c5f");
  sub_146178DD0((__int64)v1279, &v138, &v139, (__int64)v1001, 340440056i64);
  *(_QWORD *)&v138 = v1272;
  *((_QWORD *)&v138 + 1) = v1280;
  sub_146178FA0(
    (__int64)v1194,
    (__int64)"update/update2.rpf",
    (__int64)"f2007adb84a8fc9e4481d58faf88ffca3af754c5",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/3323/update2.rpf",
    416063488i64,
    &v138);
  sub_146178620(v1000, (const char *)&qword_1461217D8);
  sub_146176D00((__int64)v1301, (__int64)v1000, v1194, v105);
  *(_QWORD *)&v138 = v1298;
  *((_QWORD *)&v138 + 1) = &v1302;
  sub_1461788D0((__int64 *)v175, (__int64 *)&v138);
  v147 = 3323;
  sub_146176CD0((__int64)v1153, &v147, v175);
  v139 = 0i64;
  sub_146178FA0(
    (__int64)v1193,
    (__int64)"GTA5.exe",
    (__int64)"17183412df26a019386ffd5097df697d9041bb3d",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/3258/GTA5.exe",
    56066032i64,
    &v139);
  sub_146178620(v999, "GTA5.exe");
  sub_146176D00((__int64)v1473, (__int64)v999, v1193, v106);
  sub_146178620(v998, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_1604_to_3258.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v218, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  v138 = *(_OWORD *)sub_146178670(&v219, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  sub_146178DD0((__int64)v1444, &v138, &v139, (__int64)v998, 932235213i64);
  sub_146178620(v997, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_2060_to_3258.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v220, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  v138 = *(_OWORD *)sub_146178670(&v221, "736f1cb26e59167f302c22385463d231cce302d3");
  sub_146178DD0((__int64)v1445, &v138, &v139, (__int64)v997, 704311288i64);
  sub_146178620(v996, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_2189_to_3258.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v222, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  v138 = *(_OWORD *)sub_146178670(&v223, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  sub_146178DD0((__int64)v1446, &v138, &v139, (__int64)v996, 663014595i64);
  sub_146178620(v995, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_2372_to_3258.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v224, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  v138 = *(_OWORD *)sub_146178670(&v225, "1824cdbc27c3e0eaa86920a38751322727872831");
  sub_146178DD0((__int64)v1447, &v138, &v139, (__int64)v995, 646437117i64);
  sub_146178620(v994, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_2545_to_3258.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v226, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  v138 = *(_OWORD *)sub_146178670(&v227, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  sub_146178DD0((__int64)v1448, &v138, &v139, (__int64)v994, 507688763i64);
  sub_146178620(v993, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_2612_to_3258.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v228, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  v138 = *(_OWORD *)sub_146178670(&v229, "80f9bd028e5bc781f641fe210a88579eff827989");
  sub_146178DD0((__int64)v1449, &v138, &v139, (__int64)v993, 507688310i64);
  sub_146178620(v992, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_2699_to_3258.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v230, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  v138 = *(_OWORD *)sub_146178670(&v231, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  sub_146178DD0((__int64)v1450, &v138, &v139, (__int64)v992, 462960589i64);
  sub_146178620(v991, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_2802_to_3258.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v232, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  v138 = *(_OWORD *)sub_146178670(&v233, "66388a381347511b7b28aaf91741615e45008e8b");
  sub_146178DD0((__int64)v1451, &v138, &v139, (__int64)v991, 406279730i64);
  sub_146178620(v990, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_2944_to_3258.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v234, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  v138 = *(_OWORD *)sub_146178670(&v235, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  sub_146178DD0((__int64)v1452, &v138, &v139, (__int64)v990, 393108418i64);
  sub_146178620(v989, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_3095_to_3258.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v236, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  v138 = *(_OWORD *)sub_146178670(&v237, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1453, &v138, &v139, (__int64)v989, 63780343i64);
  sub_146178620(v988, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_3179_to_3258.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v238, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  v138 = *(_OWORD *)sub_146178670(&v239, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1454, &v138, &v139, (__int64)v988, 63780343i64);
  sub_146178620(v987, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_3323_to_3258.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v240, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  v138 = *(_OWORD *)sub_146178670(&v241, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  sub_146178DD0((__int64)v1455, &v138, &v139, (__int64)v987, 232538i64);
  sub_146178620(v986, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_3407_to_3258.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v242, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  v138 = *(_OWORD *)sub_146178670(&v243, "f6cdcdec5e3e993a31f45acc96b638283c474f53");
  sub_146178DD0((__int64)v1456, &v138, &v139, (__int64)v986, 52340312i64);
  *(_QWORD *)&v138 = v1444;
  *((_QWORD *)&v138 + 1) = v1457;
  sub_146178FA0(
    (__int64)v1192,
    (__int64)"update/update.rpf",
    (__int64)"abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/3258/update.rpf",
    1423288320i64,
    &v138);
  sub_146178620(v985, (const char *)&qword_1461212B8);
  sub_146176D00((__int64)v1474, (__int64)v985, v1192, v107);
  sub_146178620(v984, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_2612_to_3258.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v244, "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248");
  v138 = *(_OWORD *)sub_146178670(&v245, "c993e2d14cce9462fa8ba056f3406d60050a1c92");
  sub_146178DD0((__int64)v1264, &v138, &v139, (__int64)v984, 345380170i64);
  sub_146178620(v983, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_2699_to_3258.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v246, "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248");
  v138 = *(_OWORD *)sub_146178670(&v247, "414a04256bf0b00b78324478508a6beaea1ef5a7");
  sub_146178DD0((__int64)v1265, &v138, &v139, (__int64)v983, 343680669i64);
  sub_146178620(v982, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_2802_to_3258.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v248, "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248");
  v138 = *(_OWORD *)sub_146178670(&v249, "c7de68bdc56ec4577bd4fce5d85cca9a4d529839");
  sub_146178DD0((__int64)v1266, &v138, &v139, (__int64)v982, 343376273i64);
  sub_146178620(v981, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_2944_to_3258.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v250, "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248");
  v138 = *(_OWORD *)sub_146178670(&v251, "a3181d68a532950da5c584100b35f79eaca7c884");
  sub_146178DD0((__int64)v1267, &v138, &v139, (__int64)v981, 343101974i64);
  sub_146178620(v980, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_3095_to_3258.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v252, "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248");
  v138 = *(_OWORD *)sub_146178670(&v253, "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6");
  sub_146178DD0((__int64)v1268, &v138, &v139, (__int64)v980, 340810631i64);
  sub_146178620(v979, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_3179_to_3258.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v254, "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248");
  v138 = *(_OWORD *)sub_146178670(&v255, "cfea3456309664bf8762e3bce5957211f3ee8b39");
  sub_146178DD0((__int64)v1269, &v138, &v139, (__int64)v979, 340801650i64);
  sub_146178620(v978, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_3323_to_3258.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v256, "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248");
  v138 = *(_OWORD *)sub_146178670(&v257, "f2007adb84a8fc9e4481d58faf88ffca3af754c5");
  sub_146178DD0((__int64)v1270, &v138, &v139, (__int64)v978, 327846154i64);
  sub_146178620(v977, "https://content.cfx.re/mirrors/patches_fivem/3258/diffs/from_3407_to_3258.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v258, "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248");
  v138 = *(_OWORD *)sub_146178670(&v259, "b379e1752718ea1d799194b8aa70b58b28cd8c5f");
  sub_146178DD0((__int64)v1271, &v138, &v139, (__int64)v977, 340422150i64);
  *(_QWORD *)&v138 = v1264;
  *((_QWORD *)&v138 + 1) = v1272;
  sub_146178FA0(
    (__int64)v1191,
    (__int64)"update/update2.rpf",
    (__int64)"6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/3258/update2.rpf",
    416053248i64,
    &v138);
  sub_146178620(v976, (const char *)&qword_1461217D8);
  sub_146176D00((__int64)v1475, (__int64)v976, v1191, v108);
  *(_QWORD *)&v138 = v1473;
  *((_QWORD *)&v138 + 1) = &v1476;
  sub_1461788D0((__int64 *)v174, (__int64 *)&v138);
  v148 = 3258;
  sub_146176CD0((__int64)v1154, &v148, v174);
  v139 = 0i64;
  sub_146178FA0(
    (__int64)v1190,
    (__int64)"GTA5.exe",
    (__int64)"cf2b853ae2125a26e636daa99f6377b05baaad8a",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/3179/GTA5.exe",
    55367152i64,
    &v139);
  sub_146178620(v975, "GTA5.exe");
  sub_146176D00((__int64)v1469, (__int64)v975, v1190, v109);
  sub_146178620(v974, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_1604_to_3179.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v260, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v261, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  sub_146178DD0((__int64)v1315, &v138, &v139, (__int64)v974, 923117905i64);
  sub_146178620(v973, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_2060_to_3179.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v262, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v263, "736f1cb26e59167f302c22385463d231cce302d3");
  sub_146178DD0((__int64)v1316, &v138, &v139, (__int64)v973, 694772098i64);
  sub_146178620(v972, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_2189_to_3179.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v264, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v265, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  sub_146178DD0((__int64)v1317, &v138, &v139, (__int64)v972, 653422887i64);
  sub_146178620(v971, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_2372_to_3179.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v266, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v267, "1824cdbc27c3e0eaa86920a38751322727872831");
  sub_146178DD0((__int64)v1318, &v138, &v139, (__int64)v971, 636414267i64);
  sub_146178620(v970, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_2545_to_3179.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v268, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v269, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  sub_146178DD0((__int64)v1319, &v138, &v139, (__int64)v970, 496735908i64);
  sub_146178620(v969, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_2612_to_3179.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v270, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v271, "80f9bd028e5bc781f641fe210a88579eff827989");
  sub_146178DD0((__int64)v1320, &v138, &v139, (__int64)v969, 496733750i64);
  sub_146178620(v968, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_2699_to_3179.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v272, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v273, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  sub_146178DD0((__int64)v1321, &v138, &v139, (__int64)v968, 452905479i64);
  sub_146178620(v967, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_2802_to_3179.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v274, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v275, "66388a381347511b7b28aaf91741615e45008e8b");
  sub_146178DD0((__int64)v1322, &v138, &v139, (__int64)v967, 386841388i64);
  sub_146178620(v966, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_2944_to_3179.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v276, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v277, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  sub_146178DD0((__int64)v1323, &v138, &v139, (__int64)v966, 341954506i64);
  sub_146178620(v965, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_3258_to_3179.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v278, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v279, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  sub_146178DD0((__int64)v1324, &v138, &v139, (__int64)v965, 56823148i64);
  sub_146178620(v964, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_3323_to_3179.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v280, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v281, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  sub_146178DD0((__int64)v1325, &v138, &v139, (__int64)v964, 56828311i64);
  sub_146178620(v963, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_3407_to_3179.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v282, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v283, "f6cdcdec5e3e993a31f45acc96b638283c474f53");
  sub_146178DD0((__int64)v1326, &v138, &v139, (__int64)v963, 58856138i64);
  *(_QWORD *)&v138 = v1315;
  *((_QWORD *)&v138 + 1) = v1327;
  sub_146178FA0(
    (__int64)v1189,
    (__int64)"update/update.rpf",
    (__int64)"fd46de4495d32f0533b8b3ae72507b829e8650f3",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/3179/update.rpf",
    1416300544i64,
    &v138);
  sub_146178620(v962, (const char *)&qword_1461212B8);
  sub_146176D00((__int64)v1470, (__int64)v962, v1189, v110);
  sub_146178620(v961, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_2612_to_3179.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v284, "cfea3456309664bf8762e3bce5957211f3ee8b39");
  v138 = *(_OWORD *)sub_146178670(&v285, "c993e2d14cce9462fa8ba056f3406d60050a1c92");
  sub_146178DD0((__int64)v1256, &v138, &v139, (__int64)v961, 333197023i64);
  sub_146178620(v960, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_2699_to_3179.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v286, "cfea3456309664bf8762e3bce5957211f3ee8b39");
  v138 = *(_OWORD *)sub_146178670(&v287, "414a04256bf0b00b78324478508a6beaea1ef5a7");
  sub_146178DD0((__int64)v1257, &v138, &v139, (__int64)v960, 331500185i64);
  sub_146178620(v959, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_2802_to_3179.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v288, "cfea3456309664bf8762e3bce5957211f3ee8b39");
  v138 = *(_OWORD *)sub_146178670(&v289, "c7de68bdc56ec4577bd4fce5d85cca9a4d529839");
  sub_146178DD0((__int64)v1258, &v138, &v139, (__int64)v959, 331176908i64);
  sub_146178620(v958, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_2944_to_3179.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v290, "cfea3456309664bf8762e3bce5957211f3ee8b39");
  v138 = *(_OWORD *)sub_146178670(&v291, "a3181d68a532950da5c584100b35f79eaca7c884");
  sub_146178DD0((__int64)v1259, &v138, &v139, (__int64)v958, 330898163i64);
  sub_146178620(v957, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_3095_to_3179.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v292, "cfea3456309664bf8762e3bce5957211f3ee8b39");
  v138 = *(_OWORD *)sub_146178670(&v293, "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6");
  sub_146178DD0((__int64)v1260, &v138, &v139, (__int64)v957, 313464391i64);
  sub_146178620(v956, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_3258_to_3179.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v294, "cfea3456309664bf8762e3bce5957211f3ee8b39");
  v138 = *(_OWORD *)sub_146178670(&v295, "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248");
  sub_146178DD0((__int64)v1261, &v138, &v139, (__int64)v956, 328689523i64);
  sub_146178620(v955, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_3323_to_3179.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v296, "cfea3456309664bf8762e3bce5957211f3ee8b39");
  v138 = *(_OWORD *)sub_146178670(&v297, "f2007adb84a8fc9e4481d58faf88ffca3af754c5");
  sub_146178DD0((__int64)v1262, &v138, &v139, (__int64)v955, 328713490i64);
  sub_146178620(v954, "https://content.cfx.re/mirrors/patches_fivem/3179/diffs/from_3407_to_3179.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v298, "cfea3456309664bf8762e3bce5957211f3ee8b39");
  v138 = *(_OWORD *)sub_146178670(&v299, "b379e1752718ea1d799194b8aa70b58b28cd8c5f");
  sub_146178DD0((__int64)v1263, &v138, &v139, (__int64)v954, 328830163i64);
  *(_QWORD *)&v138 = v1256;
  *((_QWORD *)&v138 + 1) = v1264;
  sub_146178FA0(
    (__int64)v1188,
    (__int64)"update/update2.rpf",
    (__int64)"cfea3456309664bf8762e3bce5957211f3ee8b39",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/3179/update2.rpf",
    403941376i64,
    &v138);
  sub_146178620(v953, (const char *)&qword_1461217D8);
  sub_146176D00((__int64)v1471, (__int64)v953, v1188, v111);
  *(_QWORD *)&v138 = v1469;
  *((_QWORD *)&v138 + 1) = &v1472;
  sub_1461788D0((__int64 *)v173, (__int64 *)&v138);
  v149 = 3179;
  sub_146176CD0((__int64)v1155, &v149, v173);
  v139 = 0i64;
  sub_146178FA0(
    (__int64)v1187,
    (__int64)"GTA5.exe",
    (__int64)"17a074bb8eaca5bd8df863de84869a4ab023e1eb",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/3095/GTA5.exe",
    49634800i64,
    &v139);
  sub_146178620(v952, "GTA5.exe");
  sub_146176D00((__int64)v1465, (__int64)v952, v1187, v112);
  sub_146178620(v951, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_1604_to_3095.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v300, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v301, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  sub_146178DD0((__int64)v1303, &v138, &v139, (__int64)v951, 923117905i64);
  sub_146178620(v950, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_2060_to_3095.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v302, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v303, "736f1cb26e59167f302c22385463d231cce302d3");
  sub_146178DD0((__int64)v1304, &v138, &v139, (__int64)v950, 694772098i64);
  sub_146178620(v949, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_2189_to_3095.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v304, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v305, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  sub_146178DD0((__int64)v1305, &v138, &v139, (__int64)v949, 653422887i64);
  sub_146178620(v948, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_2372_to_3095.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v306, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v307, "1824cdbc27c3e0eaa86920a38751322727872831");
  sub_146178DD0((__int64)v1306, &v138, &v139, (__int64)v948, 636414267i64);
  sub_146178620(v947, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_2545_to_3095.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v308, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v309, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  sub_146178DD0((__int64)v1307, &v138, &v139, (__int64)v947, 496735908i64);
  sub_146178620(v946, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_2612_to_3095.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v310, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v311, "80f9bd028e5bc781f641fe210a88579eff827989");
  sub_146178DD0((__int64)v1308, &v138, &v139, (__int64)v946, 496733750i64);
  sub_146178620(v945, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_2699_to_3095.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v312, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v313, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  sub_146178DD0((__int64)v1309, &v138, &v139, (__int64)v945, 452905479i64);
  sub_146178620(v944, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_2802_to_3095.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v314, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v315, "66388a381347511b7b28aaf91741615e45008e8b");
  sub_146178DD0((__int64)v1310, &v138, &v139, (__int64)v944, 386841388i64);
  sub_146178620(v943, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_2944_to_3095.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v316, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v317, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  sub_146178DD0((__int64)v1311, &v138, &v139, (__int64)v943, 341954506i64);
  sub_146178620(v942, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_3258_to_3095.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v318, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v319, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  sub_146178DD0((__int64)v1312, &v138, &v139, (__int64)v942, 56823148i64);
  sub_146178620(v941, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_3323_to_3095.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v320, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v321, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  sub_146178DD0((__int64)v1313, &v138, &v139, (__int64)v941, 56828311i64);
  sub_146178620(v940, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_3407_to_3095.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v322, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  v138 = *(_OWORD *)sub_146178670(&v323, "f6cdcdec5e3e993a31f45acc96b638283c474f53");
  sub_146178DD0((__int64)v1314, &v138, &v139, (__int64)v940, 58856138i64);
  *(_QWORD *)&v138 = v1303;
  *((_QWORD *)&v138 + 1) = v1315;
  sub_146178FA0(
    (__int64)v1186,
    (__int64)"update/update.rpf",
    (__int64)"fd46de4495d32f0533b8b3ae72507b829e8650f3",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/3095/update.rpf",
    1416300544i64,
    &v138);
  sub_146178620(v939, (const char *)&qword_1461212B8);
  sub_146176D00((__int64)v1466, (__int64)v939, v1186, v113);
  sub_146178620(v938, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_2612_to_3095.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v324, "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6");
  v138 = *(_OWORD *)sub_146178670(&v325, "c993e2d14cce9462fa8ba056f3406d60050a1c92");
  sub_146178DD0((__int64)v1280, &v138, &v139, (__int64)v938, 333194048i64);
  sub_146178620(v937, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_2699_to_3095.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v326, "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6");
  v138 = *(_OWORD *)sub_146178670(&v327, "414a04256bf0b00b78324478508a6beaea1ef5a7");
  sub_146178DD0((__int64)v1281, &v138, &v139, (__int64)v937, 331503702i64);
  sub_146178620(v936, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_2802_to_3095.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v328, "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6");
  v138 = *(_OWORD *)sub_146178670(&v329, "c7de68bdc56ec4577bd4fce5d85cca9a4d529839");
  sub_146178DD0((__int64)v1282, &v138, &v139, (__int64)v936, 331190538i64);
  sub_146178620(v935, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_2944_to_3095.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v330, "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6");
  v138 = *(_OWORD *)sub_146178670(&v331, "a3181d68a532950da5c584100b35f79eaca7c884");
  sub_146178DD0((__int64)v1283, &v138, &v139, (__int64)v935, 330911852i64);
  sub_146178620(v934, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_3179_to_3095.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v332, "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6");
  v138 = *(_OWORD *)sub_146178670(&v333, "cfea3456309664bf8762e3bce5957211f3ee8b39");
  sub_146178DD0((__int64)v1284, &v138, &v139, (__int64)v934, 313461829i64);
  sub_146178620(v933, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_3258_to_3095.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v334, "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6");
  v138 = *(_OWORD *)sub_146178670(&v335, "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248");
  sub_146178DD0((__int64)v1285, &v138, &v139, (__int64)v933, 328700911i64);
  sub_146178620(v932, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_3323_to_3095.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v336, "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6");
  v138 = *(_OWORD *)sub_146178670(&v337, "f2007adb84a8fc9e4481d58faf88ffca3af754c5");
  sub_146178DD0((__int64)v1286, &v138, &v139, (__int64)v932, 328715458i64);
  sub_146178620(v931, "https://content.cfx.re/mirrors/patches_fivem/3095/diffs/from_3407_to_3095.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v338, "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6");
  v138 = *(_OWORD *)sub_146178670(&v339, "b379e1752718ea1d799194b8aa70b58b28cd8c5f");
  sub_146178DD0((__int64)v1287, &v138, &v139, (__int64)v931, 328834461i64);
  *(_QWORD *)&v138 = v1280;
  *((_QWORD *)&v138 + 1) = v1288;
  sub_146178FA0(
    (__int64)v1185,
    (__int64)"update/update2.rpf",
    (__int64)"1c785e7b5cfe8331aad335b3f78952bc66b9fcb6",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/3095/update2.rpf",
    403945472i64,
    &v138);
  sub_146178620(v930, (const char *)&qword_1461217D8);
  sub_146176D00((__int64)v1467, (__int64)v930, v1185, v114);
  *(_QWORD *)&v138 = v1465;
  *((_QWORD *)&v138 + 1) = &v1468;
  sub_1461788D0((__int64 *)v177, (__int64 *)&v138);
  v150 = 3095;
  sub_146176CD0((__int64)v1156, &v150, v177);
  v139 = 0i64;
  sub_146178FA0(
    (__int64)v1184,
    (__int64)"GTA5.exe",
    (__int64)"4d968a0754d59d30b29cd7b01a06e4685a5fa49c",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2944/GTA5.exe",
    49828848i64,
    &v139);
  sub_146178620(v929, "GTA5.exe");
  sub_146176D00((__int64)v1461, (__int64)v929, v1184, v115);
  sub_146178620(v928, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_1604_to_2944.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v340, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  v138 = *(_OWORD *)sub_146178670(&v341, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  sub_146178DD0((__int64)v1431, &v138, &v139, (__int64)v928, 596587088i64);
  sub_146178620(v927, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_2060_to_2944.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v342, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  v138 = *(_OWORD *)sub_146178670(&v343, "736f1cb26e59167f302c22385463d231cce302d3");
  sub_146178DD0((__int64)v1432, &v138, &v139, (__int64)v927, 368280541i64);
  sub_146178620(v926, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_2189_to_2944.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v344, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  v138 = *(_OWORD *)sub_146178670(&v345, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  sub_146178DD0((__int64)v1433, &v138, &v139, (__int64)v926, 326614727i64);
  sub_146178620(v925, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_2372_to_2944.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v346, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  v138 = *(_OWORD *)sub_146178670(&v347, "1824cdbc27c3e0eaa86920a38751322727872831");
  sub_146178DD0((__int64)v1434, &v138, &v139, (__int64)v925, 307384637i64);
  sub_146178620(v924, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_2545_to_2944.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v348, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  v138 = *(_OWORD *)sub_146178670(&v349, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  sub_146178DD0((__int64)v1435, &v138, &v139, (__int64)v924, 166552358i64);
  sub_146178620(v923, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_2612_to_2944.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v350, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  v138 = *(_OWORD *)sub_146178670(&v351, "80f9bd028e5bc781f641fe210a88579eff827989");
  sub_146178DD0((__int64)v1436, &v138, &v139, (__int64)v923, 166551505i64);
  sub_146178620(v922, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_2699_to_2944.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v352, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  v138 = *(_OWORD *)sub_146178670(&v353, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  sub_146178DD0((__int64)v1437, &v138, &v139, (__int64)v922, 121830364i64);
  sub_146178620(v921, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_2802_to_2944.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v354, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  v138 = *(_OWORD *)sub_146178670(&v355, "66388a381347511b7b28aaf91741615e45008e8b");
  sub_146178DD0((__int64)v1438, &v138, &v139, (__int64)v921, 56081281i64);
  sub_146178620(v920, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_3095_to_2944.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v356, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  v138 = *(_OWORD *)sub_146178670(&v357, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1439, &v138, &v139, (__int64)v920, 15617655i64);
  sub_146178620(v919, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_3179_to_2944.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v358, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  v138 = *(_OWORD *)sub_146178670(&v359, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1440, &v138, &v139, (__int64)v919, 15617655i64);
  sub_146178620(v918, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_3258_to_2944.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v360, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  v138 = *(_OWORD *)sub_146178670(&v361, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  sub_146178DD0((__int64)v1441, &v138, &v139, (__int64)v918, 59814458i64);
  sub_146178620(v917, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_3323_to_2944.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v362, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  v138 = *(_OWORD *)sub_146178670(&v363, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  sub_146178DD0((__int64)v1442, &v138, &v139, (__int64)v917, 59814456i64);
  sub_146178620(v916, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_3407_to_2944.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v364, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  v138 = *(_OWORD *)sub_146178670(&v365, "f6cdcdec5e3e993a31f45acc96b638283c474f53");
  sub_146178DD0((__int64)v1443, &v138, &v139, (__int64)v916, 61283961i64);
  *(_QWORD *)&v138 = v1431;
  *((_QWORD *)&v138 + 1) = v1444;
  sub_146178FA0(
    (__int64)v1183,
    (__int64)"update/update.rpf",
    (__int64)"abc628b0ae04e68f88e0581f3572d26dbaed84d2",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2944/update.rpf",
    1087019008i64,
    &v138);
  sub_146178620(v915, (const char *)&qword_1461212B8);
  sub_146176D00((__int64)v1462, (__int64)v915, v1183, v116);
  sub_146178620(v914, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_2612_to_2944.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v366, "a3181d68a532950da5c584100b35f79eaca7c884");
  v138 = *(_OWORD *)sub_146178670(&v367, "c993e2d14cce9462fa8ba056f3406d60050a1c92");
  sub_146178DD0((__int64)v1248, &v138, &v139, (__int64)v914, 280860829i64);
  sub_146178620(v913, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_2699_to_2944.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v368, "a3181d68a532950da5c584100b35f79eaca7c884");
  v138 = *(_OWORD *)sub_146178670(&v369, "414a04256bf0b00b78324478508a6beaea1ef5a7");
  sub_146178DD0((__int64)v1249, &v138, &v139, (__int64)v913, 277845689i64);
  sub_146178620(v912, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_2802_to_2944.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v370, "a3181d68a532950da5c584100b35f79eaca7c884");
  v138 = *(_OWORD *)sub_146178670(&v371, "c7de68bdc56ec4577bd4fce5d85cca9a4d529839");
  sub_146178DD0((__int64)v1250, &v138, &v139, (__int64)v912, 277310322i64);
  sub_146178620(v911, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_3095_to_2944.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v372, "a3181d68a532950da5c584100b35f79eaca7c884");
  v138 = *(_OWORD *)sub_146178670(&v373, "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6");
  sub_146178DD0((__int64)v1251, &v138, &v139, (__int64)v911, 279052198i64);
  sub_146178620(v910, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_3179_to_2944.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v374, "a3181d68a532950da5c584100b35f79eaca7c884");
  v138 = *(_OWORD *)sub_146178670(&v375, "cfea3456309664bf8762e3bce5957211f3ee8b39");
  sub_146178DD0((__int64)v1252, &v138, &v139, (__int64)v910, 279043729i64);
  sub_146178620(v909, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_3258_to_2944.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v376, "a3181d68a532950da5c584100b35f79eaca7c884");
  v138 = *(_OWORD *)sub_146178670(&v377, "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248");
  sub_146178DD0((__int64)v1253, &v138, &v139, (__int64)v909, 279135120i64);
  sub_146178620(v908, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_3323_to_2944.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v378, "a3181d68a532950da5c584100b35f79eaca7c884");
  v138 = *(_OWORD *)sub_146178670(&v379, "f2007adb84a8fc9e4481d58faf88ffca3af754c5");
  sub_146178DD0((__int64)v1254, &v138, &v139, (__int64)v908, 279135010i64);
  sub_146178620(v907, "https://content.cfx.re/mirrors/patches_fivem/2944/diffs/from_3407_to_2944.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v380, "a3181d68a532950da5c584100b35f79eaca7c884");
  v138 = *(_OWORD *)sub_146178670(&v381, "b379e1752718ea1d799194b8aa70b58b28cd8c5f");
  sub_146178DD0((__int64)v1255, &v138, &v139, (__int64)v907, 279136123i64);
  *(_QWORD *)&v138 = v1248;
  *((_QWORD *)&v138 + 1) = v1256;
  sub_146178FA0(
    (__int64)v1182,
    (__int64)"update/update2.rpf",
    (__int64)"a3181d68a532950da5c584100b35f79eaca7c884",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2944/update2.rpf",
    352088064i64,
    &v138);
  sub_146178620(v906, (const char *)&qword_1461217D8);
  sub_146176D00((__int64)v1463, (__int64)v906, v1182, v117);
  *(_QWORD *)&v138 = v1461;
  *((_QWORD *)&v138 + 1) = &v1464;
  sub_1461788D0((__int64 *)v171, (__int64 *)&v138);
  v151 = 2944;
  sub_146176CD0((__int64)v1157, &v151, v171);
  v139 = 0i64;
  sub_146178FA0(
    (__int64)v1181,
    (__int64)"GTA5.exe",
    (__int64)"ebb6c144c5befe3529235deccbd8f59d6ce1a76c",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2802/GTA5.exe",
    46709592i64,
    &v139);
  sub_146178620(v905, "GTA5.exe");
  sub_146176D00((__int64)v1457, (__int64)v905, v1181, v118);
  sub_146178620(v904, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_1604_to_2802.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v382, "66388a381347511b7b28aaf91741615e45008e8b");
  v138 = *(_OWORD *)sub_146178670(&v383, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  sub_146178DD0((__int64)v1418, &v138, &v139, (__int64)v904, 586455637i64);
  sub_146178620(v903, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_2060_to_2802.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v384, "66388a381347511b7b28aaf91741615e45008e8b");
  v138 = *(_OWORD *)sub_146178670(&v385, "736f1cb26e59167f302c22385463d231cce302d3");
  sub_146178DD0((__int64)v1419, &v138, &v139, (__int64)v903, 356615804i64);
  sub_146178620(v902, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_2189_to_2802.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v386, "66388a381347511b7b28aaf91741615e45008e8b");
  v138 = *(_OWORD *)sub_146178670(&v387, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  sub_146178DD0((__int64)v1420, &v138, &v139, (__int64)v902, 314177287i64);
  sub_146178620(v901, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_2372_to_2802.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v388, "66388a381347511b7b28aaf91741615e45008e8b");
  v138 = *(_OWORD *)sub_146178670(&v389, "1824cdbc27c3e0eaa86920a38751322727872831");
  sub_146178DD0((__int64)v1421, &v138, &v139, (__int64)v901, 294843255i64);
  sub_146178620(v900, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_2545_to_2802.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v390, "66388a381347511b7b28aaf91741615e45008e8b");
  v138 = *(_OWORD *)sub_146178670(&v391, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  sub_146178DD0((__int64)v1422, &v138, &v139, (__int64)v900, 153796192i64);
  sub_146178620(v899, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_2612_to_2802.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v392, "66388a381347511b7b28aaf91741615e45008e8b");
  v138 = *(_OWORD *)sub_146178670(&v393, "80f9bd028e5bc781f641fe210a88579eff827989");
  sub_146178DD0((__int64)v1423, &v138, &v139, (__int64)v899, 153795013i64);
  sub_146178620(v898, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_2699_to_2802.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v394, "66388a381347511b7b28aaf91741615e45008e8b");
  v138 = *(_OWORD *)sub_146178670(&v395, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  sub_146178DD0((__int64)v1424, &v138, &v139, (__int64)v898, 107750632i64);
  sub_146178620(v897, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_2944_to_2802.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v396, "66388a381347511b7b28aaf91741615e45008e8b");
  v138 = *(_OWORD *)sub_146178670(&v397, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  sub_146178DD0((__int64)v1425, &v138, &v139, (__int64)v897, 48422944i64);
  sub_146178620(v896, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_3095_to_2802.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v398, "66388a381347511b7b28aaf91741615e45008e8b");
  v138 = *(_OWORD *)sub_146178670(&v399, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1426, &v138, &v139, (__int64)v896, 52843554i64);
  sub_146178620(v895, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_3179_to_2802.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v400, "66388a381347511b7b28aaf91741615e45008e8b");
  v138 = *(_OWORD *)sub_146178670(&v401, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1427, &v138, &v139, (__int64)v895, 52843554i64);
  sub_146178620(v894, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_3258_to_2802.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v402, "66388a381347511b7b28aaf91741615e45008e8b");
  v138 = *(_OWORD *)sub_146178670(&v403, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  sub_146178DD0((__int64)v1428, &v138, &v139, (__int64)v894, 65327489i64);
  sub_146178620(v893, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_3323_to_2802.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v404, "66388a381347511b7b28aaf91741615e45008e8b");
  v138 = *(_OWORD *)sub_146178670(&v405, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  sub_146178DD0((__int64)v1429, &v138, &v139, (__int64)v893, 65327479i64);
  sub_146178620(v892, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_3407_to_2802.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v406, "66388a381347511b7b28aaf91741615e45008e8b");
  v138 = *(_OWORD *)sub_146178670(&v407, "f6cdcdec5e3e993a31f45acc96b638283c474f53");
  sub_146178DD0((__int64)v1430, &v138, &v139, (__int64)v892, 66636258i64);
  *(_QWORD *)&v138 = v1418;
  *((_QWORD *)&v138 + 1) = v1431;
  sub_146178FA0(
    (__int64)v1180,
    (__int64)"update/update.rpf",
    (__int64)"66388a381347511b7b28aaf91741615e45008e8b",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2802/update.rpf",
    1079308288i64,
    &v138);
  sub_146178620(v891, (const char *)&qword_1461212B8);
  sub_146176D00((__int64)v1458, (__int64)v891, v1180, v119);
  sub_146178620(v890, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_2612_to_2802.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v408, "c7de68bdc56ec4577bd4fce5d85cca9a4d529839");
  v138 = *(_OWORD *)sub_146178670(&v409, "c993e2d14cce9462fa8ba056f3406d60050a1c92");
  sub_146178DD0((__int64)v1240, &v138, &v139, (__int64)v890, 273248338i64);
  sub_146178620(v889, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_2699_to_2802.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v410, "c7de68bdc56ec4577bd4fce5d85cca9a4d529839");
  v138 = *(_OWORD *)sub_146178670(&v411, "414a04256bf0b00b78324478508a6beaea1ef5a7");
  sub_146178DD0((__int64)v1241, &v138, &v139, (__int64)v889, 270218937i64);
  sub_146178620(v888, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_2944_to_2802.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v412, "c7de68bdc56ec4577bd4fce5d85cca9a4d529839");
  v138 = *(_OWORD *)sub_146178670(&v413, "a3181d68a532950da5c584100b35f79eaca7c884");
  sub_146178DD0((__int64)v1242, &v138, &v139, (__int64)v888, 269824187i64);
  sub_146178620(v887, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_3095_to_2802.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v414, "c7de68bdc56ec4577bd4fce5d85cca9a4d529839");
  v138 = *(_OWORD *)sub_146178670(&v415, "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6");
  sub_146178DD0((__int64)v1243, &v138, &v139, (__int64)v887, 271850052i64);
  sub_146178620(v886, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_3179_to_2802.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v416, "c7de68bdc56ec4577bd4fce5d85cca9a4d529839");
  v138 = *(_OWORD *)sub_146178670(&v417, "cfea3456309664bf8762e3bce5957211f3ee8b39");
  sub_146178DD0((__int64)v1244, &v138, &v139, (__int64)v886, 271841345i64);
  sub_146178620(v885, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_3258_to_2802.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v418, "c7de68bdc56ec4577bd4fce5d85cca9a4d529839");
  v138 = *(_OWORD *)sub_146178670(&v419, "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248");
  sub_146178DD0((__int64)v1245, &v138, &v139, (__int64)v885, 271934438i64);
  sub_146178620(v884, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_3323_to_2802.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v420, "c7de68bdc56ec4577bd4fce5d85cca9a4d529839");
  v138 = *(_OWORD *)sub_146178670(&v421, "f2007adb84a8fc9e4481d58faf88ffca3af754c5");
  sub_146178DD0((__int64)v1246, &v138, &v139, (__int64)v884, 271926188i64);
  sub_146178620(v883, "https://content.cfx.re/mirrors/patches_fivem/2802/diffs/from_3407_to_2802.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v422, "c7de68bdc56ec4577bd4fce5d85cca9a4d529839");
  v138 = *(_OWORD *)sub_146178670(&v423, "b379e1752718ea1d799194b8aa70b58b28cd8c5f");
  sub_146178DD0((__int64)v1247, &v138, &v139, (__int64)v883, 271939214i64);
  *(_QWORD *)&v138 = v1240;
  *((_QWORD *)&v138 + 1) = v1248;
  sub_146178FA0(
    (__int64)v1179,
    (__int64)"update/update2.rpf",
    (__int64)"c7de68bdc56ec4577bd4fce5d85cca9a4d529839",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2802/update2.rpf",
    344610816i64,
    &v138);
  sub_146178620(v882, (const char *)&qword_1461217D8);
  sub_146176D00((__int64)v1459, (__int64)v882, v1179, v120);
  *(_QWORD *)&v138 = v1457;
  *((_QWORD *)&v138 + 1) = &v1460;
  sub_1461788D0((__int64 *)v170, (__int64 *)&v138);
  v152 = 2802;
  sub_146176CD0((__int64)v1158, &v152, v170);
  v139 = 0i64;
  sub_146178FA0(
    (__int64)v1178,
    (__int64)"GTA5.exe",
    (__int64)"b9f3960ca0c7c05aab23d3b1d158309bc085fbbe",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2699/GTA5.exe",
    61111680i64,
    &v139);
  sub_146178620(v881, "GTA5.exe");
  sub_146176D00((__int64)v1481, (__int64)v881, v1178, v121);
  sub_146178620(v880, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_1604_to_2699.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v424, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  v138 = *(_OWORD *)sub_146178670(&v425, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  sub_146178DD0((__int64)v1405, &v138, &v139, (__int64)v880, 577779656i64);
  sub_146178620(v879, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_2060_to_2699.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v426, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  v138 = *(_OWORD *)sub_146178670(&v427, "736f1cb26e59167f302c22385463d231cce302d3");
  sub_146178DD0((__int64)v1406, &v138, &v139, (__int64)v879, 346805883i64);
  sub_146178620(v878, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_2189_to_2699.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v428, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  v138 = *(_OWORD *)sub_146178670(&v429, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  sub_146178DD0((__int64)v1407, &v138, &v139, (__int64)v878, 304782654i64);
  sub_146178620(v877, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_2372_to_2699.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v430, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  v138 = *(_OWORD *)sub_146178670(&v431, "1824cdbc27c3e0eaa86920a38751322727872831");
  sub_146178DD0((__int64)v1408, &v138, &v139, (__int64)v877, 285467525i64);
  sub_146178620(v876, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_2545_to_2699.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v432, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  v138 = *(_OWORD *)sub_146178670(&v433, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  sub_146178DD0((__int64)v1409, &v138, &v139, (__int64)v876, 144813901i64);
  sub_146178620(v875, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_2612_to_2699.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v434, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  v138 = *(_OWORD *)sub_146178670(&v435, "80f9bd028e5bc781f641fe210a88579eff827989");
  sub_146178DD0((__int64)v1410, &v138, &v139, (__int64)v875, 144812091i64);
  sub_146178620(v874, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_2802_to_2699.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v436, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  v138 = *(_OWORD *)sub_146178670(&v437, "66388a381347511b7b28aaf91741615e45008e8b");
  sub_146178DD0((__int64)v1411, &v138, &v139, (__int64)v874, 102324935i64);
  sub_146178620(v873, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_2944_to_2699.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v438, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  v138 = *(_OWORD *)sub_146178670(&v439, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  sub_146178DD0((__int64)v1412, &v138, &v139, (__int64)v873, 108745603i64);
  sub_146178620(v872, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_3095_to_2699.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v440, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  v138 = *(_OWORD *)sub_146178670(&v441, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1413, &v138, &v139, (__int64)v872, 113480643i64);
  sub_146178620(v871, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_3179_to_2699.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v442, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  v138 = *(_OWORD *)sub_146178670(&v443, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1414, &v138, &v139, (__int64)v871, 113480643i64);
  sub_146178620(v870, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_3258_to_2699.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v444, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  v138 = *(_OWORD *)sub_146178670(&v445, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  sub_146178DD0((__int64)v1415, &v138, &v139, (__int64)v870, 116581930i64);
  sub_146178620(v869, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_3323_to_2699.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v446, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  v138 = *(_OWORD *)sub_146178670(&v447, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  sub_146178DD0((__int64)v1416, &v138, &v139, (__int64)v869, 116581929i64);
  sub_146178620(v868, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_3407_to_2699.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v448, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  v138 = *(_OWORD *)sub_146178670(&v449, "f6cdcdec5e3e993a31f45acc96b638283c474f53");
  sub_146178DD0((__int64)v1417, &v138, &v139, (__int64)v868, 117825124i64);
  *(_QWORD *)&v138 = v1405;
  *((_QWORD *)&v138 + 1) = v1418;
  sub_146178FA0(
    (__int64)v1177,
    (__int64)"update/update.rpf",
    (__int64)"86d88c5ea36e67683a138c0e690c42fe288205fa",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2699/update.rpf",
    1073854464i64,
    &v138);
  sub_146178620(v867, (const char *)&qword_1461212B8);
  sub_146176D00((__int64)v1482, (__int64)v867, v1177, v122);
  sub_146178620(v866, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_2612_to_2699.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v450, "414a04256bf0b00b78324478508a6beaea1ef5a7");
  v138 = *(_OWORD *)sub_146178670(&v451, "c993e2d14cce9462fa8ba056f3406d60050a1c92");
  sub_146178DD0((__int64)v1232, &v138, &v139, (__int64)v866, 252956098i64);
  sub_146178620(v865, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_2802_to_2699.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v452, "414a04256bf0b00b78324478508a6beaea1ef5a7");
  v138 = *(_OWORD *)sub_146178670(&v453, "c7de68bdc56ec4577bd4fce5d85cca9a4d529839");
  sub_146178DD0((__int64)v1233, &v138, &v139, (__int64)v865, 250133852i64);
  sub_146178620(v864, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_2944_to_2699.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v454, "414a04256bf0b00b78324478508a6beaea1ef5a7");
  v138 = *(_OWORD *)sub_146178670(&v455, "a3181d68a532950da5c584100b35f79eaca7c884");
  sub_146178DD0((__int64)v1234, &v138, &v139, (__int64)v864, 250283500i64);
  sub_146178620(v863, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_3095_to_2699.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v456, "414a04256bf0b00b78324478508a6beaea1ef5a7");
  v138 = *(_OWORD *)sub_146178670(&v457, "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6");
  sub_146178DD0((__int64)v1235, &v138, &v139, (__int64)v863, 252084865i64);
  sub_146178620(v862, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_3179_to_2699.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v458, "414a04256bf0b00b78324478508a6beaea1ef5a7");
  v138 = *(_OWORD *)sub_146178670(&v459, "cfea3456309664bf8762e3bce5957211f3ee8b39");
  sub_146178DD0((__int64)v1236, &v138, &v139, (__int64)v862, 252085404i64);
  sub_146178620(v861, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_3258_to_2699.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v460, "414a04256bf0b00b78324478508a6beaea1ef5a7");
  v138 = *(_OWORD *)sub_146178670(&v461, "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248");
  sub_146178DD0((__int64)v1237, &v138, &v139, (__int64)v861, 252153440i64);
  sub_146178620(v860, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_3323_to_2699.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v462, "414a04256bf0b00b78324478508a6beaea1ef5a7");
  v138 = *(_OWORD *)sub_146178670(&v463, "f2007adb84a8fc9e4481d58faf88ffca3af754c5");
  sub_146178DD0((__int64)v1238, &v138, &v139, (__int64)v860, 252145327i64);
  sub_146178620(v859, "https://content.cfx.re/mirrors/patches_fivem/2699/diffs/from_3407_to_2699.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v464, "414a04256bf0b00b78324478508a6beaea1ef5a7");
  v138 = *(_OWORD *)sub_146178670(&v465, "b379e1752718ea1d799194b8aa70b58b28cd8c5f");
  sub_146178DD0((__int64)v1239, &v138, &v139, (__int64)v859, 252158158i64);
  *(_QWORD *)&v138 = v1232;
  *((_QWORD *)&v138 + 1) = v1240;
  sub_146178FA0(
    (__int64)v1176,
    (__int64)"update/update2.rpf",
    (__int64)"414a04256bf0b00b78324478508a6beaea1ef5a7",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2699/update2.rpf",
    324530176i64,
    &v138);
  sub_146178620(v858, (const char *)&qword_1461217D8);
  sub_146176D00((__int64)v1483, (__int64)v858, v1176, v123);
  *(_QWORD *)&v138 = v1481;
  *((_QWORD *)&v138 + 1) = &v1484;
  sub_1461788D0((__int64 *)v169, (__int64 *)&v138);
  v153 = 2699;
  sub_146176CD0((__int64)v1159, &v153, v169);
  v139 = 0i64;
  sub_146178FA0(
    (__int64)v1175,
    (__int64)"GTA5.exe",
    (__int64)"d423086fd7a7721b8be77cfb9a4f8826784b284b",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2612/GTA5.exe",
    60351952i64,
    &v139);
  sub_146178620(v857, "GTA5.exe");
  sub_146176D00((__int64)v1477, (__int64)v857, v1175, v124);
  sub_146178620(v856, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_1604_to_2612.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v466, "80f9bd028e5bc781f641fe210a88579eff827989");
  v138 = *(_OWORD *)sub_146178670(&v467, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  sub_146178DD0((__int64)v1392, &v138, &v139, (__int64)v856, 560353786i64);
  sub_146178620(v855, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_2060_to_2612.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v468, "80f9bd028e5bc781f641fe210a88579eff827989");
  v138 = *(_OWORD *)sub_146178670(&v469, "736f1cb26e59167f302c22385463d231cce302d3");
  sub_146178DD0((__int64)v1393, &v138, &v139, (__int64)v855, 330036916i64);
  sub_146178620(v854, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_2189_to_2612.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v470, "80f9bd028e5bc781f641fe210a88579eff827989");
  v138 = *(_OWORD *)sub_146178670(&v471, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  sub_146178DD0((__int64)v1394, &v138, &v139, (__int64)v854, 287033107i64);
  sub_146178620(v853, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_2372_to_2612.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v472, "80f9bd028e5bc781f641fe210a88579eff827989");
  v138 = *(_OWORD *)sub_146178670(&v473, "1824cdbc27c3e0eaa86920a38751322727872831");
  sub_146178DD0((__int64)v1395, &v138, &v139, (__int64)v853, 266987849i64);
  sub_146178620(v852, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_2545_to_2612.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v474, "80f9bd028e5bc781f641fe210a88579eff827989");
  v138 = *(_OWORD *)sub_146178670(&v475, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  sub_146178DD0((__int64)v1396, &v138, &v139, (__int64)v852, 1840945i64);
  sub_146178620(v851, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_2699_to_2612.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v476, "80f9bd028e5bc781f641fe210a88579eff827989");
  v138 = *(_OWORD *)sub_146178670(&v477, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  sub_146178DD0((__int64)v1397, &v138, &v139, (__int64)v851, 127701528i64);
  sub_146178620(v850, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_2802_to_2612.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v478, "80f9bd028e5bc781f641fe210a88579eff827989");
  v138 = *(_OWORD *)sub_146178670(&v479, "66388a381347511b7b28aaf91741615e45008e8b");
  sub_146178DD0((__int64)v1398, &v138, &v139, (__int64)v850, 131292485i64);
  sub_146178620(v849, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_2944_to_2612.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v480, "80f9bd028e5bc781f641fe210a88579eff827989");
  v138 = *(_OWORD *)sub_146178670(&v481, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  sub_146178DD0((__int64)v1399, &v138, &v139, (__int64)v849, 136386970i64);
  sub_146178620(v848, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_3095_to_2612.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v482, "80f9bd028e5bc781f641fe210a88579eff827989");
  v138 = *(_OWORD *)sub_146178670(&v483, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1400, &v138, &v139, (__int64)v848, 140238453i64);
  sub_146178620(v847, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_3179_to_2612.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v484, "80f9bd028e5bc781f641fe210a88579eff827989");
  v138 = *(_OWORD *)sub_146178670(&v485, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1401, &v138, &v139, (__int64)v847, 140238453i64);
  sub_146178620(v846, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_3258_to_2612.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v486, "80f9bd028e5bc781f641fe210a88579eff827989");
  v138 = *(_OWORD *)sub_146178670(&v487, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  sub_146178DD0((__int64)v1402, &v138, &v139, (__int64)v846, 144229149i64);
  sub_146178620(v845, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_3323_to_2612.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v488, "80f9bd028e5bc781f641fe210a88579eff827989");
  v138 = *(_OWORD *)sub_146178670(&v489, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  sub_146178DD0((__int64)v1403, &v138, &v139, (__int64)v845, 144229138i64);
  sub_146178620(v844, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_3407_to_2612.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v490, "80f9bd028e5bc781f641fe210a88579eff827989");
  v138 = *(_OWORD *)sub_146178670(&v491, "f6cdcdec5e3e993a31f45acc96b638283c474f53");
  sub_146178DD0((__int64)v1404, &v138, &v139, (__int64)v844, 145561398i64);
  *(_QWORD *)&v138 = v1392;
  *((_QWORD *)&v138 + 1) = v1405;
  sub_146178FA0(
    (__int64)v1174,
    (__int64)"update/update.rpf",
    (__int64)"80f9bd028e5bc781f641fe210a88579eff827989",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2612/update.rpf",
    1056649216i64,
    &v138);
  sub_146178620(v843, (const char *)&qword_1461212B8);
  sub_146176D00((__int64)v1478, (__int64)v843, v1174, v125);
  sub_146178620(v842, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_2699_to_2612.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v492, "c993e2d14cce9462fa8ba056f3406d60050a1c92");
  v138 = *(_OWORD *)sub_146178670(&v493, "414a04256bf0b00b78324478508a6beaea1ef5a7");
  sub_146178DD0((__int64)v1224, &v138, &v139, (__int64)v842, 240637812i64);
  sub_146178620(v841, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_2802_to_2612.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v494, "c993e2d14cce9462fa8ba056f3406d60050a1c92");
  v138 = *(_OWORD *)sub_146178670(&v495, "c7de68bdc56ec4577bd4fce5d85cca9a4d529839");
  sub_146178DD0((__int64)v1225, &v138, &v139, (__int64)v841, 240847147i64);
  sub_146178620(v840, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_2944_to_2612.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v496, "c993e2d14cce9462fa8ba056f3406d60050a1c92");
  v138 = *(_OWORD *)sub_146178670(&v497, "a3181d68a532950da5c584100b35f79eaca7c884");
  sub_146178DD0((__int64)v1226, &v138, &v139, (__int64)v840, 240982514i64);
  sub_146178620(v839, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_3095_to_2612.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v498, "c993e2d14cce9462fa8ba056f3406d60050a1c92");
  v138 = *(_OWORD *)sub_146178670(&v499, "1c785e7b5cfe8331aad335b3f78952bc66b9fcb6");
  sub_146178DD0((__int64)v1227, &v138, &v139, (__int64)v839, 241447960i64);
  sub_146178620(v838, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_3179_to_2612.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v500, "c993e2d14cce9462fa8ba056f3406d60050a1c92");
  v138 = *(_OWORD *)sub_146178670(&v501, "cfea3456309664bf8762e3bce5957211f3ee8b39");
  sub_146178DD0((__int64)v1228, &v138, &v139, (__int64)v838, 241446618i64);
  sub_146178620(v837, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_3258_to_2612.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v502, "c993e2d14cce9462fa8ba056f3406d60050a1c92");
  v138 = *(_OWORD *)sub_146178670(&v503, "6e7c1bdd4b0b8d47ac28bef19d2644f3240ad248");
  sub_146178DD0((__int64)v1229, &v138, &v139, (__int64)v837, 241517010i64);
  sub_146178620(v836, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_3323_to_2612.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v504, "c993e2d14cce9462fa8ba056f3406d60050a1c92");
  v138 = *(_OWORD *)sub_146178670(&v505, "f2007adb84a8fc9e4481d58faf88ffca3af754c5");
  sub_146178DD0((__int64)v1230, &v138, &v139, (__int64)v836, 241507622i64);
  sub_146178620(v835, "https://content.cfx.re/mirrors/patches_fivem/2612/diffs/from_3407_to_2612.update2.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v506, "c993e2d14cce9462fa8ba056f3406d60050a1c92");
  v138 = *(_OWORD *)sub_146178670(&v507, "b379e1752718ea1d799194b8aa70b58b28cd8c5f");
  sub_146178DD0((__int64)v1231, &v138, &v139, (__int64)v835, 241528234i64);
  *(_QWORD *)&v138 = v1224;
  *((_QWORD *)&v138 + 1) = v1232;
  sub_146178FA0(
    (__int64)v1173,
    (__int64)"update/update2.rpf",
    (__int64)"c993e2d14cce9462fa8ba056f3406d60050a1c92",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2612/update2.rpf",
    312209408i64,
    &v138);
  sub_146178620(v834, (const char *)&qword_1461217D8);
  sub_146176D00((__int64)v1479, (__int64)v834, v1173, v126);
  *(_QWORD *)&v138 = v1477;
  *((_QWORD *)&v138 + 1) = &v1480;
  sub_1461788D0((__int64 *)v168, (__int64 *)&v138);
  v154 = 2612;
  sub_146176CD0((__int64)v1160, &v154, v168);
  v139 = 0i64;
  sub_146178FA0(
    (__int64)v1172,
    (__int64)"GTA5.exe",
    (__int64)"517556bb548880362c18d502361ce374070994c2",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2545/GTA5.exe",
    59988376i64,
    &v139);
  sub_146178620(v833, "GTA5.exe");
  sub_146176D00((__int64)v1290, (__int64)v833, v1172, v127);
  sub_146178620(v832, "https://content.cfx.re/mirrors/patches_fivem/2545/diffs/from_1604_to_2545.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v508, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  v138 = *(_OWORD *)sub_146178670(&v509, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  sub_146178DD0((__int64)v1379, &v138, &v139, (__int64)v832, 804698938i64);
  sub_146178620(v831, "https://content.cfx.re/mirrors/patches_fivem/2545/diffs/from_2060_to_2545.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v510, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  v138 = *(_OWORD *)sub_146178670(&v511, "736f1cb26e59167f302c22385463d231cce302d3");
  sub_146178DD0((__int64)v1380, &v138, &v139, (__int64)v831, 573692039i64);
  sub_146178620(v830, "https://content.cfx.re/mirrors/patches_fivem/2545/diffs/from_2189_to_2545.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v512, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  v138 = *(_OWORD *)sub_146178670(&v513, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  sub_146178DD0((__int64)v1381, &v138, &v139, (__int64)v830, 529825735i64);
  sub_146178620(v829, "https://content.cfx.re/mirrors/patches_fivem/2545/diffs/from_2372_to_2545.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v514, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  v138 = *(_OWORD *)sub_146178670(&v515, "1824cdbc27c3e0eaa86920a38751322727872831");
  sub_146178DD0((__int64)v1382, &v138, &v139, (__int64)v829, 509055770i64);
  sub_146178620(v828, "https://content.cfx.re/mirrors/patches_fivem/2545/diffs/from_2612_to_2545.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v516, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  v138 = *(_OWORD *)sub_146178670(&v517, "80f9bd028e5bc781f641fe210a88579eff827989");
  sub_146178DD0((__int64)v1383, &v138, &v139, (__int64)v828, 311774185i64);
  sub_146178620(v827, "https://content.cfx.re/mirrors/patches_fivem/2545/diffs/from_2699_to_2545.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v518, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  v138 = *(_OWORD *)sub_146178670(&v519, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  sub_146178DD0((__int64)v1384, &v138, &v139, (__int64)v827, 437636032i64);
  sub_146178620(v826, "https://content.cfx.re/mirrors/patches_fivem/2545/diffs/from_2802_to_2545.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v520, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  v138 = *(_OWORD *)sub_146178670(&v521, "66388a381347511b7b28aaf91741615e45008e8b");
  sub_146178DD0((__int64)v1385, &v138, &v139, (__int64)v826, 441227939i64);
  sub_146178620(v825, "https://content.cfx.re/mirrors/patches_fivem/2545/diffs/from_2944_to_2545.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v522, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  v138 = *(_OWORD *)sub_146178670(&v523, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  sub_146178DD0((__int64)v1386, &v138, &v139, (__int64)v825, 446324800i64);
  sub_146178620(v824, "https://content.cfx.re/mirrors/patches_fivem/2545/diffs/from_3095_to_2545.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v524, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  v138 = *(_OWORD *)sub_146178670(&v525, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1387, &v138, &v139, (__int64)v824, 450172651i64);
  sub_146178620(v823, "https://content.cfx.re/mirrors/patches_fivem/2545/diffs/from_3179_to_2545.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v526, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  v138 = *(_OWORD *)sub_146178670(&v527, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1388, &v138, &v139, (__int64)v823, 450172651i64);
  sub_146178620(v822, "https://content.cfx.re/mirrors/patches_fivem/2545/diffs/from_3258_to_2545.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v528, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  v138 = *(_OWORD *)sub_146178670(&v529, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  sub_146178DD0((__int64)v1389, &v138, &v139, (__int64)v822, 454165325i64);
  sub_146178620(v821, "https://content.cfx.re/mirrors/patches_fivem/2545/diffs/from_3323_to_2545.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v530, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  v138 = *(_OWORD *)sub_146178670(&v531, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  sub_146178DD0((__int64)v1390, &v138, &v139, (__int64)v821, 454165319i64);
  sub_146178620(v820, "https://content.cfx.re/mirrors/patches_fivem/2545/diffs/from_3407_to_2545.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v532, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  v138 = *(_OWORD *)sub_146178670(&v533, "f6cdcdec5e3e993a31f45acc96b638283c474f53");
  sub_146178DD0((__int64)v1391, &v138, &v139, (__int64)v820, 455494428i64);
  *(_QWORD *)&v138 = v1379;
  *((_QWORD *)&v138 + 1) = v1392;
  sub_146178FA0(
    (__int64)v1171,
    (__int64)"update/update.rpf",
    (__int64)"2993b3c30f61cbbb8dbce859604d7fb717ff8dae",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2545/update.rpf",
    1366638592i64,
    &v138);
  sub_146178620(v819, (const char *)&qword_1461212B8);
  sub_146176D00((__int64)v1291, (__int64)v819, v1171, v128);
  *(_QWORD *)&v138 = v1290;
  *((_QWORD *)&v138 + 1) = v1292;
  sub_1461788D0((__int64 *)v172, (__int64 *)&v138);
  v155 = 2545;
  sub_146176CD0((__int64)v1161, &v155, v172);
  v139 = 0i64;
  sub_146178FA0(
    (__int64)v1170,
    (__int64)"GTA5.exe",
    (__int64)"470235e04299b02aa3aef834ef1ff834cac2327f",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2372/GTA5.exe",
    59716912i64,
    &v139);
  sub_146178620(v818, "GTA5.exe");
  sub_146176D00((__int64)v1288, (__int64)v818, v1170, v129);
  sub_146178620(v817, "https://content.cfx.re/mirrors/patches_fivem/2372/diffs/from_1604_to_2372.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v534, "1824cdbc27c3e0eaa86920a38751322727872831");
  v138 = *(_OWORD *)sub_146178670(&v535, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  sub_146178DD0((__int64)v1366, &v138, &v139, (__int64)v817, 562253582i64);
  sub_146178620(v816, "https://content.cfx.re/mirrors/patches_fivem/2372/diffs/from_2060_to_2372.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v536, "1824cdbc27c3e0eaa86920a38751322727872831");
  v138 = *(_OWORD *)sub_146178670(&v537, "736f1cb26e59167f302c22385463d231cce302d3");
  sub_146178DD0((__int64)v1367, &v138, &v139, (__int64)v816, 329760934i64);
  sub_146178620(v815, "https://content.cfx.re/mirrors/patches_fivem/2372/diffs/from_2189_to_2372.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v538, "1824cdbc27c3e0eaa86920a38751322727872831");
  v138 = *(_OWORD *)sub_146178670(&v539, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  sub_146178DD0((__int64)v1368, &v138, &v139, (__int64)v815, 284412077i64);
  sub_146178620(v814, "https://content.cfx.re/mirrors/patches_fivem/2372/diffs/from_2545_to_2372.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v540, "1824cdbc27c3e0eaa86920a38751322727872831");
  v138 = *(_OWORD *)sub_146178670(&v541, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  sub_146178DD0((__int64)v1369, &v138, &v139, (__int64)v814, 276106385i64);
  sub_146178620(v813, "https://content.cfx.re/mirrors/patches_fivem/2372/diffs/from_2612_to_2372.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v542, "1824cdbc27c3e0eaa86920a38751322727872831");
  v138 = *(_OWORD *)sub_146178670(&v543, "80f9bd028e5bc781f641fe210a88579eff827989");
  sub_146178DD0((__int64)v1370, &v138, &v139, (__int64)v813, 343976392i64);
  sub_146178620(v812, "https://content.cfx.re/mirrors/patches_fivem/2372/diffs/from_2699_to_2372.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v544, "1824cdbc27c3e0eaa86920a38751322727872831");
  v138 = *(_OWORD *)sub_146178670(&v545, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  sub_146178DD0((__int64)v1371, &v138, &v139, (__int64)v812, 345348050i64);
  sub_146178620(v811, "https://content.cfx.re/mirrors/patches_fivem/2372/diffs/from_2802_to_2372.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v546, "1824cdbc27c3e0eaa86920a38751322727872831");
  v138 = *(_OWORD *)sub_146178670(&v547, "66388a381347511b7b28aaf91741615e45008e8b");
  sub_146178DD0((__int64)v1372, &v138, &v139, (__int64)v811, 349288020i64);
  sub_146178620(v810, "https://content.cfx.re/mirrors/patches_fivem/2372/diffs/from_2944_to_2372.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v548, "1824cdbc27c3e0eaa86920a38751322727872831");
  v138 = *(_OWORD *)sub_146178670(&v549, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  sub_146178DD0((__int64)v1373, &v138, &v139, (__int64)v810, 354164718i64);
  sub_146178620(v809, "https://content.cfx.re/mirrors/patches_fivem/2372/diffs/from_3095_to_2372.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v550, "1824cdbc27c3e0eaa86920a38751322727872831");
  v138 = *(_OWORD *)sub_146178670(&v551, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1374, &v138, &v139, (__int64)v809, 356862631i64);
  sub_146178620(v808, "https://content.cfx.re/mirrors/patches_fivem/2372/diffs/from_3179_to_2372.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v552, "1824cdbc27c3e0eaa86920a38751322727872831");
  v138 = *(_OWORD *)sub_146178670(&v553, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1375, &v138, &v139, (__int64)v808, 356862631i64);
  sub_146178620(v807, "https://content.cfx.re/mirrors/patches_fivem/2372/diffs/from_3258_to_2372.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v554, "1824cdbc27c3e0eaa86920a38751322727872831");
  v138 = *(_OWORD *)sub_146178670(&v555, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  sub_146178DD0((__int64)v1376, &v138, &v139, (__int64)v807, 359924636i64);
  sub_146178620(v806, "https://content.cfx.re/mirrors/patches_fivem/2372/diffs/from_3323_to_2372.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v556, "1824cdbc27c3e0eaa86920a38751322727872831");
  v138 = *(_OWORD *)sub_146178670(&v557, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  sub_146178DD0((__int64)v1377, &v138, &v139, (__int64)v806, 359924634i64);
  sub_146178620(v805, "https://content.cfx.re/mirrors/patches_fivem/2372/diffs/from_3407_to_2372.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v558, "1824cdbc27c3e0eaa86920a38751322727872831");
  v138 = *(_OWORD *)sub_146178670(&v559, "f6cdcdec5e3e993a31f45acc96b638283c474f53");
  sub_146178DD0((__int64)v1378, &v138, &v139, (__int64)v805, 360756556i64);
  *(_QWORD *)&v138 = v1366;
  *((_QWORD *)&v138 + 1) = v1379;
  sub_146178FA0(
    (__int64)v1169,
    (__int64)"update/update.rpf",
    (__int64)"1824cdbc27c3e0eaa86920a38751322727872831",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2372/update.rpf",
    1132066816i64,
    &v138);
  sub_146178620(v804, (const char *)&qword_1461212B8);
  sub_146176D00((__int64)v1289, (__int64)v804, v1169, v130);
  *(_QWORD *)&v138 = v1288;
  *((_QWORD *)&v138 + 1) = v1290;
  sub_1461788D0((__int64 *)v167, (__int64 *)&v138);
  v159 = 2372;
  sub_146176CD0((__int64)v1162, &v159, v167);
  v139 = 0i64;
  sub_146178FA0(
    (__int64)v1168,
    (__int64)"GTA5.exe",
    (__int64)"fcd5fd8a9f99f2e08b0cab5d500740f28a75b75a",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2189/GTA5.exe",
    63124096i64,
    &v139);
  sub_146178620(v803, "GTA5.exe");
  sub_146176D00((__int64)v1296, (__int64)v803, v1168, v131);
  sub_146178620(v802, "https://content.cfx.re/mirrors/patches_fivem/2189/diffs/from_1604_to_2189.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v560, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  v138 = *(_OWORD *)sub_146178670(&v561, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  sub_146178DD0((__int64)v1353, &v138, &v139, (__int64)v802, 562451691i64);
  sub_146178620(v801, "https://content.cfx.re/mirrors/patches_fivem/2189/diffs/from_2060_to_2189.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v562, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  v138 = *(_OWORD *)sub_146178670(&v563, "736f1cb26e59167f302c22385463d231cce302d3");
  sub_146178DD0((__int64)v1354, &v138, &v139, (__int64)v801, 296656003i64);
  sub_146178620(v800, "https://content.cfx.re/mirrors/patches_fivem/2189/diffs/from_2372_to_2189.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v564, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  v138 = *(_OWORD *)sub_146178670(&v565, "1824cdbc27c3e0eaa86920a38751322727872831");
  sub_146178DD0((__int64)v1355, &v138, &v139, (__int64)v800, 429153146i64);
  sub_146178620(v799, "https://content.cfx.re/mirrors/patches_fivem/2189/diffs/from_2545_to_2189.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v566, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  v138 = *(_OWORD *)sub_146178670(&v567, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  sub_146178DD0((__int64)v1356, &v138, &v139, (__int64)v799, 441617306i64);
  sub_146178620(v798, "https://content.cfx.re/mirrors/patches_fivem/2189/diffs/from_2612_to_2189.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v568, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  v138 = *(_OWORD *)sub_146178670(&v569, "80f9bd028e5bc781f641fe210a88579eff827989");
  sub_146178DD0((__int64)v1357, &v138, &v139, (__int64)v798, 508757790i64);
  sub_146178620(v797, "https://content.cfx.re/mirrors/patches_fivem/2189/diffs/from_2699_to_2189.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v570, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  v138 = *(_OWORD *)sub_146178670(&v571, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  sub_146178DD0((__int64)v1358, &v138, &v139, (__int64)v797, 509396786i64);
  sub_146178620(v796, "https://content.cfx.re/mirrors/patches_fivem/2189/diffs/from_2802_to_2189.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v572, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  v138 = *(_OWORD *)sub_146178670(&v573, "66388a381347511b7b28aaf91741615e45008e8b");
  sub_146178DD0((__int64)v1359, &v138, &v139, (__int64)v796, 513356064i64);
  sub_146178620(v795, "https://content.cfx.re/mirrors/patches_fivem/2189/diffs/from_2944_to_2189.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v574, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  v138 = *(_OWORD *)sub_146178670(&v575, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  sub_146178DD0((__int64)v1360, &v138, &v139, (__int64)v795, 518134363i64);
  sub_146178620(v794, "https://content.cfx.re/mirrors/patches_fivem/2189/diffs/from_3095_to_2189.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v576, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  v138 = *(_OWORD *)sub_146178670(&v577, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1361, &v138, &v139, (__int64)v794, 518604133i64);
  sub_146178620(v793, "https://content.cfx.re/mirrors/patches_fivem/2189/diffs/from_3179_to_2189.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v578, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  v138 = *(_OWORD *)sub_146178670(&v579, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1362, &v138, &v139, (__int64)v793, 518604133i64);
  sub_146178620(v792, "https://content.cfx.re/mirrors/patches_fivem/2189/diffs/from_3258_to_2189.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v580, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  v138 = *(_OWORD *)sub_146178670(&v581, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  sub_146178DD0((__int64)v1363, &v138, &v139, (__int64)v792, 521239366i64);
  sub_146178620(v791, "https://content.cfx.re/mirrors/patches_fivem/2189/diffs/from_3323_to_2189.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v582, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  v138 = *(_OWORD *)sub_146178670(&v583, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  sub_146178DD0((__int64)v1364, &v138, &v139, (__int64)v791, 521239331i64);
  sub_146178620(v790, "https://content.cfx.re/mirrors/patches_fivem/2189/diffs/from_3407_to_2189.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v584, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  v138 = *(_OWORD *)sub_146178670(&v585, "f6cdcdec5e3e993a31f45acc96b638283c474f53");
  sub_146178DD0((__int64)v1365, &v138, &v139, (__int64)v790, 522046015i64);
  *(_QWORD *)&v138 = v1353;
  *((_QWORD *)&v138 + 1) = v1366;
  sub_146178FA0(
    (__int64)v1167,
    (__int64)"update/update.rpf",
    (__int64)"fe387dbc0f700d690b53d44ce1226c624c24b8fc",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2189/update.rpf",
    1276805120i64,
    &v138);
  sub_146178620(v789, (const char *)&qword_1461212B8);
  sub_146176D00((__int64)v1297, (__int64)v789, v1167, v132);
  *(_QWORD *)&v138 = v1296;
  *((_QWORD *)&v138 + 1) = v1298;
  sub_1461788D0((__int64 *)v166, (__int64 *)&v138);
  v156 = 2189;
  sub_146176CD0((__int64)v1163, &v156, v166);
  v139 = 0i64;
  sub_146178FA0(
    (__int64)v1166,
    (__int64)"GTA5.exe",
    (__int64)"741c8b91ef57140c023d8d29e38aab599759de76",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2060/GTA5.exe",
    60589184i64,
    &v139);
  sub_146178620(v788, "GTA5.exe");
  sub_146176D00((__int64)v1294, (__int64)v788, v1166, v133);
  sub_146178620(v787, "https://content.cfx.re/mirrors/patches_fivem/2060/diffs/from_1604_to_2060.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v586, "736f1cb26e59167f302c22385463d231cce302d3");
  v138 = *(_OWORD *)sub_146178670(&v587, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  sub_146178DD0((__int64)v1340, &v138, &v139, (__int64)v787, 512193764i64);
  sub_146178620(v786, "https://content.cfx.re/mirrors/patches_fivem/2060/diffs/from_2189_to_2060.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v588, "736f1cb26e59167f302c22385463d231cce302d3");
  v138 = *(_OWORD *)sub_146178670(&v589, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  sub_146178DD0((__int64)v1341, &v138, &v139, (__int64)v786, 249363428i64);
  sub_146178620(v785, "https://content.cfx.re/mirrors/patches_fivem/2060/diffs/from_2372_to_2060.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v590, "736f1cb26e59167f302c22385463d231cce302d3");
  v138 = *(_OWORD *)sub_146178670(&v591, "1824cdbc27c3e0eaa86920a38751322727872831");
  sub_146178DD0((__int64)v1342, &v138, &v139, (__int64)v785, 427205591i64);
  sub_146178620(v784, "https://content.cfx.re/mirrors/patches_fivem/2060/diffs/from_2545_to_2060.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v592, "736f1cb26e59167f302c22385463d231cce302d3");
  v138 = *(_OWORD *)sub_146178670(&v593, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  sub_146178DD0((__int64)v1343, &v138, &v139, (__int64)v784, 438194552i64);
  sub_146178620(v783, "https://content.cfx.re/mirrors/patches_fivem/2060/diffs/from_2612_to_2060.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v594, "736f1cb26e59167f302c22385463d231cce302d3");
  v138 = *(_OWORD *)sub_146178670(&v595, "80f9bd028e5bc781f641fe210a88579eff827989");
  sub_146178DD0((__int64)v1344, &v138, &v139, (__int64)v783, 504469096i64);
  sub_146178620(v782, "https://content.cfx.re/mirrors/patches_fivem/2060/diffs/from_2699_to_2060.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v596, "736f1cb26e59167f302c22385463d231cce302d3");
  v138 = *(_OWORD *)sub_146178670(&v597, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  sub_146178DD0((__int64)v1345, &v138, &v139, (__int64)v782, 504126319i64);
  sub_146178620(v781, "https://content.cfx.re/mirrors/patches_fivem/2060/diffs/from_2802_to_2060.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v598, "736f1cb26e59167f302c22385463d231cce302d3");
  v138 = *(_OWORD *)sub_146178670(&v599, "66388a381347511b7b28aaf91741615e45008e8b");
  sub_146178DD0((__int64)v1346, &v138, &v139, (__int64)v781, 508501688i64);
  sub_146178620(v780, "https://content.cfx.re/mirrors/patches_fivem/2060/diffs/from_2944_to_2060.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v600, "736f1cb26e59167f302c22385463d231cce302d3");
  v138 = *(_OWORD *)sub_146178670(&v601, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  sub_146178DD0((__int64)v1347, &v138, &v139, (__int64)v780, 512509365i64);
  sub_146178620(v779, "https://content.cfx.re/mirrors/patches_fivem/2060/diffs/from_3095_to_2060.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v602, "736f1cb26e59167f302c22385463d231cce302d3");
  v138 = *(_OWORD *)sub_146178670(&v603, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1348, &v138, &v139, (__int64)v779, 512663221i64);
  sub_146178620(v778, "https://content.cfx.re/mirrors/patches_fivem/2060/diffs/from_3179_to_2060.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v604, "736f1cb26e59167f302c22385463d231cce302d3");
  v138 = *(_OWORD *)sub_146178670(&v605, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1349, &v138, &v139, (__int64)v778, 512663221i64);
  sub_146178620(v777, "https://content.cfx.re/mirrors/patches_fivem/2060/diffs/from_3258_to_2060.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v606, "736f1cb26e59167f302c22385463d231cce302d3");
  v138 = *(_OWORD *)sub_146178670(&v607, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  sub_146178DD0((__int64)v1350, &v138, &v139, (__int64)v777, 515246812i64);
  sub_146178620(v776, "https://content.cfx.re/mirrors/patches_fivem/2060/diffs/from_3323_to_2060.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v608, "736f1cb26e59167f302c22385463d231cce302d3");
  v138 = *(_OWORD *)sub_146178670(&v609, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  sub_146178DD0((__int64)v1351, &v138, &v139, (__int64)v776, 515246794i64);
  sub_146178620(v775, "https://content.cfx.re/mirrors/patches_fivem/2060/diffs/from_3407_to_2060.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v610, "736f1cb26e59167f302c22385463d231cce302d3");
  v138 = *(_OWORD *)sub_146178670(&v611, "f6cdcdec5e3e993a31f45acc96b638283c474f53");
  sub_146178DD0((__int64)v1352, &v138, &v139, (__int64)v775, 516145143i64);
  *(_QWORD *)&v138 = v1340;
  *((_QWORD *)&v138 + 1) = v1353;
  sub_146178FA0(
    (__int64)v1198,
    (__int64)"update/update.rpf",
    (__int64)"736f1cb26e59167f302c22385463d231cce302d3",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/2060/update.rpf",
    1229002752i64,
    &v138);
  sub_146178620(v774, (const char *)&qword_1461212B8);
  sub_146176D00((__int64)v1295, (__int64)v774, v1198, v134);
  *(_QWORD *)&v138 = v1294;
  *((_QWORD *)&v138 + 1) = v1296;
  sub_1461788D0((__int64 *)v165, (__int64 *)&v138);
  v157 = 2060;
  sub_146176CD0((__int64)v1164, &v157, v165);
  v139 = 0i64;
  sub_146178FA0(
    (__int64)v1197,
    (__int64)"GTA5.exe",
    (__int64)"8939c8c71aa98ad7ca6ac773fae1463763c420d8",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/1604/GTA5.exe",
    72484280i64,
    &v139);
  sub_146178620(v773, "GTA5.exe");
  sub_146176D00((__int64)v1292, (__int64)v773, v1197, v135);
  sub_146178620(v772, "https://content.cfx.re/mirrors/patches_fivem/1604/diffs/from_2060_to_1604.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v612, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  v138 = *(_OWORD *)sub_146178670(&v613, "736f1cb26e59167f302c22385463d231cce302d3");
  sub_146178DD0((__int64)v1327, &v138, &v139, (__int64)v772, 252578178i64);
  sub_146178620(v771, "https://content.cfx.re/mirrors/patches_fivem/1604/diffs/from_2189_to_1604.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v614, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  v138 = *(_OWORD *)sub_146178670(&v615, "fe387dbc0f700d690b53d44ce1226c624c24b8fc");
  sub_146178DD0((__int64)v1328, &v138, &v139, (__int64)v771, 255544048i64);
  sub_146178620(v770, "https://content.cfx.re/mirrors/patches_fivem/1604/diffs/from_2372_to_1604.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v616, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  v138 = *(_OWORD *)sub_146178670(&v617, "1824cdbc27c3e0eaa86920a38751322727872831");
  sub_146178DD0((__int64)v1329, &v138, &v139, (__int64)v770, 400087270i64);
  sub_146178620(v769, "https://content.cfx.re/mirrors/patches_fivem/1604/diffs/from_2545_to_1604.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v618, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  v138 = *(_OWORD *)sub_146178670(&v619, "2993b3c30f61cbbb8dbce859604d7fb717ff8dae");
  sub_146178DD0((__int64)v1330, &v138, &v139, (__int64)v769, 409505316i64);
  sub_146178620(v768, "https://content.cfx.re/mirrors/patches_fivem/1604/diffs/from_2612_to_1604.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v620, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  v138 = *(_OWORD *)sub_146178670(&v621, "80f9bd028e5bc781f641fe210a88579eff827989");
  sub_146178DD0((__int64)v1331, &v138, &v139, (__int64)v768, 475094324i64);
  sub_146178620(v767, "https://content.cfx.re/mirrors/patches_fivem/1604/diffs/from_2699_to_1604.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v622, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  v138 = *(_OWORD *)sub_146178670(&v623, "86d88c5ea36e67683a138c0e690c42fe288205fa");
  sub_146178DD0((__int64)v1332, &v138, &v139, (__int64)v767, 475411202i64);
  sub_146178620(v766, "https://content.cfx.re/mirrors/patches_fivem/1604/diffs/from_2802_to_1604.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v624, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  v138 = *(_OWORD *)sub_146178670(&v625, "66388a381347511b7b28aaf91741615e45008e8b");
  sub_146178DD0((__int64)v1333, &v138, &v139, (__int64)v766, 478650625i64);
  sub_146178620(v765, "https://content.cfx.re/mirrors/patches_fivem/1604/diffs/from_2944_to_1604.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v626, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  v138 = *(_OWORD *)sub_146178670(&v627, "abc628b0ae04e68f88e0581f3572d26dbaed84d2");
  sub_146178DD0((__int64)v1334, &v138, &v139, (__int64)v765, 481127813i64);
  sub_146178620(v764, "https://content.cfx.re/mirrors/patches_fivem/1604/diffs/from_3095_to_1604.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v628, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  v138 = *(_OWORD *)sub_146178670(&v629, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1335, &v138, &v139, (__int64)v764, 481316317i64);
  sub_146178620(v763, "https://content.cfx.re/mirrors/patches_fivem/1604/diffs/from_3179_to_1604.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v630, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  v138 = *(_OWORD *)sub_146178670(&v631, "fd46de4495d32f0533b8b3ae72507b829e8650f3");
  sub_146178DD0((__int64)v1336, &v138, &v139, (__int64)v763, 481316317i64);
  sub_146178620(v1024, "https://content.cfx.re/mirrors/patches_fivem/1604/diffs/from_3258_to_1604.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v632, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  v138 = *(_OWORD *)sub_146178670(&v633, "abf3a580ddfc4cb372b5a4ce48ed7b2ea31e5270");
  sub_146178DD0((__int64)v1337, &v138, &v139, (__int64)v1024, 483477046i64);
  sub_146178620(v1023, "https://content.cfx.re/mirrors/patches_fivem/1604/diffs/from_3323_to_1604.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v634, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  v138 = *(_OWORD *)sub_146178670(&v635, "3633a58585791b30281cec14f90f5ac1e2bfdc57");
  sub_146178DD0((__int64)v1338, &v138, &v139, (__int64)v1023, 483477045i64);
  sub_146178620(v1022, "https://content.cfx.re/mirrors/patches_fivem/1604/diffs/from_3407_to_1604.update.rpf.hdiff");
  v139 = *(_OWORD *)sub_146178670(&v636, "fc941d698834e30e40a06a40f6a35b1b18e1c50c");
  v138 = *(_OWORD *)sub_146178670(&v637, "f6cdcdec5e3e993a31f45acc96b638283c474f53");
  sub_146178DD0((__int64)v1339, &v138, &v139, (__int64)v1022, 484276041i64);
  *(_QWORD *)&v138 = v1327;
  *((_QWORD *)&v138 + 1) = v1340;
  sub_146178FA0(
    (__int64)v1196,
    (__int64)"update/update.rpf",
    (__int64)"fc941d698834e30e40a06a40f6a35b1b18e1c50c",
    (__int64)"https://content.cfx.re/mirrors/patches_fivem/1604/update.rpf",
    966805504i64,
    &v138);
  sub_146178620(v1021, (const char *)&qword_1461212B8);
  sub_146176D00((__int64)v1293, (__int64)v1021, v1196, v136);
  *(_QWORD *)&v138 = v1292;
  *((_QWORD *)&v138 + 1) = v1294;
  sub_1461788D0((__int64 *)v164, (__int64 *)&v138);
  v158 = 1604;
  sub_146176CD0((__int64)v1165, &v158, v164);
  *(_QWORD *)&v138 = &v1151;
  *((_QWORD *)&v138 + 1) = v1166;
  sub_1461786A0((__int64)&qword_14610AAE8, (__int64 *)&v138);
  `eh vector destructor iterator'(&v1151, 0x18ui64, 0xEui64, (void (__fastcall *)(void *))sub_146179250);
  sub_146179120(v164);
  `eh vector destructor iterator'(v1292, 0x98ui64, 2ui64, (void (__fastcall *)(void *))sub_146179280);
  sub_1461626B0((__int64)v1021);
  sub_146179300(v1196);
  `eh vector destructor iterator'(v1327, 0x50ui64, 0xDui64, sub_1461792F0);
  sub_1461626B0((__int64)v1022);
  sub_1461626B0((__int64)v1023);
  sub_1461626B0((__int64)v1024);
  sub_1461626B0((__int64)v763);
  sub_1461626B0((__int64)v764);
  sub_1461626B0((__int64)v765);
  sub_1461626B0((__int64)v766);
  sub_1461626B0((__int64)v767);
  sub_1461626B0((__int64)v768);
  sub_1461626B0((__int64)v769);
  sub_1461626B0((__int64)v770);
  sub_1461626B0((__int64)v771);
  sub_1461626B0((__int64)v772);
  sub_1461626B0((__int64)v773);
  sub_146179300(v1197);
  sub_146179120(v165);
  `eh vector destructor iterator'(v1294, 0x98ui64, 2ui64, (void (__fastcall *)(void *))sub_146179280);
  sub_1461626B0((__int64)v774);
  sub_146179300(v1198);
  `eh vector destructor iterator'(v1340, 0x50ui64, 0xDui64, sub_1461792F0);
  sub_1461626B0((__int64)v775);
  sub_1461626B0((__int64)v776);
  sub_1461626B0((__int64)v777);
  sub_1461626B0((__int64)v778);
  sub_1461626B0((__int64)v779);
  sub_1461626B0((__int64)v780);
  sub_1461626B0((__int64)v781);
  sub_1461626B0((__int64)v782);
  sub_1461626B0((__int64)v783);
  sub_1461626B0((__int64)v784);
  sub_1461626B0((__int64)v785);
  sub_1461626B0((__int64)v786);
  sub_1461626B0((__int64)v787);
  sub_1461626B0((__int64)v788);
  sub_146179300(v1166);
  sub_146179120(v166);
  `eh vector destructor iterator'(v1296, 0x98ui64, 2ui64, (void (__fastcall *)(void *))sub_146179280);
  sub_1461626B0((__int64)v789);
  sub_146179300(v1167);
  `eh vector destructor iterator'(v1353, 0x50ui64, 0xDui64, sub_1461792F0);
  sub_1461626B0((__int64)v790);
  sub_1461626B0((__int64)v791);
  sub_1461626B0((__int64)v792);
  sub_1461626B0((__int64)v793);
  sub_1461626B0((__int64)v794);
  sub_1461626B0((__int64)v795);
  sub_1461626B0((__int64)v796);
  sub_1461626B0((__int64)v797);
  sub_1461626B0((__int64)v798);
  sub_1461626B0((__int64)v799);
  sub_1461626B0((__int64)v800);
  sub_1461626B0((__int64)v801);
  sub_1461626B0((__int64)v802);
  sub_1461626B0((__int64)v803);
  sub_146179300(v1168);
  sub_146179120(v167);
  `eh vector destructor iterator'(v1288, 0x98ui64, 2ui64, (void (__fastcall *)(void *))sub_146179280);
  sub_1461626B0((__int64)v804);
  sub_146179300(v1169);
  `eh vector destructor iterator'(v1366, 0x50ui64, 0xDui64, sub_1461792F0);
  sub_1461626B0((__int64)v805);
  sub_1461626B0((__int64)v806);
  sub_1461626B0((__int64)v807);
  sub_1461626B0((__int64)v808);
  sub_1461626B0((__int64)v809);
  sub_1461626B0((__int64)v810);
  sub_1461626B0((__int64)v811);
  sub_1461626B0((__int64)v812);
  sub_1461626B0((__int64)v813);
  sub_1461626B0((__int64)v814);
  sub_1461626B0((__int64)v815);
  sub_1461626B0((__int64)v816);
  sub_1461626B0((__int64)v817);
  sub_1461626B0((__int64)v818);
  sub_146179300(v1170);
  sub_146179120(v172);
  `eh vector destructor iterator'(v1290, 0x98ui64, 2ui64, (void (__fastcall *)(void *))sub_146179280);
  sub_1461626B0((__int64)v819);
  sub_146179300(v1171);
  `eh vector destructor iterator'(v1379, 0x50ui64, 0xDui64, sub_1461792F0);
  sub_1461626B0((__int64)v820);
  sub_1461626B0((__int64)v821);
  sub_1461626B0((__int64)v822);
  sub_1461626B0((__int64)v823);
  sub_1461626B0((__int64)v824);
  sub_1461626B0((__int64)v825);
  sub_1461626B0((__int64)v826);
  sub_1461626B0((__int64)v827);
  sub_1461626B0((__int64)v828);
  sub_1461626B0((__int64)v829);
  sub_1461626B0((__int64)v830);
  sub_1461626B0((__int64)v831);
  sub_1461626B0((__int64)v832);
  sub_1461626B0((__int64)v833);
  sub_146179300(v1172);
  sub_146179120(v168);
  `eh vector destructor iterator'(v1477, 0x98ui64, 3ui64, (void (__fastcall *)(void *))sub_146179280);
  sub_1461626B0((__int64)v834);
  sub_146179300(v1173);
  `eh vector destructor iterator'(v1224, 0x50ui64, 8ui64, sub_1461792F0);
  sub_1461626B0((__int64)v835);
  sub_1461626B0((__int64)v836);
  sub_1461626B0((__int64)v837);
  sub_1461626B0((__int64)v838);
  sub_1461626B0((__int64)v839);
  sub_1461626B0((__int64)v840);
  sub_1461626B0((__int64)v841);
  sub_1461626B0((__int64)v842);
  sub_1461626B0((__int64)v843);
  sub_146179300(v1174);
  `eh vector destructor iterator'(v1392, 0x50ui64, 0xDui64, sub_1461792F0);
  sub_1461626B0((__int64)v844);
  sub_1461626B0((__int64)v845);
  sub_1461626B0((__int64)v846);
  sub_1461626B0((__int64)v847);
  sub_1461626B0((__int64)v848);
  sub_1461626B0((__int64)v849);
  sub_1461626B0((__int64)v850);
  sub_1461626B0((__int64)v851);
  sub_1461626B0((__int64)v852);
  sub_1461626B0((__int64)v853);
  sub_1461626B0((__int64)v854);
  sub_1461626B0((__int64)v855);
  sub_1461626B0((__int64)v856);
  sub_1461626B0((__int64)v857);
  sub_146179300(v1175);
  sub_146179120(v169);
  `eh vector destructor iterator'(v1481, 0x98ui64, 3ui64, (void (__fastcall *)(void *))sub_146179280);
  sub_1461626B0((__int64)v858);
  sub_146179300(v1176);
  `eh vector destructor iterator'(v1232, 0x50ui64, 8ui64, sub_1461792F0);
  sub_1461626B0((__int64)v859);
  sub_1461626B0((__int64)v860);
  sub_1461626B0((__int64)v861);
  sub_1461626B0((__int64)v862);
  sub_1461626B0((__int64)v863);
  sub_1461626B0((__int64)v864);
  sub_1461626B0((__int64)v865);
  sub_1461626B0((__int64)v866);
  sub_1461626B0((__int64)v867);
  sub_146179300(v1177);
  `eh vector destructor iterator'(v1405, 0x50ui64, 0xDui64, sub_1461792F0);
  sub_1461626B0((__int64)v868);
  sub_1461626B0((__int64)v869);
  sub_1461626B0((__int64)v870);
  sub_1461626B0((__int64)v871);
  sub_1461626B0((__int64)v872);
  sub_1461626B0((__int64)v873);
  sub_1461626B0((__int64)v874);
  sub_1461626B0((__int64)v875);
  sub_1461626B0((__int64)v876);
  sub_1461626B0((__int64)v877);
  sub_1461626B0((__int64)v878);
  sub_1461626B0((__int64)v879);
  sub_1461626B0((__int64)v880);
  sub_1461626B0((__int64)v881);
  sub_146179300(v1178);
  sub_146179120(v170);
  `eh vector destructor iterator'(v1457, 0x98ui64, 3ui64, (void (__fastcall *)(void *))sub_146179280);
  sub_1461626B0((__int64)v882);
  sub_146179300(v1179);
  `eh vector destructor iterator'(v1240, 0x50ui64, 8ui64, sub_1461792F0);
  sub_1461626B0((__int64)v883);
  sub_1461626B0((__int64)v884);
  sub_1461626B0((__int64)v885);
  sub_1461626B0((__int64)v886);
  sub_1461626B0((__int64)v887);
  sub_1461626B0((__int64)v888);
  sub_1461626B0((__int64)v889);
  sub_1461626B0((__int64)v890);
  sub_1461626B0((__int64)v891);
  sub_146179300(v1180);
  `eh vector destructor iterator'(v1418, 0x50ui64, 0xDui64, sub_1461792F0);
  sub_1461626B0((__int64)v892);
  sub_1461626B0((__int64)v893);
  sub_1461626B0((__int64)v894);
  sub_1461626B0((__int64)v895);
  sub_1461626B0((__int64)v896);
  sub_1461626B0((__int64)v897);
  sub_1461626B0((__int64)v898);
  sub_1461626B0((__int64)v899);
  sub_1461626B0((__int64)v900);
  sub_1461626B0((__int64)v901);
  sub_1461626B0((__int64)v902);
  sub_1461626B0((__int64)v903);
  sub_1461626B0((__int64)v904);
  sub_1461626B0((__int64)v905);
  sub_146179300(v1181);
  sub_146179120(v171);
  `eh vector destructor iterator'(v1461, 0x98ui64, 3ui64, (void (__fastcall *)(void *))sub_146179280);
  sub_1461626B0((__int64)v906);
  sub_146179300(v1182);
  `eh vector destructor iterator'(v1248, 0x50ui64, 8ui64, sub_1461792F0);
  sub_1461626B0((__int64)v907);
  sub_1461626B0((__int64)v908);
  sub_1461626B0((__int64)v909);
  sub_1461626B0((__int64)v910);
  sub_1461626B0((__int64)v911);
  sub_1461626B0((__int64)v912);
  sub_1461626B0((__int64)v913);
  sub_1461626B0((__int64)v914);
  sub_1461626B0((__int64)v915);
  sub_146179300(v1183);
  `eh vector destructor iterator'(v1431, 0x50ui64, 0xDui64, sub_1461792F0);
  sub_1461626B0((__int64)v916);
  sub_1461626B0((__int64)v917);
  sub_1461626B0((__int64)v918);
  sub_1461626B0((__int64)v919);
  sub_1461626B0((__int64)v920);
  sub_1461626B0((__int64)v921);
  sub_1461626B0((__int64)v922);
  sub_1461626B0((__int64)v923);
  sub_1461626B0((__int64)v924);
  sub_1461626B0((__int64)v925);
  sub_1461626B0((__int64)v926);
  sub_1461626B0((__int64)v927);
  sub_1461626B0((__int64)v928);
  sub_1461626B0((__int64)v929);
  sub_146179300(v1184);
  sub_146179120(v177);
  `eh vector destructor iterator'(v1465, 0x98ui64, 3ui64, (void (__fastcall *)(void *))sub_146179280);
  sub_1461626B0((__int64)v930);
  sub_146179300(v1185);
  `eh vector destructor iterator'(v1280, 0x50ui64, 8ui64, sub_1461792F0);
  sub_1461626B0((__int64)v931);
  sub_1461626B0((__int64)v932);
  sub_1461626B0((__int64)v933);
  sub_1461626B0((__int64)v934);
  sub_1461626B0((__int64)v935);
  sub_1461626B0((__int64)v936);
  sub_1461626B0((__int64)v937);
  sub_1461626B0((__int64)v938);
  sub_1461626B0((__int64)v939);
  sub_146179300(v1186);
  `eh vector destructor iterator'(v1303, 0x50ui64, 0xCui64, sub_1461792F0);
  sub_1461626B0((__int64)v940);
  sub_1461626B0((__int64)v941);
  sub_1461626B0((__int64)v942);
  sub_1461626B0((__int64)v943);
  sub_1461626B0((__int64)v944);
  sub_1461626B0((__int64)v945);
  sub_1461626B0((__int64)v946);
  sub_1461626B0((__int64)v947);
  sub_1461626B0((__int64)v948);
  sub_1461626B0((__int64)v949);
  sub_1461626B0((__int64)v950);
  sub_1461626B0((__int64)v951);
  sub_1461626B0((__int64)v952);
  sub_146179300(v1187);
  sub_146179120(v173);
  `eh vector destructor iterator'(v1469, 0x98ui64, 3ui64, (void (__fastcall *)(void *))sub_146179280);
  sub_1461626B0((__int64)v953);
  sub_146179300(v1188);
  `eh vector destructor iterator'(v1256, 0x50ui64, 8ui64, sub_1461792F0);
  sub_1461626B0((__int64)v954);
  sub_1461626B0((__int64)v955);
  sub_1461626B0((__int64)v956);
  sub_1461626B0((__int64)v957);
  sub_1461626B0((__int64)v958);
  sub_1461626B0((__int64)v959);
  sub_1461626B0((__int64)v960);
  sub_1461626B0((__int64)v961);
  sub_1461626B0((__int64)v962);
  sub_146179300(v1189);
  `eh vector destructor iterator'(v1315, 0x50ui64, 0xCui64, sub_1461792F0);
  sub_1461626B0((__int64)v963);
  sub_1461626B0((__int64)v964);
  sub_1461626B0((__int64)v965);
  sub_1461626B0((__int64)v966);
  sub_1461626B0((__int64)v967);
  sub_1461626B0((__int64)v968);
  sub_1461626B0((__int64)v969);
  sub_1461626B0((__int64)v970);
  sub_1461626B0((__int64)v971);
  sub_1461626B0((__int64)v972);
  sub_1461626B0((__int64)v973);
  sub_1461626B0((__int64)v974);
  sub_1461626B0((__int64)v975);
  sub_146179300(v1190);
  sub_146179120(v174);
  `eh vector destructor iterator'(v1473, 0x98ui64, 3ui64, (void (__fastcall *)(void *))sub_146179280);
  sub_1461626B0((__int64)v976);
  sub_146179300(v1191);
  `eh vector destructor iterator'(v1264, 0x50ui64, 8ui64, sub_1461792F0);
  sub_1461626B0((__int64)v977);
  sub_1461626B0((__int64)v978);
  sub_1461626B0((__int64)v979);
  sub_1461626B0((__int64)v980);
  sub_1461626B0((__int64)v981);
  sub_1461626B0((__int64)v982);
  sub_1461626B0((__int64)v983);
  sub_1461626B0((__int64)v984);
  sub_1461626B0((__int64)v985);
  sub_146179300(v1192);
  `eh vector destructor iterator'(v1444, 0x50ui64, 0xDui64, sub_1461792F0);
  sub_1461626B0((__int64)v986);
  sub_1461626B0((__int64)v987);
  sub_1461626B0((__int64)v988);
  sub_1461626B0((__int64)v989);
  sub_1461626B0((__int64)v990);
  sub_1461626B0((__int64)v991);
  sub_1461626B0((__int64)v992);
  sub_1461626B0((__int64)v993);
  sub_1461626B0((__int64)v994);
  sub_1461626B0((__int64)v995);
  sub_1461626B0((__int64)v996);
  sub_1461626B0((__int64)v997);
  sub_1461626B0((__int64)v998);
  sub_1461626B0((__int64)v999);
  sub_146179300(v1193);
  sub_146179120(v175);
  `eh vector destructor iterator'(v1298, 0x98ui64, 3ui64, (void (__fastcall *)(void *))sub_146179280);
  sub_1461626B0((__int64)v1000);
  sub_146179300(v1194);
  `eh vector destructor iterator'(v1272, 0x50ui64, 8ui64, sub_1461792F0);
  sub_1461626B0((__int64)v1001);
  sub_1461626B0((__int64)v1002);
  sub_1461626B0((__int64)v1003);
  sub_1461626B0((__int64)v1004);
  sub_1461626B0((__int64)v1005);
  sub_1461626B0((__int64)v1006);
  sub_1461626B0((__int64)v1007);
  sub_1461626B0((__int64)v1008);
  sub_1461626B0((__int64)v1009);
  sub_146179300(v1195);
  `eh vector destructor iterator'(&v1199, 0x50ui64, 0xDui64, sub_1461792F0);
  sub_1461626B0((__int64)v1010);
  sub_1461626B0((__int64)v1011);
  sub_1461626B0((__int64)v1012);
  sub_1461626B0((__int64)v1013);
  sub_1461626B0((__int64)v1014);
  sub_1461626B0((__int64)v1015);
  sub_1461626B0((__int64)v1016);
  sub_1461626B0((__int64)v1017);
  sub_1461626B0((__int64)v1018);
  sub_1461626B0((__int64)v1019);
  sub_1461626B0((__int64)v1020);
  sub_1461626B0((__int64)&v682);
  sub_1461626B0((__int64)&v688);
  sub_1461626B0((__int64)v690);
  sub_146179300(&v745);
  sub_146179120(v176);
  `eh vector destructor iterator'(v1217, 0x98ui64, 3ui64, (void (__fastcall *)(void *))sub_146179280);
  sub_1461626B0((__int64)v684);
  sub_146179300(&v751);
  `eh vector destructor iterator'(&v1025, 0x50ui64, 8ui64, sub_1461792F0);
  sub_1461626B0((__int64)&v691);
  sub_1461626B0((__int64)&v693);
  sub_1461626B0((__int64)&v695);
  sub_1461626B0((__int64)&v697);
  sub_1461626B0((__int64)&v699);
  sub_1461626B0((__int64)&v701);
  sub_1461626B0((__int64)&v703);
  sub_1461626B0((__int64)&v705);
  sub_1461626B0((__int64)v686);
  sub_146179300(&v757);
  `eh vector destructor iterator'(&v1073, 0x50ui64, 0xDui64, sub_1461792F0);
  sub_1461626B0((__int64)&v707);
  sub_1461626B0((__int64)&v709);
  sub_1461626B0((__int64)&v711);
  sub_1461626B0((__int64)&v713);
  sub_1461626B0((__int64)&v715);
  sub_1461626B0((__int64)&v717);
  sub_1461626B0((__int64)&v719);
  sub_1461626B0((__int64)&v721);
  sub_1461626B0((__int64)&v723);
  sub_1461626B0((__int64)&v725);
  sub_1461626B0((__int64)&v727);
  sub_1461626B0((__int64)&v729);
  sub_1461626B0((__int64)&v731);
  sub_1461626B0((__int64)v733);
  sub_146179300(&v734);
  return atexit(sub_1461AE660);
}

//----- (0000000146157270) ----------------------------------------------------
int sub_146157270()
{
  _QWORD *v0; // rax
  _QWORD *v1; // rax
  __m128i si128; // xmm6
  _QWORD *v3; // rax
  _QWORD *v4; // rax
  _QWORD *v5; // rax
  _QWORD *v6; // rax
  _QWORD *v7; // rax
  _QWORD *v8; // rax
  _QWORD *v9; // rax
  _QWORD *v10; // rdi
  __int64 v11; // r8
  __int64 *v12; // rbx
  char v14; // [rsp+20h] [rbp-E0h] BYREF
  char v15[7]; // [rsp+21h] [rbp-DFh] BYREF
  const char *v16; // [rsp+28h] [rbp-D8h] BYREF
  __int128 v17; // [rsp+30h] [rbp-D0h] BYREF
  __int128 *v18; // [rsp+40h] [rbp-C0h]
  __int64 v19; // [rsp+50h] [rbp-B0h]
  __int64 v20[3]; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v21[8]; // [rsp+70h] [rbp-90h] BYREF
  __int64 v22[3]; // [rsp+B0h] [rbp-50h] BYREF
  __int128 v23; // [rsp+C8h] [rbp-38h]
  __int64 v24; // [rsp+D8h] [rbp-28h]
  __int64 v25; // [rsp+E0h] [rbp-20h]
  const char *v26; // [rsp+E8h] [rbp-18h]
  __int128 v27; // [rsp+F0h] [rbp-10h]
  _QWORD *v28; // [rsp+100h] [rbp+0h]
  const char *v29; // [rsp+108h] [rbp+8h]
  __int64 v30; // [rsp+110h] [rbp+10h]
  __int64 v31; // [rsp+118h] [rbp+18h]
  __int64 v32; // [rsp+120h] [rbp+20h]
  __int64 v33[3]; // [rsp+128h] [rbp+28h] BYREF
  __int128 v34; // [rsp+140h] [rbp+40h]
  __m128i v35; // [rsp+150h] [rbp+50h]
  const char *v36; // [rsp+160h] [rbp+60h]
  _QWORD *v37; // [rsp+168h] [rbp+68h]
  __int128 v38; // [rsp+170h] [rbp+70h]
  const char *v39; // [rsp+180h] [rbp+80h]
  __int64 v40; // [rsp+188h] [rbp+88h]
  __int64 v41; // [rsp+190h] [rbp+90h]
  __int64 v42; // [rsp+198h] [rbp+98h]
  __int64 v43[3]; // [rsp+1A0h] [rbp+A0h] BYREF
  __int128 v44; // [rsp+1B8h] [rbp+B8h]
  __int64 v45; // [rsp+1C8h] [rbp+C8h]
  __int64 v46; // [rsp+1D0h] [rbp+D0h]
  const char *v47; // [rsp+1D8h] [rbp+D8h]
  __int128 v48; // [rsp+1E0h] [rbp+E0h]
  _QWORD *v49; // [rsp+1F0h] [rbp+F0h]
  const char *v50; // [rsp+1F8h] [rbp+F8h]
  __int64 v51; // [rsp+200h] [rbp+100h]
  __int64 v52; // [rsp+208h] [rbp+108h]
  __int64 v53; // [rsp+210h] [rbp+110h]
  __int64 v54[3]; // [rsp+218h] [rbp+118h] BYREF
  __int128 v55; // [rsp+230h] [rbp+130h]
  __m128i v56; // [rsp+240h] [rbp+140h]
  const char *v57; // [rsp+250h] [rbp+150h]
  _QWORD *v58; // [rsp+258h] [rbp+158h]
  __int128 v59; // [rsp+260h] [rbp+160h]
  const char *v60; // [rsp+270h] [rbp+170h]
  __int64 v61; // [rsp+278h] [rbp+178h]
  __int64 v62; // [rsp+280h] [rbp+180h]
  __int64 v63; // [rsp+288h] [rbp+188h]
  __int64 v64[3]; // [rsp+290h] [rbp+190h] BYREF
  __int128 v65; // [rsp+2A8h] [rbp+1A8h]
  __int64 v66; // [rsp+2B8h] [rbp+1B8h]
  __int64 v67; // [rsp+2C0h] [rbp+1C0h]
  const char *v68; // [rsp+2C8h] [rbp+1C8h]
  __int128 v69; // [rsp+2D0h] [rbp+1D0h]
  _QWORD *v70; // [rsp+2E0h] [rbp+1E0h]
  const char *v71; // [rsp+2E8h] [rbp+1E8h]
  __int64 v72; // [rsp+2F0h] [rbp+1F0h]
  __int64 v73; // [rsp+2F8h] [rbp+1F8h]
  __int64 v74; // [rsp+300h] [rbp+200h]
  __int64 v75[3]; // [rsp+308h] [rbp+208h] BYREF
  __int128 v76; // [rsp+320h] [rbp+220h]
  __m128i v77; // [rsp+330h] [rbp+230h]
  const char *v78; // [rsp+340h] [rbp+240h]
  _QWORD *v79; // [rsp+348h] [rbp+248h]
  __int128 v80; // [rsp+350h] [rbp+250h]
  const char *v81; // [rsp+360h] [rbp+260h]
  __int64 v82; // [rsp+368h] [rbp+268h]
  __int64 v83; // [rsp+370h] [rbp+270h]
  __int64 v84; // [rsp+378h] [rbp+278h]
  __int64 v85[3]; // [rsp+380h] [rbp+280h] BYREF
  __int128 v86; // [rsp+398h] [rbp+298h]
  __int64 v87; // [rsp+3A8h] [rbp+2A8h]
  __int64 v88; // [rsp+3B0h] [rbp+2B0h]
  const char *v89; // [rsp+3B8h] [rbp+2B8h]
  __int128 v90; // [rsp+3C0h] [rbp+2C0h]
  _QWORD *v91; // [rsp+3D0h] [rbp+2D0h]
  const char *v92; // [rsp+3D8h] [rbp+2D8h]
  __int64 v93; // [rsp+3E0h] [rbp+2E0h]
  __int64 v94; // [rsp+3E8h] [rbp+2E8h]
  __int64 v95; // [rsp+3F0h] [rbp+2F0h]
  __int64 v96[3]; // [rsp+3F8h] [rbp+2F8h] BYREF
  __int128 v97; // [rsp+410h] [rbp+310h]
  __m128i v98; // [rsp+420h] [rbp+320h]
  const char *v99; // [rsp+430h] [rbp+330h]
  _QWORD *v100; // [rsp+438h] [rbp+338h]
  __int128 v101; // [rsp+440h] [rbp+340h]
  const char *v102; // [rsp+450h] [rbp+350h]
  __int64 v103; // [rsp+458h] [rbp+358h]
  __int64 v104; // [rsp+460h] [rbp+360h]
  __int64 v105; // [rsp+468h] [rbp+368h]
  __int64 v106[3]; // [rsp+470h] [rbp+370h] BYREF
  __int128 v107; // [rsp+488h] [rbp+388h]
  __int64 v108; // [rsp+498h] [rbp+398h]
  __int64 v109; // [rsp+4A0h] [rbp+3A0h]
  const char *v110; // [rsp+4A8h] [rbp+3A8h]
  _QWORD v111[7]; // [rsp+4B0h] [rbp+3B0h] BYREF
  __int64 v112[3]; // [rsp+4E8h] [rbp+3E8h] BYREF
  __int128 v113; // [rsp+500h] [rbp+400h]
  __m128i v114; // [rsp+510h] [rbp+410h]
  const char *v115; // [rsp+520h] [rbp+420h]
  _QWORD v116[7]; // [rsp+528h] [rbp+428h] BYREF
  __int64 v117[3]; // [rsp+560h] [rbp+460h] BYREF
  __int128 v118; // [rsp+578h] [rbp+478h]
  __int64 v119; // [rsp+588h] [rbp+488h]
  __int64 v120; // [rsp+590h] [rbp+490h]
  const char *v121; // [rsp+598h] [rbp+498h]
  _QWORD v122[7]; // [rsp+5A0h] [rbp+4A0h] BYREF
  __int64 v123[3]; // [rsp+5D8h] [rbp+4D8h] BYREF
  __int128 v124; // [rsp+5F0h] [rbp+4F0h]
  __m128i v125; // [rsp+600h] [rbp+500h]
  const char *v126; // [rsp+610h] [rbp+510h]
  _QWORD v127[7]; // [rsp+618h] [rbp+518h] BYREF
  __int64 v128[3]; // [rsp+650h] [rbp+550h] BYREF
  __int128 v129; // [rsp+668h] [rbp+568h]
  __int64 v130; // [rsp+678h] [rbp+578h]
  __int64 v131; // [rsp+680h] [rbp+580h]
  const char *v132; // [rsp+688h] [rbp+588h]
  _QWORD v133[7]; // [rsp+690h] [rbp+590h] BYREF
  __int64 v134[3]; // [rsp+6C8h] [rbp+5C8h] BYREF
  __int128 v135; // [rsp+6E0h] [rbp+5E0h]
  __m128i v136; // [rsp+6F0h] [rbp+5F0h]
  const char *v137; // [rsp+700h] [rbp+600h]
  _QWORD v138[7]; // [rsp+708h] [rbp+608h] BYREF
  __int64 v139[3]; // [rsp+740h] [rbp+640h] BYREF
  __int128 v140; // [rsp+758h] [rbp+658h]
  __int64 v141; // [rsp+768h] [rbp+668h]
  __int64 v142; // [rsp+770h] [rbp+670h]
  const char *v143; // [rsp+778h] [rbp+678h]
  _QWORD v144[7]; // [rsp+780h] [rbp+680h] BYREF
  __int64 v145[3]; // [rsp+7B8h] [rbp+6B8h] BYREF
  __int128 v146; // [rsp+7D0h] [rbp+6D0h]
  __m128i v147; // [rsp+7E0h] [rbp+6E0h]
  const char *v148; // [rsp+7F0h] [rbp+6F0h]
  _QWORD v149[7]; // [rsp+7F8h] [rbp+6F8h] BYREF
  __int64 v150[3]; // [rsp+830h] [rbp+730h] BYREF
  __int128 v151; // [rsp+848h] [rbp+748h]
  __int64 v152; // [rsp+858h] [rbp+758h]
  __int64 v153; // [rsp+860h] [rbp+760h]
  const char *v154; // [rsp+868h] [rbp+768h]
  _QWORD v155[7]; // [rsp+870h] [rbp+770h] BYREF
  __int64 v156[3]; // [rsp+8A8h] [rbp+7A8h] BYREF
  __int128 v157; // [rsp+8C0h] [rbp+7C0h]
  __m128i v158; // [rsp+8D0h] [rbp+7D0h]
  const char *v159; // [rsp+8E0h] [rbp+7E0h]
  _QWORD v160[7]; // [rsp+8E8h] [rbp+7E8h] BYREF
  __int64 v161[3]; // [rsp+920h] [rbp+820h] BYREF
  __int128 v162; // [rsp+938h] [rbp+838h]
  __int64 v163; // [rsp+948h] [rbp+848h]
  __int64 v164; // [rsp+950h] [rbp+850h]
  const char *v165; // [rsp+958h] [rbp+858h]
  _QWORD v166[7]; // [rsp+960h] [rbp+860h] BYREF
  __int64 v167[3]; // [rsp+998h] [rbp+898h] BYREF
  __int128 v168; // [rsp+9B0h] [rbp+8B0h]
  __m128i v169; // [rsp+9C0h] [rbp+8C0h]
  const char *v170; // [rsp+9D0h] [rbp+8D0h]
  _QWORD v171[7]; // [rsp+9D8h] [rbp+8D8h] BYREF
  __int64 v172[3]; // [rsp+A10h] [rbp+910h] BYREF
  __int128 v173; // [rsp+A28h] [rbp+928h]
  __int64 v174; // [rsp+A38h] [rbp+938h]
  __int64 v175; // [rsp+A40h] [rbp+940h]
  const char *v176; // [rsp+A48h] [rbp+948h]
  _QWORD v177[7]; // [rsp+A50h] [rbp+950h] BYREF
  __int64 v178[3]; // [rsp+A88h] [rbp+988h] BYREF
  __int128 v179; // [rsp+AA0h] [rbp+9A0h]
  __m128i v180; // [rsp+AB0h] [rbp+9B0h]
  const char *v181; // [rsp+AC0h] [rbp+9C0h]
  _QWORD v182[7]; // [rsp+AC8h] [rbp+9C8h] BYREF
  __int64 v183[3]; // [rsp+B00h] [rbp+A00h] BYREF
  __int128 v184; // [rsp+B18h] [rbp+A18h]
  __int64 v185; // [rsp+B28h] [rbp+A28h]
  __int64 v186; // [rsp+B30h] [rbp+A30h]
  const char *v187; // [rsp+B38h] [rbp+A38h]
  _QWORD v188[7]; // [rsp+B40h] [rbp+A40h] BYREF
  __int64 v189[3]; // [rsp+B78h] [rbp+A78h] BYREF
  __int128 v190; // [rsp+B90h] [rbp+A90h]
  __m128i v191; // [rsp+BA0h] [rbp+AA0h]
  const char *v192; // [rsp+BB0h] [rbp+AB0h]
  _QWORD v193[7]; // [rsp+BB8h] [rbp+AB8h] BYREF
  __int64 v194[3]; // [rsp+BF0h] [rbp+AF0h] BYREF
  __int128 v195; // [rsp+C08h] [rbp+B08h]
  __int64 v196; // [rsp+C18h] [rbp+B18h]
  __int64 v197; // [rsp+C20h] [rbp+B20h]
  const char *v198; // [rsp+C28h] [rbp+B28h]
  _QWORD v199[7]; // [rsp+C30h] [rbp+B30h] BYREF
  __int64 v200[3]; // [rsp+C68h] [rbp+B68h] BYREF
  __int128 v201; // [rsp+C80h] [rbp+B80h]
  __m128i v202; // [rsp+C90h] [rbp+B90h]
  const char *v203; // [rsp+CA0h] [rbp+BA0h]
  _QWORD v204[7]; // [rsp+CA8h] [rbp+BA8h] BYREF
  __int64 v205[3]; // [rsp+CE0h] [rbp+BE0h] BYREF
  __int128 v206; // [rsp+CF8h] [rbp+BF8h]
  __int64 v207; // [rsp+D08h] [rbp+C08h]
  __int64 v208; // [rsp+D10h] [rbp+C10h]
  const char *v209; // [rsp+D18h] [rbp+C18h]
  _QWORD v210[7]; // [rsp+D20h] [rbp+C20h] BYREF
  __int64 v211[3]; // [rsp+D58h] [rbp+C58h] BYREF
  __int128 v212; // [rsp+D70h] [rbp+C70h]
  __m128i v213; // [rsp+D80h] [rbp+C80h]
  const char *v214; // [rsp+D90h] [rbp+C90h]
  _QWORD v215[7]; // [rsp+D98h] [rbp+C98h] BYREF
  __int64 v216[3]; // [rsp+DD0h] [rbp+CD0h] BYREF
  __int128 v217; // [rsp+DE8h] [rbp+CE8h]
  __int64 v218; // [rsp+DF8h] [rbp+CF8h]
  __int64 v219; // [rsp+E00h] [rbp+D00h]
  const char *v220; // [rsp+E08h] [rbp+D08h]
  _QWORD v221[7]; // [rsp+E10h] [rbp+D10h] BYREF
  __int64 v222[3]; // [rsp+E48h] [rbp+D48h] BYREF
  __int128 v223; // [rsp+E60h] [rbp+D60h]
  __m128i v224; // [rsp+E70h] [rbp+D70h]
  const char *v225; // [rsp+E80h] [rbp+D80h]
  _QWORD v226[7]; // [rsp+E88h] [rbp+D88h] BYREF
  __int64 v227[3]; // [rsp+EC0h] [rbp+DC0h] BYREF
  __int128 v228; // [rsp+ED8h] [rbp+DD8h]
  __int64 v229; // [rsp+EE8h] [rbp+DE8h]
  __int64 v230; // [rsp+EF0h] [rbp+DF0h]
  const char *v231; // [rsp+EF8h] [rbp+DF8h]
  _QWORD v232[7]; // [rsp+F00h] [rbp+E00h] BYREF
  __int64 v233[3]; // [rsp+F38h] [rbp+E38h] BYREF
  __int128 v234; // [rsp+F50h] [rbp+E50h]
  __m128i v235; // [rsp+F60h] [rbp+E60h]
  const char *v236; // [rsp+F70h] [rbp+E70h]
  _QWORD v237[7]; // [rsp+F78h] [rbp+E78h] BYREF
  __int64 v238[3]; // [rsp+FB0h] [rbp+EB0h] BYREF
  __int128 v239; // [rsp+FC8h] [rbp+EC8h]
  __int64 v240; // [rsp+FD8h] [rbp+ED8h]
  __int64 v241; // [rsp+FE0h] [rbp+EE0h]
  const char *v242; // [rsp+FE8h] [rbp+EE8h]
  _QWORD v243[7]; // [rsp+FF0h] [rbp+EF0h] BYREF
  __int64 v244[3]; // [rsp+1028h] [rbp+F28h] BYREF
  __int128 v245; // [rsp+1040h] [rbp+F40h]
  __m128i v246; // [rsp+1050h] [rbp+F50h]
  const char *v247; // [rsp+1060h] [rbp+F60h]
  _QWORD v248[7]; // [rsp+1068h] [rbp+F68h] BYREF
  __int64 v249[3]; // [rsp+10A0h] [rbp+FA0h] BYREF
  __int128 v250; // [rsp+10B8h] [rbp+FB8h]
  __int64 v251; // [rsp+10C8h] [rbp+FC8h]
  __int64 v252; // [rsp+10D0h] [rbp+FD0h]
  const char *v253; // [rsp+10D8h] [rbp+FD8h]
  _QWORD v254[7]; // [rsp+10E0h] [rbp+FE0h] BYREF
  __int64 v255[3]; // [rsp+1118h] [rbp+1018h] BYREF
  __int128 v256; // [rsp+1130h] [rbp+1030h]
  __m128i v257; // [rsp+1140h] [rbp+1040h]
  const char *v258; // [rsp+1150h] [rbp+1050h]
  _QWORD v259[7]; // [rsp+1158h] [rbp+1058h] BYREF
  __int64 v260[3]; // [rsp+1190h] [rbp+1090h] BYREF
  __int128 v261; // [rsp+11A8h] [rbp+10A8h]
  __int64 v262; // [rsp+11B8h] [rbp+10B8h]
  __int64 v263; // [rsp+11C0h] [rbp+10C0h]
  const char *v264; // [rsp+11C8h] [rbp+10C8h]
  _QWORD v265[7]; // [rsp+11D0h] [rbp+10D0h] BYREF
  __int64 v266[3]; // [rsp+1208h] [rbp+1108h] BYREF
  __int128 v267; // [rsp+1220h] [rbp+1120h]
  __m128i v268; // [rsp+1230h] [rbp+1130h]
  const char *v269; // [rsp+1240h] [rbp+1140h]
  _QWORD v270[7]; // [rsp+1248h] [rbp+1148h] BYREF
  __int64 v271[3]; // [rsp+1280h] [rbp+1180h] BYREF
  __int128 v272; // [rsp+1298h] [rbp+1198h]
  __int64 v273; // [rsp+12A8h] [rbp+11A8h]
  __int64 v274; // [rsp+12B0h] [rbp+11B0h]
  const char *v275; // [rsp+12B8h] [rbp+11B8h]
  _QWORD v276[7]; // [rsp+12C0h] [rbp+11C0h] BYREF
  __int64 v277[3]; // [rsp+12F8h] [rbp+11F8h] BYREF
  __int128 v278; // [rsp+1310h] [rbp+1210h]
  __m128i v279; // [rsp+1320h] [rbp+1220h]
  const char *v280; // [rsp+1330h] [rbp+1230h]
  _QWORD v281[7]; // [rsp+1338h] [rbp+1238h] BYREF
  __int64 v282[3]; // [rsp+1370h] [rbp+1270h] BYREF
  __int128 v283; // [rsp+1388h] [rbp+1288h]
  __int64 v284; // [rsp+1398h] [rbp+1298h]
  __int64 v285; // [rsp+13A0h] [rbp+12A0h]
  const char *v286; // [rsp+13A8h] [rbp+12A8h]
  _QWORD v287[7]; // [rsp+13B0h] [rbp+12B0h] BYREF
  __int64 v288[3]; // [rsp+13E8h] [rbp+12E8h] BYREF
  __int128 v289; // [rsp+1400h] [rbp+1300h]
  __m128i v290; // [rsp+1410h] [rbp+1310h]
  const char *v291; // [rsp+1420h] [rbp+1320h]
  _QWORD v292[7]; // [rsp+1428h] [rbp+1328h] BYREF
  __int64 v293[3]; // [rsp+1460h] [rbp+1360h] BYREF
  __int128 v294; // [rsp+1478h] [rbp+1378h]
  __int64 v295; // [rsp+1488h] [rbp+1388h]
  __int64 v296; // [rsp+1490h] [rbp+1390h]
  char v297; // [rsp+1498h] [rbp+1398h] BYREF

  v19 = -2i64;
  v21[0] = (__int64)"update/x64/dlcpacks/patchday4ng/dlc.rpf";
  v16 = "124c908d82724258a5721535c87f1b8e5c6d8e57";
  v0 = sub_14615A5E0(8ui64);
  v21[1] = (__int64)v0;
  v21[3] = (__int64)(v0 + 1);
  *v0 = "124c908d82724258a5721535c87f1b8e5c6d8e57";
  v21[2] = (__int64)(v0 + 1);
  v21[4] = (__int64)"nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday4ng/dlc.rpf";
  v21[5] = 0i64;
  v21[6] = 312438784i64;
  v21[7] = 312438784i64;
  v17 = 0i64;
  sub_146178CB0(v22, (__int64 *)&v17, (__int64)&v14);
  v23 = 0i64;
  v24 = 0i64;
  v25 = 7i64;
  LOWORD(v23) = 0;
  v26 = "update/x64/dlcpacks/mpluxe/dlc.rpf";
  v16 = "78f7777b49f4b4d77e3da6db728cb3f7ec51e2fc";
  v27 = 0i64;
  v28 = 0i64;
  v1 = sub_14615A5E0(8ui64);
  *(_QWORD *)&v27 = v1;
  v28 = v1 + 1;
  *v1 = "78f7777b49f4b4d77e3da6db728cb3f7ec51e2fc";
  *((_QWORD *)&v27 + 1) = v1 + 1;
  v29 = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpluxe/dlc.rpf";
  v30 = 0i64;
  v31 = 226260992i64;
  v32 = 226260992i64;
  v17 = 0i64;
  sub_146178CB0(v33, (__int64 *)&v17, (__int64)&v14);
  v34 = 0i64;
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  v35 = si128;
  LOWORD(v34) = 0;
  v36 = "update/x64/dlcpacks/patchday5ng/dlc.rpf";
  v16 = "af3b2a59b4e1e5fd220c308d85753bdbffd8063c";
  v37 = 0i64;
  v38 = 0i64;
  v3 = sub_14615A5E0(8ui64);
  v37 = v3;
  *((_QWORD *)&v38 + 1) = v3 + 1;
  *v3 = "af3b2a59b4e1e5fd220c308d85753bdbffd8063c";
  *(_QWORD *)&v38 = v3 + 1;
  v39 = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday5ng/dlc.rpf";
  v40 = 0i64;
  v41 = 7827456i64;
  v42 = 7827456i64;
  v17 = 0i64;
  sub_146178CB0(v43, (__int64 *)&v17, (__int64)&v14);
  v44 = 0i64;
  v45 = 0i64;
  v46 = 7i64;
  LOWORD(v44) = 0;
  v47 = "update/x64/dlcpacks/mpluxe2/dlc.rpf";
  v16 = "1e59e1f05be5dba5650a1166eadfcb5aeaf7737b";
  v48 = 0i64;
  v49 = 0i64;
  v4 = sub_14615A5E0(8ui64);
  *(_QWORD *)&v48 = v4;
  v49 = v4 + 1;
  *v4 = "1e59e1f05be5dba5650a1166eadfcb5aeaf7737b";
  *((_QWORD *)&v48 + 1) = v4 + 1;
  v50 = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpluxe2/dlc.rpf";
  v51 = 0i64;
  v52 = 105105408i64;
  v53 = 105105408i64;
  v17 = 0i64;
  sub_146178CB0(v54, (__int64 *)&v17, (__int64)&v14);
  v55 = 0i64;
  v56 = si128;
  LOWORD(v55) = 0;
  v57 = "update/x64/dlcpacks/mpreplay/dlc.rpf";
  v16 = "f5375beef591178d8aaf334431a7b6596d0d793a";
  v58 = 0i64;
  v59 = 0i64;
  v5 = sub_14615A5E0(8ui64);
  v58 = v5;
  *((_QWORD *)&v59 + 1) = v5 + 1;
  *v5 = "f5375beef591178d8aaf334431a7b6596d0d793a";
  *(_QWORD *)&v59 = v5 + 1;
  v60 = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpreplay/dlc.rpf";
  v61 = 0i64;
  v62 = 429932544i64;
  v63 = 429932544i64;
  v17 = 0i64;
  sub_146178CB0(v64, (__int64 *)&v17, (__int64)&v14);
  v65 = 0i64;
  v66 = 0i64;
  v67 = 7i64;
  LOWORD(v65) = 0;
  v68 = "update/x64/dlcpacks/patchday6ng/dlc.rpf";
  v16 = "5d38b40ad963a6cf39d24bb5e008e9692838b33b";
  v69 = 0i64;
  v70 = 0i64;
  v6 = sub_14615A5E0(8ui64);
  *(_QWORD *)&v69 = v6;
  v70 = v6 + 1;
  *v6 = "5d38b40ad963a6cf39d24bb5e008e9692838b33b";
  *((_QWORD *)&v69 + 1) = v6 + 1;
  v71 = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday6ng/dlc.rpf";
  v72 = 0i64;
  v73 = 31907840i64;
  v74 = 31907840i64;
  v17 = 0i64;
  sub_146178CB0(v75, (__int64 *)&v17, (__int64)&v14);
  v76 = 0i64;
  v77 = si128;
  LOWORD(v76) = 0;
  v78 = "update/x64/dlcpacks/mphalloween/dlc.rpf";
  v16 = "3f960c014e83be00cf8e6b520bbf22f7da6160a4";
  v79 = 0i64;
  v80 = 0i64;
  v7 = sub_14615A5E0(8ui64);
  v79 = v7;
  *((_QWORD *)&v80 + 1) = v7 + 1;
  *v7 = "3f960c014e83be00cf8e6b520bbf22f7da6160a4";
  *(_QWORD *)&v80 = v7 + 1;
  v81 = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmphalloween/dlc.rpf";
  v82 = 0i64;
  v83 = 104658944i64;
  v84 = 104658944i64;
  v17 = 0i64;
  sub_146178CB0(v85, (__int64 *)&v17, (__int64)&v14);
  v86 = 0i64;
  v87 = 0i64;
  v88 = 7i64;
  LOWORD(v86) = 0;
  v89 = "update/x64/dlcpacks/mplowrider/dlc.rpf";
  v16 = "eab744fe959ca29a2e5f36843d259ffc9d04a7f6";
  v90 = 0i64;
  v91 = 0i64;
  v8 = sub_14615A5E0(8ui64);
  *(_QWORD *)&v90 = v8;
  v91 = v8 + 1;
  *v8 = "eab744fe959ca29a2e5f36843d259ffc9d04a7f6";
  *((_QWORD *)&v90 + 1) = v8 + 1;
  v92 = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmplowrider/dlc.rpf";
  v93 = 0i64;
  v94 = 1088813056i64;
  v95 = 1088813056i64;
  v17 = 0i64;
  sub_146178CB0(v96, (__int64 *)&v17, (__int64)&v14);
  v97 = 0i64;
  v98 = si128;
  LOWORD(v97) = 0;
  v99 = "update/x64/dlcpacks/patchday7ng/dlc.rpf";
  v16 = "29df23f3539907a4e15f1cdb9426d462c1ad0337";
  v100 = 0i64;
  v101 = 0i64;
  v9 = sub_14615A5E0(8ui64);
  v100 = v9;
  *((_QWORD *)&v101 + 1) = v9 + 1;
  *v9 = "29df23f3539907a4e15f1cdb9426d462c1ad0337";
  *(_QWORD *)&v101 = v9 + 1;
  v102 = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday7ng/dlc.rpf";
  v103 = 0i64;
  v104 = 43843584i64;
  v105 = 43843584i64;
  v17 = 0i64;
  sub_146178CB0(v106, (__int64 *)&v17, (__int64)&v14);
  v107 = 0i64;
  v108 = 0i64;
  v109 = 7i64;
  LOWORD(v107) = 0;
  v110 = "update/x64/dlcpacks/mpxmas_604490/dlc.rpf";
  v16 = "929e5b79c9915f40f212f1ed9f9783f558242c3d";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v111, (__int64)&v17, (__int64)&v14);
  v111[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpxmas_604490/dlc.rpf";
  v111[4] = 0i64;
  v111[5] = 46061568i64;
  v111[6] = 46061568i64;
  v17 = 0i64;
  sub_146178CB0(v112, (__int64 *)&v17, (__int64)v15);
  v113 = 0i64;
  v114 = si128;
  LOWORD(v113) = 0;
  v115 = "update/x64/dlcpacks/mpapartment/dlc.rpf";
  v16 = "e1bed90e750848407f6afbe1db21aa3691bf9d82";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v116, (__int64)&v17, (__int64)v15);
  v116[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpapartment/dlc.rpf";
  v116[4] = 0i64;
  v116[5] = 636985344i64;
  v116[6] = 636985344i64;
  v17 = 0i64;
  sub_146178CB0(v117, (__int64 *)&v17, (__int64)&v14);
  v118 = 0i64;
  v119 = 0i64;
  v120 = 7i64;
  LOWORD(v118) = 0;
  v121 = "update/x64/dlcpacks/patchday8ng/dlc.rpf";
  v16 = "2f9840c20c9a93b48cfcf61e07cf17c684858e36";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v122, (__int64)&v17, (__int64)v15);
  v122[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday8ng/dlc.rpf";
  v122[4] = 0i64;
  v122[5] = 365328384i64;
  v122[6] = 365328384i64;
  v17 = 0i64;
  sub_146178CB0(v123, (__int64 *)&v17, (__int64)&v14);
  v124 = 0i64;
  v125 = si128;
  LOWORD(v124) = 0;
  v126 = "update/x64/dlcpacks/mpjanuary2016/dlc.rpf";
  v16 = "4f0d5fa835254eb918716857a47e8ce63e158c22";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v127, (__int64)&v17, (__int64)v15);
  v127[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpjanuary2016/dlc.rpf";
  v127[4] = 0i64;
  v127[5] = 149415936i64;
  v127[6] = 149415936i64;
  v17 = 0i64;
  sub_146178CB0(v128, (__int64 *)&v17, (__int64)&v14);
  v129 = 0i64;
  v130 = 0i64;
  v131 = 7i64;
  LOWORD(v129) = 0;
  v132 = "update/x64/dlcpacks/mpvalentines2/dlc.rpf";
  v16 = "b1ef3b0e4741978b5b04c54c6eca8b475681469a";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v133, (__int64)&v17, (__int64)v15);
  v133[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpvalentines2/dlc.rpf";
  v133[4] = 0i64;
  v133[5] = 25073664i64;
  v133[6] = 25073664i64;
  v17 = 0i64;
  sub_146178CB0(v134, (__int64 *)&v17, (__int64)&v14);
  v135 = 0i64;
  v136 = si128;
  LOWORD(v135) = 0;
  v137 = "update/x64/dlcpacks/mplowrider2/dlc.rpf";
  v16 = "6b9ac7b7b35b56208541692cf544788d35a84c82";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v138, (__int64)&v17, (__int64)v15);
  v138[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmplowrider2/dlc.rpf";
  v138[4] = 0i64;
  v138[5] = 334028800i64;
  v138[6] = 334028800i64;
  v17 = 0i64;
  sub_146178CB0(v139, (__int64 *)&v17, (__int64)&v14);
  v140 = 0i64;
  v141 = 0i64;
  v142 = 7i64;
  LOWORD(v140) = 0;
  v143 = "update/x64/dlcpacks/patchday9ng/dlc.rpf";
  v16 = "e29c191561d8fa4988a71be7be5ca9c6e1335537";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v144, (__int64)&v17, (__int64)v15);
  v144[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday9ng/dlc.rpf";
  v144[4] = 0i64;
  v144[5] = 160524288i64;
  v144[6] = 160524288i64;
  v17 = 0i64;
  sub_146178CB0(v145, (__int64 *)&v17, (__int64)&v14);
  v146 = 0i64;
  v147 = si128;
  LOWORD(v146) = 0;
  v148 = "update/x64/dlcpacks/mpexecutive/dlc.rpf";
  v16 = "3fa67dd4005993c9a7a66879d9f244a55fea95e9";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v149, (__int64)&v17, (__int64)v15);
  v149[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpexecutive/dlc.rpf";
  v149[4] = 0i64;
  v149[5] = 801568768i64;
  v149[6] = 801568768i64;
  v17 = 0i64;
  sub_146178CB0(v150, (__int64 *)&v17, (__int64)&v14);
  v151 = 0i64;
  v152 = 0i64;
  v153 = 7i64;
  LOWORD(v151) = 0;
  v154 = "update/x64/dlcpacks/patchday10ng/dlc.rpf";
  v16 = "4140c1f56fd29b0364be42a11fcbccd9e345d6ff";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v155, (__int64)&v17, (__int64)v15);
  v155[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday10ng/dlc.rpf";
  v155[4] = 0i64;
  v155[5] = 94134272i64;
  v155[6] = 94134272i64;
  v17 = 0i64;
  sub_146178CB0(v156, (__int64 *)&v17, (__int64)&v14);
  v157 = 0i64;
  v158 = si128;
  LOWORD(v157) = 0;
  v159 = "update/x64/dlcpacks/mpstunt/dlc.rpf";
  v16 = "c5d338068f72685523a49fddfd431a18c4628f61";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v160, (__int64)&v17, (__int64)v15);
  v160[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpstunt/dlc.rpf";
  v160[4] = 0i64;
  v160[5] = 348047360i64;
  v160[6] = 348047360i64;
  v17 = 0i64;
  sub_146178CB0(v161, (__int64 *)&v17, (__int64)&v14);
  v162 = 0i64;
  v163 = 0i64;
  v164 = 7i64;
  LOWORD(v162) = 0;
  v165 = "update/x64/dlcpacks/patchday11ng/dlc.rpf";
  v16 = "7941a22c6238c065f06ff667664c368b6dc10711";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v166, (__int64)&v17, (__int64)v15);
  v166[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday11ng/dlc.rpf";
  v166[4] = 0i64;
  v166[5] = 9955328i64;
  v166[6] = 9955328i64;
  v17 = 0i64;
  sub_146178CB0(v167, (__int64 *)&v17, (__int64)&v14);
  v168 = 0i64;
  v169 = si128;
  LOWORD(v168) = 0;
  v170 = "update/x64/dlcpacks/mpbiker/dlc.rpf";
  v16 = "52c48252eeed97e9a30efeabbc6623c67566c237";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v171, (__int64)&v17, (__int64)v15);
  v171[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
  v171[4] = 0i64;
  v171[5] = 1794048000i64;
  v171[6] = 1794048000i64;
  v17 = 0i64;
  sub_146178CB0(v172, (__int64 *)&v17, (__int64)&v14);
  v173 = 0i64;
  v174 = 0i64;
  v175 = 7i64;
  LOWORD(v173) = 0;
  v176 = "update/x64/dlcpacks/patchday12ng/dlc.rpf";
  v16 = "4f3f3e88d4f01760648057c56fb109e1fbeb116a";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v177, (__int64)&v17, (__int64)v15);
  v177[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday12ng/dlc.rpf";
  v177[4] = 0i64;
  v177[5] = 155363328i64;
  v177[6] = 155363328i64;
  v17 = 0i64;
  sub_146178CB0(v178, (__int64 *)&v17, (__int64)&v14);
  v179 = 0i64;
  v180 = si128;
  LOWORD(v179) = 0;
  v181 = "update/x64/dlcpacks/mpimportexport/dlc.rpf";
  v16 = "019b1b433d9734ac589520a74dd451d72cbff051";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v182, (__int64)&v17, (__int64)v15);
  v182[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
  v182[4] = 0i64;
  v182[5] = 915310592i64;
  v182[6] = 915310592i64;
  v17 = 0i64;
  sub_146178CB0(v183, (__int64 *)&v17, (__int64)&v14);
  v184 = 0i64;
  v185 = 0i64;
  v186 = 7i64;
  LOWORD(v184) = 0;
  v187 = "update/x64/dlcpacks/patchday13ng/dlc.rpf";
  v16 = "4fe0ee843e83ef6a7a5f3352b4f6d7eb14d96e0f";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v188, (__int64)&v17, (__int64)v15);
  v188[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday12ng/dlc.rpf";
  v188[4] = 0i64;
  v188[5] = 144752640i64;
  v188[6] = 144752640i64;
  v17 = 0i64;
  sub_146178CB0(v189, (__int64 *)&v17, (__int64)&v14);
  v190 = 0i64;
  v191 = si128;
  LOWORD(v190) = 0;
  v192 = "update/x64/dlcpacks/mpspecialraces/dlc.rpf";
  v16 = "de1a6f688fdf8965e7b9a92691ac34f9c9881742";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v193, (__int64)&v17, (__int64)v15);
  v193[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
  v193[4] = 0i64;
  v193[5] = 78448640i64;
  v193[6] = 78448640i64;
  v17 = 0i64;
  sub_146178CB0(v194, (__int64 *)&v17, (__int64)&v14);
  v195 = 0i64;
  v196 = 0i64;
  v197 = 7i64;
  LOWORD(v195) = 0;
  v198 = "update/x64/dlcpacks/patchday14ng/dlc.rpf";
  v16 = "078b683deb9b787e523093b9f3bc1bf5d3e7be09";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v199, (__int64)&v17, (__int64)v15);
  v199[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday12ng/dlc.rpf";
  v199[4] = 0i64;
  v199[5] = 92930048i64;
  v199[6] = 92930048i64;
  v17 = 0i64;
  sub_146178CB0(v200, (__int64 *)&v17, (__int64)&v14);
  v201 = 0i64;
  v202 = si128;
  LOWORD(v201) = 0;
  v203 = "update/x64/dlcpacks/mpgunrunning/dlc.rpf";
  v16 = "153bee008c16e0bcc007d76cf97999f503fc9b2a";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v204, (__int64)&v17, (__int64)v15);
  v204[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
  v204[4] = 0i64;
  v204[5] = 1879756800i64;
  v204[6] = 1879756800i64;
  v17 = 0i64;
  sub_146178CB0(v205, (__int64 *)&v17, (__int64)&v14);
  v206 = 0i64;
  v207 = 0i64;
  v208 = 7i64;
  LOWORD(v206) = 0;
  v209 = "update/x64/dlcpacks/patchday15ng/dlc.rpf";
  v16 = "6114122c428e901532ab6577ea7dbe2113126647";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v210, (__int64)&v17, (__int64)v15);
  v210[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday12ng/dlc.rpf";
  v210[4] = 0i64;
  v210[5] = 47478784i64;
  v210[6] = 47478784i64;
  v17 = 0i64;
  sub_146178CB0(v211, (__int64 *)&v17, (__int64)&v14);
  v212 = 0i64;
  v213 = si128;
  LOWORD(v212) = 0;
  v214 = "update/x64/dlcpacks/mpsmuggler/dlc.rpf";
  v16 = "ac6a3501c6e5fc2ac06a60d1bc1bd3eb8683643b";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v215, (__int64)&v17, (__int64)v15);
  v215[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
  v215[4] = 0i64;
  v215[5] = 973670400i64;
  v215[6] = 973670400i64;
  v17 = 0i64;
  sub_146178CB0(v216, (__int64 *)&v17, (__int64)&v14);
  v217 = 0i64;
  v218 = 0i64;
  v219 = 7i64;
  LOWORD(v217) = 0;
  v220 = "update/x64/dlcpacks/patchday16ng/dlc.rpf";
  v16 = "37fae29af765ff0f2d7a5abd3d40d3a9ea7f357a";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v221, (__int64)&v17, (__int64)v15);
  v221[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday12ng/dlc.rpf";
  v221[4] = 0i64;
  v221[5] = 12083200i64;
  v221[6] = 12083200i64;
  v17 = 0i64;
  sub_146178CB0(v222, (__int64 *)&v17, (__int64)&v14);
  v223 = 0i64;
  v224 = si128;
  LOWORD(v223) = 0;
  v225 = "update/x64/dlcpacks/mpchristmas2017/dlc.rpf";
  v16 = "16f8c031aa79f1e83b7f5ab883df3dbfcda8dddf";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v226, (__int64)&v17, (__int64)v15);
  v226[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
  v226[4] = 0i64;
  v226[5] = 2406123520i64;
  v226[6] = 2406123520i64;
  v17 = 0i64;
  sub_146178CB0(v227, (__int64 *)&v17, (__int64)&v14);
  v228 = 0i64;
  v229 = 0i64;
  v230 = 7i64;
  LOWORD(v228) = 0;
  v20[0] = (__int64)"7dc8639f1ffa25b3237d01aea1e9975238628952";
  v20[1] = (__int64)"c7163e1d8105c87b867b09928ea8346e26b27565";
  v20[2] = (__int64)"7dc8639f1ffa25b3237d01aea1e9975238628952";
  v231 = "update/x64/dlcpacks/patchday17ng/dlc.rpf";
  *(_QWORD *)&v17 = v20;
  *((_QWORD *)&v17 + 1) = v21;
  sub_146178AE0(v232, (__int64)&v17, (__int64)v15);
  v232[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday12ng/dlc.rpf";
  v232[4] = 0i64;
  v232[5] = 59975680i64;
  v232[6] = 59975680i64;
  v17 = 0i64;
  sub_146178CB0(v233, (__int64 *)&v17, (__int64)&v14);
  v234 = 0i64;
  v235 = si128;
  LOWORD(v234) = 0;
  v236 = "update/x64/dlcpacks/mpassault/dlc.rpf";
  v16 = "7c65b096261dd88bd1f952fc6046626f1ca56215";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v237, (__int64)&v17, (__int64)v15);
  v237[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
  v237[4] = 0i64;
  v237[5] = 314443776i64;
  v237[6] = 314443776i64;
  v17 = 0i64;
  sub_146178CB0(v238, (__int64 *)&v17, (__int64)&v14);
  v239 = 0i64;
  v240 = 0i64;
  v241 = 7i64;
  LOWORD(v239) = 0;
  v242 = "update/x64/dlcpacks/patchday18ng/dlc.rpf";
  v16 = "9e16b7af4a1e58878f0dd16dd86cbd772a8ce9ef";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v243, (__int64)&v17, (__int64)v15);
  v243[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday12ng/dlc.rpf";
  v243[4] = 0i64;
  v243[5] = 4405248i64;
  v243[6] = 4405248i64;
  v17 = 0i64;
  sub_146178CB0(v244, (__int64 *)&v17, (__int64)&v14);
  v245 = 0i64;
  v246 = si128;
  LOWORD(v245) = 0;
  v247 = "update/x64/dlcpacks/mpbattle/dlc.rpf";
  v16 = "80018257a637417b911bd4540938866ae95d0cf5";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v248, (__int64)&v17, (__int64)v15);
  v248[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
  v248[4] = 0i64;
  v248[5] = 3981039616i64;
  v248[6] = 3981039616i64;
  v17 = 0i64;
  sub_146178CB0(v249, (__int64 *)&v17, (__int64)&v14);
  v250 = 0i64;
  v251 = 0i64;
  v252 = 7i64;
  LOWORD(v250) = 0;
  v253 = "update/x64/dlcpacks/mpbattle/dlc1.rpf";
  v16 = "b16fb76065132f5f9af4b2a92431b9f91b670542";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v254, (__int64)&v17, (__int64)v15);
  v254[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
  v254[4] = 0i64;
  v254[5] = 992296960i64;
  v254[6] = 992296960i64;
  v17 = 0i64;
  sub_146178CB0(v255, (__int64 *)&v17, (__int64)&v14);
  v256 = 0i64;
  v257 = si128;
  LOWORD(v256) = 0;
  v258 = "update/x64/dlcpacks/patchday19ng/dlc.rpf";
  v16 = "3373311add1eb5ff850e1f3fbb7d15512cbc5b8b";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v259, (__int64)&v17, (__int64)v15);
  v259[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday12ng/dlc.rpf";
  v259[4] = 0i64;
  v259[5] = 765630464i64;
  v259[6] = 765630464i64;
  v17 = 0i64;
  sub_146178CB0(v260, (__int64 *)&v17, (__int64)&v14);
  v261 = 0i64;
  v262 = 0i64;
  v263 = 7i64;
  LOWORD(v261) = 0;
  v264 = "update/x64/dlcpacks/mpchristmas2018/dlc.rpf";
  v16 = "c4cda116420f14a28e5a999740cc53cf53a950ec";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v265, (__int64)&v17, (__int64)v15);
  v265[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
  v265[4] = 0i64;
  v265[5] = 3247781888i64;
  v265[6] = 3247781888i64;
  v17 = 0i64;
  sub_146178CB0(v266, (__int64 *)&v17, (__int64)&v14);
  v267 = 0i64;
  v268 = si128;
  LOWORD(v267) = 0;
  v269 = "update/x64/dlcpacks/patchday20ng/dlc.rpf";
  v16 = "fbba396a0ede622e08f76c5ced8ac1d6839c0227";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v270, (__int64)&v17, (__int64)v15);
  v270[3] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfpatchday12ng/dlc.rpf";
  v270[4] = 0i64;
  v270[5] = 457129984i64;
  v270[6] = 457129984i64;
  v17 = 0i64;
  sub_146178CB0(v271, (__int64 *)&v17, (__int64)&v14);
  v272 = 0i64;
  v273 = 0i64;
  v274 = 7i64;
  LOWORD(v272) = 0;
  v275 = "ros_2090/socialclub.dll";
  v16 = "AE14687363C0FB5A8B086B4EB24D5A6E2D5161B9";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v276, (__int64)&v17, (__int64)v15);
  v276[3] = "https://content.cfx.re/mirrors/ros/2.0.9.0/socialclub.dll";
  v276[4] = 0i64;
  v276[5] = 5287320i64;
  v276[6] = 5287320i64;
  v17 = 0i64;
  sub_146178CB0(v277, (__int64 *)&v17, (__int64)&v14);
  v278 = 0i64;
  v279 = si128;
  LOWORD(v278) = 0;
  v280 = "ros_2090/socialclub.pak";
  v16 = "D70F269F7EBBA3A13AA2871BAFA58212B01E6280";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v281, (__int64)&v17, (__int64)v15);
  v281[3] = "https://content.cfx.re/mirrors/ros/2.0.9.0/socialclub.pak";
  v281[4] = 0i64;
  v281[5] = 4996i64;
  v281[6] = 4996i64;
  v17 = 0i64;
  sub_146178CB0(v282, (__int64 *)&v17, (__int64)&v14);
  v283 = 0i64;
  v284 = 0i64;
  v285 = 7i64;
  LOWORD(v283) = 0;
  v286 = "launcher/LauncherPatcher.exe";
  v16 = "1C6BCE6CDB4B2E1766A67F931A72519CEFF6AEB1";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v287, (__int64)&v17, (__int64)v15);
  v287[3] = Src;
  v287[4] = Src;
  v287[5] = 0i64;
  v287[6] = 0i64;
  v17 = 0i64;
  sub_146178CB0(v288, (__int64 *)&v17, (__int64)&v14);
  v289 = 0i64;
  v290 = si128;
  LOWORD(v289) = 0;
  v291 = "launcher/index.bin";
  v16 = "85e2cc75d6d07518883ce5d377d3425b74636667";
  *(_QWORD *)&v17 = &v16;
  *((_QWORD *)&v17 + 1) = &v17;
  sub_146178AE0(v292, (__int64)&v17, (__int64)v15);
  v292[3] = Src;
  v292[4] = Src;
  v292[5] = 0i64;
  v292[6] = 0i64;
  v17 = 0i64;
  sub_146178CB0(v293, (__int64 *)&v17, (__int64)&v14);
  v294 = 0i64;
  v295 = 0i64;
  v296 = 7i64;
  LOWORD(v294) = 0;
  xmmword_14610AAC0 = 0i64;
  qword_14610AAD0 = 0i64;
  v10 = sub_14615A5E0(0x1428ui64);
  *(_QWORD *)&xmmword_14610AAC0 = v10;
  *((_QWORD *)&xmmword_14610AAC0 + 1) = v10;
  qword_14610AAD0 = (__int64)(v10 + 645);
  v16 = (const char *)&xmmword_14610AAC0;
  v12 = v21;
  *(_QWORD *)&v17 = v10;
  *((_QWORD *)&v17 + 1) = v10;
  v18 = &xmmword_14610AAC0;
  do
  {
    sub_146178F20(v10, v12, v11);
    v10 += 15;
    *((_QWORD *)&v17 + 1) = v10;
    v12 += 15;
  }
  while ( v12 != (__int64 *)&v297 );
  *((_QWORD *)&xmmword_14610AAC0 + 1) = v10;
  `eh vector destructor iterator'(v21, 0x78ui64, 0x2Bui64, (void (__fastcall *)(void *))sub_146179300);
  return atexit(sub_1461AE700);
}
// 146158FB6: variable 'v11' is possibly undefined
// 14610AAC0: using guessed type __int128 xmmword_14610AAC0;
// 14610AAD0: using guessed type __int64 qword_14610AAD0;
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 146157270: using guessed type __int64 var_1410[3];
// 146157270: using guessed type __int64 var_1398[3];
// 146157270: using guessed type __int64 var_1320[3];
// 146157270: using guessed type __int64 var_12A8[3];
// 146157270: using guessed type __int64 var_1230[3];
// 146157270: using guessed type __int64 var_11B8[3];
// 146157270: using guessed type __int64 var_1140[3];
// 146157270: using guessed type __int64 var_10C8[3];
// 146157270: using guessed type __int64 var_1050[3];
// 146157270: using guessed type __int64 var_FD8[3];
// 146157270: using guessed type __int64 var_F60[3];
// 146157270: using guessed type __int64 var_EE8[3];
// 146157270: using guessed type __int64 var_E70[3];
// 146157270: using guessed type __int64 var_DF8[3];
// 146157270: using guessed type __int64 var_D80[3];
// 146157270: using guessed type __int64 var_D08[3];
// 146157270: using guessed type __int64 var_C90[3];
// 146157270: using guessed type __int64 var_C18[3];
// 146157270: using guessed type __int64 var_BA0[3];
// 146157270: using guessed type __int64 var_B28[3];
// 146157270: using guessed type __int64 var_AB0[3];
// 146157270: using guessed type __int64 var_A38[3];
// 146157270: using guessed type __int64 var_9C0[3];
// 146157270: using guessed type __int64 var_948[3];
// 146157270: using guessed type __int64 var_8D0[3];
// 146157270: using guessed type __int64 var_858[3];
// 146157270: using guessed type __int64 var_7E0[3];
// 146157270: using guessed type __int64 var_768[3];
// 146157270: using guessed type __int64 var_6F0[3];
// 146157270: using guessed type __int64 var_678[3];
// 146157270: using guessed type __int64 var_600[3];
// 146157270: using guessed type __int64 var_588[3];
// 146157270: using guessed type __int64 var_510[3];
// 146157270: using guessed type __int64 var_498[3];
// 146157270: using guessed type __int64 var_420[3];
// 146157270: using guessed type __int64 var_3A8[3];
// 146157270: using guessed type __int64 var_330[3];
// 146157270: using guessed type __int64 var_2B8[3];
// 146157270: using guessed type __int64 var_240[3];
// 146157270: using guessed type __int64 var_1C8[3];
// 146157270: using guessed type __int64 var_150[3];
// 146157270: using guessed type __int64 var_D8[3];
// 146157270: using guessed type __int64 var_60[3];

//----- (0000000146159030) ----------------------------------------------------
int sub_146159030()
{
  _QWORD *v0; // rsi
  __int64 *v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  void *v6; // rdi
  _OWORD *v7; // rax
  __int128 v9; // [rsp+20h] [rbp-98h] BYREF
  __int64 v10[2]; // [rsp+30h] [rbp-88h] BYREF
  int v11; // [rsp+40h] [rbp-78h]
  int v12; // [rsp+44h] [rbp-74h]
  __int64 v13; // [rsp+48h] [rbp-70h]
  void **v14; // [rsp+50h] [rbp-68h] BYREF
  __int64 v15; // [rsp+58h] [rbp-60h]
  __int64 v16; // [rsp+60h] [rbp-58h]
  __int64 v17; // [rsp+78h] [rbp-40h]
  char v18[32]; // [rsp+80h] [rbp-38h] BYREF

  v16 = -2i64;
  v10[0] = (__int64)"rdr3";
  v10[1] = 4i64;
  v11 = 1491;
  v12 = HIDWORD(v17);
  v13 = 50i64;
  v0 = operator new(0x40ui64);
  *v0 = v0;
  v0[1] = v0;
  v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
  qword_14610AAD8 = v0;
  v1 = v10;
  do
  {
    v2 = sub_14615A770((__int64 *)&qword_14610AAD8, (__int64)v18, v0, (__int64)v1);
    v9 = *(_OWORD *)v2;
    v17 = *(_QWORD *)(v2 + 16);
    if ( !(_BYTE)v17 )
    {
      if ( qword_14610AAE0 == 0x3FFFFFFFFFFFFFFi64 )
        unknown_libname_3(v4, v3, v5);
      v6 = qword_14610AAD8;
      v14 = &qword_14610AAD8;
      v15 = 0i64;
      v7 = operator new(0x40ui64);
      v7[2] = *(_OWORD *)v1;
      v7[3] = *((_OWORD *)v1 + 1);
      *(_QWORD *)v7 = v6;
      *((_QWORD *)v7 + 1) = v6;
      *((_QWORD *)v7 + 2) = v6;
      *((_WORD *)v7 + 12) = 0;
      v15 = 0i64;
      sub_146165130(&qword_14610AAD8, (__int64)&v9, (__int64)v7);
    }
    v1 += 4;
  }
  while ( v1 != (__int64 *)&v14 );
  return atexit(sub_1461AE710);
}
// 146159192: variable 'v4' is possibly undefined
// 146159192: variable 'v3' is possibly undefined
// 146159192: variable 'v5' is possibly undefined
// 14610AAE0: using guessed type __int64 qword_14610AAE0;
// 1461653B0: using guessed type void __fastcall __noreturn unknown_libname_3(_QWORD, _QWORD, _QWORD);
// 146159030: using guessed type char var_38[32];

//----- (00000001461591A0) ----------------------------------------------------
int sub_1461591A0()
{
  _QWORD *v0; // rax

  v0 = operator new(0x60ui64);
  *v0 = v0;
  v0[1] = v0;
  v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
  qword_14610AB20 = v0;
  return atexit(sub_1461AE780);
}

//----- (00000001461591E0) ----------------------------------------------------
int sub_1461591E0()
{
  _QWORD *v0; // rsi
  __int64 *v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  void *v6; // rdi
  _OWORD *v7; // rax
  __int128 v9; // [rsp+20h] [rbp-98h] BYREF
  __int64 v10[2]; // [rsp+30h] [rbp-88h] BYREF
  int v11; // [rsp+40h] [rbp-78h]
  int v12; // [rsp+44h] [rbp-74h]
  __int64 v13; // [rsp+48h] [rbp-70h]
  void **v14; // [rsp+50h] [rbp-68h] BYREF
  __int64 v15; // [rsp+58h] [rbp-60h]
  __int64 v16; // [rsp+60h] [rbp-58h]
  __int64 v17; // [rsp+78h] [rbp-40h]
  char v18[32]; // [rsp+80h] [rbp-38h] BYREF

  v16 = -2i64;
  v10[0] = (__int64)"rdr3";
  v10[1] = 4i64;
  v11 = 1491;
  v12 = HIDWORD(v17);
  v13 = 50i64;
  v0 = operator new(0x40ui64);
  *v0 = v0;
  v0[1] = v0;
  v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
  qword_14610AB10 = v0;
  v1 = v10;
  do
  {
    v2 = sub_14615A770((__int64 *)&qword_14610AB10, (__int64)v18, v0, (__int64)v1);
    v9 = *(_OWORD *)v2;
    v17 = *(_QWORD *)(v2 + 16);
    if ( !(_BYTE)v17 )
    {
      if ( qword_14610AB18 == 0x3FFFFFFFFFFFFFFi64 )
        unknown_libname_3(v4, v3, v5);
      v6 = qword_14610AB10;
      v14 = &qword_14610AB10;
      v15 = 0i64;
      v7 = operator new(0x40ui64);
      v7[2] = *(_OWORD *)v1;
      v7[3] = *((_OWORD *)v1 + 1);
      *(_QWORD *)v7 = v6;
      *((_QWORD *)v7 + 1) = v6;
      *((_QWORD *)v7 + 2) = v6;
      *((_WORD *)v7 + 12) = 0;
      v15 = 0i64;
      sub_146165130(&qword_14610AB10, (__int64)&v9, (__int64)v7);
    }
    v1 += 4;
  }
  while ( v1 != (__int64 *)&v14 );
  return atexit(sub_1461AE890);
}
// 146159342: variable 'v4' is possibly undefined
// 146159342: variable 'v3' is possibly undefined
// 146159342: variable 'v5' is possibly undefined
// 14610AB18: using guessed type __int64 qword_14610AB18;
// 1461653B0: using guessed type void __fastcall __noreturn unknown_libname_3(_QWORD, _QWORD, _QWORD);
// 1461591E0: using guessed type char var_38[32];

//----- (0000000146159350) ----------------------------------------------------
int sub_146159350()
{
  _QWORD *v0; // rsi
  __int64 *v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  void *v6; // rdi
  _OWORD *v7; // rax
  __int128 v9; // [rsp+20h] [rbp-98h] BYREF
  __int64 v10[2]; // [rsp+30h] [rbp-88h] BYREF
  int v11; // [rsp+40h] [rbp-78h]
  int v12; // [rsp+44h] [rbp-74h]
  __int64 v13; // [rsp+48h] [rbp-70h]
  void **v14; // [rsp+50h] [rbp-68h] BYREF
  __int64 v15; // [rsp+58h] [rbp-60h]
  __int64 v16; // [rsp+60h] [rbp-58h]
  __int64 v17; // [rsp+78h] [rbp-40h]
  char v18[32]; // [rsp+80h] [rbp-38h] BYREF

  v16 = -2i64;
  v10[0] = (__int64)"rdr3";
  v10[1] = 4i64;
  v11 = 1491;
  v12 = HIDWORD(v17);
  v13 = 50i64;
  v0 = operator new(0x40ui64);
  *v0 = v0;
  v0[1] = v0;
  v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
  qword_14611AB98 = v0;
  v1 = v10;
  do
  {
    v2 = sub_14615A770((__int64 *)&qword_14611AB98, (__int64)v18, v0, (__int64)v1);
    v9 = *(_OWORD *)v2;
    v17 = *(_QWORD *)(v2 + 16);
    if ( !(_BYTE)v17 )
    {
      if ( qword_14611ABA0 == 0x3FFFFFFFFFFFFFFi64 )
        unknown_libname_3(v4, v3, v5);
      v6 = qword_14611AB98;
      v14 = &qword_14611AB98;
      v15 = 0i64;
      v7 = operator new(0x40ui64);
      v7[2] = *(_OWORD *)v1;
      v7[3] = *((_OWORD *)v1 + 1);
      *(_QWORD *)v7 = v6;
      *((_QWORD *)v7 + 1) = v6;
      *((_QWORD *)v7 + 2) = v6;
      *((_WORD *)v7 + 12) = 0;
      v15 = 0i64;
      sub_146165130(&qword_14611AB98, (__int64)&v9, (__int64)v7);
    }
    v1 += 4;
  }
  while ( v1 != (__int64 *)&v14 );
  return atexit(sub_1461AE950);
}
// 1461594B2: variable 'v4' is possibly undefined
// 1461594B2: variable 'v3' is possibly undefined
// 1461594B2: variable 'v5' is possibly undefined
// 14611ABA0: using guessed type __int64 qword_14611ABA0;
// 1461653B0: using guessed type void __fastcall __noreturn unknown_libname_3(_QWORD, _QWORD, _QWORD);
// 146159350: using guessed type char var_38[32];

//----- (00000001461594C0) ----------------------------------------------------
__int64 sub_1461594C0()
{
  sub_1461A2980((__int64)&qword_14611AD20, 0x80000000);
  qword_14611AD20 = (__int64)&InitFunction::`vftable';
  qword_14611AD38 = (__int64)sub_1461A3120;
  return sub_1461A2B10((__int64)&qword_14611AD20);
}
// 14611AD20: using guessed type __int64 qword_14611AD20;
// 14611AD38: using guessed type __int64 qword_14611AD38;
// 14612FF20: using guessed type void *InitFunction::`vftable';
// 1461594C0: using guessed type __int64 sub_1461594C0();

//----- (0000000146159510) ----------------------------------------------------
int sub_146159510()
{
  _QWORD *v0; // rsi
  __int64 *v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  void *v6; // rdi
  _OWORD *v7; // rax
  __int128 v9; // [rsp+20h] [rbp-98h] BYREF
  __int64 v10[2]; // [rsp+30h] [rbp-88h] BYREF
  int v11; // [rsp+40h] [rbp-78h]
  int v12; // [rsp+44h] [rbp-74h]
  __int64 v13; // [rsp+48h] [rbp-70h]
  void **v14; // [rsp+50h] [rbp-68h] BYREF
  __int64 v15; // [rsp+58h] [rbp-60h]
  __int64 v16; // [rsp+60h] [rbp-58h]
  __int64 v17; // [rsp+78h] [rbp-40h]
  char v18[32]; // [rsp+80h] [rbp-38h] BYREF

  v16 = -2i64;
  v10[0] = (__int64)"rdr3";
  v10[1] = 4i64;
  v11 = 1491;
  v12 = HIDWORD(v17);
  v13 = 50i64;
  v0 = operator new(0x40ui64);
  *v0 = v0;
  v0[1] = v0;
  v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
  qword_14611AD48 = v0;
  v1 = v10;
  do
  {
    v2 = sub_14615A770((__int64 *)&qword_14611AD48, (__int64)v18, v0, (__int64)v1);
    v9 = *(_OWORD *)v2;
    v17 = *(_QWORD *)(v2 + 16);
    if ( !(_BYTE)v17 )
    {
      if ( qword_14611AD50 == 0x3FFFFFFFFFFFFFFi64 )
        unknown_libname_3(v4, v3, v5);
      v6 = qword_14611AD48;
      v14 = &qword_14611AD48;
      v15 = 0i64;
      v7 = operator new(0x40ui64);
      v7[2] = *(_OWORD *)v1;
      v7[3] = *((_OWORD *)v1 + 1);
      *(_QWORD *)v7 = v6;
      *((_QWORD *)v7 + 1) = v6;
      *((_QWORD *)v7 + 2) = v6;
      *((_WORD *)v7 + 12) = 0;
      v15 = 0i64;
      sub_146165130(&qword_14611AD48, (__int64)&v9, (__int64)v7);
    }
    v1 += 4;
  }
  while ( v1 != (__int64 *)&v14 );
  return atexit(sub_1461AEB80);
}
// 146159672: variable 'v4' is possibly undefined
// 146159672: variable 'v3' is possibly undefined
// 146159672: variable 'v5' is possibly undefined
// 14611AD50: using guessed type __int64 qword_14611AD50;
// 1461653B0: using guessed type void __fastcall __noreturn unknown_libname_3(_QWORD, _QWORD, _QWORD);
// 146159510: using guessed type char var_38[32];

//----- (0000000146159680) ----------------------------------------------------
int sub_146159680()
{
  _QWORD *v0; // rsi
  __int64 *v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  void *v6; // rdi
  _OWORD *v7; // rax
  __int128 v9; // [rsp+20h] [rbp-98h] BYREF
  __int64 v10[2]; // [rsp+30h] [rbp-88h] BYREF
  int v11; // [rsp+40h] [rbp-78h]
  int v12; // [rsp+44h] [rbp-74h]
  __int64 v13; // [rsp+48h] [rbp-70h]
  void **v14; // [rsp+50h] [rbp-68h] BYREF
  __int64 v15; // [rsp+58h] [rbp-60h]
  __int64 v16; // [rsp+60h] [rbp-58h]
  __int64 v17; // [rsp+78h] [rbp-40h]
  char v18[32]; // [rsp+80h] [rbp-38h] BYREF

  v16 = -2i64;
  v10[0] = (__int64)"rdr3";
  v10[1] = 4i64;
  v11 = 1491;
  v12 = HIDWORD(v17);
  v13 = 50i64;
  v0 = operator new(0x40ui64);
  *v0 = v0;
  v0[1] = v0;
  v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
  qword_14611ADC8 = v0;
  v1 = v10;
  do
  {
    v2 = sub_14615A770((__int64 *)&qword_14611ADC8, (__int64)v18, v0, (__int64)v1);
    v9 = *(_OWORD *)v2;
    v17 = *(_QWORD *)(v2 + 16);
    if ( !(_BYTE)v17 )
    {
      if ( qword_14611ADD0 == 0x3FFFFFFFFFFFFFFi64 )
        unknown_libname_3(v4, v3, v5);
      v6 = qword_14611ADC8;
      v14 = &qword_14611ADC8;
      v15 = 0i64;
      v7 = operator new(0x40ui64);
      v7[2] = *(_OWORD *)v1;
      v7[3] = *((_OWORD *)v1 + 1);
      *(_QWORD *)v7 = v6;
      *((_QWORD *)v7 + 1) = v6;
      *((_QWORD *)v7 + 2) = v6;
      *((_WORD *)v7 + 12) = 0;
      v15 = 0i64;
      sub_146165130(&qword_14611ADC8, (__int64)&v9, (__int64)v7);
    }
    v1 += 4;
  }
  while ( v1 != (__int64 *)&v14 );
  return atexit(sub_1461AEBF0);
}
// 1461597E2: variable 'v4' is possibly undefined
// 1461597E2: variable 'v3' is possibly undefined
// 1461597E2: variable 'v5' is possibly undefined
// 14611ADD0: using guessed type __int64 qword_14611ADD0;
// 1461653B0: using guessed type void __fastcall __noreturn unknown_libname_3(_QWORD, _QWORD, _QWORD);
// 146159680: using guessed type char var_38[32];

//----- (00000001461597E8) ----------------------------------------------------
int sub_1461597E8()
{
  return atexit(sub_1461AEC54);
}

//----- (0000000146159800) ----------------------------------------------------
__int64 *__fastcall sub_146159800(__int64 *a1, __int64 *a2, int a3)
{
  __int64 v3; // rax
  __int64 v5; // r11
  unsigned int v6; // r9d
  unsigned int v8; // ecx

  v3 = a1[2];
  v5 = a1[1];
  v6 = a3;
  if ( a3 >= 0 )
  {
    v8 = dword_14611CFB0[(__int64)(int)(*(_DWORD *)(v5 + 12) << 25) >> 29];
  }
  else
  {
    v8 = 16777261;
    v6 = -a3;
  }
  sub_14615EFB0(a2, *a1, v6 | ((unsigned __int64)v8 << 32), v5, v3);
  return a2;
}
// 14611CFB0: using guessed type int dword_14611CFB0[];

//----- (0000000146159870) ----------------------------------------------------
void __noreturn sub_146159870()
{
  const char *pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v1; // [rsp+30h] [rbp-38h]
  void **v2; // [rsp+40h] [rbp-28h] BYREF
  __int128 v3; // [rsp+48h] [rbp-20h]

  v2 = &std::exception::`vftable';
  v3 = 0i64;
  pExceptionObject = "width is not integer";
  v1 = 1;
  _std_exception_copy(&pExceptionObject);
  v2 = &fmt::v8::format_error::`vftable';
  sub_146162440((__int64)&pExceptionObject, (__int64)&v2);
  CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 146159870: using guessed type void __noreturn sub_146159870();
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (00000001461598F0) ----------------------------------------------------
void __noreturn sub_1461598F0()
{
  const char *pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v1; // [rsp+30h] [rbp-38h]
  void **v2; // [rsp+40h] [rbp-28h] BYREF
  __int128 v3; // [rsp+48h] [rbp-20h]

  v2 = &std::exception::`vftable';
  v3 = 0i64;
  pExceptionObject = "precision is not integer";
  v1 = 1;
  _std_exception_copy(&pExceptionObject);
  v2 = &fmt::v8::format_error::`vftable';
  sub_146162440((__int64)&pExceptionObject, (__int64)&v2);
  CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461598F0: using guessed type void __noreturn sub_1461598F0();
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146159970) ----------------------------------------------------
char __fastcall sub_146159970(unsigned int *a1, _QWORD **a2)
{
  __int16 v4; // dx
  _BYTE *v5; // rcx
  _BYTE *v6; // rcx
  _BYTE *v7; // rcx
  _BYTE *v8; // rcx
  _BYTE *v9; // rcx
  _BYTE *v10; // rcx
  _BYTE *v11; // rcx
  _BYTE *v12; // rcx
  _BYTE *v13; // rcx
  _BYTE *v14; // rcx
  _BYTE *v15; // rcx
  _BYTE *v16; // rcx
  char *v17; // rax
  __int64 v18; // rbx
  _BYTE *v19; // rcx
  __int64 v20; // rbx
  unsigned int v21; // r8d
  unsigned __int8 *v22; // rdx
  _QWORD *v23; // rbx
  _BYTE *v24; // rcx
  char *v25; // rax
  _QWORD *v26; // rbx
  _BYTE *v27; // rcx
  __int64 v28; // rbx
  _QWORD *v29; // rbx
  _BYTE *v30; // rcx
  double v32; // xmm6_8
  _QWORD *v33; // rbx
  char *v34; // rdi
  char *v35; // rbx
  int v36; // esi
  char *v37; // rax
  signed int v38; // edi
  _QWORD *v39; // rbx
  _BYTE *v40; // rsi
  _BYTE *v41; // rdx
  signed __int64 v42; // rax
  unsigned int v43; // esi
  _QWORD *v44; // rbx
  _BYTE *v45; // rdi
  signed __int64 v46; // rdi
  _QWORD *v47; // rbx
  _BYTE *v48; // rsi
  _BYTE *v49; // rdx
  unsigned __int64 v50; // rsi
  _QWORD *v51; // rbx
  _BYTE *v52; // rdi
  double v53; // [rsp+60h] [rbp+8h] BYREF
  int v54; // [rsp+70h] [rbp+18h] BYREF

  v4 = *((_WORD *)a1 + 7);
  switch ( v4 & 7 )
  {
    case 0:
      sub_1461648D0((__int64)a2);
      sub_14615A510(*a2, 4i64);
      v5 = (_BYTE *)(*a2)[3];
      (*a2)[3] = v5 + 1;
      *v5 = 110;
      v6 = (_BYTE *)(*a2)[3];
      (*a2)[3] = v6 + 1;
      *v6 = 117;
      v7 = (_BYTE *)(*a2)[3];
      (*a2)[3] = v7 + 1;
      *v7 = 108;
      v8 = (_BYTE *)(*a2)[3];
      (*a2)[3] = v8 + 1;
      *v8 = 108;
      return 1;
    case 1:
      sub_1461648D0((__int64)a2);
      sub_14615A510(*a2, 5i64);
      v9 = (_BYTE *)(*a2)[3];
      (*a2)[3] = v9 + 1;
      *v9 = 102;
      v10 = (_BYTE *)(*a2)[3];
      (*a2)[3] = v10 + 1;
      *v10 = 97;
      v11 = (_BYTE *)(*a2)[3];
      (*a2)[3] = v11 + 1;
      *v11 = 108;
      v12 = (_BYTE *)(*a2)[3];
      (*a2)[3] = v12 + 1;
      *v12 = 115;
      goto LABEL_4;
    case 2:
      sub_1461648D0((__int64)a2);
      sub_14615A510(*a2, 4i64);
      v14 = (_BYTE *)(*a2)[3];
      (*a2)[3] = v14 + 1;
      *v14 = 116;
      v15 = (_BYTE *)(*a2)[3];
      (*a2)[3] = v15 + 1;
      *v15 = 114;
      v16 = (_BYTE *)(*a2)[3];
      (*a2)[3] = v16 + 1;
      *v16 = 117;
LABEL_4:
      v13 = (_BYTE *)(*a2)[3];
      (*a2)[3] = v13 + 1;
      *v13 = 101;
      return 1;
    case 3:
      sub_1461648D0((__int64)a2);
      v17 = sub_14615A430(a2 + 1, 1i64);
      *(_QWORD *)v17 = 0i64;
      v17[8] = 0;
      v18 = (__int64)*a2;
      sub_14615A510(*a2, 1i64);
      v19 = *(_BYTE **)(v18 + 24);
      *(_QWORD *)(v18 + 24) = v19 + 1;
      *v19 = 123;
      v20 = *((_QWORD *)a1 + 1) & 0xFFFFFFFFFFFFi64;
      if ( v20 == v20 + 32i64 * *a1 )
        goto LABEL_13;
      while ( 1 )
      {
        if ( _bittest16((const signed __int16 *)(v20 + 14), 0xCu) )
        {
          v21 = 13 - *(char *)(v20 + 13);
          v22 = (unsigned __int8 *)v20;
        }
        else
        {
          v21 = *(_DWORD *)v20;
          v22 = (unsigned __int8 *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFi64);
        }
        if ( !sub_146164B40(a2, v22, v21) || !(unsigned __int8)sub_146159970(v20 + 16, a2) )
          break;
        v20 += 32i64;
        if ( v20 == (*((_QWORD *)a1 + 1) & 0xFFFFFFFFFFFFi64) + 32i64 * *a1 )
        {
LABEL_13:
          a2[4] -= 2;
          v23 = *a2;
          sub_14615A510(*a2, 1i64);
          v24 = (_BYTE *)v23[3];
          v23[3] = v24 + 1;
          *v24 = 125;
          return 1;
        }
      }
      return 0;
    case 4:
      sub_1461648D0((__int64)a2);
      v25 = sub_14615A430(a2 + 1, 1i64);
      *(_QWORD *)v25 = 0i64;
      v25[8] = 1;
      v26 = *a2;
      sub_14615A510(*a2, 1i64);
      v27 = (_BYTE *)v26[3];
      v26[3] = v27 + 1;
      *v27 = 91;
      v28 = *((_QWORD *)a1 + 1) & 0xFFFFFFFFFFFFi64;
      if ( v28 == v28 + 16i64 * *a1 )
        goto LABEL_17;
      break;
    case 5:
      if ( (v4 & 0x1000) != 0 )
        return sub_146164B40(a2, (unsigned __int8 *)a1, 13 - *((char *)a1 + 13));
      else
        return sub_146164B40(a2, (unsigned __int8 *)(*((_QWORD *)a1 + 1) & 0xFFFFFFFFFFFFi64), *a1);
    default:
      if ( (*((_WORD *)a1 + 7) & 0x200) != 0 )
      {
        v32 = *(double *)a1;
        sub_1461648D0((__int64)a2);
        v53 = v32;
        if ( (*(_QWORD *)&v32 & 0x7FF0000000000000i64) == 0x7FF0000000000000i64 )
          return 0;
        v33 = *a2;
        sub_14615A510(*a2, 25i64);
        v34 = (char *)v33[3];
        v53 = v32;
        v33[3] = v34 + 25;
        v35 = v34;
        v36 = *((_DWORD *)a2 + 14);
        if ( (*(_QWORD *)&v53 & 0x7FFFFFFFFFFFFFFFi64) != 0 )
        {
          if ( v32 < 0.0 )
          {
            v32 = -v32;
            v35 = v34 + 1;
            *v34 = 45;
          }
          sub_1461643F0(v32, (__int64)v35, &v54, &v53);
          v37 = sub_146164980(v35, v54, SLODWORD(v53), v36);
        }
        else
        {
          if ( v53 < 0.0 )
          {
            *v34 = 45;
            v35 = v34 + 1;
          }
          *(_WORD *)v35 = 11824;
          v37 = v35 + 3;
          v35[2] = 48;
        }
        (*a2)[3] += v37 - v34 - 25;
        return 1;
      }
      if ( (v4 & 0x20) != 0 )
      {
        v38 = *a1;
        sub_1461648D0((__int64)a2);
        v39 = *a2;
        sub_14615A510(*a2, 11i64);
        v40 = (_BYTE *)v39[3];
        v41 = v40;
        v39[3] = v40 + 11;
        if ( v38 < 0 )
        {
          *v40 = 45;
          v41 = v40 + 1;
          v38 = -v38;
        }
        v42 = sub_146165830(v38, v41) - v40 - 11;
      }
      else if ( (v4 & 0x40) != 0 )
      {
        v43 = *a1;
        sub_1461648D0((__int64)a2);
        v44 = *a2;
        sub_14615A510(*a2, 10i64);
        v45 = (_BYTE *)v44[3];
        v44[3] = v45 + 10;
        v42 = sub_146165830(v43, v45) - v45 - 10;
      }
      else if ( (v4 & 0x80u) == 0 )
      {
        v50 = *(_QWORD *)a1;
        sub_1461648D0((__int64)a2);
        v51 = *a2;
        sub_14615A510(*a2, 20i64);
        v52 = (_BYTE *)v51[3];
        v51[3] = v52 + 20;
        v42 = sub_146165A90(v50, v52) - v52 - 20;
      }
      else
      {
        v46 = *(_QWORD *)a1;
        sub_1461648D0((__int64)a2);
        v47 = *a2;
        sub_14615A510(*a2, 21i64);
        v48 = (_BYTE *)v47[3];
        v49 = v48;
        v47[3] = v48 + 21;
        if ( v46 < 0 )
        {
          *v48 = 45;
          v49 = v48 + 1;
          v46 = -v46;
        }
        v42 = sub_146165A90(v46, v49) - v48 - 21;
      }
      (*a2)[3] += v42;
      return 1;
  }
  do
  {
    if ( !(unsigned __int8)sub_146159970(v28, a2) )
      return 0;
    v28 += 16i64;
  }
  while ( v28 != (*((_QWORD *)a1 + 1) & 0xFFFFFFFFFFFFi64) + 16i64 * *a1 );
LABEL_17:
  a2[4] -= 2;
  v29 = *a2;
  sub_14615A510(*a2, 1i64);
  v30 = (_BYTE *)v29[3];
  v29[3] = v30 + 1;
  *v30 = 93;
  return 1;
}

//----- (0000000146159F90) ----------------------------------------------------
_QWORD *__fastcall sub_146159F90(_QWORD *a1, __int64 a2, unsigned int *a3)
{
  _QWORD *v6; // rax
  void *v7; // r9
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rcx
  __int16 v13; // ax
  __int16 v14; // bx
  int v15; // eax
  char *v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  char *v19; // rbx
  size_t v20; // rdx
  _BYTE *v21; // rcx
  size_t v22; // rax
  __int64 v23; // rbx
  size_t v24; // rdi
  const void *v25; // r15
  size_t v26; // rdi
  __int64 v27; // r14
  _QWORD *v28; // rbx
  void *v29; // rdi
  _QWORD *v30; // rax
  _QWORD *v31; // rbx
  __int128 v33; // [rsp+20h] [rbp-E0h] BYREF
  const char *v34; // [rsp+30h] [rbp-D0h] BYREF
  int v35; // [rsp+38h] [rbp-C8h]
  void *v36[2]; // [rsp+40h] [rbp-C0h] BYREF
  void *Block[2]; // [rsp+50h] [rbp-B0h]
  __m128i Size; // [rsp+60h] [rbp-A0h]
  _QWORD *v39[2]; // [rsp+80h] [rbp-80h] BYREF
  void *v40[2]; // [rsp+90h] [rbp-70h]
  __int128 v41; // [rsp+A0h] [rbp-60h]
  __int64 v42; // [rsp+B0h] [rbp-50h]
  int v43; // [rsp+B8h] [rbp-48h]
  char v44; // [rsp+BCh] [rbp-44h]
  __int64 v45; // [rsp+C0h] [rbp-40h]
  __int128 v46; // [rsp+D0h] [rbp-30h] BYREF
  void *v47[2]; // [rsp+E0h] [rbp-20h]
  void *v48[2]; // [rsp+F0h] [rbp-10h]
  void *v49[2]; // [rsp+100h] [rbp+0h]
  __m128i si128; // [rsp+110h] [rbp+10h]
  int v51; // [rsp+120h] [rbp+20h]
  __int64 v52; // [rsp+128h] [rbp+28h]

  v45 = -2i64;
  v46 = 0i64;
  HIWORD(v46) = 0;
  *(_OWORD *)v47 = 0i64;
  *(_OWORD *)v48 = 0i64;
  *(_OWORD *)v49 = 0i64;
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA40);
  v51 = 0;
  v52 = 0i64;
  v6 = operator new(0x28ui64);
  v7 = v6;
  *(_QWORD *)&v33 = v6;
  if ( v6 )
  {
    *v6 = 0i64;
    v6[1] = 0x10000i64;
    v6[2] = 0i64;
    v6[3] = 0i64;
    v6[4] = 0i64;
  }
  else
  {
    v7 = 0i64;
  }
  v47[0] = v7;
  v47[1] = v7;
  v46 = 0i64;
  HIWORD(v46) = 3;
  v8 = *(_QWORD *)a2;
  v33 = 0i64;
  HIWORD(v33) = 1029;
  v9 = (unsigned __int64)&unk_14611D8C7;
  v10 = (unsigned __int64)&unk_14611D8C7;
  if ( v8 )
    v10 = v8;
  *((_QWORD *)&v33 + 1) = *((_QWORD *)&v33 + 1) & 0xFFFF000000000000ui64 | v10;
  LODWORD(v33) = *(_DWORD *)(a2 + 8);
  v34 = "message";
  v35 = 7;
  sub_1461639F0((unsigned int *)&v46, (__int64)&v34, (__int64)&v33, (__int64)v7);
  v11 = *((_QWORD *)a3 + 1);
  v33 = 0i64;
  HIWORD(v33) = 1029;
  if ( v11 )
    v9 = v11;
  *((_QWORD *)&v33 + 1) = *((_QWORD *)&v33 + 1) & 0xFFFF000000000000ui64 | v9;
  LODWORD(v33) = a3[4];
  v34 = "file";
  v35 = 4;
  sub_1461639F0((unsigned int *)&v46, (__int64)&v34, (__int64)&v33, (__int64)v47[0]);
  v12 = (int)a3[1];
  v33 = v12;
  v13 = 182;
  v14 = 502;
  if ( (v12 & 0x80000000) == 0i64 )
    v13 = 502;
  HIWORD(v33) = v13;
  v34 = "line";
  v35 = 4;
  sub_1461639F0((unsigned int *)&v46, (__int64)&v34, (__int64)&v33, (__int64)v47[0]);
  v15 = *a3;
  v33 = *a3;
  if ( v15 < 0 )
    v14 = 470;
  HIWORD(v33) = v14;
  v34 = "sigHash";
  v35 = 7;
  sub_1461639F0((unsigned int *)&v46, (__int64)&v34, (__int64)&v33, (__int64)v47[0]);
  *(_OWORD *)v36 = 0i64;
  *(_OWORD *)Block = 0i64;
  Size = _mm_load_si128((const __m128i *)&xmmword_14611DA30);
  v39[0] = v36;
  v39[1] = 0i64;
  *(_OWORD *)v40 = 0i64;
  v41 = 0i64;
  v42 = 512i64;
  v43 = 324;
  v44 = 0;
  sub_146159970((unsigned int *)&v46, v39);
  v19 = (char *)Block[1];
  v20 = Size.m128i_i64[0];
  if ( (unsigned __int64)Block[1] + 1 > Size.m128i_i64[0] )
  {
    v21 = Block[0];
    if ( Block[0] )
    {
      v22 = Size.m128i_i64[0] - (unsigned __int64)Block[0] + ((Size.m128i_i64[0] - (unsigned __int64)Block[0] + 1) >> 1);
    }
    else
    {
      if ( !v36[0] )
      {
        v36[0] = operator new(1ui64);
        v36[1] = v36[0];
        v19 = (char *)Block[1];
        v21 = Block[0];
      }
      v22 = Size.m128i_u64[1];
    }
    v23 = v19 - v21;
    v24 = v23 + 1;
    if ( v22 >= v23 + 1 )
      v24 = v22;
    if ( v24 )
    {
      v16 = (char *)realloc_0(v21, v24);
    }
    else
    {
      free_0(v21);
      v16 = 0i64;
    }
    Block[0] = v16;
    Size.m128i_i64[0] = (__int64)&v16[v24];
    v19 = &v16[v23];
  }
  Block[1] = v19 + 1;
  *v19 = 0;
  --Block[1];
  v25 = Block[0];
  v26 = Block[1] - Block[0];
  *(_OWORD *)a1 = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  v27 = 0x7FFFFFFFFFFFFFFFi64;
  if ( v26 > 0x7FFFFFFFFFFFFFFFi64 )
    unknown_libname_4(v16, v20, v17, v18);
  if ( v26 > 0xF )
  {
    if ( (v26 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      v27 = v26 | 0xF;
      if ( (v26 | 0xF) < 0x16 )
        v27 = 22i64;
    }
    v28 = sub_14615A5E0(v27 + 1);
    *a1 = v28;
    a1[2] = v26;
    a1[3] = v27;
    memcpy(v28, v25, v26);
    *((_BYTE *)v28 + v26) = 0;
  }
  else
  {
    a1[2] = v26;
    a1[3] = 15i64;
    memcpy(a1, v25, v26);
    *((_BYTE *)a1 + v26) = 0;
  }
  free_0(v40[1]);
  j_j_free(v40[0]);
  free_0(Block[0]);
  j_j_free(v36[1]);
  v29 = v47[1];
  if ( v47[1] )
  {
    v30 = *(_QWORD **)v47[1];
    if ( *(_QWORD *)v47[1] )
    {
      while ( v30 != *((_QWORD **)v29 + 2) )
      {
        v31 = (_QWORD *)v30[2];
        free_0(v30);
        *(_QWORD *)v29 = v31;
        v30 = v31;
        if ( !v31 )
          goto LABEL_37;
      }
      v30[1] = 0i64;
    }
LABEL_37:
    j_j_free(*((void **)v29 + 4));
    j_j_free(v29);
  }
  free_0(v49[0]);
  j_j_free(v48[1]);
  return a1;
}
// 14615A427: variable 'v16' is possibly undefined
// 14615A427: variable 'v20' is possibly undefined
// 14615A427: variable 'v17' is possibly undefined
// 14615A427: variable 'v18' is possibly undefined
// 14611DA30: using guessed type __int128 xmmword_14611DA30;
// 14611DA40: using guessed type __int128 xmmword_14611DA40;
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);
// 146159F90: using guessed type __m128i Size;

//----- (000000014615A430) ----------------------------------------------------
char *__fastcall sub_14615A430(_QWORD *a1, __int64 a2)
{
  char *v2; // rdi
  unsigned __int64 v3; // r8
  __int64 v4; // r15
  _BYTE *v6; // rcx
  char *v7; // rsi
  void *v8; // rax
  unsigned __int64 v9; // rax
  __int64 v10; // rdi
  size_t v11; // r14
  char *result; // rax

  v2 = (char *)a1[3];
  v3 = a1[4];
  v4 = 2 * a2;
  if ( (unsigned __int64)&v2[16 * a2] > v3 )
  {
    v6 = (_BYTE *)a1[2];
    v7 = 0i64;
    if ( v6 )
    {
      v9 = v3 - (_QWORD)v6 + ((v3 - (unsigned __int64)v6 + 1) >> 1);
    }
    else
    {
      v6 = 0i64;
      if ( !*a1 )
      {
        v8 = operator new(1ui64);
        v6 = (_BYTE *)a1[2];
        v2 = (char *)a1[3];
        *a1 = v8;
        a1[1] = v8;
      }
      v9 = a1[5];
    }
    v10 = v2 - v6;
    v11 = v10 + 8 * v4;
    if ( v9 >= v11 )
      v11 = v9;
    if ( v11 )
      v7 = (char *)realloc_0(v6, v11);
    else
      free_0(v6);
    a1[2] = v7;
    v2 = &v7[v10];
    a1[4] = &v7[v11];
  }
  result = v2;
  a1[3] = &v2[8 * v4];
  return result;
}

//----- (000000014615A510) ----------------------------------------------------
char *__fastcall sub_14615A510(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rsi
  unsigned __int64 v4; // r8
  char *result; // rax
  void *v7; // rcx
  char *v8; // rdi
  void *v9; // rax
  unsigned __int64 v10; // rax
  __int64 v11; // rsi
  size_t v12; // r14

  v2 = a1[3];
  v4 = a1[4];
  result = (char *)(v2 + a2);
  if ( v2 + a2 > v4 )
  {
    v7 = (void *)a1[2];
    v8 = 0i64;
    if ( v7 )
    {
      v10 = v4 - (_QWORD)v7 + ((v4 - (unsigned __int64)v7 + 1) >> 1);
    }
    else
    {
      v7 = 0i64;
      if ( !*a1 )
      {
        v9 = operator new(1ui64);
        v7 = (void *)a1[2];
        v2 = a1[3];
        *a1 = v9;
        a1[1] = v9;
      }
      v10 = a1[5];
    }
    v11 = v2 - (_QWORD)v7;
    v12 = v11 + a2;
    if ( v10 >= v11 + a2 )
      v12 = v10;
    if ( v12 )
      v8 = (char *)realloc_0(v7, v12);
    else
      free_0(v7);
    result = &v8[v12];
    a1[2] = v8;
    a1[3] = &v8[v11];
    a1[4] = &v8[v12];
  }
  return result;
}

//----- (000000014615A5E0) ----------------------------------------------------
_QWORD *__fastcall sub_14615A5E0(size_t a1)
{
  _QWORD *result; // rax
  void *v2; // rax
  void *v3; // rcx

  if ( !a1 )
    return 0i64;
  if ( a1 < 0x1000 )
    return operator new(a1);
  if ( a1 + 39 <= a1 )
    sub_146165390();
  v2 = operator new(a1 + 39);
  v3 = v2;
  if ( !v2 )
    invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
  result = (_QWORD *)(((unsigned __int64)v2 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
  *(result - 1) = v3;
  return result;
}
// 146165390: using guessed type void __noreturn sub_146165390(void);

//----- (000000014615A650) ----------------------------------------------------
void *__fastcall sub_14615A650(_QWORD *a1, const void *a2, size_t a3)
{
  __int64 v3; // rbp
  void *result; // rax
  _QWORD *v8; // rax
  _QWORD *v9; // rbx

  v3 = 0x7FFFFFFFFFFFFFFFi64;
  if ( a3 > 0x7FFFFFFFFFFFFFFFi64 )
    unknown_libname_4();
  if ( a3 > 0xF )
  {
    if ( (a3 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      v3 = a3 | 0xF;
      if ( (a3 | 0xF) < 0x16 )
        v3 = 22i64;
    }
    v8 = sub_14615A5E0(v3 + 1);
    *a1 = v8;
    a1[2] = a3;
    a1[3] = v3;
    v9 = v8;
    result = memcpy(v8, a2, a3);
    *((_BYTE *)v9 + a3) = 0;
  }
  else
  {
    a1[2] = a3;
    a1[3] = 15i64;
    result = memcpy(a1, a2, a3);
    *((_BYTE *)a1 + a3) = 0;
  }
  return result;
}
// 1461653D0: using guessed type void __noreturn unknown_libname_4(void);

//----- (000000014615A710) ----------------------------------------------------
void __fastcall sub_14615A710(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rbx
  void *v6; // rcx

  v3 = (_QWORD *)a3;
  if ( !*(_BYTE *)(a3 + 25) )
  {
    do
    {
      sub_14615A710(a1, a2, v3[2]);
      v6 = v3;
      v3 = (_QWORD *)*v3;
      j_j_free(v6);
    }
    while ( !*((_BYTE *)v3 + 25) );
  }
}

//----- (000000014615A770) ----------------------------------------------------
__int64 __fastcall sub_14615A770(__int64 *a1, __int64 a2, __int64 *a3, __int64 a4)
{
  _QWORD *v5; // rax
  _QWORD *v9; // rbx
  __int64 v10; // r8
  __int64 *i; // rbx
  __int64 *v12; // rax
  __int64 *j; // rax
  char v14; // cl
  __int64 result; // rax
  __int64 *v16; // rbx
  __int64 *v17; // rax
  __int64 **v18; // rcx
  __int64 *v19; // rcx
  __int64 v20; // rbx
  __int128 v21; // xmm0
  char v22; // cl
  __int128 v23; // [rsp+20h] [rbp-28h] BYREF
  __int64 v24; // [rsp+30h] [rbp-18h]

  v5 = (_QWORD *)*a1;
  if ( *((_BYTE *)a3 + 25) )
  {
    v9 = v5 + 2;
    if ( *(_BYTE *)(v5[1] + 25i64) || sub_146163510((__int64)a1, *v9 + 32i64, a4) )
    {
      *(_QWORD *)a2 = *v9;
      *(_BYTE *)(a2 + 16) = 0;
LABEL_41:
      *(_DWORD *)(a2 + 8) = 0;
      return a2;
    }
LABEL_33:
    sub_14615A9D0(a1, (__int64)&v23, a4);
    v20 = v24;
    if ( *(_BYTE *)(v24 + 25) || sub_146163510((__int64)a1, a4, v24 + 32) )
    {
      v21 = v23;
      *(_BYTE *)(a2 + 16) = 0;
      *(_OWORD *)a2 = v21;
    }
    else
    {
      *(_QWORD *)a2 = v20;
      *(_DWORD *)(a2 + 8) = 2;
      *(_BYTE *)(a2 + 16) = 1;
    }
    return a2;
  }
  v10 = (__int64)(a3 + 4);
  if ( a3 == (__int64 *)*v5 )
  {
    if ( sub_146163510((__int64)a1, a4, v10) )
    {
      *(_QWORD *)a2 = a3;
      *(_DWORD *)(a2 + 8) = 1;
      *(_BYTE *)(a2 + 16) = 0;
      return a2;
    }
    goto LABEL_33;
  }
  if ( !sub_146163510((__int64)a1, a4, v10) )
  {
    if ( !sub_146163510((__int64)a1, (__int64)(a3 + 4), a4) )
    {
      *(_QWORD *)a2 = a3;
      *(_BYTE *)(a2 + 16) = 1;
      goto LABEL_41;
    }
    v16 = (__int64 *)a3[2];
    if ( *((_BYTE *)v16 + 25) )
    {
      v16 = (__int64 *)a3[1];
      if ( *((_BYTE *)v16 + 25) )
      {
LABEL_37:
        v22 = *(_BYTE *)(a3[2] + 25);
        result = a2;
        *(_BYTE *)(a2 + 16) = 0;
        if ( v22 )
        {
          *(_QWORD *)a2 = a3;
          *(_DWORD *)(a2 + 8) = 0;
        }
        else
        {
          *(_QWORD *)a2 = v16;
          *(_DWORD *)(a2 + 8) = 1;
        }
        return result;
      }
      v17 = a3;
      do
      {
        v18 = (__int64 **)v16;
        if ( v17 != (__int64 *)v16[2] )
          break;
        v16 = (__int64 *)v16[1];
        v17 = (__int64 *)v18;
      }
      while ( !*((_BYTE *)v16 + 25) );
    }
    else
    {
      v19 = (__int64 *)*v16;
      if ( !*(_BYTE *)(*v16 + 25) )
      {
        do
        {
          v16 = v19;
          v19 = (__int64 *)*v19;
        }
        while ( !*((_BYTE *)v19 + 25) );
      }
    }
    if ( !*((_BYTE *)v16 + 25) && !sub_146163510((__int64)a1, a4, (__int64)(v16 + 4)) )
      goto LABEL_33;
    goto LABEL_37;
  }
  i = (__int64 *)*a3;
  v12 = a3;
  if ( *(_BYTE *)(*a3 + 25) )
  {
    for ( i = (__int64 *)a3[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
    {
      if ( v12 != (__int64 *)*i )
        break;
      v12 = i;
    }
    if ( *((_BYTE *)v12 + 25) )
      i = v12;
  }
  else
  {
    for ( j = (__int64 *)i[2]; !*((_BYTE *)j + 25); j = (__int64 *)j[2] )
      i = j;
  }
  if ( !sub_146163510((__int64)a1, (__int64)(i + 4), a4) )
    goto LABEL_33;
  v14 = *(_BYTE *)(i[2] + 25);
  result = a2;
  *(_BYTE *)(a2 + 16) = 0;
  if ( v14 )
  {
    *(_QWORD *)a2 = i;
    *(_DWORD *)(a2 + 8) = 0;
  }
  else
  {
    *(_QWORD *)a2 = a3;
    *(_DWORD *)(a2 + 8) = 1;
  }
  return result;
}

//----- (000000014615A9D0) ----------------------------------------------------
__int64 __fastcall sub_14615A9D0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 *v6; // rbx
  size_t v7; // rsi
  size_t v8; // rbp
  size_t v9; // r8
  const void *v10; // rdx
  const void *v11; // rcx
  int v12; // eax
  size_t v13; // r8
  size_t v14; // rsi
  size_t v15; // rbp
  int v16; // eax
  int v17; // eax

  v3 = *a1;
  *(_DWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = v3;
  v6 = *(__int64 **)(v3 + 8);
  for ( *(_QWORD *)a2 = v6; !*((_BYTE *)v6 + 25); *(_DWORD *)(a2 + 8) = v17 )
  {
    v7 = v6[5];
    v8 = *(_QWORD *)(a3 + 8);
    v9 = v7;
    v10 = *(const void **)a3;
    v11 = (const void *)v6[4];
    if ( v8 < v7 )
      v9 = *(_QWORD *)(a3 + 8);
    *(_QWORD *)a2 = v6;
    v12 = memcmp(v11, v10, v9);
    if ( !v12 )
    {
      if ( v7 >= v8 )
        v12 = v7 > v8;
      else
        v12 = -1;
    }
    if ( v12 < 0 )
      goto LABEL_18;
    v13 = v8;
    v14 = v8;
    v15 = v6[5];
    if ( v15 < v13 )
      v13 = v6[5];
    v16 = memcmp(*(const void **)a3, (const void *)v6[4], v13);
    if ( !v16 )
    {
      if ( v14 >= v15 )
        v16 = v14 > v15;
      else
        v16 = -1;
    }
    if ( v16 >= 0 && *((_DWORD *)v6 + 12) < *(_DWORD *)(a3 + 16) )
    {
LABEL_18:
      v17 = 0;
      v6 += 2;
    }
    else
    {
      *(_QWORD *)(a2 + 16) = v6;
      v17 = 1;
    }
    v6 = (__int64 *)*v6;
  }
  return a2;
}

//----- (000000014615AAE0) ----------------------------------------------------
void *__fastcall sub_14615AAE0(__int64 a1, char *a2, char *a3)
{
  char *v4; // rsi
  size_t v6; // rbx
  __int64 v7; // rcx
  void *result; // rax

  if ( a2 != a3 )
  {
    v4 = a2;
    do
    {
      v6 = a3 - v4;
      if ( a3 - v4 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( v6 + *(_QWORD *)(a1 + 16) > *(_QWORD *)(a1 + 24) )
        (**(void (__fastcall ***)(__int64))a1)(a1);
      v7 = *(_QWORD *)(a1 + 16);
      result = (void *)(*(_QWORD *)(a1 + 24) - v7);
      if ( (unsigned __int64)result < v6 )
        v6 = *(_QWORD *)(a1 + 24) - v7;
      if ( v6 )
        result = memmove((void *)(*(_QWORD *)(a1 + 8) + v7), v4, v6);
      *(_QWORD *)(a1 + 16) += v6;
      v4 += v6;
    }
    while ( v4 != a3 );
  }
  return result;
}

//----- (000000014615AB90) ----------------------------------------------------
void __fastcall __noreturn sub_14615AB90(__int64 a1)
{
  char pExceptionObject[40]; // [rsp+20h] [rbp-28h] BYREF

  sub_146162440((__int64)pExceptionObject, a1);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
}

//----- (000000014615ABC0) ----------------------------------------------------
_QWORD *__fastcall sub_14615ABC0(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4)
{
  __int64 v5; // rbp
  unsigned __int64 v6; // rbx
  _WORD *v8; // rdi
  _WORD *i; // r8
  __int16 v10; // ax

  v5 = a4;
  v6 = a3;
  if ( a4 < (int)sub_146165560(a3) )
    sub_14619F290(
      "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\format.h",
      0x41Cu,
      "invalid digit count");
  v8 = (_WORD *)(v5 + a2);
  for ( i = v8; v6 >= 0x64; *v8 = v10 )
  {
    --v8;
    v10 = *(_WORD *)&a00010203040506[2 * (v6 % 0x64)];
    v6 /= 0x64ui64;
  }
  a1[1] = i;
  if ( v6 >= 0xA )
  {
    *(v8 - 1) = *(_WORD *)&a00010203040506[2 * v6];
    *a1 = v8 - 1;
  }
  else
  {
    *((_BYTE *)v8 - 1) = v6 + 48;
    *a1 = (char *)v8 - 1;
  }
  return a1;
}

//----- (000000014615ACB0) ----------------------------------------------------
_QWORD *__fastcall sub_14615ACB0(_QWORD *a1, __int64 a2, unsigned int a3, int a4)
{
  __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  __int64 v9; // rcx
  _BYTE *v10; // rdx
  char v11; // cl
  char *v12; // rbp
  char *v13; // rcx
  char v14; // al
  char *i; // rsi
  size_t v16; // rdi
  __int64 v17; // rcx
  char Src[40]; // [rsp+20h] [rbp-48h] BYREF

  if ( a4 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v7 = *(_QWORD *)(a2 + 16);
  v8 = v7 + (unsigned int)a4;
  if ( *(_QWORD *)(a2 + 24) >= v8 && (*(_QWORD *)(a2 + 16) = v8, (v9 = *(_QWORD *)(a2 + 8) + v7) != 0) )
  {
    v10 = (_BYTE *)(v9 + a4);
    do
    {
      --v10;
      v11 = (a3 & 1) + 48;
      a3 >>= 1;
      *v10 = v11;
    }
    while ( a3 );
  }
  else
  {
    v12 = &Src[a4];
    v13 = v12;
    do
    {
      --v13;
      v14 = (a3 & 1) + 48;
      a3 >>= 1;
      *v13 = v14;
    }
    while ( a3 );
    for ( i = Src; i != v12; i += v16 )
    {
      v16 = v12 - i;
      if ( v12 - i < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( v16 + *(_QWORD *)(a2 + 16) > *(_QWORD *)(a2 + 24) )
        (**(void (__fastcall ***)(__int64))a2)(a2);
      v17 = *(_QWORD *)(a2 + 16);
      if ( *(_QWORD *)(a2 + 24) - v17 < v16 )
        v16 = *(_QWORD *)(a2 + 24) - v17;
      if ( v16 )
        memmove((void *)(*(_QWORD *)(a2 + 8) + v17), i, v16);
      *(_QWORD *)(a2 + 16) += v16;
    }
  }
  *a1 = a2;
  return a1;
}

//----- (000000014615AE10) ----------------------------------------------------
_QWORD *__fastcall sub_14615AE10(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4)
{
  __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  __int64 v9; // rcx
  _BYTE *v10; // rdx
  char v11; // cl
  char *v12; // rbp
  char *v13; // rcx
  char v14; // al
  char *i; // rsi
  size_t v16; // rdi
  __int64 v17; // rcx
  char Src[80]; // [rsp+20h] [rbp-78h] BYREF

  if ( a4 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v7 = *(_QWORD *)(a2 + 16);
  v8 = v7 + (unsigned int)a4;
  if ( *(_QWORD *)(a2 + 24) >= v8 && (*(_QWORD *)(a2 + 16) = v8, (v9 = *(_QWORD *)(a2 + 8) + v7) != 0) )
  {
    v10 = (_BYTE *)(v9 + a4);
    do
    {
      --v10;
      v11 = (a3 & 1) + 48;
      a3 >>= 1;
      *v10 = v11;
    }
    while ( a3 );
  }
  else
  {
    v12 = &Src[a4];
    v13 = v12;
    do
    {
      --v13;
      v14 = (a3 & 1) + 48;
      a3 >>= 1;
      *v13 = v14;
    }
    while ( a3 );
    for ( i = Src; i != v12; i += v16 )
    {
      v16 = v12 - i;
      if ( v12 - i < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( v16 + *(_QWORD *)(a2 + 16) > *(_QWORD *)(a2 + 24) )
        (**(void (__fastcall ***)(__int64))a2)(a2);
      v17 = *(_QWORD *)(a2 + 16);
      if ( *(_QWORD *)(a2 + 24) - v17 < v16 )
        v16 = *(_QWORD *)(a2 + 24) - v17;
      if ( v16 )
        memmove((void *)(*(_QWORD *)(a2 + 8) + v17), i, v16);
      *(_QWORD *)(a2 + 16) += v16;
    }
  }
  *a1 = a2;
  return a1;
}

//----- (000000014615AF70) ----------------------------------------------------
_QWORD *__fastcall sub_14615AF70(_QWORD *a1, __int64 a2, unsigned int a3, int a4)
{
  __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  __int64 v9; // rcx
  _BYTE *v10; // rdx
  char v11; // cl
  char *v12; // rbp
  char *v13; // rcx
  char v14; // al
  char *i; // rsi
  size_t v16; // rdi
  __int64 v17; // rcx
  char Src[16]; // [rsp+20h] [rbp-38h] BYREF

  if ( a4 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v7 = *(_QWORD *)(a2 + 16);
  v8 = v7 + (unsigned int)a4;
  if ( *(_QWORD *)(a2 + 24) >= v8 && (*(_QWORD *)(a2 + 16) = v8, (v9 = *(_QWORD *)(a2 + 8) + v7) != 0) )
  {
    v10 = (_BYTE *)(v9 + a4);
    do
    {
      --v10;
      v11 = a3 & 7;
      a3 >>= 3;
      *v10 = v11 + 48;
    }
    while ( a3 );
  }
  else
  {
    v12 = &Src[a4];
    v13 = v12;
    do
    {
      --v13;
      v14 = a3 & 7;
      a3 >>= 3;
      *v13 = v14 + 48;
    }
    while ( a3 );
    for ( i = Src; i != v12; i += v16 )
    {
      v16 = v12 - i;
      if ( v12 - i < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( v16 + *(_QWORD *)(a2 + 16) > *(_QWORD *)(a2 + 24) )
        (**(void (__fastcall ***)(__int64))a2)(a2);
      v17 = *(_QWORD *)(a2 + 16);
      if ( *(_QWORD *)(a2 + 24) - v17 < v16 )
        v16 = *(_QWORD *)(a2 + 24) - v17;
      if ( v16 )
        memmove((void *)(*(_QWORD *)(a2 + 8) + v17), i, v16);
      *(_QWORD *)(a2 + 16) += v16;
    }
  }
  *a1 = a2;
  return a1;
}

//----- (000000014615B0D0) ----------------------------------------------------
_QWORD *__fastcall sub_14615B0D0(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4)
{
  __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  __int64 v9; // rcx
  _BYTE *v10; // rdx
  char v11; // cl
  char *v12; // rbp
  char *v13; // rcx
  char v14; // al
  char *i; // rsi
  size_t v16; // rdi
  __int64 v17; // rcx
  char Src[24]; // [rsp+20h] [rbp-38h] BYREF

  if ( a4 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v7 = *(_QWORD *)(a2 + 16);
  v8 = v7 + (unsigned int)a4;
  if ( *(_QWORD *)(a2 + 24) >= v8 && (*(_QWORD *)(a2 + 16) = v8, (v9 = *(_QWORD *)(a2 + 8) + v7) != 0) )
  {
    v10 = (_BYTE *)(v9 + a4);
    do
    {
      --v10;
      v11 = a3 & 7;
      a3 >>= 3;
      *v10 = v11 + 48;
    }
    while ( a3 );
  }
  else
  {
    v12 = &Src[a4];
    v13 = v12;
    do
    {
      --v13;
      v14 = a3 & 7;
      a3 >>= 3;
      *v13 = v14 + 48;
    }
    while ( a3 );
    for ( i = Src; i != v12; i += v16 )
    {
      v16 = v12 - i;
      if ( v12 - i < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( v16 + *(_QWORD *)(a2 + 16) > *(_QWORD *)(a2 + 24) )
        (**(void (__fastcall ***)(__int64))a2)(a2);
      v17 = *(_QWORD *)(a2 + 16);
      if ( *(_QWORD *)(a2 + 24) - v17 < v16 )
        v16 = *(_QWORD *)(a2 + 24) - v17;
      if ( v16 )
        memmove((void *)(*(_QWORD *)(a2 + 8) + v17), i, v16);
      *(_QWORD *)(a2 + 16) += v16;
    }
  }
  *a1 = a2;
  return a1;
}

//----- (000000014615B230) ----------------------------------------------------
_QWORD *__fastcall sub_14615B230(_QWORD *a1, __int64 a2, unsigned int a3, int a4, char a5)
{
  __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  __int64 v10; // rcx
  char *v11; // r8
  _BYTE *v12; // rdx
  __int64 v13; // rcx
  char *v14; // r8
  char *v15; // rbp
  char *v16; // rcx
  __int64 v17; // rax
  char *i; // rsi
  size_t v19; // rdi
  __int64 v20; // rcx
  char Src[16]; // [rsp+20h] [rbp-38h] BYREF

  if ( a4 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v8 = *(_QWORD *)(a2 + 16);
  v9 = v8 + (unsigned int)a4;
  if ( *(_QWORD *)(a2 + 24) >= v9 && (*(_QWORD *)(a2 + 16) = v9, (v10 = *(_QWORD *)(a2 + 8) + v8) != 0) )
  {
    v11 = "0123456789abcdef";
    if ( a5 )
      v11 = "0123456789ABCDEF";
    v12 = (_BYTE *)(a4 + v10);
    do
    {
      --v12;
      v13 = a3 & 0xF;
      a3 >>= 4;
      *v12 = v11[v13];
    }
    while ( a3 );
  }
  else
  {
    v14 = "0123456789abcdef";
    v15 = &Src[a4];
    v16 = v15;
    if ( a5 )
      v14 = "0123456789ABCDEF";
    do
    {
      --v16;
      v17 = a3 & 0xF;
      a3 >>= 4;
      *v16 = v14[v17];
    }
    while ( a3 );
    for ( i = Src; i != v15; i += v19 )
    {
      v19 = v15 - i;
      if ( v15 - i < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( v19 + *(_QWORD *)(a2 + 16) > *(_QWORD *)(a2 + 24) )
        (**(void (__fastcall ***)(__int64))a2)(a2);
      v20 = *(_QWORD *)(a2 + 16);
      if ( *(_QWORD *)(a2 + 24) - v20 < v19 )
        v19 = *(_QWORD *)(a2 + 24) - v20;
      if ( v19 )
        memmove((void *)(*(_QWORD *)(a2 + 8) + v20), i, v19);
      *(_QWORD *)(a2 + 16) += v19;
    }
  }
  *a1 = a2;
  return a1;
}

//----- (000000014615B3C0) ----------------------------------------------------
_QWORD *__fastcall sub_14615B3C0(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4, char a5)
{
  __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  __int64 v10; // rcx
  char *v11; // r8
  _BYTE *v12; // rdx
  __int64 v13; // rcx
  char *v14; // r8
  char *v15; // rbp
  char *v16; // rcx
  __int64 v17; // rax
  char *i; // rsi
  size_t v19; // rdi
  __int64 v20; // rcx
  char Src[24]; // [rsp+20h] [rbp-38h] BYREF

  if ( a4 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v8 = *(_QWORD *)(a2 + 16);
  v9 = v8 + (unsigned int)a4;
  if ( *(_QWORD *)(a2 + 24) >= v9 && (*(_QWORD *)(a2 + 16) = v9, (v10 = *(_QWORD *)(a2 + 8) + v8) != 0) )
  {
    v11 = "0123456789abcdef";
    if ( a5 )
      v11 = "0123456789ABCDEF";
    v12 = (_BYTE *)(a4 + v10);
    do
    {
      --v12;
      v13 = a3 & 0xF;
      a3 >>= 4;
      *v12 = v11[v13];
    }
    while ( a3 );
  }
  else
  {
    v14 = "0123456789abcdef";
    v15 = &Src[a4];
    v16 = v15;
    if ( a5 )
      v14 = "0123456789ABCDEF";
    do
    {
      --v16;
      v17 = a3 & 0xF;
      a3 >>= 4;
      *v16 = v14[v17];
    }
    while ( a3 );
    for ( i = Src; i != v15; i += v19 )
    {
      v19 = v15 - i;
      if ( v15 - i < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( v19 + *(_QWORD *)(a2 + 16) > *(_QWORD *)(a2 + 24) )
        (**(void (__fastcall ***)(__int64))a2)(a2);
      v20 = *(_QWORD *)(a2 + 16);
      if ( *(_QWORD *)(a2 + 24) - v20 < v19 )
        v19 = *(_QWORD *)(a2 + 24) - v20;
      if ( v19 )
        memmove((void *)(*(_QWORD *)(a2 + 8) + v20), i, v19);
      *(_QWORD *)(a2 + 16) += v19;
    }
  }
  *a1 = a2;
  return a1;
}

//----- (000000014615B550) ----------------------------------------------------
__int64 __fastcall sub_14615B550(__int64 a1, __int64 a2, __int64 a3)
{
  char v3; // r9
  int v4; // eax
  __int64 result; // rax
  bool v6; // cf

  v3 = *(_BYTE *)(a2 + 16) & 2 | (16 * (*(_BYTE *)(a2 + 16) & 1));
  v4 = *(char *)(a2 + 8);
  *(_OWORD *)a1 = 0i64;
  *(_BYTE *)(a1 + 12) = v3;
  switch ( v4 )
  {
    case 0:
      return a1;
    case 65:
      *(_BYTE *)(a1 + 12) = v3 | 1;
      goto LABEL_9;
    case 69:
      v3 |= 1u;
      goto LABEL_5;
    case 70:
      v3 |= 1u;
      goto LABEL_7;
    case 71:
      *(_BYTE *)(a1 + 12) = v3 | 1;
      goto LABEL_3;
    case 97:
LABEL_9:
      *(_BYTE *)(a1 + 4) = 3;
      result = a1;
      break;
    case 101:
LABEL_5:
      v6 = *(_DWORD *)(a2 + 4) != 0;
      *(_BYTE *)(a1 + 4) = 1;
      result = a1;
      *(_BYTE *)(a1 + 12) = v3 & 0xEF ^ (v3 & 0x10 | (v6 ? 0x10 : 0));
      break;
    case 102:
LABEL_7:
      v6 = *(_DWORD *)(a2 + 4) != 0;
      *(_BYTE *)(a1 + 4) = 2;
      result = a1;
      *(_BYTE *)(a1 + 12) = v3 & 0xEF ^ (v3 & 0x10 | (v6 ? 0x10 : 0));
      break;
    case 103:
LABEL_3:
      *(_BYTE *)(a1 + 4) = 0;
      result = a1;
      break;
    default:
      sub_14619FE20(a3, (__int64)"invalid type specifier");
  }
  return result;
}

//----- (000000014615B6D0) ----------------------------------------------------
__int64 __fastcall sub_14615B6D0(char **a1, char *a2, __int64 a3, __int64 *a4)
{
  unsigned int v8; // r15d
  char v9; // r14
  unsigned int v10; // esi
  char *v11; // rax
  char *v12; // rcx
  char v13; // al
  int v15; // eax
  _DWORD *v16; // rax
  const char *v17; // [rsp+28h] [rbp-50h] BYREF
  char v18; // [rsp+30h] [rbp-48h]
  void **v19; // [rsp+38h] [rbp-40h] BYREF
  __int128 v20; // [rsp+40h] [rbp-38h]
  __int64 v21; // [rsp+80h] [rbp+8h] BYREF

  v8 = -1;
  v9 = **a1;
  if ( (unsigned __int8)(v9 - 48) <= 9u )
  {
    v10 = sub_14615B920(a1, a2, 0xFFFFFFFF);
    v11 = *a1;
    if ( *a1 == a2 || *v11 != 36 )
    {
      if ( v9 == 48 )
        *(_BYTE *)(a3 + 17) = 48;
      if ( v10 )
      {
        if ( v10 == -1 )
        {
          v19 = &std::exception::`vftable';
          v20 = 0i64;
          v17 = "number is too big";
          v18 = 1;
          _std_exception_copy(&v17);
          v19 = &fmt::v8::format_error::`vftable';
          sub_14615AB90((__int64)&v19);
        }
        *(_DWORD *)a3 = v10;
        return 0xFFFFFFFFi64;
      }
    }
    else
    {
      *a1 = v11 + 1;
      v8 = 0x7FFFFFFF;
      if ( v10 != -1 )
        v8 = v10;
    }
  }
  v12 = *a1;
  if ( *a1 != a2 )
  {
    do
    {
      v13 = *v12;
      if ( *v12 == 32 )
      {
        if ( (*(_DWORD *)(a3 + 12) & 0x70) != 32 )
          *(_DWORD *)(a3 + 12) = *(_DWORD *)(a3 + 12) & 0xFFFFFF8F | 0x30;
      }
      else
      {
        switch ( v13 )
        {
          case '#':
            *(_BYTE *)(a3 + 16) |= 1u;
            break;
          case '+':
            *(_DWORD *)(a3 + 12) &= 0xFFFFFFAF;
            *(_DWORD *)(a3 + 12) |= 0x20u;
            break;
          case '-':
            *(_DWORD *)(a3 + 12) &= 0xFFFFFFF1;
            *(_DWORD *)(a3 + 12) |= 1u;
            break;
          case '0':
            *(_BYTE *)(a3 + 17) = 48;
            break;
          default:
            goto LABEL_25;
        }
      }
      v12 = ++*a1;
    }
    while ( *a1 != a2 );
LABEL_25:
    if ( v12 != a2 )
    {
      if ( (unsigned __int8)(*v12 - 48) > 9u )
      {
        if ( *v12 == 42 )
        {
          *a1 = v12 + 1;
          v16 = (_DWORD *)sub_146162AC0(a4, (__int64)&v19, -1);
          v21 = a3;
          *(_DWORD *)a3 = sub_14615C4A0((__int64)&v21, v16);
        }
      }
      else
      {
        v15 = sub_14615B920(a1, a2, 0xFFFFFFFF);
        *(_DWORD *)a3 = v15;
        if ( v15 == -1 )
        {
          v19 = &std::exception::`vftable';
          v20 = 0i64;
          v17 = "number is too big";
          v18 = 1;
          _std_exception_copy(&v17);
          v19 = &fmt::v8::format_error::`vftable';
          sub_14615AB90((__int64)&v19);
        }
      }
    }
  }
  return v8;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014615B920) ----------------------------------------------------
__int64 __fastcall sub_14615B920(char **a1, char *a2, unsigned int a3)
{
  char v5; // al
  unsigned int v6; // r8d
  char *v7; // r9
  char *v8; // rdx
  char v9; // al
  char *v10; // r10
  __int64 v11; // r11

  if ( *a1 == a2 || (v5 = **a1, v5 < 48) || v5 > 57 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x832u, Src);
  v6 = 0;
  v7 = *a1;
  v8 = *a1;
  v9 = **a1;
  do
  {
    v10 = v8;
    v11 = v6;
    v6 = v9 + 2 * (5 * v6 - 24);
    if ( ++v8 == a2 )
      break;
    v9 = *v8;
    if ( *v8 < 48 )
      break;
  }
  while ( v9 <= 57 );
  *a1 = v8;
  if ( v8 - v7 > 9 && (v8 - v7 != 10 || (unsigned __int64)(unsigned int)(*v10 - 48) + 10 * v11 > 0x7FFFFFFF) )
    return a3;
  return v6;
}

//----- (000000014615B9F0) ----------------------------------------------------
__int64 __fastcall sub_14615B9F0(int a1)
{
  if ( a1 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  return (unsigned int)a1;
}

//----- (000000014615BA20) ----------------------------------------------------
__int64 __fastcall sub_14615BA20(__int64 *a1, _DWORD *a2)
{
  __int64 result; // rax
  __int64 v3; // r8
  char v4; // al
  __int64 v5; // rcx
  __int128 v6; // [rsp+0h] [rbp-20h]
  __int64 v7; // [rsp+10h] [rbp-10h]

  result = a2[4] - 1;
  switch ( a2[4] )
  {
    case 1:
    case 2:
      LODWORD(v3) = *a2;
      goto LABEL_3;
    case 3:
    case 4:
      v3 = *(_QWORD *)a2;
LABEL_3:
      v4 = *((_BYTE *)a1 + 8);
      if ( v4 != 100 && v4 != 105 )
        goto LABEL_5;
      LODWORD(v6) = (char)v3;
      goto LABEL_14;
    case 7:
      result = *((unsigned __int8 *)a1 + 8);
      if ( (_BYTE)result != 115 )
        goto LABEL_11;
      return result;
    case 8:
      LOBYTE(result) = *((_BYTE *)a1 + 8);
LABEL_11:
      LOBYTE(v3) = *(_BYTE *)a2;
      if ( (_BYTE)result == 100 || (_BYTE)result == 105 )
      {
        LODWORD(v6) = *(char *)a2;
LABEL_14:
        result = *a1;
        LODWORD(v7) = 1;
        *(_OWORD *)result = v6;
        *(_QWORD *)(result + 16) = v7;
      }
      else
      {
LABEL_5:
        v5 = *a1;
        LODWORD(v6) = (unsigned __int8)v3;
        result = HIDWORD(v6);
        LODWORD(v7) = 2;
        *(_OWORD *)v5 = v6;
        *(_QWORD *)(v5 + 16) = v7;
      }
      return result;
    default:
      return result;
  }
}
// 14615BA6C: variable 'v6' is possibly undefined
// 14615BA8A: variable 'v7' is possibly undefined

//----- (000000014615BB30) ----------------------------------------------------
__int64 __fastcall sub_14615BB30(__int64 *a1, _DWORD *a2)
{
  __int64 result; // rax
  __int64 v3; // r8
  char v4; // al
  __int64 v5; // rcx
  int v6; // r8d
  char v7; // al
  __int64 v8; // rdx
  __int128 v9; // [rsp+0h] [rbp-20h]
  __int64 v10; // [rsp+10h] [rbp-10h]

  result = a2[4] - 1;
  switch ( a2[4] )
  {
    case 1:
    case 2:
      LODWORD(v3) = *a2;
      goto LABEL_3;
    case 3:
    case 4:
      v3 = *(_QWORD *)a2;
LABEL_3:
      v4 = *((_BYTE *)a1 + 8);
      if ( v4 != 100 && v4 != 105 )
      {
        LODWORD(v9) = (unsigned __int16)v3;
        goto LABEL_6;
      }
      LODWORD(v9) = (__int16)v3;
      goto LABEL_17;
    case 7:
      result = *((unsigned __int8 *)a1 + 8);
      if ( (_BYTE)result == 115 )
        return result;
      v6 = *(unsigned __int8 *)a2;
      if ( (_BYTE)result == 100 || (_BYTE)result == 105 )
      {
LABEL_16:
        LODWORD(v9) = v6;
LABEL_17:
        result = *a1;
        LODWORD(v10) = 1;
        *(_OWORD *)result = v9;
        *(_QWORD *)(result + 16) = v10;
      }
      else
      {
        LODWORD(v9) = *(unsigned __int8 *)a2;
LABEL_6:
        v5 = *a1;
        result = HIDWORD(v9);
        LODWORD(v10) = 2;
        *(_OWORD *)v5 = v9;
        *(_QWORD *)(v5 + 16) = v10;
      }
      return result;
    case 8:
      v7 = *((_BYTE *)a1 + 8);
      v6 = *(char *)a2;
      if ( v7 == 100 || v7 == 105 )
        goto LABEL_16;
      v8 = *a1;
      result = HIDWORD(v9);
      LODWORD(v9) = (unsigned __int16)v6;
      LODWORD(v10) = 2;
      *(_OWORD *)v8 = v9;
      *(_QWORD *)(v8 + 16) = v10;
      return result;
    default:
      return result;
  }
}
// 14615BB7C: variable 'v9' is possibly undefined
// 14615BB9A: variable 'v10' is possibly undefined

//----- (000000014615BC90) ----------------------------------------------------
__int64 __fastcall sub_14615BC90(__int64 *a1, _DWORD *a2)
{
  __int64 result; // rax
  __int64 v3; // r8
  __int64 v4; // rcx
  __int128 v5; // [rsp+0h] [rbp-20h]
  __int64 v6; // [rsp+10h] [rbp-10h]

  result = a2[4] - 1;
  switch ( a2[4] )
  {
    case 1:
    case 2:
      LODWORD(v3) = *a2;
      goto LABEL_7;
    case 3:
    case 4:
      v3 = *(_QWORD *)a2;
      goto LABEL_7;
    case 7:
      result = *((unsigned __int8 *)a1 + 8);
      if ( (_BYTE)result == 115 )
        return result;
      LODWORD(v3) = *(unsigned __int8 *)a2;
      goto LABEL_8;
    case 8:
      LODWORD(v3) = *(char *)a2;
LABEL_7:
      LOBYTE(result) = *((_BYTE *)a1 + 8);
LABEL_8:
      if ( (_BYTE)result == 100 || (_BYTE)result == 105 )
      {
        result = *a1;
        LODWORD(v5) = v3;
        LODWORD(v6) = 1;
        *(_OWORD *)result = v5;
        *(_QWORD *)(result + 16) = v6;
      }
      else
      {
        v4 = *a1;
        result = HIDWORD(v5);
        LODWORD(v5) = v3;
        LODWORD(v6) = 2;
        *(_OWORD *)v4 = v5;
        *(_QWORD *)(v4 + 16) = v6;
      }
      break;
    default:
      return result;
  }
  return result;
}
// 14615BCEE: variable 'v5' is possibly undefined
// 14615BD10: variable 'v6' is possibly undefined

//----- (000000014615BD90) ----------------------------------------------------
__int64 __fastcall sub_14615BD90(__int64 *a1, int *a2)
{
  __int64 result; // rax
  char v3; // al
  int v4; // r8d
  char v5; // al
  __int64 v6; // rcx
  char v7; // al
  __int64 v8; // rcx
  __int128 v9; // [rsp+0h] [rbp-20h]
  __int64 v10; // [rsp+10h] [rbp-10h]

  result = a2[4] - 1;
  switch ( a2[4] )
  {
    case 1:
    case 2:
      v3 = *((_BYTE *)a1 + 8);
      v4 = *a2;
      if ( v3 == 100 || v3 == 105 )
        goto LABEL_17;
      LODWORD(v9) = *a2;
      goto LABEL_16;
    case 3:
    case 4:
      v5 = *((_BYTE *)a1 + 8);
      if ( v5 != 100 && v5 != 105 )
      {
        v6 = *a1;
        result = *((_QWORD *)&v9 + 1);
        *(_QWORD *)&v9 = *(_QWORD *)a2;
        LODWORD(v10) = 4;
        *(_OWORD *)v6 = v9;
        *(_QWORD *)(v6 + 16) = v10;
        return result;
      }
      LODWORD(v10) = 3;
      *(_QWORD *)&v9 = *(_QWORD *)a2;
      goto LABEL_18;
    case 7:
      result = *((unsigned __int8 *)a1 + 8);
      if ( (_BYTE)result == 115 )
        return result;
      v4 = *(unsigned __int8 *)a2;
      if ( (_BYTE)result == 100 || (_BYTE)result == 105 )
      {
LABEL_17:
        LODWORD(v10) = 1;
        LODWORD(v9) = v4;
LABEL_18:
        result = *a1;
        *(_OWORD *)result = v9;
        *(_QWORD *)(result + 16) = v10;
      }
      else
      {
        LODWORD(v9) = *(unsigned __int8 *)a2;
LABEL_16:
        v8 = *a1;
        result = HIDWORD(v9);
        LODWORD(v10) = 2;
        *(_OWORD *)v8 = v9;
        *(_QWORD *)(v8 + 16) = v10;
      }
      return result;
    case 8:
      v7 = *((_BYTE *)a1 + 8);
      v4 = *(char *)a2;
      if ( v7 == 100 || v7 == 105 )
        goto LABEL_17;
      LODWORD(v9) = (unsigned __int8)v4;
      goto LABEL_16;
    default:
      return result;
  }
}
// 14615BDF0: variable 'v9' is possibly undefined
// 14615BE0F: variable 'v10' is possibly undefined

//----- (000000014615BF10) ----------------------------------------------------
__int64 __fastcall sub_14615BF10(__int64 *a1, unsigned int *a2)
{
  __int64 result; // rax
  __int64 v3; // r8
  char v4; // al
  char v5; // al
  char v6; // al
  __int64 v7; // rcx
  __int128 v8; // [rsp+0h] [rbp-20h]
  __int64 v9; // [rsp+10h] [rbp-10h]

  result = (int)(a2[4] - 1);
  switch ( a2[4] )
  {
    case 1u:
      v3 = (int)*a2;
      goto LABEL_3;
    case 2u:
      v3 = *a2;
LABEL_3:
      v4 = *((_BYTE *)a1 + 8);
      if ( v4 == 100 || v4 == 105 )
        goto LABEL_19;
      LODWORD(v8) = v3;
      goto LABEL_17;
    case 3u:
    case 4u:
      v5 = *((_BYTE *)a1 + 8);
      v3 = *(_QWORD *)a2;
      if ( v5 == 100 || v5 == 105 )
        goto LABEL_19;
      result = *((_QWORD *)&v8 + 1);
      LODWORD(v9) = 4;
      *(_QWORD *)&v8 = *(_QWORD *)a2;
      goto LABEL_18;
    case 7u:
      result = *((unsigned __int8 *)a1 + 8);
      if ( (_BYTE)result == 115 )
        return result;
      v3 = *(unsigned __int8 *)a2;
      if ( (_BYTE)result == 100 || (_BYTE)result == 105 )
      {
LABEL_19:
        result = *a1;
        *(_QWORD *)&v8 = v3;
        LODWORD(v9) = 3;
        *(_OWORD *)result = v8;
        *(_QWORD *)(result + 16) = v9;
      }
      else
      {
        result = HIBYTE(v8);
        LODWORD(v9) = 7;
        LOBYTE(v8) = *(_BYTE *)a2;
LABEL_18:
        v7 = *a1;
        *(_OWORD *)v7 = v8;
        *(_QWORD *)(v7 + 16) = v9;
      }
      return result;
    case 8u:
      v6 = *((_BYTE *)a1 + 8);
      v3 = *(char *)a2;
      if ( v6 == 100 || v6 == 105 )
        goto LABEL_19;
      LODWORD(v8) = (unsigned __int8)v3;
LABEL_17:
      result = HIDWORD(v8);
      LODWORD(v9) = 2;
      goto LABEL_18;
    default:
      return result;
  }
}
// 14615BF7A: variable 'v8' is possibly undefined
// 14615C010: variable 'v9' is possibly undefined

//----- (000000014615C090) ----------------------------------------------------
__int64 *__fastcall sub_14615C090(__int64 *a1, __int64 *a2, int *a3)
{
  int v6; // r8d
  __int64 v7; // r8
  __int64 v8; // rax
  __int64 v9; // r9
  int v10; // ecx
  __int64 v11; // rdx
  char v12; // r9
  __int64 v13; // r14
  __int64 v14; // rbx
  char v15; // al
  const char *v16; // rdi
  size_t v17; // rax
  __m128i *v18; // rax
  __int64 v19; // xmm0_8
  char v20; // al
  __int32 v21; // ecx
  __m128i *v22; // rax
  float v23; // xmm2_4
  __int64 v24; // rdx
  __m128i v25; // xmm0
  __int64 v26; // xmm1_8
  __int64 v27; // rax
  __m128i *v28; // rax
  double v29; // xmm2_8
  __int64 v30; // rdx
  __m128i v31; // xmm0
  __int64 v32; // xmm1_8
  __int64 v33; // rax
  __m128i *v34; // rax
  long double v35; // xmm2_8
  __int64 v36; // rdx
  __m128i v37; // xmm0
  __int64 v38; // xmm1_8
  __int64 v39; // rax
  __int64 v40; // r9
  __int64 v41; // rdx
  __int64 v42; // r8
  const char *v43; // rcx
  unsigned __int8 v45; // [rsp+30h] [rbp-19h]
  __m128i v46; // [rsp+40h] [rbp-9h] BYREF
  __m128i v47; // [rsp+50h] [rbp+7h] BYREF
  __int64 v48; // [rsp+60h] [rbp+17h]

  switch ( a3[4] )
  {
    case 1:
      v6 = *a3;
      goto LABEL_3;
    case 2:
      sub_14615EFB0(
        a1,
        *a2,
        (unsigned int)*a3 | ((unsigned __int64)(unsigned int)dword_14611CFB0[(__int64)(int)(*(_DWORD *)(a2[1] + 12) << 25) >> 29] << 32),
        a2[1],
        a2[2]);
      return a1;
    case 3:
      v7 = *(_QWORD *)a3;
      v8 = a2[2];
      v9 = a2[1];
      if ( v7 >= 0 )
      {
        v10 = dword_14611CFB0[(__int64)(int)(*(_DWORD *)(v9 + 12) << 25) >> 29];
      }
      else
      {
        v10 = 16777261;
        v7 = -v7;
      }
      v46.m128i_i64[0] = v7;
      goto LABEL_9;
    case 4:
      v9 = a2[1];
      v8 = a2[2];
      v46.m128i_i64[0] = *(_QWORD *)a3;
      v10 = dword_14611CFB0[(__int64)(int)(*(_DWORD *)(v9 + 12) << 25) >> 29];
LABEL_9:
      v11 = *a2;
      v46.m128i_i32[2] = v10;
      v47 = v46;
      sub_14615F5D0(a1, v11, (__int64)&v47, v9, v8);
      break;
    case 5:
    case 6:
      sub_146163960(a2, a1, v45);
    case 7:
      v12 = *(_BYTE *)a3;
      v13 = a2[1];
      v14 = *a2;
      v15 = *(_BYTE *)(v13 + 8);
      if ( !v15 || v15 == 115 )
      {
        v16 = "false";
        if ( v12 )
          v16 = "true";
        v17 = strlen(v16);
        v47.m128i_i64[0] = (__int64)v16;
        v47.m128i_i64[1] = v17;
        sub_146160390(v46.m128i_i64, v14, (char *)v13, v17, v17, (__int64)&v47);
        *a1 = v46.m128i_i64[0];
      }
      else
      {
        sub_14615EFB0(
          v46.m128i_i64,
          v14,
          (v12 != 0) | ((unsigned __int64)(unsigned int)dword_14611CFB0[(__int64)(int)(*(_DWORD *)(v13 + 12) << 25) >> 29] << 32),
          v13,
          0i64);
        *a1 = v46.m128i_i64[0];
      }
      break;
    case 8:
      v18 = (__m128i *)a2[1];
      v6 = *(char *)a3;
      v47 = *v18;
      v19 = v18[1].m128i_i64[0];
      v20 = _mm_cvtsi128_si32(_mm_srli_si128(v47, 8));
      v48 = v19;
      if ( v20 && v20 != 99 )
      {
LABEL_3:
        sub_146159800(a2, a1, v6);
      }
      else
      {
        LOBYTE(v48) = v48 & 0xFE;
        v47.m128i_i32[3] &= 0xFFFFFF8F;
        v21 = v47.m128i_i32[3] << 28 >> 28;
        BYTE1(v48) = 32;
        if ( !v21 || v21 == 4 )
          v47.m128i_i32[3] = v47.m128i_i32[3] & 0xFFFFFFF0 | 2;
        sub_14615D880(a1, *a2, v6, (__int64)&v47, 0i64);
      }
      break;
    case 9:
      v22 = (__m128i *)a2[1];
      v23 = *(float *)a3;
      v24 = *a2;
      v25 = *v22;
      v26 = v22[1].m128i_i64[0];
      v27 = a2[2];
      v47 = v25;
      v48 = v26;
      sub_14615DBD0(a1, v24, v23, (__int64)&v47, v27);
      break;
    case 10:
      v28 = (__m128i *)a2[1];
      v29 = *(double *)a3;
      v30 = *a2;
      v31 = *v28;
      v32 = v28[1].m128i_i64[0];
      v33 = a2[2];
      v47 = v31;
      v48 = v32;
      sub_14615E050(a1, v30, v29, (__int64)&v47, v33);
      break;
    case 11:
      v34 = (__m128i *)a2[1];
      v35 = *(double *)a3;
      v36 = *a2;
      v37 = *v34;
      v38 = v34[1].m128i_i64[0];
      v39 = a2[2];
      v47 = v37;
      v48 = v38;
      sub_14615E4D0(a1, v36, v35, (__int64)&v47, v39);
      break;
    case 12:
      sub_1461635D0(a2, a1, *(const char **)a3);
      break;
    case 13:
      v40 = a2[1];
      v41 = *a2;
      v47 = *(__m128i *)a3;
      sub_14615DA40(a1, v41, (unsigned __int64 *)&v47, v40);
      break;
    case 14:
      sub_1461637A0(a2, a1, *(_QWORD *)a3);
      break;
    case 15:
      v42 = a2[3];
      v43 = *(const char **)a3;
      v47 = 0ui64;
      LODWORD(v48) = 0;
      (*((void (__fastcall **)(const char *, __m128i *, __int64))a3 + 1))(v43, &v47, v42);
      *a1 = *a2;
      break;
    default:
      sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\format.h", 0x73Cu, Src);
  }
  return a1;
}
// 14615C1B3: variable 'v45' is possibly undefined
// 14611CFB0: using guessed type int dword_14611CFB0[];
// 146163960: using guessed type void __fastcall __noreturn sub_146163960(_QWORD, _QWORD, _QWORD);

//----- (000000014615C4A0) ----------------------------------------------------
__int64 __fastcall sub_14615C4A0(__int64 a1, _DWORD *a2)
{
  unsigned __int64 v2; // rdi
  const char *pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  char v5; // [rsp+30h] [rbp-30h]
  void **v6; // [rsp+40h] [rbp-20h] BYREF
  __int128 v7; // [rsp+48h] [rbp-18h]
  unsigned __int8 v8; // [rsp+78h] [rbp+18h]

  switch ( a2[4] )
  {
    case 1:
      LODWORD(v2) = *a2;
      if ( (int)*a2 < 0 )
      {
        *(_DWORD *)(*(_QWORD *)a1 + 12i64) = *(_DWORD *)(*(_QWORD *)a1 + 12i64) & 0xFFFFFFF0 | 1;
        LODWORD(v2) = -(int)v2;
      }
      if ( (unsigned int)v2 > 0x7FFFFFFF )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "number is too big";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      return (unsigned int)v2;
    case 2:
      LODWORD(v2) = *a2;
      if ( *a2 > 0x7FFFFFFFu )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "number is too big";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      return (unsigned int)v2;
    case 3:
      v2 = *(_QWORD *)a2;
      if ( *(__int64 *)a2 < 0 )
      {
        *(_DWORD *)(*(_QWORD *)a1 + 12i64) = *(_DWORD *)(*(_QWORD *)a1 + 12i64) & 0xFFFFFFF0 | 1;
        v2 = -(__int64)v2;
      }
      if ( v2 > 0x7FFFFFFF )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "number is too big";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      return (unsigned int)v2;
    case 4:
      v2 = *(_QWORD *)a2;
      if ( *(_QWORD *)a2 > 0x7FFFFFFFui64 )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "number is too big";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      return (unsigned int)v2;
    case 7:
      return *(unsigned __int8 *)a2;
    case 8:
      LODWORD(v2) = *(char *)a2;
      if ( *(char *)a2 < 0 )
      {
        *(_DWORD *)(*(_QWORD *)a1 + 12i64) = *(_DWORD *)(*(_QWORD *)a1 + 12i64) & 0xFFFFFFF0 | 1;
        LODWORD(v2) = -(int)v2;
      }
      if ( (unsigned int)v2 > 0x7FFFFFFF )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "number is too big";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      return (unsigned int)v2;
    case 9:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xA:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xB:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xC:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xD:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xE:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xF:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    default:
      sub_146159870(a1, v8);
  }
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 146159870: using guessed type void __fastcall __noreturn sub_146159870(_QWORD, _QWORD);
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014615CA80) ----------------------------------------------------
__int64 __fastcall sub_14615CA80(__int64 a1, unsigned int *a2)
{
  __int64 result; // rax
  __int64 v3; // rdi
  const char *pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  char v5; // [rsp+30h] [rbp-30h]
  void **v6; // [rsp+40h] [rbp-20h] BYREF
  __int128 v7; // [rsp+48h] [rbp-18h]
  unsigned __int8 v8; // [rsp+78h] [rbp+18h]

  switch ( a2[4] )
  {
    case 1u:
      result = *a2;
      if ( (int)result < 0 )
        return 0i64;
      return result;
    case 2u:
      LODWORD(v3) = *a2;
      if ( *a2 > 0x7FFFFFFF )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "number is too big";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      goto LABEL_6;
    case 3u:
      v3 = *(_QWORD *)a2;
      if ( (unsigned __int64)(*(_QWORD *)a2 + 0x80000000i64) > 0xFFFFFFFF )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "number is too big";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      goto LABEL_6;
    case 4u:
      v3 = *(_QWORD *)a2;
      if ( *(_QWORD *)a2 > 0x7FFFFFFFui64 )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "number is too big";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
LABEL_6:
      if ( (int)v3 < 0 )
        LODWORD(v3) = 0;
      result = (unsigned int)v3;
      break;
    case 7u:
      result = *(unsigned __int8 *)a2;
      break;
    case 8u:
      result = (unsigned int)*(char *)a2;
      if ( (int)result < 0 )
        result = 0i64;
      break;
    case 9u:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xAu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xBu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xCu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xDu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xEu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xFu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    default:
      sub_1461598F0(a1, v8);
  }
  return result;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461598F0: using guessed type void __fastcall __noreturn sub_1461598F0(_QWORD, _QWORD);
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014615CF80) ----------------------------------------------------
void *__fastcall sub_14615CF80(__int64 a1, __int64 a2, __int128 *a3)
{
  __int64 v3; // rbx
  char *v4; // r15
  char *v5; // r12
  char *v6; // rdi
  __int128 v7; // xmm6
  char v8; // r13
  __int64 v9; // xmm7_8
  __int64 v10; // xmm8_8
  __int64 v11; // xmm9_8
  __int64 v12; // xmm10_8
  __int64 v13; // xmm11_8
  __int64 v14; // xmm12_8
  char *v15; // rax
  char v16; // cl
  _BYTE *v17; // rdi
  int v18; // edi
  char *v19; // r15
  int v20; // edx
  __int128 v21; // xmm0
  unsigned __int64 v22; // r8
  int v23; // edi
  __int64 v24; // r14
  const __m128i *v25; // rdi
  const __m128i *v26; // rax
  __int64 v27; // rsi
  bool v28; // zf
  char v29; // r8
  char v30; // dl
  char v31; // al
  char v32; // al
  char v33; // cl
  char v35[8]; // [rsp+28h] [rbp-E0h] BYREF
  _BYTE v36[24]; // [rsp+38h] [rbp-D0h] BYREF
  _QWORD v37[3]; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v38; // [rsp+68h] [rbp-A0h]
  __int128 v39; // [rsp+78h] [rbp-90h] BYREF
  char v40; // [rsp+88h] [rbp-80h] BYREF
  char v41[7]; // [rsp+89h] [rbp-7Fh] BYREF
  char *v42; // [rsp+90h] [rbp-78h] BYREF
  __int128 v43; // [rsp+98h] [rbp-70h] BYREF
  int v44; // [rsp+A8h] [rbp-60h]
  __int64 v45; // [rsp+B0h] [rbp-58h] BYREF
  __int128 v46; // [rsp+B8h] [rbp-50h]
  const char *pExceptionObject; // [rsp+C8h] [rbp-40h] BYREF
  char v48; // [rsp+D0h] [rbp-38h]
  _QWORD *v49; // [rsp+E0h] [rbp-28h] BYREF
  char v50; // [rsp+E8h] [rbp-20h]
  _QWORD *v51; // [rsp+F0h] [rbp-18h] BYREF
  char v52; // [rsp+F8h] [rbp-10h]
  _QWORD *v53; // [rsp+100h] [rbp-8h] BYREF
  char v54; // [rsp+108h] [rbp+0h]
  _QWORD *v55; // [rsp+110h] [rbp+8h] BYREF
  char v56; // [rsp+118h] [rbp+10h]
  _QWORD *v57; // [rsp+120h] [rbp+18h] BYREF
  char v58; // [rsp+128h] [rbp+20h]
  _QWORD *v59; // [rsp+130h] [rbp+28h] BYREF
  char v60; // [rsp+138h] [rbp+30h]
  _QWORD *v61; // [rsp+140h] [rbp+38h] BYREF
  char v62; // [rsp+148h] [rbp+40h]
  _QWORD *v63; // [rsp+150h] [rbp+48h] BYREF
  char v64; // [rsp+158h] [rbp+50h]
  __int64 v65; // [rsp+160h] [rbp+58h]
  int v66; // [rsp+168h] [rbp+60h] BYREF
  int v67; // [rsp+16Ch] [rbp+64h]
  char v68; // [rsp+170h] [rbp+68h]
  unsigned int v69; // [rsp+174h] [rbp+6Ch]
  char v70; // [rsp+178h] [rbp+70h]
  int v71; // [rsp+179h] [rbp+71h]
  char v72; // [rsp+17Dh] [rbp+75h]

  v65 = -2i64;
  v3 = a1;
  v45 = a1;
  v46 = *a3;
  v43 = *(_OWORD *)a2;
  v44 = 0;
  *(_QWORD *)&v39 = &v43;
  *((_QWORD *)&v39 + 1) = &v45;
  v4 = (char *)v43;
  v5 = (char *)(v43 + *(_QWORD *)(a2 + 8));
  v6 = (char *)v43;
  if ( (char *)v43 != v5 )
  {
    v7 = v39;
    v8 = HIBYTE(v39);
    v9 = *(_QWORD *)((char *)&v39 + 1);
    v10 = *(_QWORD *)((char *)&v39 + 1);
    v11 = *(_QWORD *)((char *)&v39 + 1);
    v12 = *(_QWORD *)((char *)&v39 + 1);
    v13 = *(_QWORD *)((char *)&v39 + 1);
    v14 = *(_QWORD *)((char *)&v39 + 1);
    while ( 1 )
    {
      if ( v5 - v6 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      v15 = (char *)memchr(v6, 37, v5 - v6);
      if ( !v15 )
      {
        v6 = v5;
        goto LABEL_114;
      }
      v16 = *v15;
      v17 = v15 + 1;
      v42 = v15 + 1;
      if ( v15 + 1 == v5 || *v17 != v16 )
        break;
      if ( v17 - v4 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      sub_14615AAE0(v3, v4, v15 + 1);
      v4 = v17 + 1;
LABEL_111:
      v6 = v4;
      if ( v4 == v5 )
        goto LABEL_114;
    }
    if ( v15 - v4 < 0 )
      sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
    sub_14615AAE0(v3, v4, v15);
    v66 = 0;
    v67 = -1;
    v68 = 0;
    v70 &= 0xFCu;
    v71 = 32;
    v72 = 1;
    v69 = v69 & 0xFFFFFF80 | 2;
    *(_OWORD *)v36 = v7;
    v18 = sub_14615B6D0(&v42, v5, (__int64)&v66, (__int64 *)v36);
    if ( !v18 )
      sub_14619FE20((__int64)&v43, (__int64)"argument not found");
    v19 = v42;
    if ( v42 == v5 || *v42 != 46 )
    {
LABEL_35:
      if ( v18 >= 0 )
      {
        v23 = v18 - 1;
        if ( v44 > 0 )
          sub_14619FE20((__int64)&v43, (__int64)"cannot switch from automatic to manual argument indexing");
        v44 = -1;
      }
      else
      {
        v23 = v44;
        if ( v44 < 0 )
          sub_14619FE20((__int64)&v43, (__int64)"cannot switch from manual to automatic argument indexing");
        ++v44;
      }
      LODWORD(v38) = 0;
      if ( (__int64)v46 >= 0 )
      {
        if ( v23 >= 15 )
          goto LABEL_49;
        LODWORD(v38) = ((unsigned __int64)v46 >> (4 * (unsigned __int8)v23)) & 0xF;
        if ( (_DWORD)v38 )
          *(_OWORD *)&v37[1] = *(_OWORD *)(*((_QWORD *)&v46 + 1) + 16i64 * v23);
      }
      else
      {
        if ( v23 >= (int)v46 )
          goto LABEL_49;
        *(_OWORD *)&v37[1] = *(_OWORD *)(*((_QWORD *)&v46 + 1) + 24i64 * v23);
        v38 = *(_QWORD *)(*((_QWORD *)&v46 + 1) + 24i64 * v23 + 16);
      }
      if ( !(_DWORD)v38 )
LABEL_49:
        sub_14619FE20((__int64)v41, (__int64)"argument not found");
      if ( v67 >= 0 )
      {
        if ( (unsigned int)(v38 - 1) <= 7 )
          LOBYTE(v71) = 32;
        if ( (_DWORD)v38 == 12 )
        {
          v24 = v37[1];
          v25 = (const __m128i *)(v37[1] + v67);
          v26 = sub_1461A7820((const __m128i *)v37[1], v25, 0);
          if ( v26 == v25 )
            v27 = v67;
          else
            v27 = (__int64)v26->m128i_i64 - v24;
          if ( v27 < 0 )
            sub_14619F290(
              "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h",
              0x19Eu,
              "negative value");
          *(_DWORD *)&v36[16] = 13;
          *(_QWORD *)v36 = v24;
          *(_QWORD *)&v36[8] = v27;
          *(_OWORD *)&v37[1] = *(_OWORD *)v36;
          v38 = *(_QWORD *)&v36[16];
        }
      }
      if ( (v70 & 1) != 0 )
      {
        switch ( (int)v38 )
        {
          case 1:
          case 2:
            v28 = LODWORD(v37[1]) == 0;
            goto LABEL_65;
          case 3:
          case 4:
            v28 = v37[1] == 0i64;
            goto LABEL_65;
          case 7:
          case 8:
            v28 = LOBYTE(v37[1]) == 0;
LABEL_65:
            if ( v28 )
              v70 &= ~1u;
            break;
          default:
            break;
        }
      }
      if ( (_BYTE)v71 == 48 )
      {
        if ( (unsigned int)(v38 - 1) > 0xA || (v69 & 0xF) == 1 )
          LOBYTE(v71) = 32;
        else
          v69 = v69 & 0xFFFFFFF0 | 4;
      }
      if ( v19 == v5 )
        v29 = 0;
      else
        v29 = *v19++;
      if ( v19 == v5 )
        v30 = 0;
      else
        v30 = *v19;
      switch ( v29 )
      {
        case 'L':
          break;
        case 'h':
          if ( v30 == 104 )
          {
            if ( ++v19 == v5 )
              v31 = 0;
            else
              v31 = *v19;
            v49 = &v37[1];
            v50 = v31;
            sub_14615BA20((__int64 *)&v49, &v37[1]);
          }
          else
          {
            v51 = &v37[1];
            v52 = v30;
            sub_14615BB30((__int64 *)&v51, &v37[1]);
          }
          break;
        case 'j':
          v57 = &v37[1];
          v58 = v30;
          sub_14615BF10((__int64 *)&v57, (unsigned int *)&v37[1]);
          break;
        case 'l':
          if ( v30 == 108 )
          {
            if ( ++v19 == v5 )
              v32 = 0;
            else
              v32 = *v19;
            v53 = &v37[1];
            v54 = v32;
            sub_14615BF10((__int64 *)&v53, (unsigned int *)&v37[1]);
          }
          else
          {
            v55 = &v37[1];
            v56 = v30;
            sub_14615BC90((__int64 *)&v55, &v37[1]);
          }
          break;
        case 't':
          v61 = &v37[1];
          v62 = v30;
          sub_14615BF10((__int64 *)&v61, (unsigned int *)&v37[1]);
          break;
        case 'z':
          v59 = &v37[1];
          v60 = v30;
          sub_14615BF10((__int64 *)&v59, (unsigned int *)&v37[1]);
          break;
        default:
          --v19;
          v63 = &v37[1];
          v64 = v29;
          sub_14615BD90((__int64 *)&v63, (int *)&v37[1]);
          break;
      }
      if ( v19 == v5 )
      {
        *(_QWORD *)v36 = &std::exception::`vftable';
        *(_OWORD *)&v36[8] = 0i64;
        pExceptionObject = "invalid format string";
        v48 = 1;
        _std_exception_copy(&pExceptionObject);
        *(_QWORD *)v36 = &fmt::v8::format_error::`vftable';
        v35[0] = 1;
        sub_146162440((__int64)&pExceptionObject, (__int64)v36);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      v33 = *v19;
      v68 = *v19;
      v4 = v19 + 1;
      if ( (unsigned int)(v38 - 1) <= 7 )
      {
        if ( v33 == 99 )
        {
          switch ( (int)v38 )
          {
            case 1:
              v36[0] = v37[1];
              *(_QWORD *)&v36[1] = v9;
              *(_DWORD *)&v36[9] = *(_DWORD *)((char *)&v39 + 9);
              *(_WORD *)&v36[13] = *(_WORD *)((char *)&v39 + 13);
              v36[15] = v8;
              goto LABEL_109;
            case 2:
              *(_QWORD *)&v36[1] = v10;
              goto LABEL_108;
            case 3:
              *(_QWORD *)&v36[1] = v11;
              goto LABEL_108;
            case 4:
              *(_QWORD *)&v36[1] = v12;
              goto LABEL_108;
            case 7:
              *(_QWORD *)&v36[1] = v13;
              goto LABEL_108;
            case 8:
              *(_QWORD *)&v36[1] = v14;
LABEL_108:
              v36[0] = v37[1];
              *(_DWORD *)&v36[9] = *(_DWORD *)((char *)&v39 + 9);
              *(_WORD *)&v36[13] = *(_WORD *)((char *)&v39 + 13);
              v36[15] = HIBYTE(v39);
LABEL_109:
              *(_DWORD *)&v36[16] = 8;
              v38 = *(_QWORD *)&v36[16];
              *(_OWORD *)&v37[1] = *(_OWORD *)v36;
              break;
            default:
              break;
          }
        }
        else if ( v33 == 105 || v33 == 117 )
        {
          v68 = 100;
        }
      }
      *(_QWORD *)v36 = v3;
      *(_QWORD *)&v36[8] = &v66;
      *(_QWORD *)&v36[16] = 0i64;
      v37[0] = &v45;
      v3 = *sub_14615C090((__int64 *)&v39, (__int64 *)v36, (int *)&v37[1]);
      goto LABEL_111;
    }
    v19 = v42 + 1;
    v42 = v19;
    if ( v19 == v5 )
      goto LABEL_34;
    if ( (unsigned __int8)(*v19 - 48) <= 9u )
    {
      v67 = sub_14615B920(&v42, v5, 0);
      v19 = v42;
      goto LABEL_35;
    }
    if ( *v19 != 42 )
    {
LABEL_34:
      v67 = 0;
      goto LABEL_35;
    }
    ++v19;
    v20 = v44;
    if ( v44 < 0 )
      sub_14619FE20((__int64)&v43, (__int64)"cannot switch from manual to automatic argument indexing");
    ++v44;
    *(_DWORD *)&v36[16] = 0;
    if ( (__int64)v46 >= 0 )
    {
      if ( v20 >= 15 )
        goto LABEL_32;
      v22 = ((unsigned __int64)v46 >> (4 * (unsigned __int8)v20)) & 0xF;
      *(_DWORD *)&v36[16] = v22;
      if ( !(_DWORD)v22 )
      {
LABEL_31:
        if ( !(_DWORD)v22 )
LABEL_32:
          sub_14619FE20((__int64)&v40, (__int64)"argument not found");
        v67 = sub_14615CA80((__int64)v35, (unsigned int *)v36);
        goto LABEL_35;
      }
      v21 = *(_OWORD *)(*((_QWORD *)&v46 + 1) + 16i64 * v20);
    }
    else
    {
      if ( v20 >= (int)v46 )
        goto LABEL_32;
      v21 = *(_OWORD *)(*((_QWORD *)&v46 + 1) + 24i64 * v20);
      *(_QWORD *)&v36[16] = *(_QWORD *)(*((_QWORD *)&v46 + 1) + 24i64 * v20 + 16);
      LODWORD(v22) = *(_DWORD *)&v36[16];
    }
    *(_OWORD *)v36 = v21;
    goto LABEL_31;
  }
LABEL_114:
  if ( v6 - v4 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  return sub_14615AAE0(v3, v4, v6);
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 14615CF80: using guessed type char var_18F[7];
// 14615CF80: using guessed type char var_1F0[8];

//----- (000000014615D880) ----------------------------------------------------
__int64 *__fastcall sub_14615D880(__int64 *a1, __int64 a2, char a3, __int64 a4, __int64 a5)
{
  int v5; // eax
  unsigned int v8; // edx
  unsigned int v9; // eax
  __int64 v10; // rax
  int v11; // ecx
  __int64 v13[5]; // [rsp+30h] [rbp-28h] BYREF
  char v14; // [rsp+60h] [rbp+8h] BYREF
  __int64 v15; // [rsp+78h] [rbp+20h] BYREF

  v5 = *(char *)(a4 + 8);
  v14 = 0;
  if ( !(_BYTE)v5 || (_BYTE)v5 == 99 )
  {
    v11 = *(_DWORD *)(a4 + 12);
    if ( (v11 & 0xF) == 4 || (v11 & 0x70) != 0 || (*(_BYTE *)(a4 + 16) & 1) != 0 )
      sub_14619FE20((__int64)&v14, (__int64)"invalid format specifier for char");
    LOBYTE(v15) = a3;
    sub_1461601E0(v13, a2, (char *)a4, 1i64, 1ui64, &v15);
    v10 = v13[0];
  }
  else
  {
    switch ( v5 )
    {
      case 0:
      case 66:
      case 88:
      case 98:
      case 99:
      case 100:
      case 111:
      case 120:
        v8 = a3;
        if ( a3 >= 0 )
        {
          v9 = dword_14611CFB0[(__int64)(int)(*(_DWORD *)(a4 + 12) << 25) >> 29];
        }
        else
        {
          v9 = 16777261;
          v8 = -a3;
        }
        sub_14615EFB0(&v15, a2, v8 | ((unsigned __int64)v9 << 32), a4, a5);
        v10 = v15;
        break;
      default:
        sub_14619FE20((__int64)&v14, (__int64)"invalid type specifier");
    }
  }
  *a1 = v10;
  return a1;
}
// 14611CFB0: using guessed type int dword_14611CFB0[];
// 14615D880: using guessed type __int64 var_28[5];

//----- (000000014615DA40) ----------------------------------------------------
__int64 *__fastcall sub_14615DA40(__int64 *a1, __int64 a2, unsigned __int64 *a3, __int64 a4)
{
  char v4; // al
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // r14
  unsigned __int64 v10; // rbp
  unsigned __int64 v11; // rax
  unsigned __int8 *v12; // rdi
  unsigned __int64 v13; // rsi
  __int64 v14; // rsi
  unsigned __int8 *v15; // rcx
  char v17[8]; // [rsp+30h] [rbp-58h] BYREF
  __int64 *v18; // [rsp+38h] [rbp-50h] BYREF
  __int64 v19[2]; // [rsp+40h] [rbp-48h] BYREF
  int v20; // [rsp+50h] [rbp-38h] BYREF
  __int16 v21; // [rsp+54h] [rbp-34h]
  char v22; // [rsp+56h] [rbp-32h]

  v4 = *(_BYTE *)(a4 + 8);
  v17[0] = 0;
  if ( v4 && v4 != 115 )
    sub_14619FE20((__int64)v17, (__int64)"invalid type specifier");
  v8 = *(unsigned int *)(a4 + 4);
  v9 = *a3;
  v10 = a3[1];
  if ( (v8 & 0x80000000) == 0i64 && v8 < v10 )
    v10 = *(unsigned int *)(a4 + 4);
  v11 = 0i64;
  if ( *(_DWORD *)a4 )
  {
    v19[0] = 0i64;
    v18 = v19;
    v12 = (unsigned __int8 *)v9;
    if ( v10 >= 4 )
    {
      v13 = v10 + v9 - 3;
      if ( v9 < v13 )
      {
        do
          v12 = sub_146162E60(&v18, v12);
        while ( (unsigned __int64)v12 < v13 );
      }
    }
    v14 = v10 + v9 - (_QWORD)v12;
    if ( v14 )
    {
      v20 = 0;
      v21 = 0;
      v22 = 0;
      if ( v14 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      memcpy(&v20, v12, v10 + v9 - (_QWORD)v12);
      v15 = (unsigned __int8 *)&v20;
      do
        v15 = sub_146162E60(&v18, v15);
      while ( v15 - (unsigned __int8 *)&v20 < v14 );
    }
    v11 = v19[0];
  }
  v19[0] = v9;
  v19[1] = v10;
  sub_146160390(a1, a2, (char *)a4, v10, v11, (__int64)v19);
  return a1;
}
// 14615DA40: using guessed type char var_58[8];

//----- (000000014615DBD0) ----------------------------------------------------
__int64 *__fastcall sub_14615DBD0(__int64 *a1, __int64 a2, float a3, __int64 a4, __int64 a5)
{
  float v6; // xmm6_4
  unsigned int v9; // edi
  const char *v10; // rax
  const char *v11; // rcx
  char v12; // al
  void *v13; // rcx
  int v14; // r15d
  __int8 v15; // di
  int v16; // r13d
  char v17; // cl
  char v19[8]; // [rsp+38h] [rbp-D0h] BYREF
  __m128i v20; // [rsp+48h] [rbp-C0h] BYREF
  __m128i v21; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v22; // [rsp+68h] [rbp-A0h]
  _BYTE v23[24]; // [rsp+78h] [rbp-90h] BYREF
  __int64 v24; // [rsp+98h] [rbp-70h] BYREF
  int v25; // [rsp+A0h] [rbp-68h]
  int v26; // [rsp+A4h] [rbp-64h]
  __int64 v27; // [rsp+A8h] [rbp-60h]
  void **v28; // [rsp+B8h] [rbp-50h] BYREF
  __m128i Block; // [rsp+C0h] [rbp-48h]
  unsigned __int64 v30; // [rsp+D0h] [rbp-38h]
  char v31[512]; // [rsp+D8h] [rbp-30h] BYREF

  v27 = -2i64;
  v6 = a3;
  v19[0] = 0;
  v20 = *(__m128i *)sub_14615B550((__int64)&v21, a4, (__int64)v19);
  v9 = _mm_cvtsi128_si32(_mm_srli_si128(v20, 8)) & 0xFFFFFF00 | (unsigned __int8)((int)(*(_DWORD *)(a4 + 12) << 25) >> 29);
  v20.m128i_i32[2] = v9;
  if ( fdsign(a3) )
  {
    v9 = v9 & 0xFFFFFF00 | 1;
    v6 = -a3;
  }
  else
  {
    if ( (_BYTE)v9 != 1 )
      goto LABEL_6;
    v9 &= 0xFFFFFF00;
  }
  v20.m128i_i32[2] = v9;
LABEL_6:
  if ( fdclass(v6) > 0 )
  {
    *(_OWORD *)v23 = *(_OWORD *)a4;
    *(_QWORD *)&v23[16] = *(_QWORD *)(a4 + 16);
    if ( fabs(v6) >= INFINITY )
    {
      v10 = "INF";
      v11 = "inf";
    }
    else
    {
      v10 = "NAN";
      v11 = "nan";
    }
    if ( (v20.m128i_i8[12] & 1) != 0 )
      v11 = v10;
    if ( v23[21] == 1 )
    {
      v12 = v23[17];
      if ( v23[17] == 48 )
        v12 = 32;
      v23[17] = v12;
    }
    v21.m128i_i32[0] = (char)v9;
    v21.m128i_i64[1] = (__int64)v11;
    v22 = 3i64;
    sub_146160020(a1, a2, v23, ((_BYTE)v9 != 0) + 3i64, ((_BYTE)v9 != 0) + 3i64, (char **)&v21);
    return a1;
  }
  if ( (*(_DWORD *)(a4 + 12) & 0xF) == 4 )
  {
    if ( !(_BYTE)v9 )
      goto LABEL_24;
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = byte_14611CFAC[(char)v9];
    v20.m128i_i32[2] = v9 & 0xFFFFFF00;
    if ( *(_DWORD *)a4 )
      --*(_DWORD *)a4;
  }
  LOBYTE(v9) = v20.m128i_i8[8];
LABEL_24:
  Block.m128i_i64[1] = 0i64;
  v28 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  Block.m128i_i64[0] = (__int64)v31;
  v30 = 500i64;
  if ( v20.m128i_i8[4] == 3 )
  {
    if ( (_BYTE)v9 )
    {
      v31[0] = byte_14611CFAC[(char)v9];
      Block.m128i_i64[1] = 1i64;
    }
    v21 = v20;
    sub_146199D60(v6, *(_DWORD *)(a4 + 4), (__int64)&v21, (__int64)&v28);
    v20 = Block;
    sub_146160900(a1, a2, (char *)a4, Block.m128i_i64[1], Block.m128i_u64[1], (__int64)&v20);
    v28 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
    v13 = (void *)Block.m128i_i64[0];
    if ( (char *)Block.m128i_i64[0] != v31 )
    {
      if ( v30 >= 0x1000 )
      {
        v13 = *(void **)(Block.m128i_i64[0] - 8);
        if ( (unsigned __int64)(Block.m128i_i64[0] - (_QWORD)v13 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
LABEL_45:
      j_j_free(v13);
    }
  }
  else
  {
    v14 = *(_DWORD *)(a4 + 4);
    if ( v14 < 0 && *(_BYTE *)(a4 + 8) )
      v14 = 6;
    if ( v20.m128i_i8[4] == 1 )
    {
      if ( v14 == 0x7FFFFFFF )
      {
        *(_QWORD *)v23 = &std::exception::`vftable';
        *(_OWORD *)&v23[8] = 0i64;
        v21.m128i_i64[0] = (__int64)"number is too big";
        v21.m128i_i8[8] = 1;
        _std_exception_copy(&v21);
        *(_QWORD *)v23 = &fmt::v8::format_error::`vftable';
        sub_14615AB90((__int64)v23);
      }
      ++v14;
    }
    v20.m128i_i8[12] |= 0xCu;
    v15 = v20.m128i_i8[12];
    v21 = v20;
    v16 = sub_146196120(v6, v14, (__int64)&v21, &v28);
    v20.m128i_i32[0] = v14;
    if ( (v15 & 2) != 0 )
      v17 = sub_146196700(a5);
    else
      v17 = 46;
    v24 = Block.m128i_i64[0];
    v25 = Block.m128i_i32[2];
    v26 = v16;
    v21 = v20;
    sub_14615EBF0(a1, a2, (__int64)&v24, (char *)a4, (__int64)&v21, v17);
    v28 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
    v13 = (void *)Block.m128i_i64[0];
    if ( (char *)Block.m128i_i64[0] != v31 )
    {
      if ( v30 >= 0x1000 )
      {
        v13 = *(void **)(Block.m128i_i64[0] - 8);
        if ( (unsigned __int64)(Block.m128i_i64[0] - (_QWORD)v13 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      goto LABEL_45;
    }
  }
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 14615DBD0: using guessed type char anonymous_0[8];

//----- (000000014615E050) ----------------------------------------------------
__int64 *__fastcall sub_14615E050(__int64 *a1, __int64 a2, double a3, __int64 a4, __int64 a5)
{
  double v6; // xmm6_8
  unsigned int v9; // edi
  const char *v10; // rax
  const char *v11; // rcx
  char v12; // al
  void *v13; // rcx
  int v14; // r15d
  __int8 v15; // di
  int v16; // r13d
  char v17; // cl
  char v19[8]; // [rsp+38h] [rbp-D0h] BYREF
  __m128i v20; // [rsp+48h] [rbp-C0h] BYREF
  __m128i v21; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v22; // [rsp+68h] [rbp-A0h]
  _BYTE v23[24]; // [rsp+78h] [rbp-90h] BYREF
  __int64 v24; // [rsp+98h] [rbp-70h] BYREF
  int v25; // [rsp+A0h] [rbp-68h]
  int v26; // [rsp+A4h] [rbp-64h]
  __int64 v27; // [rsp+A8h] [rbp-60h]
  void **v28; // [rsp+B8h] [rbp-50h] BYREF
  __m128i Block; // [rsp+C0h] [rbp-48h]
  unsigned __int64 v30; // [rsp+D0h] [rbp-38h]
  char v31[512]; // [rsp+D8h] [rbp-30h] BYREF

  v27 = -2i64;
  v6 = a3;
  v19[0] = 0;
  v20 = *(__m128i *)sub_14615B550((__int64)&v21, a4, (__int64)v19);
  v9 = _mm_cvtsi128_si32(_mm_srli_si128(v20, 8)) & 0xFFFFFF00 | (unsigned __int8)((int)(*(_DWORD *)(a4 + 12) << 25) >> 29);
  v20.m128i_i32[2] = v9;
  if ( dsign(a3) )
  {
    v9 = v9 & 0xFFFFFF00 | 1;
    v6 = -a3;
  }
  else
  {
    if ( (_BYTE)v9 != 1 )
      goto LABEL_6;
    v9 &= 0xFFFFFF00;
  }
  v20.m128i_i32[2] = v9;
LABEL_6:
  if ( dclass(v6) > 0 )
  {
    *(_OWORD *)v23 = *(_OWORD *)a4;
    *(_QWORD *)&v23[16] = *(_QWORD *)(a4 + 16);
    if ( fabs(v6) >= INFINITY )
    {
      v10 = "INF";
      v11 = "inf";
    }
    else
    {
      v10 = "NAN";
      v11 = "nan";
    }
    if ( (v20.m128i_i8[12] & 1) != 0 )
      v11 = v10;
    if ( v23[21] == 1 )
    {
      v12 = v23[17];
      if ( v23[17] == 48 )
        v12 = 32;
      v23[17] = v12;
    }
    v21.m128i_i32[0] = (char)v9;
    v21.m128i_i64[1] = (__int64)v11;
    v22 = 3i64;
    sub_146160020(a1, a2, v23, ((_BYTE)v9 != 0) + 3i64, ((_BYTE)v9 != 0) + 3i64, (char **)&v21);
    return a1;
  }
  if ( (*(_DWORD *)(a4 + 12) & 0xF) == 4 )
  {
    if ( !(_BYTE)v9 )
      goto LABEL_24;
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = byte_14611CFAC[(char)v9];
    v20.m128i_i32[2] = v9 & 0xFFFFFF00;
    if ( *(_DWORD *)a4 )
      --*(_DWORD *)a4;
  }
  LOBYTE(v9) = v20.m128i_i8[8];
LABEL_24:
  Block.m128i_i64[1] = 0i64;
  v28 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  Block.m128i_i64[0] = (__int64)v31;
  v30 = 500i64;
  if ( v20.m128i_i8[4] == 3 )
  {
    if ( (_BYTE)v9 )
    {
      v31[0] = byte_14611CFAC[(char)v9];
      Block.m128i_i64[1] = 1i64;
    }
    v21 = v20;
    sub_146199D60(v6, *(_DWORD *)(a4 + 4), (__int64)&v21, (__int64)&v28);
    v20 = Block;
    sub_146160900(a1, a2, (char *)a4, Block.m128i_i64[1], Block.m128i_u64[1], (__int64)&v20);
    v28 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
    v13 = (void *)Block.m128i_i64[0];
    if ( (char *)Block.m128i_i64[0] != v31 )
    {
      if ( v30 >= 0x1000 )
      {
        v13 = *(void **)(Block.m128i_i64[0] - 8);
        if ( (unsigned __int64)(Block.m128i_i64[0] - (_QWORD)v13 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
LABEL_45:
      j_j_free(v13);
    }
  }
  else
  {
    v14 = *(_DWORD *)(a4 + 4);
    if ( v14 < 0 && *(_BYTE *)(a4 + 8) )
      v14 = 6;
    if ( v20.m128i_i8[4] == 1 )
    {
      if ( v14 == 0x7FFFFFFF )
      {
        *(_QWORD *)v23 = &std::exception::`vftable';
        *(_OWORD *)&v23[8] = 0i64;
        v21.m128i_i64[0] = (__int64)"number is too big";
        v21.m128i_i8[8] = 1;
        _std_exception_copy(&v21);
        *(_QWORD *)v23 = &fmt::v8::format_error::`vftable';
        sub_14615AB90((__int64)v23);
      }
      ++v14;
    }
    v20.m128i_i8[12] |= 8u;
    v15 = v20.m128i_i8[12];
    v21 = v20;
    v16 = sub_146196120(v6, v14, (__int64)&v21, &v28);
    v20.m128i_i32[0] = v14;
    if ( (v15 & 2) != 0 )
      v17 = sub_146196700(a5);
    else
      v17 = 46;
    v24 = Block.m128i_i64[0];
    v25 = Block.m128i_i32[2];
    v26 = v16;
    v21 = v20;
    sub_14615EBF0(a1, a2, (__int64)&v24, (char *)a4, (__int64)&v21, v17);
    v28 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
    v13 = (void *)Block.m128i_i64[0];
    if ( (char *)Block.m128i_i64[0] != v31 )
    {
      if ( v30 >= 0x1000 )
      {
        v13 = *(void **)(Block.m128i_i64[0] - 8);
        if ( (unsigned __int64)(Block.m128i_i64[0] - (_QWORD)v13 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      goto LABEL_45;
    }
  }
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 14615E050: using guessed type char anonymous_0[8];

//----- (000000014615E4D0) ----------------------------------------------------
__int64 *__fastcall sub_14615E4D0(__int64 *a1, __int64 a2, long double a3, __int64 a4, __int64 a5)
{
  double v6; // xmm6_8
  unsigned int v9; // edi
  const char *v10; // rax
  const char *v11; // rcx
  char v12; // al
  void *v13; // rcx
  int v14; // r15d
  __int8 v15; // di
  int v16; // r13d
  char v17; // cl
  char v19[8]; // [rsp+38h] [rbp-D0h] BYREF
  __m128i v20; // [rsp+48h] [rbp-C0h] BYREF
  __m128i v21; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v22; // [rsp+68h] [rbp-A0h]
  _BYTE v23[24]; // [rsp+78h] [rbp-90h] BYREF
  __int64 v24; // [rsp+98h] [rbp-70h] BYREF
  int v25; // [rsp+A0h] [rbp-68h]
  int v26; // [rsp+A4h] [rbp-64h]
  __int64 v27; // [rsp+A8h] [rbp-60h]
  void **v28; // [rsp+B8h] [rbp-50h] BYREF
  __m128i Block; // [rsp+C0h] [rbp-48h]
  unsigned __int64 v30; // [rsp+D0h] [rbp-38h]
  char v31[512]; // [rsp+D8h] [rbp-30h] BYREF

  v27 = -2i64;
  v6 = a3;
  v19[0] = 0;
  v20 = *(__m128i *)sub_14615B550((__int64)&v21, a4, (__int64)v19);
  v9 = _mm_cvtsi128_si32(_mm_srli_si128(v20, 8)) & 0xFFFFFF00 | (unsigned __int8)((int)(*(_DWORD *)(a4 + 12) << 25) >> 29);
  v20.m128i_i32[2] = v9;
  if ( ldsign(a3) )
  {
    v9 = v9 & 0xFFFFFF00 | 1;
    v6 = -a3;
  }
  else
  {
    if ( (_BYTE)v9 != 1 )
      goto LABEL_6;
    v9 &= 0xFFFFFF00;
  }
  v20.m128i_i32[2] = v9;
LABEL_6:
  if ( ldclass(v6) > 0 )
  {
    *(_OWORD *)v23 = *(_OWORD *)a4;
    *(_QWORD *)&v23[16] = *(_QWORD *)(a4 + 16);
    if ( fabs(v6) >= INFINITY )
    {
      v10 = "INF";
      v11 = "inf";
    }
    else
    {
      v10 = "NAN";
      v11 = "nan";
    }
    if ( (v20.m128i_i8[12] & 1) != 0 )
      v11 = v10;
    if ( v23[21] == 1 )
    {
      v12 = v23[17];
      if ( v23[17] == 48 )
        v12 = 32;
      v23[17] = v12;
    }
    v21.m128i_i32[0] = (char)v9;
    v21.m128i_i64[1] = (__int64)v11;
    v22 = 3i64;
    sub_146160020(a1, a2, v23, ((_BYTE)v9 != 0) + 3i64, ((_BYTE)v9 != 0) + 3i64, (char **)&v21);
    return a1;
  }
  if ( (*(_DWORD *)(a4 + 12) & 0xF) == 4 )
  {
    if ( !(_BYTE)v9 )
      goto LABEL_24;
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = byte_14611CFAC[(char)v9];
    v20.m128i_i32[2] = v9 & 0xFFFFFF00;
    if ( *(_DWORD *)a4 )
      --*(_DWORD *)a4;
  }
  LOBYTE(v9) = v20.m128i_i8[8];
LABEL_24:
  Block.m128i_i64[1] = 0i64;
  v28 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  Block.m128i_i64[0] = (__int64)v31;
  v30 = 500i64;
  if ( v20.m128i_i8[4] == 3 )
  {
    if ( (_BYTE)v9 )
    {
      v31[0] = byte_14611CFAC[(char)v9];
      Block.m128i_i64[1] = 1i64;
    }
    v21 = v20;
    sub_146199FE0(v6, *(_DWORD *)(a4 + 4), (__int64)&v21, (__int64)&v28);
    v20 = Block;
    sub_146160900(a1, a2, (char *)a4, Block.m128i_i64[1], Block.m128i_u64[1], (__int64)&v20);
    v28 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
    v13 = (void *)Block.m128i_i64[0];
    if ( (char *)Block.m128i_i64[0] != v31 )
    {
      if ( v30 >= 0x1000 )
      {
        v13 = *(void **)(Block.m128i_i64[0] - 8);
        if ( (unsigned __int64)(Block.m128i_i64[0] - (_QWORD)v13 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
LABEL_45:
      j_j_free(v13);
    }
  }
  else
  {
    v14 = *(_DWORD *)(a4 + 4);
    if ( v14 < 0 && *(_BYTE *)(a4 + 8) )
      v14 = 6;
    if ( v20.m128i_i8[4] == 1 )
    {
      if ( v14 == 0x7FFFFFFF )
      {
        *(_QWORD *)v23 = &std::exception::`vftable';
        *(_OWORD *)&v23[8] = 0i64;
        v21.m128i_i64[0] = (__int64)"number is too big";
        v21.m128i_i8[8] = 1;
        _std_exception_copy(&v21);
        *(_QWORD *)v23 = &fmt::v8::format_error::`vftable';
        sub_14615AB90((__int64)v23);
      }
      ++v14;
    }
    v20.m128i_i8[12] |= 8u;
    v15 = v20.m128i_i8[12];
    v21 = v20;
    v16 = sub_1461982F0(v6, v14, (__int64)&v21, &v28);
    v20.m128i_i32[0] = v14;
    if ( (v15 & 2) != 0 )
      v17 = sub_146196700(a5);
    else
      v17 = 46;
    v24 = Block.m128i_i64[0];
    v25 = Block.m128i_i32[2];
    v26 = v16;
    v21 = v20;
    sub_14615EBF0(a1, a2, (__int64)&v24, (char *)a4, (__int64)&v21, v17);
    v28 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
    v13 = (void *)Block.m128i_i64[0];
    if ( (char *)Block.m128i_i64[0] != v31 )
    {
      if ( v30 >= 0x1000 )
      {
        v13 = *(void **)(Block.m128i_i64[0] - 8);
        if ( (unsigned __int64)(Block.m128i_i64[0] - (_QWORD)v13 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      goto LABEL_45;
    }
  }
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 14615E4D0: using guessed type char anonymous_0[8];

//----- (000000014615E950) ----------------------------------------------------
_QWORD *__fastcall sub_14615E950(_QWORD *a1, __int64 a2, __int64 a3, char *a4)
{
  char v4; // al
  unsigned __int64 v6; // rax
  int v7; // edi
  __int64 v9; // [rsp+30h] [rbp-28h] BYREF
  int v10; // [rsp+38h] [rbp-20h]
  __int64 v11; // [rsp+60h] [rbp+8h] BYREF

  v4 = a4[8];
  if ( v4 && v4 != 112 )
    sub_14619FE20((__int64)&v11, (__int64)"invalid type specifier");
  v6 = a3;
  v7 = 0;
  do
  {
    ++v7;
    v6 >>= 4;
  }
  while ( v6 );
  if ( v7 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v9 = a3;
  v10 = v7;
  sub_146160CD0(&v11, a2, a4, (unsigned int)v7 + 2i64, (unsigned int)v7 + 2i64, (__int64)&v9);
  *a1 = v11;
  return a1;
}

//----- (000000014615EA10) ----------------------------------------------------
__int64 *__fastcall sub_14615EA10(__int64 *a1, __int64 a2, char a3, char *a4)
{
  char v6; // [rsp+50h] [rbp+18h] BYREF

  v6 = a3;
  sub_1461601E0(a1, a2, a4, 1i64, 1ui64, &v6);
  return a1;
}

//----- (000000014615EA50) ----------------------------------------------------
_QWORD *__fastcall sub_14615EA50(_QWORD *a1, int a2, __int64 a3)
{
  int v4; // edi
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rdx
  __int64 v8; // rcx
  char *v9; // r15
  char *v10; // rdi
  char v11; // al
  __int64 v12; // rcx
  __int64 v13; // rdx
  _QWORD *result; // rax

  v4 = a2;
  if ( (unsigned int)(a2 + 9999) > 0x4E1E )
    sub_14619F290(
      "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\format.h",
      0x4CEu,
      "exponent out of range");
  v6 = *(_QWORD *)(a3 + 24);
  v7 = *(_QWORD *)(a3 + 16) + 1i64;
  if ( v4 >= 0 )
  {
    if ( v7 > v6 )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_BYTE *)(*(_QWORD *)(a3 + 8) + (*(_QWORD *)(a3 + 16))++) = 43;
  }
  else
  {
    if ( v7 > v6 )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_BYTE *)(*(_QWORD *)(a3 + 8) + (*(_QWORD *)(a3 + 16))++) = 45;
    v4 = -v4;
  }
  v8 = *(_QWORD *)(a3 + 16);
  if ( v4 >= 100 )
  {
    v9 = &a00010203040506[2 * (v4 / 100)];
    if ( v4 >= 1000 )
    {
      if ( (unsigned __int64)(v8 + 1) > *(_QWORD *)(a3 + 24) )
        (**(void (__fastcall ***)(__int64))a3)(a3);
      *(_BYTE *)(*(_QWORD *)(a3 + 8) + (*(_QWORD *)(a3 + 16))++) = *v9;
      v8 = *(_QWORD *)(a3 + 16);
    }
    if ( (unsigned __int64)(v8 + 1) > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_BYTE *)(*(_QWORD *)(a3 + 8) + (*(_QWORD *)(a3 + 16))++) = v9[1];
    v8 = *(_QWORD *)(a3 + 16);
    v4 %= 100;
  }
  v10 = &a00010203040506[2 * v4];
  if ( (unsigned __int64)(v8 + 1) > *(_QWORD *)(a3 + 24) )
    (**(void (__fastcall ***)(__int64))a3)(a3);
  *(_BYTE *)(*(_QWORD *)(a3 + 16) + *(_QWORD *)(a3 + 8)) = *v10;
  if ( (unsigned __int64)(++*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
    (**(void (__fastcall ***)(__int64))a3)(a3);
  v11 = v10[1];
  v12 = *(_QWORD *)(a3 + 16);
  v13 = *(_QWORD *)(a3 + 8);
  *a1 = a3;
  *(_BYTE *)(v13 + v12) = v11;
  result = a1;
  ++*(_QWORD *)(a3 + 16);
  return result;
}

//----- (000000014615EBF0) ----------------------------------------------------
__int64 *__fastcall sub_14615EBF0(__int64 *a1, __int64 a2, __int64 a3, char *a4, __int64 a5, char a6)
{
  int v6; // r15d
  int v8; // edx
  __int64 v9; // rax
  int v11; // r10d
  __int64 v12; // r8
  __int64 v13; // rdi
  int v14; // ecx
  __int64 v15; // r15
  int v16; // r12d
  __int64 v17; // rax
  int v18; // eax
  unsigned __int64 v19; // r15
  int v20; // esi
  bool v21; // zf
  int v22; // ecx
  int v23; // r12d
  int v24; // eax
  char v25; // cl
  int v26; // esi
  char v27; // r9
  __int64 v28; // r8
  int v29; // eax
  unsigned __int64 v30; // r8
  bool v31; // cc
  __int64 v32; // rax
  char v34; // [rsp+30h] [rbp-59h] BYREF
  int v35; // [rsp+34h] [rbp-55h] BYREF
  int v36; // [rsp+38h] [rbp-51h] BYREF
  int v37; // [rsp+3Ch] [rbp-4Dh] BYREF
  int v38; // [rsp+40h] [rbp-49h] BYREF
  char *v39; // [rsp+48h] [rbp-41h] BYREF
  __int64 *v40; // [rsp+50h] [rbp-39h] BYREF
  int *v41; // [rsp+58h] [rbp-31h] BYREF
  __int64 *v42; // [rsp+60h] [rbp-29h]
  int *v43; // [rsp+68h] [rbp-21h]
  int *v44; // [rsp+70h] [rbp-19h]
  __int64 *v45; // [rsp+78h] [rbp-11h]
  int *v46; // [rsp+80h] [rbp-9h]
  int *v47; // [rsp+88h] [rbp-1h]
  int v48; // [rsp+90h] [rbp+7h] BYREF
  int *v49; // [rsp+98h] [rbp+Fh] BYREF

  v6 = *(_DWORD *)(a3 + 8);
  v8 = v6;
  v9 = *(_QWORD *)a3;
  v39 = a4;
  v49 = (int *)a3;
  v11 = *(char *)(a5 + 8);
  v36 = v11;
  v40 = (__int64 *)v9;
  v35 = v6;
  if ( v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v12 = *(unsigned int *)(a3 + 12);
  v13 = 0i64;
  v14 = v12 + v6;
  v15 = (unsigned int)(v11 != 0) + v6;
  v16 = v12 + v8 - 1;
  v17 = HIDWORD(*(_QWORD *)a5);
  if ( (_BYTE)v17 == 1 )
    goto LABEL_35;
  if ( !(_BYTE)v17 )
  {
    if ( v16 < -4 )
      goto LABEL_35;
    v18 = 16;
    if ( (int)*(_QWORD *)a5 > 0 )
      v18 = *(_QWORD *)a5;
    if ( v16 >= v18 )
    {
LABEL_35:
      v25 = *(_BYTE *)(a5 + 12);
      v26 = 0;
      if ( (v25 & 0x10) != 0 )
      {
        if ( *(_DWORD *)a5 - v8 >= 0 )
          v26 = *(_DWORD *)a5 - v8;
        if ( v26 < 0 )
          sub_14619F290(
            "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h",
            0x19Eu,
            "negative value");
        v15 += (unsigned int)v26;
      }
      else if ( v8 == 1 )
      {
        v27 = 0;
        a6 = 0;
        goto LABEL_42;
      }
      v27 = a6;
LABEL_42:
      v28 = 2i64;
      v29 = -v16;
      if ( v16 > 0 )
        v29 = v16;
      if ( v29 >= 100 )
        v28 = (v29 >= 1000) + 3i64;
      v42 = v40;
      LOBYTE(v13) = v27 != 0;
      LODWORD(v41) = v11;
      LODWORD(v43) = v8;
      BYTE4(v43) = v27;
      BYTE4(v44) = ~(32 * v25) & 0x20 | 0x45;
      v30 = v15 + v13 + 2 + v28;
      LODWORD(v44) = v26;
      v31 = *(_DWORD *)v39 <= 0;
      LODWORD(v45) = v16;
      if ( v31 )
      {
        v32 = *sub_146162960((int *)&v41, &v39, a2);
      }
      else
      {
        sub_146160760((__int64 *)&v49, a2, v39, v30, v30, (int *)&v41);
        v32 = (__int64)v49;
      }
      *a1 = v32;
      return a1;
    }
  }
  v48 = v14;
  if ( (int)v12 >= 0 )
  {
    v19 = v12 + v15;
    v20 = *(_DWORD *)a5 - v14;
    v21 = (*(_BYTE *)(a5 + 12) & 0x10) == 0;
    v37 = v20;
    if ( !v21 )
    {
      if ( v20 > 0 )
      {
LABEL_14:
        v19 += (unsigned int)sub_14615B9F0(v20) + 1;
        goto LABEL_15;
      }
      if ( *(_BYTE *)(a5 + 4) != 2 )
      {
        v20 = 1;
        v37 = 1;
        goto LABEL_14;
      }
    }
LABEL_15:
    v41 = &v36;
    v45 = (__int64 *)a5;
    v42 = (__int64 *)&v40;
    v43 = &v35;
    v44 = v49;
    v46 = (int *)&a6;
    v47 = &v37;
    sub_146161AB0(a1, a2, v39, v19, v19, &v41);
    return a1;
  }
  if ( v14 <= 0 )
  {
    v22 = -v14;
    v38 = v22;
    v23 = v22;
    if ( !v8 )
    {
      v24 = *(_DWORD *)a5;
      if ( *(int *)a5 >= 0 && v24 < v22 )
      {
        v38 = *(_DWORD *)a5;
        v23 = v24;
      }
    }
    if ( v23 || v8 || (*(_BYTE *)(a5 + 12) & 0x10) != 0 )
    {
      v34 = 1;
      LODWORD(v13) = 1;
      if ( v23 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
    }
    else
    {
      v34 = 0;
    }
    v41 = &v36;
    v42 = (__int64 *)&v34;
    v43 = (int *)&a6;
    v44 = &v38;
    v45 = (__int64 *)&v40;
    v46 = &v35;
    sub_1461616E0(a1, a2, v39, v15 + (unsigned int)(v23 + v13 + 1), v15 + (unsigned int)(v23 + v13 + 1), &v41);
  }
  else
  {
    if ( (*(_BYTE *)(a5 + 12) & 0x10) != 0 )
    {
      v21 = *(_DWORD *)a5 == v8;
      v37 = *(_DWORD *)a5 - v8;
      if ( v37 >= 0 && !v21 )
        LODWORD(v13) = v37;
      if ( (int)v13 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
    }
    else
    {
      v37 = 0;
    }
    v41 = &v36;
    v42 = (__int64 *)&v40;
    v43 = &v35;
    v44 = &v48;
    v45 = (__int64 *)&a6;
    v46 = &v37;
    sub_1461610F0(a1, a2, v39, v15 + (unsigned int)(v13 + 1), v15 + (unsigned int)(v13 + 1), &v41);
  }
  return a1;
}

//----- (000000014615EFB0) ----------------------------------------------------
__int64 *__fastcall sub_14615EFB0(__int64 *a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5)
{
  unsigned int v6; // edi
  __int64 v7; // rbx
  unsigned __int64 v9; // rsi
  int v10; // edx
  unsigned __int64 v11; // rax
  unsigned int v12; // ecx
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rdi
  unsigned int i; // esi
  int v16; // eax
  bool v17; // r13
  int v18; // eax
  int v19; // r12d
  unsigned int k; // esi
  unsigned int v22; // edx
  unsigned int v23; // eax
  unsigned int v24; // r13d
  int v25; // r13d
  unsigned int j; // esi
  int v27; // ecx
  int v28; // r13d
  int v29; // eax
  unsigned int m; // esi
  __int128 pExceptionObject; // [rsp+38h] [rbp-48h] BYREF
  void **v32; // [rsp+50h] [rbp-30h] BYREF
  __int128 v33; // [rsp+58h] [rbp-28h]
  unsigned __int64 v34; // [rsp+68h] [rbp-18h]
  bool v35; // [rsp+70h] [rbp-10h]
  __int16 v36; // [rsp+71h] [rbp-Fh]
  char v37; // [rsp+73h] [rbp-Dh]
  __int64 v38; // [rsp+C8h] [rbp+48h] BYREF
  unsigned __int64 v39; // [rsp+D0h] [rbp+50h] BYREF
  __int64 v40; // [rsp+D8h] [rbp+58h] BYREF

  v38 = a2;
  v6 = a3;
  v7 = a2;
  v9 = HIDWORD(a3);
  v10 = *(char *)(a4 + 8);
  switch ( *(_BYTE *)(a4 + 8) )
  {
    case 0:
    case 0x64:
      if ( (*(_BYTE *)(a4 + 16) & 2) == 0 )
        goto LABEL_6;
      if ( (unsigned __int8)sub_14615FBB0(&v38, (unsigned int)a3, SHIDWORD(a3), a4, a5) )
      {
        v11 = v38;
        goto LABEL_32;
      }
      v7 = v38;
LABEL_6:
      LODWORD(v39) = 0;
      _BitScanReverse(&v12, v6 | 1);
      v13 = ((unsigned __int64)v6 + qword_14611CFD0[v12]) >> 32;
      v39 = __PAIR64__(v13, v6);
      v14 = __PAIR64__(v13, v6);
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)&pExceptionObject, v13, v9, (unsigned int *)a4);
        LODWORD(v32) = v9;
        v33 = pExceptionObject;
        v34 = v14;
        sub_146161290(a1, v7, (char *)a4, pExceptionObject, pExceptionObject, &v32);
      }
      else
      {
        if ( (v13 & 0x80000000) != 0i64 )
          sub_14619F290(
            "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h",
            0x19Eu,
            "negative value");
        if ( (_DWORD)v9 )
        {
          for ( i = v9 & 0xFFFFFF; i; i >>= 8 )
          {
            if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
              (**(void (__fastcall ***)(__int64))v7)(v7);
            *(_BYTE *)(*(_QWORD *)(v7 + 16) + *(_QWORD *)(v7 + 8)) = i;
            ++*(_QWORD *)(v7 + 16);
          }
        }
        *a1 = *sub_146163240((unsigned int *)&v39, &v40, v7);
      }
      return a1;
    case 0x42:
    case 0x62:
      if ( (*(_BYTE *)(a4 + 16) & 1) != 0 )
      {
        v22 = (v10 << 8) | 0x30;
        v23 = v22 << 8;
        if ( !HIDWORD(a3) )
          v23 = v22;
        LODWORD(a3) = 0x1000000;
        if ( v22 > 0xFF )
          LODWORD(a3) = 0x2000000;
        LODWORD(v9) = a3 + (v23 | HIDWORD(a3));
      }
      LODWORD(v39) = 0;
      _BitScanReverse(&v24, v6 | 1);
      v25 = v24 + 1;
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)&pExceptionObject, v25, v9, (unsigned int *)a4);
        LODWORD(v32) = v9;
        v33 = pExceptionObject;
        v34 = v6 | ((unsigned __int64)(unsigned int)v25 << 32);
        sub_1461614B0(a1, v7, (char *)a4, pExceptionObject, pExceptionObject, &v32);
        return a1;
      }
      if ( v25 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( (_DWORD)v9 )
      {
        for ( j = v9 & 0xFFFFFF; j; j >>= 8 )
        {
          if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
            (**(void (__fastcall ***)(__int64))v7)(v7);
          *(_BYTE *)(*(_QWORD *)(v7 + 16) + *(_QWORD *)(v7 + 8)) = j;
          ++*(_QWORD *)(v7 + 16);
        }
      }
      sub_14615ACB0(&v39, v7, v6, v25);
      goto LABEL_31;
    case 0x58:
    case 0x78:
      if ( (*(_BYTE *)(a4 + 16) & 1) != 0 )
      {
        v16 = ((v10 << 8) | 0x30) << 8;
        if ( !HIDWORD(a3) )
          v16 = (v10 << 8) | 0x30;
        LODWORD(a3) = 0x1000000;
        if ( ((v10 << 8) | 0x30u) > 0xFF )
          LODWORD(a3) = 0x2000000;
        LODWORD(v9) = a3 + (v16 | HIDWORD(a3));
      }
      v17 = v10 != 120;
      LODWORD(v39) = 0;
      _BitScanReverse((unsigned int *)&v18, v6 | 1);
      v19 = v18 / 4 + 1;
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)&pExceptionObject, v19, v9, (unsigned int *)a4);
        LODWORD(v32) = v9;
        v33 = pExceptionObject;
        v34 = __PAIR64__(v19, v6);
        v35 = v17;
        v36 = *(_WORD *)((char *)&pExceptionObject + 9);
        v37 = BYTE11(pExceptionObject);
        sub_146161E70(a1, v7, (char *)a4, pExceptionObject, pExceptionObject, &v32);
        return a1;
      }
      if ( v19 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( (_DWORD)v9 )
      {
        for ( k = v9 & 0xFFFFFF; k; k >>= 8 )
        {
          if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
            (**(void (__fastcall ***)(__int64))v7)(v7);
          *(_BYTE *)(*(_QWORD *)(v7 + 16) + *(_QWORD *)(v7 + 8)) = k;
          ++*(_QWORD *)(v7 + 16);
        }
      }
      sub_14615B230(&v39, v7, v6, v19, v17);
      goto LABEL_31;
    case 0x63:
      sub_14615EA10(a1, v7, a3, (char *)a4);
      return a1;
    case 0x6F:
      LODWORD(v39) = 0;
      _BitScanReverse((unsigned int *)&v27, a3 | 1);
      v28 = ((unsigned __int64)(1431655766i64 * v27) >> 32)
          + ((unsigned int)((unsigned __int64)(1431655766i64 * v27) >> 32) >> 31)
          + 1;
      if ( (*(_BYTE *)(a4 + 16) & 1) != 0 && *(_DWORD *)(a4 + 4) <= v28 && (_DWORD)a3 )
      {
        v29 = 12288;
        if ( !HIDWORD(a3) )
          v29 = 48;
        LODWORD(v9) = (v29 | HIDWORD(a3)) + 0x1000000;
      }
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)&pExceptionObject, v28, v9, (unsigned int *)a4);
        LODWORD(v32) = v9;
        v33 = pExceptionObject;
        v34 = v6 | ((unsigned __int64)(unsigned int)v28 << 32);
        sub_146160EC0(a1, v7, (char *)a4, pExceptionObject, pExceptionObject, &v32);
      }
      else
      {
        if ( v28 < 0 )
          sub_14619F290(
            "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h",
            0x19Eu,
            "negative value");
        if ( (_DWORD)v9 )
        {
          for ( m = v9 & 0xFFFFFF; m; m >>= 8 )
          {
            if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
              (**(void (__fastcall ***)(__int64))v7)(v7);
            *(_BYTE *)(*(_QWORD *)(v7 + 16) + *(_QWORD *)(v7 + 8)) = m;
            ++*(_QWORD *)(v7 + 16);
          }
        }
        sub_14615AF70(&v39, v7, v6, v28);
LABEL_31:
        v11 = v39;
LABEL_32:
        *a1 = v11;
      }
      return a1;
    default:
      v32 = &std::exception::`vftable';
      v33 = 0i64;
      *(_QWORD *)&pExceptionObject = "invalid type specifier";
      BYTE8(pExceptionObject) = 1;
      _std_exception_copy(&pExceptionObject);
      v32 = &fmt::v8::format_error::`vftable';
      LOBYTE(v39) = 1;
      sub_146162440((__int64)&pExceptionObject, (__int64)&v32);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 14611CFD0: using guessed type __int64 qword_14611CFD0[32];
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014615F5D0) ----------------------------------------------------
__int64 *__fastcall sub_14615F5D0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // rbx
  unsigned __int64 v8; // r12
  int v9; // edi
  int v10; // r8d
  __int64 v11; // rax
  int v12; // eax
  __int128 v13; // xmm6
  unsigned int i; // edi
  int v15; // eax
  int v16; // eax
  int v17; // edi
  bool v18; // r13
  unsigned __int64 v19; // rax
  int v20; // esi
  unsigned int k; // edi
  unsigned int v23; // r8d
  unsigned int v24; // eax
  int v25; // eax
  int v26; // edi
  unsigned __int64 v27; // rax
  int v28; // esi
  unsigned int j; // edi
  unsigned __int64 v30; // rax
  int v31; // esi
  int v32; // eax
  unsigned int m; // edi
  __int128 pExceptionObject[2]; // [rsp+48h] [rbp-41h] BYREF
  void **v35; // [rsp+68h] [rbp-21h] BYREF
  __int128 v36; // [rsp+70h] [rbp-19h]
  __int128 v37; // [rsp+80h] [rbp-9h]
  __int64 v38; // [rsp+F0h] [rbp+67h] BYREF
  __int64 v39; // [rsp+F8h] [rbp+6Fh] BYREF

  v38 = a2;
  v6 = a2;
  v8 = *(_QWORD *)a3;
  v9 = *(_DWORD *)(a3 + 8);
  v10 = *(char *)(a4 + 8);
  switch ( *(_BYTE *)(a4 + 8) )
  {
    case 0:
    case 0x64:
      if ( (*(_BYTE *)(a4 + 16) & 2) == 0 )
        goto LABEL_6;
      if ( (unsigned __int8)sub_14615FBB0(&v38, v8, v9, a4, a5) )
      {
        v11 = v38;
        goto LABEL_34;
      }
      v6 = v38;
LABEL_6:
      v12 = sub_146165560(v8);
      *(_QWORD *)&pExceptionObject[0] = v8;
      DWORD2(pExceptionObject[0]) = v12;
      v13 = pExceptionObject[0];
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)pExceptionObject, v12, v9, (unsigned int *)a4);
        LODWORD(v35) = v9;
        v36 = pExceptionObject[0];
        v37 = v13;
        sub_146161C50(
          a1,
          v6,
          (char *)a4,
          *(__int64 *)&pExceptionObject[0],
          *(unsigned __int64 *)&pExceptionObject[0],
          &v35);
      }
      else
      {
        if ( v12 < 0 )
          sub_14619F290(
            "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h",
            0x19Eu,
            "negative value");
        if ( v9 )
        {
          for ( i = v9 & 0xFFFFFF; i; i >>= 8 )
          {
            if ( (unsigned __int64)(*(_QWORD *)(v6 + 16) + 1i64) > *(_QWORD *)(v6 + 24) )
              (**(void (__fastcall ***)(__int64))v6)(v6);
            *(_BYTE *)(*(_QWORD *)(v6 + 8) + (*(_QWORD *)(v6 + 16))++) = i;
          }
        }
        *a1 = *sub_1461630C0((__int64)pExceptionObject, &v39, v6);
      }
      return a1;
    case 0x42:
    case 0x62:
      if ( (*(_BYTE *)(a4 + 16) & 1) != 0 )
      {
        v23 = (v10 << 8) | 0x30;
        v24 = v23 << 8;
        if ( !v9 )
          v24 = v23;
        v25 = v9 | v24;
        v26 = 0x1000000;
        if ( v23 > 0xFF )
          v26 = 0x2000000;
        v9 = v25 + v26;
      }
      v27 = v8;
      v28 = 0;
      do
      {
        ++v28;
        v27 >>= 1;
      }
      while ( v27 );
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)pExceptionObject, v28, v9, (unsigned int *)a4);
        LODWORD(v35) = v9;
        v36 = pExceptionObject[0];
        *(_QWORD *)&v37 = v8;
        *((_QWORD *)&v37 + 1) = __PAIR64__(HIDWORD(pExceptionObject[0]), v28);
        sub_146160AA0(
          a1,
          v6,
          (char *)a4,
          *(__int64 *)&pExceptionObject[0],
          *(unsigned __int64 *)&pExceptionObject[0],
          &v35);
        return a1;
      }
      if ( v28 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( v9 )
      {
        for ( j = v9 & 0xFFFFFF; j; j >>= 8 )
        {
          if ( (unsigned __int64)(*(_QWORD *)(v6 + 16) + 1i64) > *(_QWORD *)(v6 + 24) )
            (**(void (__fastcall ***)(__int64))v6)(v6);
          *(_BYTE *)(*(_QWORD *)(v6 + 8) + (*(_QWORD *)(v6 + 16))++) = j;
        }
      }
      sub_14615AE10(&v39, v6, v8, v28);
      goto LABEL_33;
    case 0x58:
    case 0x78:
      if ( (*(_BYTE *)(a4 + 16) & 1) != 0 )
      {
        v15 = ((v10 << 8) | 0x30) << 8;
        if ( !v9 )
          v15 = (v10 << 8) | 0x30;
        v16 = v9 | v15;
        v17 = 0x1000000;
        if ( ((v10 << 8) | 0x30u) > 0xFF )
          v17 = 0x2000000;
        v9 = v16 + v17;
      }
      v18 = v10 != 120;
      v19 = v8;
      v20 = 0;
      do
      {
        ++v20;
        v19 >>= 4;
      }
      while ( v19 );
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)pExceptionObject, v20, v9, (unsigned int *)a4);
        LODWORD(v35) = v9;
        v36 = pExceptionObject[0];
        *(_QWORD *)&v37 = v8;
        DWORD2(v37) = v20;
        BYTE12(v37) = v18;
        *(_WORD *)((char *)&v37 + 13) = *(_WORD *)((char *)pExceptionObject + 13);
        HIBYTE(v37) = HIBYTE(pExceptionObject[0]);
        sub_146161880(
          a1,
          v6,
          (char *)a4,
          *(__int64 *)&pExceptionObject[0],
          *(unsigned __int64 *)&pExceptionObject[0],
          &v35);
        return a1;
      }
      if ( v20 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( v9 )
      {
        for ( k = v9 & 0xFFFFFF; k; k >>= 8 )
        {
          if ( (unsigned __int64)(*(_QWORD *)(v6 + 16) + 1i64) > *(_QWORD *)(v6 + 24) )
            (**(void (__fastcall ***)(__int64))v6)(v6);
          *(_BYTE *)(*(_QWORD *)(v6 + 8) + (*(_QWORD *)(v6 + 16))++) = k;
        }
      }
      sub_14615B3C0(&v39, v6, v8, v20, v18);
      goto LABEL_33;
    case 0x63:
      sub_14615EA10(a1, a2, v8, (char *)a4);
      return a1;
    case 0x6F:
      v30 = v8;
      v31 = 0;
      do
      {
        ++v31;
        v30 >>= 3;
      }
      while ( v30 );
      if ( (*(_BYTE *)(a4 + 16) & 1) != 0 && *(_DWORD *)(a4 + 4) <= v31 && v8 )
      {
        v32 = 12288;
        if ( !v9 )
          v32 = 48;
        v9 = (v9 | v32) + 0x1000000;
      }
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)pExceptionObject, v31, v9, (unsigned int *)a4);
        LODWORD(v35) = v9;
        v36 = pExceptionObject[0];
        *(_QWORD *)&v37 = v8;
        *((_QWORD *)&v37 + 1) = __PAIR64__(HIDWORD(pExceptionObject[0]), v31);
        sub_146160530(
          a1,
          v6,
          (char *)a4,
          *(__int64 *)&pExceptionObject[0],
          *(unsigned __int64 *)&pExceptionObject[0],
          &v35);
      }
      else
      {
        if ( v31 < 0 )
          sub_14619F290(
            "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h",
            0x19Eu,
            "negative value");
        if ( v9 )
        {
          for ( m = v9 & 0xFFFFFF; m; m >>= 8 )
          {
            if ( (unsigned __int64)(*(_QWORD *)(v6 + 16) + 1i64) > *(_QWORD *)(v6 + 24) )
              (**(void (__fastcall ***)(__int64))v6)(v6);
            *(_BYTE *)(*(_QWORD *)(v6 + 8) + (*(_QWORD *)(v6 + 16))++) = m;
          }
        }
        sub_14615B0D0(&v39, v6, v8, v31);
LABEL_33:
        v11 = v39;
LABEL_34:
        *a1 = v11;
      }
      return a1;
    default:
      v35 = &std::exception::`vftable';
      v36 = 0i64;
      *(_QWORD *)&pExceptionObject[0] = "invalid type specifier";
      BYTE8(pExceptionObject[0]) = 1;
      _std_exception_copy(pExceptionObject);
      v35 = &fmt::v8::format_error::`vftable';
      LOBYTE(v39) = 1;
      sub_146162440((__int64)pExceptionObject, (__int64)&v35);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014615FBB0) ----------------------------------------------------
__int64 __fastcall sub_14615FBB0(__int64 *a1, unsigned __int64 a2, int a3, __int64 a4, __int64 a5)
{
  char *v5; // r15
  unsigned __int64 v9; // rsi
  void **v10; // r14
  __int64 v11; // rdi
  unsigned __int8 v12; // bl
  signed int v13; // eax
  __int64 v14; // rsi
  unsigned int v15; // edi
  signed int v16; // edx
  __int128 *v17; // rcx
  __int128 *v18; // rax
  int v19; // eax
  __int128 *v20; // rax
  __int128 *v21; // rax
  char *i; // r8
  unsigned int v23; // r14d
  int v24; // r11d
  __int128 *v25; // rbx
  _BYTE *v26; // r10
  __int64 v27; // r8
  char *v28; // rbx
  char *v29; // rsi
  int v30; // r9d
  int v31; // r15d
  __int128 *v32; // rcx
  char *v33; // rdx
  _BYTE *v34; // rcx
  char *v36; // [rsp+30h] [rbp-D0h] BYREF
  void *v37; // [rsp+40h] [rbp-C0h] BYREF
  unsigned int v38; // [rsp+48h] [rbp-B8h]
  __int64 v39; // [rsp+50h] [rbp-B0h]
  __int128 v40; // [rsp+58h] [rbp-A8h] BYREF
  __int128 v41; // [rsp+68h] [rbp-98h]
  char v42; // [rsp+78h] [rbp-88h]
  void *Src[2]; // [rsp+80h] [rbp-80h] BYREF
  unsigned __int64 v44; // [rsp+90h] [rbp-70h]
  unsigned __int64 v45; // [rsp+98h] [rbp-68h]
  char v46; // [rsp+A0h] [rbp-60h]
  void **v47; // [rsp+B0h] [rbp-50h] BYREF
  void *Block; // [rsp+B8h] [rbp-48h]
  unsigned __int64 v49; // [rsp+C0h] [rbp-40h]
  unsigned __int64 v50; // [rsp+C8h] [rbp-38h]
  char v51[512]; // [rsp+D0h] [rbp-30h] BYREF
  char v52[40]; // [rsp+2D0h] [rbp+1D0h] BYREF

  v39 = -2i64;
  v5 = (char *)a4;
  v36 = (char *)a4;
  sub_14619A260((__int64)Src, a5);
  v40 = 0i64;
  v41 = 0i64;
  v9 = v44;
  v10 = Src;
  if ( v45 > 0xF )
    v10 = (void **)Src[0];
  v11 = 0x7FFFFFFFFFFFFFFFi64;
  if ( v44 > 0x7FFFFFFFFFFFFFFFi64 )
    unknown_libname_4();
  if ( v44 > 0xF )
  {
    if ( (v44 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      v11 = v44 | 0xF;
      if ( (v44 | 0xF) < 0x16 )
        v11 = 22i64;
    }
    *(_QWORD *)&v40 = sub_14615A5E0(v11 + 1);
    *(_QWORD *)&v41 = v9;
    *((_QWORD *)&v41 + 1) = v11;
    memcpy((void *)v40, v10, v9 + 1);
  }
  else
  {
    *(_QWORD *)&v41 = v44;
    *((_QWORD *)&v41 + 1) = 15i64;
    v40 = *(_OWORD *)v10;
  }
  v42 = v46;
  sub_1461626B0((__int64)Src);
  if ( v42 )
  {
    v13 = sub_146165560(a2);
    v14 = v13;
    v15 = v13;
    v16 = v13;
    v17 = &v40;
    if ( *((_QWORD *)&v41 + 1) > 0xFui64 )
      v17 = (__int128 *)v40;
    while ( 1 )
    {
      v18 = &v40;
      if ( *((_QWORD *)&v41 + 1) > 0xFui64 )
        v18 = (__int128 *)v40;
      if ( v17 == (__int128 *)((char *)v18 + v41) )
        break;
      v19 = *(char *)v17;
      if ( v16 <= v19 || (unsigned __int8)(v19 - 1) > 0x7Du )
        break;
      ++v15;
      v16 -= v19;
      v17 = (__int128 *)((char *)v17 + 1);
    }
    v20 = &v40;
    if ( *((_QWORD *)&v41 + 1) > 0xFui64 )
      v20 = (__int128 *)v40;
    if ( v17 == (__int128 *)((char *)v20 + v41) )
    {
      v21 = &v40;
      if ( *((_QWORD *)&v41 + 1) > 0xFui64 )
        v21 = (__int128 *)v40;
      v15 += (v16 - 1) / *((char *)v21 + v41 - 1);
    }
    if ( (int)v14 < (int)sub_146165560(a2) )
      sub_14619F290(
        "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\format.h",
        0x41Cu,
        "invalid digit count");
    for ( i = &v52[v14]; a2 >= 0x64; a2 /= 0x64ui64 )
    {
      i -= 2;
      *(_WORD *)i = *(_WORD *)&a00010203040506[2 * (a2 % 0x64)];
    }
    if ( a2 >= 0xA )
      *((_WORD *)i - 1) = *(_WORD *)&a00010203040506[2 * a2];
    else
      *(i - 1) = a2 + 48;
    v49 = 0i64;
    v47 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
    Block = v51;
    v50 = 500i64;
    v23 = v15 + 1;
    if ( !a3 )
      v23 = v15;
    if ( (v23 & 0x80000000) != 0 )
      sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
    if ( v23 <= 0x1F4ui64 )
      goto LABEL_42;
    if ( fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable' == sub_146165760 )
      sub_146165760(&v47, v23);
    else
      ((void (__fastcall *)(void ***, _QWORD, char *, const char *))fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable')(
        &v47,
        v23,
        i,
        "0001020304050607080910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455"
        "56575859606162636465666768697071727374757677787980818283848586878889909192939495969798990123456789abcdef");
    v49 = v50;
    if ( v23 <= v50 )
LABEL_42:
      v49 = v23;
    v24 = 0;
    v25 = &v40;
    if ( *((_QWORD *)&v41 + 1) > 0xFui64 )
      v25 = (__int128 *)v40;
    v26 = (char *)Block + (int)v23 - 1;
    v27 = (int)v14 - 1;
    if ( (int)v14 - 1 > 0 )
    {
      v28 = (char *)v25 + 1;
      do
      {
        v29 = v28;
        *v26-- = v52[v27];
        v30 = *(v28 - 1);
        if ( *(v28 - 1) > 0 )
        {
          v31 = ++v24;
          if ( !(v24 % v30) && (_BYTE)v30 != 127 )
          {
            v32 = &v40;
            if ( *((_QWORD *)&v41 + 1) > 0xFui64 )
              v32 = (__int128 *)v40;
            v33 = (char *)v32 + v41;
            *v26-- = v42;
            v24 = 0;
            if ( v28 == v33 )
              v24 = v31;
            ++v28;
            if ( v29 == v33 )
              v28 = v29;
          }
        }
        --v27;
      }
      while ( v27 > 0 );
      v5 = v36;
    }
    *v26 = v52[0];
    if ( a3 )
      *(v26 - 1) = a3;
    v37 = Block;
    v38 = v23;
    *a1 = *sub_1461620A0((__int64 *)&v36, *a1, v5, v23, v23, (__int64)&v37);
    v12 = 1;
    v47 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
    v34 = Block;
    if ( Block != v51 )
    {
      if ( v50 >= 0x1000 )
      {
        v34 = (_BYTE *)*((_QWORD *)Block - 1);
        if ( (unsigned __int64)((_BYTE *)Block - v34 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v34);
    }
  }
  else
  {
    v12 = 0;
  }
  sub_1461626B0((__int64)&v40);
  return v12;
}
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
// 1461653D0: using guessed type void __noreturn unknown_libname_4(void);
// 14615FBB0: using guessed type char var_60[40];

//----- (0000000146160020) ----------------------------------------------------
__int64 *__fastcall sub_146160020(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, char **a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r15
  char *v16; // rbp
  __int64 v17; // rbp
  __int64 v18; // rax
  _BYTE *v19; // rsi
  char *v20; // rbp

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC0[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  v17 = *(int *)a6;
  if ( (_DWORD)v17 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = byte_14611CFAC[v17];
  }
  sub_14615AAE0(a2, a6[1], &a6[2][(_QWORD)a6[1]]);
  if ( v13 )
  {
    v18 = (unsigned __int8)a3[21];
    v19 = a3 + 17;
    if ( v18 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v19;
        --v13;
      }
      while ( v13 );
    }
    else
    {
      v20 = &v19[v18];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v20);
        --v13;
      }
      while ( v13 );
    }
  }
  *a1 = a2;
  return a1;
}
// 14611CFC0: using guessed type _BYTE byte_14611CFC0[8];

//----- (00000001461601E0) ----------------------------------------------------
__int64 *__fastcall sub_1461601E0(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _BYTE *a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  __int64 v17; // rdx
  __int64 v18; // rax
  _BYTE *v19; // rsi
  char *v20; // rbp
  __int64 *result; // rax

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC0[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
    (**(void (__fastcall ***)(__int64))a2)(a2);
  *(_BYTE *)(*(_QWORD *)(a2 + 8) + *(_QWORD *)(a2 + 16)) = *a6;
  v17 = *(_QWORD *)(a2 + 16) + 1i64;
  *(_QWORD *)(a2 + 16) = v17;
  if ( v13 )
  {
    v18 = (unsigned __int8)a3[21];
    v19 = a3 + 17;
    if ( v18 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(v17 + 1) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v19;
        v17 = *(_QWORD *)(a2 + 16);
        --v13;
      }
      while ( v13 );
    }
    else
    {
      v20 = &v19[v18];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v20);
        --v13;
      }
      while ( v13 );
    }
  }
  result = a1;
  *a1 = a2;
  return result;
}
// 14611CFC0: using guessed type _BYTE byte_14611CFC0[8];

//----- (0000000146160390) ----------------------------------------------------
__int64 *__fastcall sub_146160390(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, __int64 a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  __int64 v17; // rax
  _BYTE *v18; // rsi
  char *v19; // rbp
  __int64 *result; // rax

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC0[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  sub_14615AAE0(a2, *(char **)a6, (char *)(*(_QWORD *)a6 + *(_QWORD *)(a6 + 8)));
  if ( v13 )
  {
    v17 = (unsigned __int8)a3[21];
    v18 = a3 + 17;
    if ( v17 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v18;
        --v13;
      }
      while ( v13 );
    }
    else
    {
      v19 = &v18[v17];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v19);
        --v13;
      }
      while ( v13 );
    }
  }
  result = a1;
  *a1 = a2;
  return result;
}
// 14611CFC0: using guessed type _BYTE byte_14611CFC0[8];

//----- (0000000146160530) ----------------------------------------------------
_QWORD *__fastcall sub_146160530(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  _DWORD *v17; // r14
  unsigned int i; // esi
  __int64 j; // rsi
  __int64 v20; // rax
  _BYTE *v21; // rsi
  __int64 v22; // rbx
  char *v23; // rbp

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  v17 = a6;
  for ( i = *a6 & 0xFFFFFF; i; i >>= 8 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = i;
  }
  for ( j = *((_QWORD *)v17 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = 48;
  }
  sub_14615B0D0(&a5, a2, *((_QWORD *)v17 + 3), v17[8]);
  if ( v13 )
  {
    v20 = (unsigned __int8)a3[21];
    v21 = a3 + 17;
    v22 = a5;
    if ( v20 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v22 + 16) + 1i64) > *(_QWORD *)(v22 + 24) )
          (**(void (__fastcall ***)(__int64))v22)(v22);
        *(_BYTE *)(*(_QWORD *)(v22 + 8) + (*(_QWORD *)(v22 + 16))++) = *v21;
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
    else
    {
      v23 = &v21[v20];
      do
      {
        sub_14615AAE0(v22, a3 + 17, v23);
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
  }
  else
  {
    *a1 = a5;
  }
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (0000000146160760) ----------------------------------------------------
__int64 *__fastcall sub_146160760(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int *a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  __int64 v17; // rbx
  __int64 v18; // rax
  _BYTE *v19; // rsi
  char *v20; // rbp
  __int64 *result; // rax

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = *v15;
        ++*(_QWORD *)(a2 + 16);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  v17 = *sub_146162960(a6, &a5, a2);
  if ( v13 )
  {
    v18 = (unsigned __int8)a3[21];
    v19 = a3 + 17;
    if ( v18 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v17 + 16) + 1i64) > *(_QWORD *)(v17 + 24) )
          (**(void (__fastcall ***)(__int64))v17)(v17);
        *(_BYTE *)(*(_QWORD *)(v17 + 8) + (*(_QWORD *)(v17 + 16))++) = *v19;
        --v13;
      }
      while ( v13 );
    }
    else
    {
      v20 = &v19[v18];
      do
      {
        sub_14615AAE0(v17, a3 + 17, v20);
        --v13;
      }
      while ( v13 );
    }
  }
  result = a1;
  *a1 = v17;
  return result;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (0000000146160900) ----------------------------------------------------
__int64 *__fastcall sub_146160900(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, __int64 a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  __int64 v17; // rax
  _BYTE *v18; // rsi
  char *v19; // rbp
  __int64 *result; // rax

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  sub_14615AAE0(a2, *(char **)a6, (char *)(*(_QWORD *)a6 + *(_QWORD *)(a6 + 8)));
  if ( v13 )
  {
    v17 = (unsigned __int8)a3[21];
    v18 = a3 + 17;
    if ( v17 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v18;
        --v13;
      }
      while ( v13 );
    }
    else
    {
      v19 = &v18[v17];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v19);
        --v13;
      }
      while ( v13 );
    }
  }
  result = a1;
  *a1 = a2;
  return result;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (0000000146160AA0) ----------------------------------------------------
_QWORD *__fastcall sub_146160AA0(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  _DWORD *v17; // r14
  unsigned int i; // esi
  __int64 j; // rsi
  __int64 v20; // rax
  _BYTE *v21; // rsi
  __int64 v22; // rbx
  char *v23; // rbp

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  v17 = a6;
  for ( i = *a6 & 0xFFFFFF; i; i >>= 8 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = i;
  }
  for ( j = *((_QWORD *)v17 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = 48;
  }
  sub_14615AE10(&a5, a2, *((_QWORD *)v17 + 3), v17[8]);
  if ( v13 )
  {
    v20 = (unsigned __int8)a3[21];
    v21 = a3 + 17;
    v22 = a5;
    if ( v20 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v22 + 16) + 1i64) > *(_QWORD *)(v22 + 24) )
          (**(void (__fastcall ***)(__int64))v22)(v22);
        *(_BYTE *)(*(_QWORD *)(v22 + 8) + (*(_QWORD *)(v22 + 16))++) = *v21;
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
    else
    {
      v23 = &v21[v20];
      do
      {
        sub_14615AAE0(v22, a3 + 17, v23);
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
  }
  else
  {
    *a1 = a5;
  }
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (0000000146160CD0) ----------------------------------------------------
_QWORD *__fastcall sub_146160CD0(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, __int64 a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  __int64 v17; // r8
  __int64 v18; // rax
  _BYTE *v19; // rsi
  __int64 v20; // rbx
  char *v21; // rbp

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
    (**(void (__fastcall ***)(__int64))a2)(a2);
  *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = 48;
  if ( (unsigned __int64)(++*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
    (**(void (__fastcall ***)(__int64))a2)(a2);
  v17 = a6;
  *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = 120;
  ++*(_QWORD *)(a2 + 16);
  sub_14615B3C0(&a5, a2, *(_QWORD *)v17, *(_DWORD *)(v17 + 8), 0);
  if ( v13 )
  {
    v18 = (unsigned __int8)a3[21];
    v19 = a3 + 17;
    v20 = a5;
    if ( v18 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v20 + 16) + 1i64) > *(_QWORD *)(v20 + 24) )
          (**(void (__fastcall ***)(__int64))v20)(v20);
        *(_BYTE *)(*(_QWORD *)(v20 + 16) + *(_QWORD *)(v20 + 8)) = *v19;
        ++*(_QWORD *)(v20 + 16);
        --v13;
      }
      while ( v13 );
      *a1 = v20;
    }
    else
    {
      v21 = &v19[v18];
      do
      {
        sub_14615AAE0(v20, a3 + 17, v21);
        --v13;
      }
      while ( v13 );
      *a1 = v20;
    }
  }
  else
  {
    *a1 = a5;
  }
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (0000000146160EC0) ----------------------------------------------------
_QWORD *__fastcall sub_146160EC0(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  _DWORD *v17; // r14
  unsigned int i; // esi
  __int64 j; // rsi
  __int64 v20; // rax
  _BYTE *v21; // rsi
  __int64 v22; // rbx
  char *v23; // rbp

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  v17 = a6;
  for ( i = *a6 & 0xFFFFFF; i; i >>= 8 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = i;
  }
  for ( j = *((_QWORD *)v17 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = 48;
  }
  sub_14615AF70(&a5, a2, v17[6], v17[7]);
  if ( v13 )
  {
    v20 = (unsigned __int8)a3[21];
    v21 = a3 + 17;
    v22 = a5;
    if ( v20 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v22 + 16) + 1i64) > *(_QWORD *)(v22 + 24) )
          (**(void (__fastcall ***)(__int64))v22)(v22);
        *(_BYTE *)(*(_QWORD *)(v22 + 8) + (*(_QWORD *)(v22 + 16))++) = *v21;
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
    else
    {
      v23 = &v21[v20];
      do
      {
        sub_14615AAE0(v22, a3 + 17, v23);
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
  }
  else
  {
    *a1 = a5;
  }
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (00000001461610F0) ----------------------------------------------------
__int64 *__fastcall sub_1461610F0(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  __int64 v17; // rbx
  __int64 v18; // rax
  _BYTE *v19; // rsi
  char *v20; // rbp
  __int64 *result; // rax

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = *v15;
        ++*(_QWORD *)(a2 + 16);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  v17 = *sub_146162BC0(a6, (__int64 *)&a5, a2);
  if ( v13 )
  {
    v18 = (unsigned __int8)a3[21];
    v19 = a3 + 17;
    if ( v18 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v17 + 16) + 1i64) > *(_QWORD *)(v17 + 24) )
          (**(void (__fastcall ***)(__int64))v17)(v17);
        *(_BYTE *)(*(_QWORD *)(v17 + 8) + (*(_QWORD *)(v17 + 16))++) = *v19;
        --v13;
      }
      while ( v13 );
    }
    else
    {
      v20 = &v19[v18];
      do
      {
        sub_14615AAE0(v17, a3 + 17, v20);
        --v13;
      }
      while ( v13 );
    }
  }
  result = a1;
  *a1 = v17;
  return result;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (0000000146161290) ----------------------------------------------------
_QWORD *__fastcall sub_146161290(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  _DWORD *v17; // r14
  unsigned int i; // esi
  __int64 j; // rsi
  __int64 v20; // rax
  _BYTE *v21; // rsi
  __int64 v22; // rbx
  char *v23; // rbp

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = *v15;
        ++*(_QWORD *)(a2 + 16);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  v17 = a6;
  for ( i = *a6 & 0xFFFFFF; i; i >>= 8 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = i;
    ++*(_QWORD *)(a2 + 16);
  }
  for ( j = *((_QWORD *)v17 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = 48;
    ++*(_QWORD *)(a2 + 16);
  }
  sub_146163240(v17 + 6, &a5, a2);
  if ( v13 )
  {
    v20 = (unsigned __int8)a3[21];
    v21 = a3 + 17;
    v22 = a5;
    if ( v20 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v22 + 16) + 1i64) > *(_QWORD *)(v22 + 24) )
          (**(void (__fastcall ***)(__int64))v22)(v22);
        *(_BYTE *)(*(_QWORD *)(v22 + 8) + (*(_QWORD *)(v22 + 16))++) = *v21;
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
    else
    {
      v23 = &v21[v20];
      do
      {
        sub_14615AAE0(v22, a3 + 17, v23);
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
  }
  else
  {
    *a1 = a5;
  }
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (00000001461614B0) ----------------------------------------------------
_QWORD *__fastcall sub_1461614B0(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  _DWORD *v17; // r14
  unsigned int i; // esi
  __int64 j; // rsi
  __int64 v20; // rax
  _BYTE *v21; // rsi
  __int64 v22; // rbx
  char *v23; // rbp

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  v17 = a6;
  for ( i = *a6 & 0xFFFFFF; i; i >>= 8 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = i;
  }
  for ( j = *((_QWORD *)v17 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = 48;
  }
  sub_14615ACB0(&a5, a2, v17[6], v17[7]);
  if ( v13 )
  {
    v20 = (unsigned __int8)a3[21];
    v21 = a3 + 17;
    v22 = a5;
    if ( v20 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v22 + 16) + 1i64) > *(_QWORD *)(v22 + 24) )
          (**(void (__fastcall ***)(__int64))v22)(v22);
        *(_BYTE *)(*(_QWORD *)(v22 + 8) + (*(_QWORD *)(v22 + 16))++) = *v21;
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
    else
    {
      v23 = &v21[v20];
      do
      {
        sub_14615AAE0(v22, a3 + 17, v23);
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
  }
  else
  {
    *a1 = a5;
  }
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (00000001461616E0) ----------------------------------------------------
__int64 *__fastcall sub_1461616E0(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  __int64 v17; // rbx
  __int64 v18; // rax
  _BYTE *v19; // rsi
  char *v20; // rbp
  __int64 *result; // rax

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = *v15;
        ++*(_QWORD *)(a2 + 16);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  v17 = *sub_146162CF0(a6, (__int64 *)&a5, a2);
  if ( v13 )
  {
    v18 = (unsigned __int8)a3[21];
    v19 = a3 + 17;
    if ( v18 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v17 + 16) + 1i64) > *(_QWORD *)(v17 + 24) )
          (**(void (__fastcall ***)(__int64))v17)(v17);
        *(_BYTE *)(*(_QWORD *)(v17 + 8) + (*(_QWORD *)(v17 + 16))++) = *v19;
        --v13;
      }
      while ( v13 );
    }
    else
    {
      v20 = &v19[v18];
      do
      {
        sub_14615AAE0(v17, a3 + 17, v20);
        --v13;
      }
      while ( v13 );
    }
  }
  result = a1;
  *a1 = v17;
  return result;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (0000000146161880) ----------------------------------------------------
_QWORD *__fastcall sub_146161880(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  _DWORD *v17; // r14
  unsigned int i; // esi
  __int64 j; // rsi
  __int64 v20; // rax
  _BYTE *v21; // rsi
  __int64 v22; // rbx
  char *v23; // rbp

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  v17 = a6;
  for ( i = *a6 & 0xFFFFFF; i; i >>= 8 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = i;
  }
  for ( j = *((_QWORD *)v17 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = 48;
  }
  sub_14615B3C0(&a5, a2, *((_QWORD *)v17 + 3), v17[8], *((_BYTE *)v17 + 36));
  if ( v13 )
  {
    v20 = (unsigned __int8)a3[21];
    v21 = a3 + 17;
    v22 = a5;
    if ( v20 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v22 + 16) + 1i64) > *(_QWORD *)(v22 + 24) )
          (**(void (__fastcall ***)(__int64))v22)(v22);
        *(_BYTE *)(*(_QWORD *)(v22 + 8) + (*(_QWORD *)(v22 + 16))++) = *v21;
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
    else
    {
      v23 = &v21[v20];
      do
      {
        sub_14615AAE0(v22, a3 + 17, v23);
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
  }
  else
  {
    *a1 = a5;
  }
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (0000000146161AB0) ----------------------------------------------------
__int64 *__fastcall sub_146161AB0(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  __int64 v17; // rbx
  __int64 v18; // rax
  _BYTE *v19; // rsi
  char *v20; // rbp
  __int64 *result; // rax

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = *v15;
        ++*(_QWORD *)(a2 + 16);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  v17 = *sub_1461633C0(a6, (__int64 *)&a5, a2);
  if ( v13 )
  {
    v18 = (unsigned __int8)a3[21];
    v19 = a3 + 17;
    if ( v18 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v17 + 16) + 1i64) > *(_QWORD *)(v17 + 24) )
          (**(void (__fastcall ***)(__int64))v17)(v17);
        *(_BYTE *)(*(_QWORD *)(v17 + 8) + (*(_QWORD *)(v17 + 16))++) = *v19;
        --v13;
      }
      while ( v13 );
    }
    else
    {
      v20 = &v19[v18];
      do
      {
        sub_14615AAE0(v17, a3 + 17, v20);
        --v13;
      }
      while ( v13 );
    }
  }
  result = a1;
  *a1 = v17;
  return result;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (0000000146161C50) ----------------------------------------------------
_QWORD *__fastcall sub_146161C50(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  _DWORD *v17; // r14
  unsigned int i; // esi
  __int64 j; // rsi
  __int64 v20; // rax
  _BYTE *v21; // rsi
  __int64 v22; // rbx
  char *v23; // rbp

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = *v15;
        ++*(_QWORD *)(a2 + 16);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  v17 = a6;
  for ( i = *a6 & 0xFFFFFF; i; i >>= 8 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = i;
    ++*(_QWORD *)(a2 + 16);
  }
  for ( j = *((_QWORD *)v17 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = 48;
    ++*(_QWORD *)(a2 + 16);
  }
  sub_1461630C0((__int64)(v17 + 6), &a5, a2);
  if ( v13 )
  {
    v20 = (unsigned __int8)a3[21];
    v21 = a3 + 17;
    v22 = a5;
    if ( v20 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v22 + 16) + 1i64) > *(_QWORD *)(v22 + 24) )
          (**(void (__fastcall ***)(__int64))v22)(v22);
        *(_BYTE *)(*(_QWORD *)(v22 + 8) + (*(_QWORD *)(v22 + 16))++) = *v21;
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
    else
    {
      v23 = &v21[v20];
      do
      {
        sub_14615AAE0(v22, a3 + 17, v23);
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
  }
  else
  {
    *a1 = a5;
  }
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (0000000146161E70) ----------------------------------------------------
_QWORD *__fastcall sub_146161E70(_QWORD *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, _DWORD *a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  _DWORD *v17; // r14
  unsigned int i; // esi
  __int64 j; // rsi
  __int64 v20; // rax
  _BYTE *v21; // rsi
  __int64 v22; // rbx
  char *v23; // rbp

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  v17 = a6;
  for ( i = *a6 & 0xFFFFFF; i; i >>= 8 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = i;
  }
  for ( j = *((_QWORD *)v17 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = 48;
  }
  sub_14615B230(&a5, a2, v17[6], v17[7], *((_BYTE *)v17 + 32));
  if ( v13 )
  {
    v20 = (unsigned __int8)a3[21];
    v21 = a3 + 17;
    v22 = a5;
    if ( v20 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v22 + 16) + 1i64) > *(_QWORD *)(v22 + 24) )
          (**(void (__fastcall ***)(__int64))v22)(v22);
        *(_BYTE *)(*(_QWORD *)(v22 + 8) + (*(_QWORD *)(v22 + 16))++) = *v21;
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
    else
    {
      v23 = &v21[v20];
      do
      {
        sub_14615AAE0(v22, a3 + 17, v23);
        --v13;
      }
      while ( v13 );
      *a1 = v22;
    }
  }
  else
  {
    *a1 = a5;
  }
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (00000001461620A0) ----------------------------------------------------
__int64 *__fastcall sub_1461620A0(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, __int64 a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r14
  char *v16; // rbp
  __int64 v17; // rax
  _BYTE *v18; // rsi
  char *v19; // rbp
  __int64 *result; // rax

  v6 = *(unsigned int *)a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  if ( v12 )
  {
    v14 = (unsigned __int8)a3[21];
    v15 = a3 + 17;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = *v15;
        ++*(_QWORD *)(a2 + 16);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v16);
        --v12;
      }
      while ( v12 );
    }
  }
  sub_14615AAE0(a2, *(char **)a6, (char *)(*(_QWORD *)a6 + *(int *)(a6 + 8)));
  if ( v13 )
  {
    v17 = (unsigned __int8)a3[21];
    v18 = a3 + 17;
    if ( v17 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = *v18;
        ++*(_QWORD *)(a2 + 16);
        --v13;
      }
      while ( v13 );
    }
    else
    {
      v19 = &v18[v17];
      do
      {
        sub_14615AAE0(a2, a3 + 17, v19);
        --v13;
      }
      while ( v13 );
    }
  }
  result = a1;
  *a1 = a2;
  return result;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (0000000146162240) ----------------------------------------------------
unsigned __int64 *__fastcall sub_146162240(unsigned __int64 *a1, int a2, unsigned int a3, unsigned int *a4)
{
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // rdx
  int v6; // r14d
  int v7; // edi

  if ( a2 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  a1[1] = 0i64;
  *a1 = HIBYTE(a3) + a2;
  if ( (a4[3] & 0xF) == 4 )
  {
    v4 = *a4;
    if ( (v4 & 0x80000000) != 0i64 )
      sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
    v5 = *a1;
    if ( v4 > *a1 )
    {
      *a1 = v4;
      a1[1] = v4 - v5;
    }
  }
  else
  {
    v6 = a4[1];
    if ( v6 > a2 )
    {
      if ( v6 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      *a1 = v6 + HIBYTE(a3);
      v7 = a4[1] - a2;
      if ( v7 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      a1[1] = (unsigned int)v7;
    }
  }
  return a1;
}

//----- (0000000146162350) ----------------------------------------------------
__int64 __fastcall sub_146162350(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0i64;
  _std_exception_copy(a2 + 8);
  *(_QWORD *)a1 = &std::bad_alloc::`vftable';
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CDF0: using guessed type void *std::bad_alloc::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146162390) ----------------------------------------------------
__int64 __fastcall sub_146162390(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0i64;
  _std_exception_copy(a2 + 8);
  *(_QWORD *)a1 = &std::bad_array_new_length::`vftable';
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CE08: using guessed type void *std::bad_array_new_length::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (00000001461623D0) ----------------------------------------------------
_QWORD *__fastcall sub_1461623D0(_QWORD *a1)
{
  a1[2] = 0i64;
  a1[1] = "bad array new length";
  *a1 = &std::bad_array_new_length::`vftable';
  return a1;
}
// 14611CE08: using guessed type void *std::bad_array_new_length::`vftable';

//----- (0000000146162400) ----------------------------------------------------
__int64 __fastcall sub_146162400(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0i64;
  _std_exception_copy(a2 + 8);
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146162440) ----------------------------------------------------
__int64 __fastcall sub_146162440(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0i64;
  _std_exception_copy(a2 + 8);
  *(_QWORD *)a1 = &fmt::v8::format_error::`vftable';
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146162480) ----------------------------------------------------
__int64 __fastcall sub_146162480(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0i64;
  _std_exception_copy(a2 + 8);
  *(_QWORD *)a1 = &std::runtime_error::`vftable';
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CE48: using guessed type void *std::runtime_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (00000001461624C0) ----------------------------------------------------
void __fastcall sub_1461624C0(__int64 a1)
{
  void *v1; // rdi
  _QWORD *v3; // rax
  _QWORD *v4; // rbx

  v1 = *(void **)(a1 + 24);
  if ( v1 )
  {
    v3 = *(_QWORD **)v1;
    if ( *(_QWORD *)v1 )
    {
      while ( v3 != *((_QWORD **)v1 + 2) )
      {
        v4 = (_QWORD *)v3[2];
        free_0(v3);
        *(_QWORD *)v1 = v4;
        v3 = v4;
        if ( !v4 )
          goto LABEL_7;
      }
      v3[1] = 0i64;
    }
LABEL_7:
    j_j_free(*((void **)v1 + 4));
    j_j_free(v1);
  }
  free_0(*(void **)(a1 + 48));
  j_j_free(*(void **)(a1 + 40));
}

//----- (0000000146162550) ----------------------------------------------------
void __fastcall sub_146162550(__int64 a1)
{
  free_0(*(void **)(a1 + 16));
  j_j_free(*(void **)(a1 + 8));
}

//----- (0000000146162590) ----------------------------------------------------
void __fastcall sub_146162590(__int64 a1)
{
  free_0(*(void **)(a1 + 24));
  j_j_free(*(void **)(a1 + 16));
}

//----- (00000001461625E0) ----------------------------------------------------
void __fastcall sub_1461625E0(void **a1)
{
  _QWORD *v2; // rbx
  void *v3; // rcx

  v2 = (_QWORD *)*((_QWORD *)*a1 + 1);
  while ( !*((_BYTE *)v2 + 25) )
  {
    sub_14615A710((__int64)a1, (__int64)a1, v2[2]);
    v3 = v2;
    v2 = (_QWORD *)*v2;
    j_j_free(v3);
  }
  j_j_free(*a1);
}

//----- (0000000146162640) ----------------------------------------------------
void __fastcall sub_146162640(_QWORD *a1)
{
  _QWORD *v2; // rcx

  *a1 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  v2 = (_QWORD *)a1[1];
  if ( v2 != a1 + 4 )
  {
    if ( a1[3] >= 0x1000ui64 )
    {
      if ( (unsigned __int64)v2 - *(v2 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v2 = (_QWORD *)*(v2 - 1);
    }
    j_j_free(v2);
  }
}
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';

//----- (00000001461626B0) ----------------------------------------------------
void __fastcall sub_1461626B0(__int64 a1)
{
  unsigned __int64 v1; // rdx
  _QWORD *v3; // rcx

  v1 = *(_QWORD *)(a1 + 24);
  if ( v1 > 0xF )
  {
    v3 = *(_QWORD **)a1;
    if ( v1 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)v3 - *(v3 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v3 = (_QWORD *)*(v3 - 1);
    }
    j_j_free(v3);
  }
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 15i64;
  *(_BYTE *)a1 = 0;
}

//----- (0000000146162730) ----------------------------------------------------
__int64 __fastcall sub_146162730(__int64 a1)
{
  unsigned __int64 v1; // rdx
  _QWORD *v3; // rcx
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 24);
  if ( v1 > 7 )
  {
    v3 = *(_QWORD **)a1;
    if ( 2 * v1 + 2 >= 0x1000 )
    {
      if ( (unsigned __int64)v3 - *(v3 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v3 = (_QWORD *)*(v3 - 1);
    }
    j_j_free(v3);
  }
  result = 0i64;
  *(_QWORD *)(a1 + 24) = 7i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_WORD *)a1 = 0;
  return result;
}

//----- (00000001461627C0) ----------------------------------------------------
__int64 sub_1461627C0()
{
  __int64 result; // rax

  result = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  *(_OWORD *)(result + 24) = 0ui64;
  *(_QWORD *)(result + 16) = 0i64;
  return result;
}
// 14611AE78: using guessed type int TlsIndex;
// 1461627C0: using guessed type __int64 sub_1461627C0();

//----- (0000000146162830) ----------------------------------------------------
void **__fastcall sub_146162830(void **a1, char *Str)
{
  size_t v4; // rax
  unsigned __int64 v5; // r14
  size_t v6; // rsi
  void *v7; // rdi
  __int64 v8; // rdi
  unsigned __int64 v9; // rdx
  _QWORD *v10; // rax
  _QWORD *v11; // r15
  _QWORD *v12; // rcx

  v4 = strlen(Str);
  v5 = (unsigned __int64)a1[3];
  v6 = v4;
  if ( v4 > v5 )
  {
    v8 = 0x7FFFFFFFFFFFFFFFi64;
    if ( v4 > 0x7FFFFFFFFFFFFFFFi64 )
      unknown_libname_4();
    if ( (v4 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      v9 = v5 >> 1;
      if ( v5 <= 0x7FFFFFFFFFFFFFFFi64 - (v5 >> 1) )
      {
        v8 = v4 | 0xF;
        if ( (v4 | 0xF) < v5 + v9 )
          v8 = v5 + v9;
      }
    }
    v10 = sub_14615A5E0(v8 + 1);
    a1[2] = (void *)v6;
    a1[3] = (void *)v8;
    v11 = v10;
    memcpy(v10, Str, v6);
    *((_BYTE *)v11 + v6) = 0;
    if ( v5 > 0xF )
    {
      v12 = *a1;
      if ( v5 + 1 >= 0x1000 )
      {
        if ( (unsigned __int64)v12 - *(v12 - 1) - 8 > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        v12 = (_QWORD *)*(v12 - 1);
      }
      j_j_free(v12);
    }
    *a1 = v11;
  }
  else
  {
    v7 = a1;
    if ( v5 > 0xF )
      v7 = *a1;
    a1[2] = (void *)v4;
    memmove(v7, Str, v4);
    *((_BYTE *)v7 + v6) = 0;
  }
  return a1;
}
// 1461653D0: using guessed type void __noreturn unknown_libname_4(void);

//----- (0000000146162960) ----------------------------------------------------
_QWORD *__fastcall sub_146162960(int *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rbp
  _QWORD *v4; // rdi
  _QWORD *v5; // rsi
  _QWORD *v9; // r14
  char *v10; // r13
  _QWORD *v11; // rbp
  int v12; // eax
  __int64 v13; // rbp
  char v15; // [rsp+60h] [rbp+8h]
  int v16; // [rsp+68h] [rbp+10h]

  v3 = *a1;
  v4 = (_QWORD *)(a3 + 16);
  v5 = (_QWORD *)(a3 + 24);
  if ( (_DWORD)v3 )
  {
    if ( (unsigned __int64)(*v4 + 1i64) > *v5 )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    v9 = (_QWORD *)(a3 + 8);
    *(_BYTE *)(*v4 + *(_QWORD *)(a3 + 8)) = byte_14611CFAC[v3];
    ++*v4;
  }
  else
  {
    v9 = (_QWORD *)(a3 + 8);
  }
  v10 = (char *)*((_QWORD *)a1 + 1);
  v15 = *((_BYTE *)a1 + 20);
  v16 = a1[4];
  sub_14615AAE0(a3, v10, v10 + 1);
  v11 = v9;
  if ( v15 )
  {
    if ( (unsigned __int64)(*v4 + 1i64) > *v5 )
    {
      (**(void (__fastcall ***)(__int64))a3)(a3);
      v11 = (_QWORD *)(a3 + 8);
    }
    *(_BYTE *)(*v9 + (*v4)++) = v15;
    sub_14615AAE0(a3, v10 + 1, &v10[v16]);
  }
  v12 = a1[6];
  if ( v12 > 0 )
  {
    v13 = (unsigned int)v12;
    do
    {
      if ( (unsigned __int64)(*v4 + 1i64) > *v5 )
        (**(void (__fastcall ***)(__int64))a3)(a3);
      *(_BYTE *)(*v4 + *v9) = 48;
      ++*v4;
      --v13;
    }
    while ( v13 );
    v4 = (_QWORD *)(a3 + 16);
    v5 = (_QWORD *)(a3 + 24);
    v11 = (_QWORD *)(a3 + 8);
  }
  if ( (unsigned __int64)(*v4 + 1i64) > *v5 )
    (**(void (__fastcall ***)(__int64))a3)(a3);
  *(_BYTE *)(*v11 + (*v4)++) = *((_BYTE *)a1 + 28);
  sub_14615EA50(a2, a1[8], a3);
  return a2;
}

//----- (0000000146162AC0) ----------------------------------------------------
__int64 __fastcall sub_146162AC0(__int64 *a1, __int64 a2, int a3)
{
  int v4; // esi
  __int64 v5; // rcx
  int v7; // eax
  int v8; // ebx
  __int64 v9; // r8
  __int64 v10; // rdx
  __int64 v11; // rax
  __int64 v12; // xmm1_8
  int v14; // edx
  char v15; // [rsp+40h] [rbp+18h] BYREF

  v4 = 0;
  v5 = *a1;
  v7 = *(_DWORD *)(v5 + 16);
  if ( a3 >= 0 )
  {
    v8 = a3 - 1;
    if ( v7 > 0 )
      sub_14619FE20(v5, (__int64)"cannot switch from automatic to manual argument indexing");
    *(_DWORD *)(v5 + 16) = -1;
  }
  else
  {
    v8 = *(_DWORD *)(v5 + 16);
    if ( v7 < 0 )
      sub_14619FE20(v5, (__int64)"cannot switch from manual to automatic argument indexing");
    *(_DWORD *)(v5 + 16) = v7 + 1;
  }
  v9 = a1[1];
  *(_DWORD *)(a2 + 16) = 0;
  v10 = *(_QWORD *)(v9 + 8);
  if ( v10 >= 0 )
  {
    if ( v8 >= 15 )
      goto LABEL_12;
    v14 = ((unsigned __int64)v10 >> (4 * (unsigned __int8)v8)) & 0xF;
    *(_DWORD *)(a2 + 16) = v14;
    if ( !v14 )
      goto LABEL_12;
    *(_OWORD *)a2 = *(_OWORD *)(*(_QWORD *)(v9 + 16) + 16i64 * v8);
  }
  else
  {
    if ( v8 < (int)v10 )
    {
      v11 = *(_QWORD *)(v9 + 16);
      v12 = *(_QWORD *)(v11 + 24i64 * v8 + 16);
      *(_OWORD *)a2 = *(_OWORD *)(v11 + 24i64 * v8);
      *(_QWORD *)(a2 + 16) = v12;
      v4 = *(_DWORD *)(a2 + 16);
    }
    if ( !v4 )
LABEL_12:
      sub_14619FE20((__int64)&v15, (__int64)"argument not found");
  }
  return a2;
}

//----- (0000000146162BC0) ----------------------------------------------------
__int64 *__fastcall sub_146162BC0(int **a1, __int64 *a2, __int64 a3)
{
  __int64 v6; // r15
  char v7; // r12
  char *v8; // r15
  char *v9; // r13
  int v10; // ecx
  __int64 v11; // rsi
  __int64 *result; // rax
  int v13; // [rsp+50h] [rbp+8h]

  v6 = **a1;
  if ( (_DWORD)v6 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_BYTE *)(*(_QWORD *)(a3 + 8) + (*(_QWORD *)(a3 + 16))++) = byte_14611CFAC[v6];
  }
  v7 = *(_BYTE *)a1[4];
  v13 = *a1[2];
  v8 = *(char **)a1[1];
  v9 = &v8[*a1[3]];
  sub_14615AAE0(a3, v8, v9);
  if ( v7 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_BYTE *)(*(_QWORD *)(a3 + 16) + *(_QWORD *)(a3 + 8)) = v7;
    ++*(_QWORD *)(a3 + 16);
    sub_14615AAE0(a3, v9, &v8[v13]);
  }
  v10 = *a1[5];
  if ( v10 > 0 )
  {
    v11 = (unsigned int)v10;
    do
    {
      if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
        (**(void (__fastcall ***)(__int64))a3)(a3);
      *(_BYTE *)(*(_QWORD *)(a3 + 16) + *(_QWORD *)(a3 + 8)) = 48;
      ++*(_QWORD *)(a3 + 16);
      --v11;
    }
    while ( v11 );
  }
  result = a2;
  *a2 = a3;
  return result;
}

//----- (0000000146162CF0) ----------------------------------------------------
__int64 *__fastcall sub_146162CF0(int **a1, __int64 *a2, __int64 a3)
{
  _QWORD *v3; // rbp
  __int64 v7; // rdi
  _QWORD *v8; // r12
  __int64 v9; // rdx
  int *v10; // rax
  __int64 *v11; // rdi
  _QWORD *v12; // r14
  __int64 v13; // rdx
  int v14; // ecx
  __int64 v15; // rsi
  __int64 *result; // rax
  int *v17; // [rsp+50h] [rbp+8h]

  v3 = (_QWORD *)(a3 + 24);
  v7 = **a1;
  if ( (_DWORD)v7 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *v3 )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    v8 = (_QWORD *)(a3 + 8);
    *(_BYTE *)(*(_QWORD *)(a3 + 8) + (*(_QWORD *)(a3 + 16))++) = byte_14611CFAC[v7];
  }
  else
  {
    v8 = (_QWORD *)(a3 + 8);
  }
  if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *v3 )
    (**(void (__fastcall ***)(__int64))a3)(a3);
  *(_BYTE *)(*(_QWORD *)(a3 + 16) + *v8) = 48;
  v9 = *(_QWORD *)(a3 + 16) + 1i64;
  *(_QWORD *)(a3 + 16) = v9;
  if ( *(_BYTE *)a1[1] )
  {
    v10 = a1[2];
    v11 = (__int64 *)(a3 + 16);
    v12 = v8;
    v17 = v10;
    if ( (unsigned __int64)(v9 + 1) > *v3 )
    {
      (**(void (__fastcall ***)(__int64))a3)(a3);
      v10 = v17;
      v3 = (_QWORD *)(a3 + 24);
      v12 = (_QWORD *)(a3 + 8);
      v11 = (__int64 *)(a3 + 16);
    }
    *(_BYTE *)(*v8 + *(_QWORD *)(a3 + 16)) = *(_BYTE *)v10;
    v13 = *(_QWORD *)(a3 + 16) + 1i64;
    *(_QWORD *)(a3 + 16) = v13;
    v14 = *a1[3];
    if ( v14 > 0 )
    {
      v15 = (unsigned int)v14;
      do
      {
        if ( (unsigned __int64)(v13 + 1) > *v3 )
          (**(void (__fastcall ***)(__int64))a3)(a3);
        *(_BYTE *)(*v12 + (*v11)++) = 48;
        v13 = *v11;
        --v15;
      }
      while ( v15 );
    }
    sub_14615AAE0(a3, *(char **)a1[4], (char *)(*(_QWORD *)a1[4] + *a1[5]));
  }
  result = a2;
  *a2 = a3;
  return result;
}

//----- (0000000146162E60) ----------------------------------------------------
unsigned __int8 *__fastcall sub_146162E60(_QWORD **a1, unsigned __int8 *a2)
{
  unsigned int v2; // r8d
  int v3; // ebx
  unsigned __int8 v6; // r10
  unsigned int v7; // r11d
  int v8; // ecx
  __int64 v9; // r9
  unsigned __int8 v10; // dl
  unsigned __int8 *v11; // rdi
  char v12; // al
  unsigned int v13; // r11d
  unsigned int v14; // r8d
  int v15; // edx
  int v16; // r11d
  int v17; // r11d
  __int64 v18; // rcx
  __int64 v20; // [rsp+0h] [rbp-88h]
  int v21; // [rsp+8h] [rbp-80h]
  int v22; // [rsp+Ch] [rbp-7Ch]
  int v23; // [rsp+10h] [rbp-78h]
  __m128i si128; // [rsp+18h] [rbp-70h]
  int v25; // [rsp+28h] [rbp-60h]
  __m128i v26; // [rsp+30h] [rbp-58h]
  int v27; // [rsp+40h] [rbp-48h]
  __m128i v28; // [rsp+48h] [rbp-40h]
  int v29; // [rsp+58h] [rbp-30h]
  _OWORD v30[2]; // [rsp+60h] [rbp-28h]

  v2 = *a2;
  v3 = 0;
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA70);
  v27 = 0;
  v6 = a2[1];
  v7 = a2[3];
  v26 = _mm_load_si128((const __m128i *)&xmmword_14611DA60);
  v29 = 0;
  v28 = _mm_load_si128((const __m128i *)&xmmword_14611DA50);
  v25 = 7;
  v30[0] = _mm_load_si128((const __m128i *)&xmmword_14611DA90);
  v20 = 0x400000i64;
  v21 = 128;
  v22 = 2048;
  v23 = 0x10000;
  v30[1] = _mm_load_si128((const __m128i *)&xmmword_14611DA80);
  v8 = *((char *)v30 + ((unsigned __int64)v2 >> 3));
  v9 = v8 + ((_BYTE)v8 == 0);
  v10 = a2[2];
  v11 = &a2[v9];
  v12 = v7;
  v13 = v6 & 0xC0 | ((v10 & 0xC0 | (v7 >> 2)) >> 2);
  v14 = (v12 & 0x3F | ((v10 & 0x3F | ((v6 & 0x3F | (((unsigned int)(char)v2 & si128.m128i_i32[v9]) << 6)) << 6)) << 6)) >> v26.m128i_i32[v9];
  v15 = 0;
  v16 = (v14 < *((_DWORD *)&v20 + v9) ? 0x40 : 0) | (v13 >> 2);
  if ( (v14 & 0xFFFFF800) == 55296 )
    v15 = 128;
  v17 = v15 | v16;
  if ( v14 > 0x10FFFF )
    v3 = 256;
  if ( ((v3 | v17) ^ 0x2A) >> v28.m128i_i32[v9]
    || v14 < 0x1100
    || (v14 - 4448 <= 0x11C8 || v14 >= 0x232B)
    && (v14 - 11904 > 0x764F || v14 == 12351)
    && v14 - 44032 > 0x2BA3
    && v14 - 63744 > 0x1FF
    && v14 - 65040 > 9
    && v14 - 65072 > 0x3F
    && v14 - 65280 > 0x60
    && v14 - 65504 > 6
    && v14 - 0x20000 > 0xFFFD
    && v14 - 196608 > 0xFFFD
    && v14 - 127744 > 0x34F
    && v14 - 129280 > 0xFF )
  {
    v18 = 1i64;
  }
  else
  {
    v18 = 2i64;
  }
  **a1 += v18;
  return v11;
}
// 14611DA50: using guessed type __int128 xmmword_14611DA50;
// 14611DA60: using guessed type __int128 xmmword_14611DA60;
// 14611DA70: using guessed type __int128 xmmword_14611DA70;
// 14611DA80: using guessed type __int128 xmmword_14611DA80;
// 14611DA90: using guessed type __int128 xmmword_14611DA90;
// 146162E60: using guessed type __m128i var_58;
// 146162E60: using guessed type __m128i var_70;
// 146162E60: using guessed type __m128i var_40;

//----- (00000001461630C0) ----------------------------------------------------
_QWORD *__fastcall sub_1461630C0(__int64 a1, _QWORD *a2, __int64 a3)
{
  unsigned __int64 v3; // rdi
  __int64 v5; // rsi
  char *v7; // r15
  const char *v8; // r9
  char *i; // r8
  __int16 v10; // ax
  char *j; // rsi
  size_t v12; // rdi
  size_t v13; // rdx
  __int64 v14; // rdx
  _QWORD *result; // rax
  char Src[24]; // [rsp+20h] [rbp-48h] BYREF

  v3 = *(_QWORD *)a1;
  v5 = *(int *)(a1 + 8);
  if ( (int)v5 < (int)sub_146165560(*(_QWORD *)a1) )
    sub_14619F290(
      "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\format.h",
      0x41Cu,
      "invalid digit count");
  v7 = &Src[v5];
  v8 = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555"
       "6575859606162636465666768697071727374757677787980818283848586878889909192939495969798990123456789abcdef";
  for ( i = &Src[v5]; v3 >= 0x64; *(_WORD *)i = v10 )
  {
    i -= 2;
    v10 = *(_WORD *)&a00010203040506[2 * (v3 % 0x64)];
    v3 /= 0x64ui64;
  }
  if ( v3 >= 0xA )
    *((_WORD *)i - 1) = *(_WORD *)&a00010203040506[2 * v3];
  else
    *(i - 1) = v3 + 48;
  for ( j = Src; j != v7; j += v12 )
  {
    v12 = v7 - j;
    if ( v7 - j < 0 )
      sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
    v13 = v12 + *(_QWORD *)(a3 + 16);
    if ( v13 > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64, size_t, char *, const char *))a3)(a3, v13, i, v8);
    v14 = *(_QWORD *)(a3 + 16);
    if ( *(_QWORD *)(a3 + 24) - v14 < v12 )
      v12 = *(_QWORD *)(a3 + 24) - v14;
    if ( v12 )
      memmove((void *)(v14 + *(_QWORD *)(a3 + 8)), j, v12);
    *(_QWORD *)(a3 + 16) += v12;
  }
  result = a2;
  *a2 = a3;
  return result;
}
// 1461631D3: variable 'i' is possibly undefined
// 1461631D3: variable 'v8' is possibly undefined

//----- (0000000146163240) ----------------------------------------------------
_QWORD *__fastcall sub_146163240(unsigned int *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rsi
  char *v7; // r15
  char *i; // rcx
  __int16 v9; // ax
  char *j; // rsi
  size_t v11; // rdi
  __int64 v12; // rdx
  _QWORD *result; // rax
  char Src[16]; // [rsp+28h] [rbp-40h] BYREF

  v3 = *a1;
  v4 = (int)a1[1];
  _BitScanReverse((unsigned int *)&a1, *a1 | 1);
  if ( (int)v4 < (int)((unsigned __int64)(v3 + qword_14611CFD0[(int)a1]) >> 32) )
    sub_14619F290(
      "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\format.h",
      0x41Cu,
      "invalid digit count");
  v7 = &Src[v4];
  for ( i = &Src[v4]; (unsigned int)v3 >= 0x64; *(_WORD *)i = v9 )
  {
    i -= 2;
    v9 = *(_WORD *)&a00010203040506[2 * ((unsigned int)v3 % 0x64)];
    LODWORD(v3) = (unsigned int)v3 / 0x64;
  }
  if ( (unsigned int)v3 >= 0xA )
    *((_WORD *)i - 1) = *(_WORD *)&a00010203040506[2 * (unsigned int)v3];
  else
    *(i - 1) = v3 + 48;
  for ( j = Src; j != v7; j += v11 )
  {
    v11 = v7 - j;
    if ( v7 - j < 0 )
      sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
    if ( v11 + *(_QWORD *)(a3 + 16) > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    v12 = *(_QWORD *)(a3 + 16);
    if ( *(_QWORD *)(a3 + 24) - v12 < v11 )
      v11 = *(_QWORD *)(a3 + 24) - v12;
    if ( v11 )
      memmove((void *)(v12 + *(_QWORD *)(a3 + 8)), j, v11);
    *(_QWORD *)(a3 + 16) += v11;
  }
  result = a2;
  *a2 = a3;
  return result;
}
// 14611CFD0: using guessed type __int64 qword_14611CFD0[32];

//----- (00000001461633C0) ----------------------------------------------------
__int64 *__fastcall sub_1461633C0(int **a1, __int64 *a2, __int64 a3)
{
  _QWORD *v3; // rsi
  __int64 *v5; // rdi
  __int64 v8; // rbp
  int v9; // ecx
  __int64 v10; // rbp
  int *v11; // rbp
  __int64 v12; // rdx
  int v13; // ecx
  __int64 v14; // rbp
  __int64 *result; // rax

  v3 = (_QWORD *)(a3 + 24);
  v5 = (__int64 *)(a3 + 16);
  v8 = **a1;
  if ( (_DWORD)v8 )
  {
    if ( (unsigned __int64)(*v5 + 1) > *v3 )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_BYTE *)(*(_QWORD *)(a3 + 8) + (*v5)++) = byte_14611CFAC[v8];
  }
  sub_14615AAE0(a3, *(char **)a1[1], (char *)(*(_QWORD *)a1[1] + *a1[2]));
  v9 = a1[3][3];
  if ( v9 > 0 )
  {
    v10 = (unsigned int)v9;
    do
    {
      if ( (unsigned __int64)(*v5 + 1) > *v3 )
        (**(void (__fastcall ***)(__int64))a3)(a3);
      *(_BYTE *)(*(_QWORD *)(a3 + 8) + (*v5)++) = 48;
      --v10;
    }
    while ( v10 );
    v5 = (__int64 *)(a3 + 16);
    v3 = (_QWORD *)(a3 + 24);
  }
  if ( (a1[4][3] & 0x10) != 0 )
  {
    v11 = a1[5];
    if ( (unsigned __int64)(*v5 + 1) > *v3 )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_BYTE *)(*v5 + *(_QWORD *)(a3 + 8)) = *(_BYTE *)v11;
    v12 = *v5 + 1;
    *v5 = v12;
    v13 = *a1[6];
    if ( v13 > 0 )
    {
      v14 = (unsigned int)v13;
      do
      {
        if ( (unsigned __int64)(v12 + 1) > *v3 )
          (**(void (__fastcall ***)(__int64))a3)(a3);
        *(_BYTE *)(*(_QWORD *)(a3 + 8) + (*v5)++) = 48;
        v12 = *v5;
        --v14;
      }
      while ( v14 );
    }
  }
  result = a2;
  *a2 = a3;
  return result;
}

//----- (0000000146163510) ----------------------------------------------------
bool __fastcall sub_146163510(__int64 a1, __int64 a2, __int64 a3)
{
  size_t v3; // rbx
  size_t v6; // r8
  size_t v7; // rdi
  int v8; // eax
  size_t v9; // rbx
  size_t v10; // r8
  size_t v11; // rdi
  int v12; // eax

  v3 = *(_QWORD *)(a2 + 8);
  v6 = v3;
  v7 = *(_QWORD *)(a3 + 8);
  if ( v7 < v3 )
    v6 = *(_QWORD *)(a3 + 8);
  v8 = memcmp(*(const void **)a2, *(const void **)a3, v6);
  if ( !v8 )
  {
    if ( v3 >= v7 )
      v8 = v3 > v7;
    else
      v8 = -1;
  }
  if ( v8 < 0 )
    return 1;
  v9 = v7;
  v10 = v7;
  v11 = *(_QWORD *)(a2 + 8);
  if ( v11 < v9 )
    v10 = *(_QWORD *)(a2 + 8);
  v12 = memcmp(*(const void **)a3, *(const void **)a2, v10);
  if ( !v12 )
  {
    if ( v9 >= v11 )
      v12 = v9 > v11;
    else
      v12 = -1;
  }
  return v12 >= 0 && *(_DWORD *)(a2 + 16) < *(_DWORD *)(a3 + 16);
}

//----- (00000001461635D0) ----------------------------------------------------
__int64 *__fastcall sub_1461635D0(__int64 *a1, __int64 *a2, const char *a3)
{
  char *v3; // rbp
  char v6; // al
  __int64 v7; // rdi
  unsigned __int64 v8; // rax
  int v9; // ebx
  __int64 v10; // r9
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rdx
  __int64 v14; // [rsp+30h] [rbp-38h] BYREF
  const char *v15; // [rsp+40h] [rbp-28h] BYREF
  size_t v16; // [rsp+48h] [rbp-20h]
  char v17; // [rsp+80h] [rbp+18h] BYREF
  __int64 v18; // [rsp+88h] [rbp+20h] BYREF

  v3 = (char *)a1[1];
  if ( a3 )
  {
    v6 = v3[8];
    v7 = *a1;
    v17 = 0;
    if ( !v6 || v6 == 115 )
    {
      v15 = a3;
      v16 = strlen(a3);
      *a2 = *sub_14615DA40(&v14, v7, (unsigned __int64 *)&v15, (__int64)v3);
      return a2;
    }
    else
    {
      if ( v6 != 112 )
        sub_14619FE20((__int64)&v17, (__int64)"invalid type specifier");
      v8 = (unsigned __int64)a3;
      v9 = 0;
      do
      {
        ++v9;
        v8 >>= 4;
      }
      while ( v8 );
      if ( v9 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      v10 = (unsigned int)v9 + 2i64;
      v15 = a3;
      LODWORD(v16) = v9;
      if ( v3 )
      {
        sub_146160CD0(&v18, v7, v3, v10, (unsigned int)v9 + 2i64, (__int64)&v15);
        *a2 = v18;
        return a2;
      }
      else
      {
        v12 = *(_QWORD *)(v7 + 16) + 1i64;
        if ( v12 > *(_QWORD *)(v7 + 24) )
          (**(void (__fastcall ***)(__int64, unsigned __int64, const char *, __int64))v7)(v7, v12, a3, v10);
        *(_BYTE *)(*(_QWORD *)(v7 + 16) + *(_QWORD *)(v7 + 8)) = 48;
        v13 = ++*(_QWORD *)(v7 + 16) + 1i64;
        if ( v13 > *(_QWORD *)(v7 + 24) )
          (**(void (__fastcall ***)(__int64, unsigned __int64, const char *, __int64))v7)(v7, v13, a3, v10);
        *(_BYTE *)(*(_QWORD *)(v7 + 16) + *(_QWORD *)(v7 + 8)) = 120;
        ++*(_QWORD *)(v7 + 16);
        sub_14615B3C0(&v18, v7, (unsigned __int64)a3, v9, 0);
        *a2 = v18;
        return a2;
      }
    }
  }
  else
  {
    sub_146166100(a1, a2, v3[8] != 112);
    return a2;
  }
}
// 1461636E7: variable 'a3' is possibly undefined
// 1461636E7: variable 'v10' is possibly undefined

//----- (00000001461637A0) ----------------------------------------------------
_QWORD *__fastcall sub_1461637A0(__int64 *a1, _QWORD *a2, unsigned __int64 a3)
{
  __int64 v3; // rsi
  char v6; // al
  __int64 v7; // rbx
  unsigned __int64 v8; // rax
  int v9; // edi
  __int64 v10; // r9
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rdx
  __int128 v13; // xmm0
  __int64 v14; // rdx
  char v16[8]; // [rsp+30h] [rbp-68h] BYREF
  __int64 v17; // [rsp+38h] [rbp-60h] BYREF
  const char *v18; // [rsp+40h] [rbp-58h] BYREF
  __int64 v19; // [rsp+48h] [rbp-50h]
  __int128 v20; // [rsp+50h] [rbp-48h] BYREF
  __int64 v21; // [rsp+60h] [rbp-38h]

  v3 = a1[1];
  if ( a3 )
  {
    v6 = *(_BYTE *)(v3 + 8);
    v7 = *a1;
    if ( v6 && v6 != 112 )
      sub_14619FE20((__int64)v16, (__int64)"invalid type specifier");
    v8 = a3;
    v9 = 0;
    do
    {
      ++v9;
      v8 >>= 4;
    }
    while ( v8 );
    if ( v9 < 0 )
      sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
    v10 = (unsigned int)v9 + 2i64;
    v18 = (const char *)a3;
    LODWORD(v19) = v9;
    if ( v3 )
    {
      sub_146160CD0(&v17, v7, (char *)v3, v10, (unsigned int)v9 + 2i64, (__int64)&v18);
    }
    else
    {
      v11 = *(_QWORD *)(v7 + 16) + 1i64;
      if ( v11 > *(_QWORD *)(v7 + 24) )
        (**(void (__fastcall ***)(__int64, unsigned __int64, unsigned __int64, __int64))v7)(v7, v11, a3, v10);
      *(_BYTE *)(*(_QWORD *)(v7 + 16) + *(_QWORD *)(v7 + 8)) = 48;
      v12 = ++*(_QWORD *)(v7 + 16) + 1i64;
      if ( v12 > *(_QWORD *)(v7 + 24) )
        (**(void (__fastcall ***)(__int64, unsigned __int64, unsigned __int64, __int64))v7)(v7, v12, a3, v10);
      *(_BYTE *)(*(_QWORD *)(v7 + 16) + *(_QWORD *)(v7 + 8)) = 120;
      ++*(_QWORD *)(v7 + 16);
      sub_14615B3C0(&v17, v7, a3, v9, 0);
    }
  }
  else
  {
    v13 = *(_OWORD *)v3;
    v14 = *a1;
    v18 = "(nil)";
    v20 = v13;
    v21 = *(_QWORD *)(v3 + 16);
    BYTE8(v20) = 0;
    v19 = 5i64;
    sub_146160390(&v17, v14, (char *)&v20, 5i64, 5ui64, (__int64)&v18);
  }
  *a2 = v17;
  return a2;
}
// 1461638A2: variable 'a3' is possibly undefined
// 1461638A2: variable 'v10' is possibly undefined
// 1461637A0: using guessed type char var_68[8];

//----- (0000000146163960) ----------------------------------------------------
void __noreturn sub_146163960()
{
  sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\format.h", 0x73Cu, Src);
}
// 146163960: using guessed type void __noreturn sub_146163960();

//----- (00000001461639F0) ----------------------------------------------------
unsigned int *__fastcall sub_1461639F0(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v6; // rcx
  unsigned int v7; // ebp
  __int64 v8; // rax
  __int64 v9; // rbx
  size_t v10; // rsi
  unsigned __int64 v11; // rdx
  _QWORD *v12; // rcx
  size_t v13; // r8
  char *v14; // rax
  char *v15; // r14
  __int64 v16; // rcx
  __int128 v18; // [rsp+28h] [rbp-40h]

  v18 = 0i64;
  HIWORD(v18) = 1029;
  *((_QWORD *)&v18 + 1) = *(_QWORD *)a2 | *((_QWORD *)&v18 + 1) & 0xFFFF000000000000ui64;
  LODWORD(v18) = *(_DWORD *)(a2 + 8);
  v6 = a1[1];
  if ( *a1 >= (unsigned int)v6 )
  {
    if ( (_DWORD)v6 )
    {
      v7 = v6 + ((unsigned int)(v6 + 1) >> 1);
      if ( v7 <= (unsigned int)v6 )
        goto LABEL_19;
    }
    else
    {
      v7 = 16;
    }
    v8 = 32i64 * v7;
    v9 = *((_QWORD *)a1 + 1) & 0xFFFFFFFFFFFFi64;
    if ( v9 )
    {
      if ( v8 )
      {
        v10 = 32 * v6;
        v11 = (v8 + 7) & 0xFFFFFFFFFFFFFFF8ui64;
        if ( 32 * v6 < v11 )
        {
          v12 = *(_QWORD **)a4;
          v13 = *(_QWORD *)(*(_QWORD *)a4 + 8i64) - v10;
          if ( v9 == v13 + *(_QWORD *)a4 + 24i64 && v13 + v11 <= *v12 )
          {
            v12[1] = v13 + v11;
          }
          else
          {
            v14 = sub_146164810(a4, v11);
            v15 = v14;
            if ( v14 )
            {
              if ( v10 )
                memcpy(v14, (const void *)v9, v10);
              v9 = (__int64)v15;
            }
            else
            {
              v9 = 0i64;
            }
          }
        }
      }
      else
      {
        v9 = 0i64;
      }
    }
    else
    {
      v9 = (__int64)sub_146164810(a4, 32i64 * v7);
    }
    *((_QWORD *)a1 + 1) &= 0xFFFF000000000000ui64;
    *((_QWORD *)a1 + 1) |= v9;
    a1[1] = v7;
  }
LABEL_19:
  v16 = *((_QWORD *)a1 + 1) & 0xFFFFFFFFFFFFi64;
  *(_OWORD *)(32i64 * *a1 + v16) = v18;
  *(_OWORD *)(32i64 * *a1 + v16 + 16) = *(_OWORD *)a3;
  *(_WORD *)(a3 + 14) = 0;
  ++*a1;
  return a1;
}

//----- (0000000146163B70) ----------------------------------------------------
unsigned __int64 __fastcall sub_146163B70(_QWORD *a1, __int64 a2, unsigned __int64 a3, __int64 a4, int *a5, _DWORD *a6)
{
  int v8; // r11d
  int v9; // ecx
  unsigned __int64 v10; // r15
  unsigned __int64 v11; // rsi
  __int64 v12; // rdi
  unsigned __int64 v14; // r8
  unsigned int v15; // r13d
  int v16; // r12d
  unsigned int v17; // r10d
  int v18; // r9d
  unsigned __int64 v19; // rdx
  int v20; // eax
  unsigned __int64 v21; // r8
  unsigned __int64 result; // rax
  int v23; // r11d
  unsigned __int64 v24; // rdx
  __int64 v25; // r10
  unsigned __int64 v26; // r9
  unsigned __int64 v27; // r8
  __int64 v28; // r10
  unsigned __int64 v29; // r9
  int v30; // [rsp+40h] [rbp+10h]
  int v31; // [rsp+40h] [rbp+10h]

  v8 = 1;
  v30 = *(_DWORD *)(a2 + 8);
  v9 = -v30;
  v10 = 1i64 << -(char)v30;
  v11 = *(_QWORD *)a2 - *a1;
  v12 = *(_QWORD *)a2 >> -(char)v30;
  v14 = *(_QWORD *)a2 & (v10 - 1);
  if ( (unsigned int)v12 >= 0xA )
  {
    if ( (unsigned int)v12 >= 0x64 )
    {
      if ( (unsigned int)v12 >= 0x3E8 )
      {
        if ( (unsigned int)v12 >= 0x2710 )
        {
          if ( (unsigned int)v12 >= 0x186A0 )
          {
            if ( (unsigned int)v12 >= 0xF4240 )
            {
              if ( (unsigned int)v12 >= 0x989680 )
                v8 = 9 - ((unsigned int)v12 < 0x5F5E100);
              else
                v8 = 7;
            }
            else
            {
              v8 = 6;
            }
          }
          else
          {
            v8 = 5;
          }
        }
        else
        {
          v8 = 4;
        }
      }
      else
      {
        v8 = 3;
      }
    }
    else
    {
      v8 = 2;
    }
  }
  v15 = 0;
  v16 = 0;
  *a5 = 0;
  while ( 1 )
  {
    LOBYTE(v17) = 0;
    if ( (unsigned int)(v8 - 1) > 8 )
      goto LABEL_29;
    switch ( v8 )
    {
      case 1:
        v17 = v12;
        LODWORD(v12) = 0;
        break;
      case 2:
        v17 = (unsigned int)v12 / 0xA;
        LODWORD(v12) = (unsigned int)v12 % 0xA;
        break;
      case 3:
        v17 = (unsigned int)v12 / 0x64;
        LODWORD(v12) = (unsigned int)v12 % 0x64;
        break;
      case 4:
        v17 = (unsigned int)v12 / 0x3E8;
        LODWORD(v12) = (unsigned int)v12 % 0x3E8;
        break;
      case 5:
        v17 = (unsigned int)v12 / 0x2710;
        LODWORD(v12) = (unsigned int)v12 % 0x2710;
        break;
      case 6:
        v17 = (unsigned int)v12 / 0x186A0;
        LODWORD(v12) = (unsigned int)v12 % 0x186A0;
        break;
      case 7:
        v17 = (unsigned int)v12 / 0xF4240;
        LODWORD(v12) = (unsigned int)v12 % 0xF4240;
        break;
      case 8:
        v17 = (unsigned int)v12 / 0x989680;
        LODWORD(v12) = (unsigned int)v12 % 0x989680;
        break;
      case 9:
        v17 = (unsigned int)v12 / 0x5F5E100;
        LODWORD(v12) = (unsigned int)v12 % 0x5F5E100;
        break;
    }
    if ( !v17 )
    {
      LOBYTE(v9) = -(char)v30;
LABEL_29:
      v18 = v16;
      if ( !v16 )
        goto LABEL_31;
    }
    LOBYTE(v9) = -(char)v30;
    *(_BYTE *)(v16 + a4) = v17 + 48;
    v18 = ++*a5;
LABEL_31:
    --v8;
    v19 = v14 + ((unsigned __int64)(unsigned int)v12 << v9);
    if ( v19 <= a3 )
      break;
    v16 = v18;
    if ( v8 <= 0 )
    {
      v20 = -v30;
      v31 = -v30;
      do
      {
        v21 = 10 * v14;
        a3 *= 10i64;
        if ( (unsigned __int8)(v21 >> v20) || v18 )
        {
          *(_BYTE *)(v18 + a4) = (v21 >> v20) + 48;
          v18 = ++*a5;
          LOBYTE(v20) = v31;
        }
        v14 = (v10 - 1) & v21;
        --v8;
      }
      while ( v14 >= a3 );
      result = (unsigned __int64)a6;
      *a6 += v8;
      v23 = -v8;
      if ( v23 < 9 )
      {
        result = v23;
        v15 = dword_14611D718[v23];
      }
      v24 = v11 * v15;
      if ( v14 < v24 )
      {
        v25 = *a5;
        do
        {
          result = a3 - v14;
          if ( a3 - v14 < v10 )
            break;
          v26 = v10 + v14;
          if ( v10 + v14 >= v24 )
          {
            result = v24 - v14;
            if ( v24 - v14 <= v14 + v10 - v24 )
              break;
          }
          --*(_BYTE *)(v25 + a4 - 1);
          v14 += v10;
        }
        while ( v26 < v24 );
      }
      return result;
    }
  }
  *a6 += v8;
  result = v8;
  v27 = (unsigned __int64)(unsigned int)dword_14611D718[v8] << v9;
  if ( v19 < v11 )
  {
    v28 = *a5;
    do
    {
      result = a3 - v19;
      if ( a3 - v19 < v27 )
        break;
      v29 = v19 + v27;
      if ( v19 + v27 >= v11 )
      {
        result = v11 - v19;
        if ( v11 - v19 <= v27 + v19 - v11 )
          break;
      }
      --*(_BYTE *)(v28 + a4 - 1);
      v19 += v27;
    }
    while ( v29 < v11 );
  }
  return result;
}
// 14611D718: using guessed type int dword_14611D718[10];

//----- (0000000146163EF0) ----------------------------------------------------
__int64 __fastcall sub_146163EF0(const char *a1, int a2, int a3, const char *a4, __int128 *a5)
{
  __int128 v6; // [rsp+30h] [rbp-18h] BYREF

  v6 = *a5;
  return sub_146163F20(a1, a2, a3, a4, &v6);
}
// 146163EF0: using guessed type __int128 var_18;

//----- (0000000146163F20) ----------------------------------------------------
__int64 __fastcall sub_146163F20(const char *a1, int a2, int a3, const char *a4, _OWORD *a5)
{
  __int64 v8; // rbx
  _BYTE *v9; // rcx
  char *v10; // rdx
  unsigned int v11; // edi
  void *v12; // r8
  _BYTE v14[24]; // [rsp+38h] [rbp-D0h] BYREF
  __int64 v15[3]; // [rsp+68h] [rbp-A0h] BYREF
  __int128 v16; // [rsp+80h] [rbp-88h] BYREF
  __int128 v17; // [rsp+90h] [rbp-78h]
  void **v18; // [rsp+A8h] [rbp-60h] BYREF
  void *Block; // [rsp+B0h] [rbp-58h]
  size_t v20; // [rsp+B8h] [rbp-50h]
  unsigned __int64 v21; // [rsp+C0h] [rbp-48h]
  char v22[520]; // [rsp+C8h] [rbp-40h] BYREF

  v15[2] = -2i64;
  *(_QWORD *)&v14[8] = a1;
  *(_QWORD *)&v14[16] = strlen(a1);
  v8 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 16i64;
  *(_OWORD *)(v8 + 8) = *(_OWORD *)&v14[8];
  *(_DWORD *)(v8 + 4) = a2;
  *(_DWORD *)v8 = a3;
  v20 = 0i64;
  v18 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  Block = v22;
  v21 = 500i64;
  *(_OWORD *)v14 = *a5;
  v15[0] = (__int64)a4;
  v15[1] = strlen(a4);
  sub_14615CF80((__int64)&v18, (__int64)v15, (__int128 *)v14);
  v16 = 0i64;
  v17 = 0i64;
  sub_14615A650(&v16, Block, v20);
  v18 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  v9 = Block;
  if ( Block != v22 )
  {
    if ( v21 >= 0x1000 )
    {
      v9 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v9 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v9);
  }
  v10 = (char *)&v16;
  if ( *((_QWORD *)&v17 + 1) > 0xFui64 )
    v10 = (char *)v16;
  v11 = sub_146164130(1, v10);
  if ( *((_QWORD *)&v17 + 1) > 0xFui64 )
  {
    v12 = (void *)v16;
    if ( (unsigned __int64)(*((_QWORD *)&v17 + 1) + 1i64) >= 0x1000 )
    {
      v12 = *(void **)(v16 - 8);
      if ( (unsigned __int64)(v16 - (_QWORD)v12 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v12);
  }
  *(_OWORD *)(v8 + 8) = 0u;
  *(_QWORD *)v8 = 0i64;
  return v11;
}
// 14611AE78: using guessed type int TlsIndex;
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';

//----- (0000000146164130) ----------------------------------------------------
__int64 __fastcall sub_146164130(int a1, char *a2)
{
  __int64 ErrorData; // rdi
  __int64 v5; // rbx
  int v6; // eax
  __int64 v7; // rsi
  __int128 v8; // xmm0
  __int64 *v9; // rbx
  char *v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rcx
  char *v13; // rax
  char *v14; // rbx
  __int128 v16; // [rsp+30h] [rbp-50h] BYREF
  __int128 v17; // [rsp+40h] [rbp-40h] BYREF
  __int128 v18; // [rsp+50h] [rbp-30h] BYREF
  __int64 v19; // [rsp+60h] [rbp-20h]
  __int64 v20; // [rsp+68h] [rbp-18h]

  ErrorData = GetErrorData();
  if ( !ErrorData )
  {
    v5 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
    ErrorData = v5 + 144;
    v6 = *(_DWORD *)(v5 + 232);
    if ( (v6 & 1) == 0 )
    {
      *(_BYTE *)(v5 + 152) = 0;
      *(_DWORD *)(v5 + 232) = v6 | 1;
      *(_OWORD *)(v5 + 160) = 0i64;
      *(_QWORD *)(v5 + 184) = 15i64;
      *(_QWORD *)(v5 + 176) = 0i64;
      *(_BYTE *)(v5 + 160) = 0;
      *(_BYTE *)(v5 + 192) = 0;
      *(_OWORD *)(v5 + 200) = 0i64;
      *(_QWORD *)(v5 + 216) = 0i64;
      *(_QWORD *)(v5 + 224) = 15i64;
      *(_BYTE *)(v5 + 200) = 0;
      _tlregdtor(sub_1461AE220);
    }
    if ( !*(_QWORD *)ErrorData )
    {
      if ( dword_14610A974 > *(_DWORD *)(v5 + 380) )
      {
        sub_1461A7CF4(&dword_14610A974);
        if ( dword_14610A974 == -1 )
        {
          atexit(sub_1461AE270);
          Init_thread_footer(&dword_14610A974);
        }
      }
      *(_QWORD *)ErrorData = &unk_146106028;
    }
  }
  v7 = *(_QWORD *)ErrorData;
  *((_QWORD *)&v16 + 1) = &v18;
  *(_QWORD *)&v17 = a2;
  v8 = v17;
  *(_QWORD *)&v17 = "Error: %s\n";
  v18 = v8;
  *(_QWORD *)&v16 = 12i64;
  v9 = (__int64 *)(v7 + 8);
  *((_QWORD *)&v17 + 1) = 10i64;
  sub_1461A2D50(
    (__int64)"Launcher",
    (__int64)"GlobalErrorHandler",
    (__int64)"F:\\NewBuildFivem\\LauncherGTA\\code\\client\\common\\Error.cpp",
    0xE8u,
    &v17,
    &v16);
  if ( *(_BYTE *)(ErrorData + 48) || a1 == 1 && *(_BYTE *)v7 )
  {
    if ( *(_BYTE *)(ErrorData + 8) )
    {
      v11 = ErrorData + 16;
      if ( *(_QWORD *)(ErrorData + 40) > 0xFui64 )
        v11 = *(_QWORD *)(ErrorData + 16);
      *((_QWORD *)&v18 + 1) = v16;
      v20 = *(_QWORD *)(ErrorData + 32);
      *((_QWORD *)&v17 + 1) = &v18;
      v19 = v11;
      *(_QWORD *)&v16 = "Recursive-recursive error: %s\n%s";
      *(_QWORD *)&v18 = a2;
      *(_QWORD *)&v17 = 220i64;
      *((_QWORD *)&v16 + 1) = 32i64;
      v10 = (char *)sub_1461A30D0(&v16, &v17);
    }
    else
    {
      if ( !*(_QWORD *)(v7 + 24) )
        v9 = (__int64 *)(ErrorData + 56);
      v12 = (__int64)v9;
      if ( (unsigned __int64)v9[3] > 0xF )
        v12 = *v9;
      *((_QWORD *)&v18 + 1) = v16;
      v20 = v9[2];
      *((_QWORD *)&v17 + 1) = &v18;
      v19 = v12;
      *(_QWORD *)&v16 = "Recursive error: %s\nOriginal error: %s";
      *(_QWORD *)&v18 = a2;
      *(_QWORD *)&v17 = 220i64;
      *((_QWORD *)&v16 + 1) = 38i64;
      v13 = (char *)sub_1461A30D0(&v16, &v17);
      *(_BYTE *)(ErrorData + 8) = 1;
      v14 = v13;
      sub_146162830((void **)(ErrorData + 16), v13);
      v10 = v14;
    }
  }
  else
  {
    *(_BYTE *)(ErrorData + 48) = 1;
    sub_146162830((void **)(ErrorData + 56), a2);
    if ( a1 )
    {
      *(_BYTE *)v7 = 1;
      sub_146162830((void **)(v7 + 8), a2);
    }
    v10 = a2;
  }
  return sub_146164C90(v10);
}
// 14610A974: using guessed type int dword_14610A974;
// 14611AE78: using guessed type int TlsIndex;
// 1461661B0: using guessed type __int64 GetErrorData(void);
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);
// 1461A7E18: using guessed type __int64 __fastcall _tlregdtor(_QWORD);

//----- (00000001461643F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1461643F0(double a1, __int64 a2, int *a3, _DWORD *a4)
{
  __int64 v6; // rcx
  int v8; // r10d
  bool v9; // zf
  char v10; // cl
  __int64 v11; // r9
  int v12; // eax
  __int64 i; // r8
  __int64 v14; // r8
  int v15; // ebx
  __int64 v16; // rsi
  __int64 v17; // rsi
  double v18; // xmm1_8
  int v19; // edx
  __int64 v20; // rdx
  unsigned __int64 v21; // rax
  __int64 v22; // r11
  int v23; // r10d
  int v24; // edi
  unsigned __int128 v25; // rax
  __int64 v26; // rax
  __int64 v27; // r8
  unsigned __int128 v28; // rax
  __int64 v30; // [rsp+30h] [rbp-38h] BYREF
  int v31; // [rsp+38h] [rbp-30h]
  __int64 v32; // [rsp+40h] [rbp-28h] BYREF
  int v33; // [rsp+48h] [rbp-20h]

  v6 = (*(_QWORD *)&a1 >> 52) & 0x7FFi64;
  v8 = v6 - 1075;
  if ( ((*(_QWORD *)&a1 >> 52) & 0x7FF) == 0 )
    v8 = -1074;
  v9 = (_DWORD)v6 == 0;
  v10 = v8 - 1;
  v11 = (*(_QWORD *)&a1 & 0xFFFFFFFFFFFFFi64) + 0x10000000000000i64;
  if ( v9 )
    v11 = *(_QWORD *)&a1 & 0xFFFFFFFFFFFFFi64;
  v12 = v8 - 1;
  for ( i = 2 * v11 + 1; (i & 0x20000000000000i64) == 0; --v12 )
    i *= 2i64;
  v14 = i << 10;
  v15 = v12 - 10;
  if ( v11 == 0x10000000000000i64 )
    v10 = v8 - 2;
  v16 = 0x40000000000000i64;
  if ( v11 != 0x10000000000000i64 )
    v16 = 2 * v11;
  v17 = (v16 - 1) << (v10 - (unsigned __int8)v15);
  v18 = (double)(-61 - v15) * 0.3010299956639811 + 347.0;
  v19 = (int)v18 + 1;
  if ( v18 - (double)(int)v18 <= 0.0 )
    v19 = (int)v18;
  v20 = (unsigned int)((v19 >> 3) + 1);
  _BitScanReverse64(&v21, v11);
  *a4 = 348 - 8 * v20;
  v22 = qword_14611D2E0[v20];
  v23 = v21 + v8;
  v24 = word_14611D5A0[v20];
  v25 = (unsigned __int64)(v11 << (63 - (unsigned __int8)v21)) * (unsigned __int128)(unsigned __int64)v22;
  if ( (v25 & 0x8000000000000000ui64) != 0i64 )
    ++*((_QWORD *)&v25 + 1);
  v32 = *((_QWORD *)&v25 + 1);
  v33 = v23 + v24 + 1;
  v26 = v14 * v22;
  v27 = ((unsigned __int64)v14 * (unsigned __int128)(unsigned __int64)v22) >> 64;
  if ( v26 < 0 )
    ++v27;
  v28 = (unsigned __int64)v17 * (unsigned __int128)(unsigned __int64)v22;
  v31 = v15 + v24 + 64;
  if ( (v28 & 0x8000000000000000ui64) != 0i64 )
    ++*((_QWORD *)&v28 + 1);
  v30 = v27 - 1;
  return sub_146163B70(&v32, (__int64)&v30, v27 - 1 - *((_QWORD *)&v28 + 1) - 1, a2, a3, a4);
}
// 14611D2E0: using guessed type __int64 qword_14611D2E0[88];
// 14611D5A0: using guessed type __int16 word_14611D5A0[88];

//----- (00000001461645B0) ----------------------------------------------------
__int64 __fastcall sub_1461645B0(__int64 a1, void **a2, __int64 a3, __int64 a4)
{
  _QWORD *v6; // rax
  __int64 v7; // r9
  void *v8; // rdx
  __m128i *v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  _BYTE *v14; // xmm1_8
  __m128i v15; // xmm2
  __int128 *v16; // r12
  _BYTE *v17; // r14
  unsigned __int64 v18; // r15
  __int64 v19; // rsi
  __int64 v20; // rcx
  _QWORD *v21; // rax
  _BYTE *v22; // rcx
  __m128i v24; // [rsp+40h] [rbp-88h] BYREF
  __m128i v25; // [rsp+50h] [rbp-78h]
  void **v26; // [rsp+60h] [rbp-68h]
  void *Block; // [rsp+68h] [rbp-60h] BYREF
  __m128i si128; // [rsp+78h] [rbp-50h]

  v26 = a2;
  v6 = (_QWORD *)sub_1461A1350((__int64)&Block, (__int64)a2, a3, a4);
  v8 = a2;
  if ( (unsigned __int64)a2[3] > 7 )
    v8 = *a2;
  v9 = (__m128i *)sub_1461653F0(v6, v8, (unsigned __int64)a2[2], v7);
  v24 = *v9;
  v14 = (_BYTE *)v24.m128i_i64[0];
  v25 = v9[1];
  v15 = v25;
  v9[1].m128i_i64[0] = 0i64;
  v9[1].m128i_i64[1] = 7i64;
  v9->m128i_i16[0] = 0;
  *(_OWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  v16 = (__int128 *)&v24;
  v17 = v14;
  v18 = _mm_srli_si128(v15, 8).m128i_u64[0];
  if ( v18 > 7 )
    v16 = (__int128 *)v14;
  v19 = 0x7FFFFFFFFFFFFFFEi64;
  if ( v15.m128i_i64[0] > 0x7FFFFFFFFFFFFFFEui64 )
    unknown_libname_4(v11, v10, v12, v13);
  if ( v15.m128i_i64[0] > 7ui64 )
  {
    if ( (v15.m128i_i64[0] | 7ui64) <= 0x7FFFFFFFFFFFFFFEi64 )
    {
      v19 = v15.m128i_i64[0] | 7;
      if ( (v15.m128i_i64[0] | 7ui64) < 0xA )
        v19 = 10i64;
      v20 = v19 + 1;
      if ( (unsigned __int64)(v19 + 1) > 0x7FFFFFFFFFFFFFFFi64 )
        sub_146165390(v20, v10, v12);
    }
    else
    {
      v20 = 0x7FFFFFFFFFFFFFFFi64;
    }
    v21 = sub_14615A5E0(2 * v20);
    *(_QWORD *)a1 = v21;
    *(_QWORD *)(a1 + 16) = v15.m128i_i64[0];
    *(_QWORD *)(a1 + 24) = v19;
    memcpy(v21, v16, 2 * v15.m128i_i64[0] + 2);
  }
  else
  {
    *(_QWORD *)(a1 + 16) = v15.m128i_i64[0];
    *(_QWORD *)(a1 + 24) = 7i64;
    *(_OWORD *)a1 = *v16;
  }
  if ( v18 > 7 )
  {
    if ( 2 * v18 + 2 >= 0x1000 )
    {
      v17 = (_BYTE *)*((_QWORD *)v14 - 1);
      if ( (unsigned __int64)(v14 - v17 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v17);
  }
  if ( si128.m128i_i64[1] > 7ui64 )
  {
    v22 = Block;
    if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
    {
      v22 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v22 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v22);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(Block) = 0;
  sub_146162730((__int64)a2);
  return a1;
}
// 146164618: variable 'v7' is possibly undefined
// 1461647F7: variable 'v11' is possibly undefined
// 1461647F7: variable 'v10' is possibly undefined
// 1461647F7: variable 'v12' is possibly undefined
// 1461647F7: variable 'v13' is possibly undefined
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146164810) ----------------------------------------------------
char *__fastcall sub_146164810(__int64 a1, __int64 a2)
{
  __int64 v3; // rsi
  _QWORD *v4; // rdx
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // rdi
  void *v7; // rax
  _QWORD *v8; // rax
  __int64 v9; // rcx

  if ( a2 )
  {
    v3 = a2 + 7;
    v4 = *(_QWORD **)a1;
    v5 = v3 & 0xFFFFFFFFFFFFFFF8ui64;
    if ( *(_QWORD *)a1 && v5 + v4[1] <= *v4 )
      goto LABEL_11;
    v6 = *(_QWORD *)(a1 + 8);
    if ( v6 <= v5 )
      v6 = v5;
    if ( !*(_QWORD *)(a1 + 24) )
    {
      v7 = operator new(1ui64);
      *(_QWORD *)(a1 + 24) = v7;
      *(_QWORD *)(a1 + 32) = v7;
    }
    if ( v6 != -24i64 )
    {
      v8 = malloc_0(v6 + 24);
      v4 = v8;
      if ( v8 )
      {
        *v8 = v6;
        v8[1] = 0i64;
        v8[2] = *(_QWORD *)a1;
        *(_QWORD *)a1 = v8;
LABEL_11:
        v9 = v4[1];
        v4[1] = v9 + v5;
        return (char *)v4 + v9 + 24;
      }
    }
  }
  return 0i64;
}

//----- (00000001461648D0) ----------------------------------------------------
void __fastcall sub_1461648D0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rsi
  _QWORD *v3; // rdi
  _QWORD *v4; // rcx
  _BYTE *v5; // rcx
  char *v6; // rcx
  char v7; // al

  v1 = *(_QWORD *)(a1 + 32);
  if ( v1 == *(_QWORD *)(a1 + 24) )
  {
    *(_BYTE *)(a1 + 60) = 1;
  }
  else
  {
    v2 = *(_QWORD *)(v1 - 16);
    if ( v2 )
    {
      v3 = *(_QWORD **)a1;
      v4 = *(_QWORD **)a1;
      if ( *(_BYTE *)(v1 - 8) )
      {
        sub_14615A510(v4, 1i64);
        v5 = (_BYTE *)v3[3];
        v3[3] = v5 + 1;
        *v5 = 44;
        ++*(_QWORD *)(v1 - 16);
        return;
      }
      sub_14615A510(v4, 1i64);
      v6 = (char *)v3[3];
      v3[3] = v6 + 1;
      v7 = 58;
      if ( (v2 & 1) == 0 )
        v7 = 44;
      *v6 = v7;
    }
    ++*(_QWORD *)(v1 - 16);
  }
}

//----- (0000000146164980) ----------------------------------------------------
char *__fastcall sub_146164980(char *Src, int a2, int a3, int a4)
{
  __int64 v6; // r14
  int v8; // esi
  char *v9; // rcx
  __int64 v11; // r15
  char *v12; // rbx
  int v13; // ecx
  __int64 v14; // rax
  int v15; // edx
  __int64 v16; // rax
  char *v17; // rcx
  char *v18; // rdx

  v6 = a2;
  v8 = a2 + a3;
  if ( a3 >= 0 && v8 <= 21 )
  {
    if ( a2 < v8 )
    {
      v9 = &Src[a2];
      LOBYTE(a2) = 48;
      memset(v9, a2, a3);
    }
    *(_WORD *)&Src[v8] = 12334;
    return &Src[v8 + 2];
  }
  if ( (unsigned int)(v8 - 1) <= 0x14 )
  {
    v11 = v8 + 1;
    v12 = &Src[v8];
    memmove(&Src[v11], &Src[a2 + a3], -a3);
    *v12 = 46;
    if ( a3 + a4 >= 0 )
      return &Src[(int)v6 + 1];
    v13 = v8 + a4;
    v14 = v8 + a4;
    if ( v14 <= v11 )
      return &Src[v8 + 2];
    while ( Src[v14] == 48 )
    {
      --v13;
      if ( --v14 <= v11 )
        return &Src[v8 + 2];
    }
    return &Src[v13 + 1];
  }
  if ( (unsigned int)v8 >= 0xFFFFFFFB || v8 == 0 )
  {
    memmove(&Src[2 - v8], Src, a2);
    *(_WORD *)Src = 11824;
    if ( 2 - v8 > 2 )
    {
      LOBYTE(v15) = 48;
      memset(Src + 2, v15, -v8);
    }
    if ( (int)v6 - v8 <= a4 )
      return &Src[2 - v8 + (int)v6];
    v13 = a4 + 1;
    v16 = a4 + 1;
    if ( v16 > 2 )
    {
      while ( Src[v16] == 48 )
      {
        --v13;
        if ( --v16 <= 2 )
          return Src + 3;
      }
      return &Src[v13 + 1];
    }
    return Src + 3;
  }
  v17 = Src + 2;
  if ( v8 < -a4 )
  {
    *(_WORD *)Src = 11824;
    *v17 = 48;
    return Src + 3;
  }
  if ( a2 == 1 )
  {
    Src[1] = 101;
    v18 = v17;
  }
  else
  {
    memmove(v17, Src + 1, a2 - 1);
    Src[1] = 46;
    v18 = &Src[(int)v6 + 2];
    Src[v6 + 1] = 101;
  }
  return sub_146165040(v8 - 1, v18);
}
// 146164A85: variable 'v15' is possibly undefined

//----- (0000000146164B40) ----------------------------------------------------
char __fastcall sub_146164B40(_QWORD **a1, unsigned __int8 *a2, unsigned int a3)
{
  _BYTE *v6; // r8
  unsigned __int64 v7; // r10
  __int64 v8; // r9
  bool v9; // zf
  _BYTE *v10; // rax
  char v11; // r8
  char *v12; // rcx
  _BYTE *v13; // rcx
  _BYTE *v14; // rcx
  char *v15; // rcx
  char v16; // r8
  char v17; // r8
  char *v18; // rcx
  _BYTE *v19; // rcx
  char result; // al

  sub_1461648D0((__int64)a1);
  sub_14615A510(*a1, 6 * a3 + 2);
  v6 = (_BYTE *)(*a1)[3];
  (*a1)[3] = v6 + 1;
  *v6 = 34;
  if ( a3 )
  {
    v7 = 0i64;
    do
    {
      v8 = *a2++;
      ++v7;
      v9 = aUuuuuuuubtnufr[v8] == 0;
      v10 = (_BYTE *)(*a1)[3];
      (*a1)[3] = v10 + 1;
      if ( v9 )
      {
        *v10 = v8;
      }
      else
      {
        *v10 = 92;
        v11 = aUuuuuuuubtnufr[v8];
        v12 = (char *)(*a1)[3];
        (*a1)[3] = v12 + 1;
        *v12 = v11;
        if ( aUuuuuuuubtnufr[v8] == 117 )
        {
          v13 = (_BYTE *)(*a1)[3];
          (*a1)[3] = v13 + 1;
          *v13 = 48;
          v14 = (_BYTE *)(*a1)[3];
          (*a1)[3] = v14 + 1;
          *v14 = 48;
          v15 = (char *)(*a1)[3];
          v16 = a0123456789abcd_0[(unsigned __int64)(unsigned int)v8 >> 4];
          (*a1)[3] = v15 + 1;
          *v15 = v16;
          v17 = a0123456789abcd_0[v8 & 0xF];
          v18 = (char *)(*a1)[3];
          (*a1)[3] = v18 + 1;
          *v18 = v17;
        }
      }
    }
    while ( v7 < a3 );
  }
  v19 = (_BYTE *)(*a1)[3];
  (*a1)[3] = v19 + 1;
  result = 1;
  *v19 = 34;
  return result;
}

//----- (0000000146164C90) ----------------------------------------------------
__int64 __fastcall sub_146164C90(char *Str)
{
  __int64 (*ProcAddress)(void); // rax
  HMODULE ModuleHandleW; // rax
  HWND v4; // r14
  unsigned int *v5; // rbx
  _QWORD *v6; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rax
  FILE *v10; // rbx
  void *v11; // r8
  void **v12; // r8
  unsigned int v13; // ebx
  HMODULE LibraryW; // rax
  HMODULE v15; // rbx
  FARPROC v16; // rsi
  void (*v17)(void); // r15
  int v18; // ebx
  size_t v19; // rax
  __int64 v20; // rax
  void *v21; // rcx
  HANDLE CurrentProcess; // rax
  void *v23; // rcx
  __int128 v25; // [rsp+38h] [rbp-39h] BYREF
  __int64 v26; // [rsp+48h] [rbp-29h]
  __int64 v27; // [rsp+50h] [rbp-21h]
  char v28[8]; // [rsp+58h] [rbp-19h] BYREF
  __int64 v29; // [rsp+60h] [rbp-11h]
  void *Block[2]; // [rsp+68h] [rbp-9h] BYREF
  __m128i si128; // [rsp+78h] [rbp+7h]
  void *v32[3]; // [rsp+88h] [rbp+17h] BYREF
  unsigned __int64 v33; // [rsp+A0h] [rbp+2Fh]

  v29 = -2i64;
  ProcAddress = (__int64 (*)(void))qword_14610A968;
  if ( qword_14610A968
    || ((ModuleHandleW = GetModuleHandleW(L"CoreRT.dll")) == 0i64
      ? (ProcAddress = (__int64 (*)(void))qword_14610A968)
      : (__int64 (*)(void))(ProcAddress = GetProcAddress(ModuleHandleW, "CoreGetGameWindow"),
                            qword_14610A968 = (__int64)ProcAddress),
        ProcAddress) )
  {
    v4 = (HWND)ProcAddress();
  }
  else
  {
    v4 = 0i64;
  }
  if ( IsDebuggerPresent() )
    __debugbreak();
  v5 = (unsigned int *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 16i64);
  *(_QWORD *)&v25 = Str;
  *((_QWORD *)&v25 + 1) = strlen(Str);
  sub_146159F90(v32, (__int64)&v25, v5);
  v25 = 0i64;
  v26 = 0i64;
  v27 = 0i64;
  v6 = sub_14615A5E0(0x30ui64);
  *(_QWORD *)&v25 = v6;
  v26 = 23i64;
  v27 = 23i64;
  *(_OWORD *)v6 = xmmword_14611D7B0;
  *((_OWORD *)v6 + 1) = xmmword_14611D7C0;
  v6[4] = 0x6300690070002Di64;
  *((_DWORD *)v6 + 10) = 7667819;
  *((_WORD *)v6 + 22) = 112;
  *((_WORD *)v6 + 23) = 0;
  v9 = sub_1461645B0((__int64)Block, (void **)&v25, v7, v8);
  if ( *(_QWORD *)(v9 + 24) > 7ui64 )
    v9 = *(_QWORD *)v9;
  v10 = wfopen((const wchar_t *)v9, L"wb");
  if ( si128.m128i_i64[1] > 7ui64 )
  {
    v11 = Block[0];
    if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
    {
      v11 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v11 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v11);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(Block[0]) = 0;
  if ( !v10 )
    goto LABEL_22;
  v12 = v32;
  if ( v33 > 0xF )
    v12 = (void **)v32[0];
  sub_1461662A0(v10, "%s", (const char *)v12);
  fclose(v10);
  if ( (unsigned __int8)sub_146193E50() )
  {
    v13 = -1;
  }
  else
  {
LABEL_22:
    LibraryW = LoadLibraryW(L"wtsapi32.dll");
    v15 = LibraryW;
    if ( !LibraryW
      || (v16 = GetProcAddress(LibraryW, "WTSQuerySessionInformationW"),
          v17 = (void (*)(void))GetProcAddress(v15, "WTSFreeMemory"),
          !v16)
      || !((unsigned int (__fastcall *)(_QWORD, __int64, __int64, __int128 *, char *))v16)(
            0i64,
            0xFFFFFFFFi64,
            8i64,
            &v25,
            v28)
      || (v18 = *(_DWORD *)v25, v17(), !v18) )
    {
      v19 = strlen(Str);
      *(_QWORD *)&v25 = Str;
      *((_QWORD *)&v25 + 1) = v19;
      v20 = sub_1461A2C60((__int64)Block, (__int64)&v25);
      if ( *(_QWORD *)(v20 + 24) > 7ui64 )
        v20 = *(_QWORD *)v20;
      MessageBoxW(v4, (LPCWSTR)v20, L"Fatal Error", 0x10u);
      if ( si128.m128i_i64[1] > 7ui64 )
      {
        v21 = Block[0];
        if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
        {
          v21 = (void *)*((_QWORD *)Block[0] - 1);
          if ( (unsigned __int64)(Block[0] - v21 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v21);
      }
    }
    CurrentProcess = GetCurrentProcess();
    TerminateProcess(CurrentProcess, 1u);
    v13 = 0;
  }
  if ( v33 > 0xF )
  {
    v23 = v32[0];
    if ( v33 + 1 >= 0x1000 )
    {
      v23 = (void *)*((_QWORD *)v32[0] - 1);
      if ( (unsigned __int64)(v32[0] - v23 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v23);
  }
  return v13;
}
// 146164DD6: variable 'v7' is possibly undefined
// 146164DD6: variable 'v8' is possibly undefined
// 14610A968: using guessed type __int64 qword_14610A968;
// 14611AE78: using guessed type int TlsIndex;
// 14611D7B0: using guessed type __int128 xmmword_14611D7B0;
// 14611D7C0: using guessed type __int128 xmmword_14611D7C0;
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 146193E50: using guessed type __int64 sub_146193E50(void);
// 146164C90: using guessed type char var_70[8];

//----- (0000000146165040) ----------------------------------------------------
_BYTE *__fastcall sub_146165040(int a1, _BYTE *a2)
{
  _BYTE *v2; // r8
  __int64 v3; // rcx
  _BYTE *result; // rax
  __int64 v5; // rcx

  v2 = a2;
  if ( a1 < 0 )
  {
    v2 = a2 + 1;
    *a2 = 45;
    a1 = -a1;
  }
  if ( a1 < 100 )
  {
    if ( a1 < 10 )
    {
      result = v2 + 1;
      *v2 = a1 + 48;
    }
    else
    {
      v5 = 2 * a1;
      *v2 = byte_14611D650[v5];
      v2[1] = byte_14611D650[v5 + 1];
      return v2 + 2;
    }
  }
  else
  {
    *v2 = a1 / 100 + 48;
    v3 = 2 * (a1 % 100);
    v2[1] = byte_14611D650[v3];
    v2[2] = byte_14611D650[v3 + 1];
    return v2 + 3;
  }
  return result;
}
// 14611D650: using guessed type _BYTE byte_14611D650[200];

//----- (00000001461650D0) ----------------------------------------------------
void __fastcall sub_1461650D0(__int64 a1, void *a2, __int64 a3)
{
  void *v3; // rax

  v3 = a2;
  if ( (unsigned __int64)(2 * a3 + 2) >= 0x1000 )
  {
    if ( (unsigned __int64)a2 - *((_QWORD *)a2 - 1) - 8 > 0x1F )
      invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    v3 = (void *)*((_QWORD *)a2 - 1);
  }
  j_j_free(v3);
}

//----- (0000000146165130) ----------------------------------------------------
__int64 __fastcall sub_146165130(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *v4; // r11
  _QWORD *v6; // rax
  __int64 result; // rax
  _QWORD *v8; // rdx
  __int64 v9; // rax
  __int64 *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rcx
  _QWORD *v13; // r8
  _QWORD *v14; // rcx
  _QWORD *v15; // rcx
  _QWORD *v16; // r8
  __int64 v17; // rax
  _QWORD *v18; // rax
  _QWORD *v19; // r8
  __int64 v20; // rcx
  _QWORD *v21; // rcx
  _QWORD *v22; // rax

  ++a1[1];
  v4 = (_QWORD *)*a1;
  v6 = *(_QWORD **)a2;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)a2;
  if ( v6 == v4 )
  {
    *v4 = a3;
    result = a3;
    v4[1] = a3;
    v4[2] = a3;
    *(_BYTE *)(a3 + 24) = 1;
    return result;
  }
  if ( *(_DWORD *)(a2 + 8) )
  {
    *v6 = a3;
    if ( v6 == (_QWORD *)*v4 )
      *v4 = a3;
  }
  else
  {
    v6[2] = a3;
    if ( v6 == (_QWORD *)v4[2] )
      v4[2] = a3;
  }
  v8 = (_QWORD *)a3;
  while ( !*(_BYTE *)(v8[1] + 24i64) )
  {
    v9 = v8[1];
    v10 = *(__int64 **)(v9 + 8);
    v11 = *v10;
    if ( v9 == *v10 )
    {
      v12 = v10[2];
      if ( *(_BYTE *)(v12 + 24) )
      {
        v13 = *(_QWORD **)(v9 + 16);
        if ( v8 == v13 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)(v9 + 16) = *v13;
          if ( !*(_BYTE *)(*v13 + 25i64) )
            *(_QWORD *)(*v13 + 8i64) = v9;
          v13[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == *(_QWORD *)(*a1 + 8i64) )
          {
            *(_QWORD *)(*a1 + 8i64) = v13;
          }
          else
          {
            v14 = *(_QWORD **)(v9 + 8);
            if ( v9 == *v14 )
              *v14 = v13;
            else
              v14[2] = v13;
          }
          *v13 = v9;
          *(_QWORD *)(v9 + 8) = v13;
        }
        *(_BYTE *)(v8[1] + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8i64) + 24i64) = 0;
        v15 = *(_QWORD **)(v8[1] + 8i64);
        v16 = (_QWORD *)*v15;
        *v15 = *(_QWORD *)(*v15 + 16i64);
        v17 = v16[2];
        if ( !*(_BYTE *)(v17 + 25) )
          *(_QWORD *)(v17 + 8) = v15;
        v16[1] = v15[1];
        if ( v15 == *(_QWORD **)(*a1 + 8i64) )
        {
          *(_QWORD *)(*a1 + 8i64) = v16;
          v16[2] = v15;
        }
        else
        {
          v18 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)v18[2] )
            v18[2] = v16;
          else
            *v18 = v16;
          v16[2] = v15;
        }
LABEL_48:
        v15[1] = v16;
        continue;
      }
      *(_BYTE *)(v9 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8i64) + 24i64) = 0;
      v8 = *(_QWORD **)(v8[1] + 8i64);
    }
    else
    {
      if ( *(_BYTE *)(v11 + 24) )
      {
        v19 = *(_QWORD **)v9;
        if ( v8 == *(_QWORD **)v9 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)v9 = v19[2];
          v20 = v19[2];
          if ( !*(_BYTE *)(v20 + 25) )
            *(_QWORD *)(v20 + 8) = v9;
          v19[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == *(_QWORD *)(*a1 + 8i64) )
          {
            *(_QWORD *)(*a1 + 8i64) = v19;
          }
          else
          {
            v21 = *(_QWORD **)(v9 + 8);
            if ( v9 == v21[2] )
              v21[2] = v19;
            else
              *v21 = v19;
          }
          v19[2] = v9;
          *(_QWORD *)(v9 + 8) = v19;
        }
        *(_BYTE *)(v8[1] + 24i64) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8i64) + 24i64) = 0;
        v15 = *(_QWORD **)(v8[1] + 8i64);
        v16 = (_QWORD *)v15[2];
        v15[2] = *v16;
        if ( !*(_BYTE *)(*v16 + 25i64) )
          *(_QWORD *)(*v16 + 8i64) = v15;
        v16[1] = v15[1];
        if ( v15 == *(_QWORD **)(*a1 + 8i64) )
        {
          *(_QWORD *)(*a1 + 8i64) = v16;
        }
        else
        {
          v22 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)*v22 )
            *v22 = v16;
          else
            v22[2] = v16;
        }
        *v16 = v15;
        goto LABEL_48;
      }
      *(_BYTE *)(v9 + 24) = 1;
      *(_BYTE *)(v11 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8i64) + 24i64) = 0;
      v8 = *(_QWORD **)(v8[1] + 8i64);
    }
  }
  *(_BYTE *)(v4[1] + 24i64) = 1;
  return a3;
}

//----- (0000000146165390) ----------------------------------------------------
void __noreturn sub_146165390()
{
  _QWORD pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_1461623D0(pExceptionObject);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVbad_array_new_length_std__);
}
// 146165390: using guessed type void __noreturn sub_146165390();
// 146165390: using guessed type _QWORD pExceptionObject[5];

//----- (00000001461653F0) ----------------------------------------------------
_QWORD *__fastcall sub_1461653F0(_QWORD *Src, void *a2, unsigned __int64 a3, __int64 a4)
{
  unsigned __int64 v4; // r15
  __int64 v6; // r14
  __int64 v9; // rbp
  _QWORD *v10; // rbx
  __int64 v11; // rbx
  __int64 v12; // rbp
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rdx
  __int64 v15; // rcx
  _QWORD *v16; // rax
  size_t v17; // rsi
  size_t v18; // r8
  _QWORD *v19; // r12
  char *v20; // r14
  _QWORD *v21; // rbx

  v4 = Src[3];
  v6 = Src[2];
  if ( a3 > v4 - v6 )
  {
    v11 = 0x7FFFFFFFFFFFFFFEi64;
    if ( 0x7FFFFFFFFFFFFFFEi64 - v6 < a3 )
      unknown_libname_4(Src, a2, a3, a4);
    v12 = v6 + a3;
    v13 = (v6 + a3) | 7;
    if ( v13 > 0x7FFFFFFFFFFFFFFEi64 || (v14 = v4 >> 1, v4 > 0x7FFFFFFFFFFFFFFEi64 - (v4 >> 1)) )
    {
      v15 = 0x7FFFFFFFFFFFFFFFi64;
    }
    else
    {
      v11 = (v6 + a3) | 7;
      if ( v13 < v4 + v14 )
        v11 = v4 + v14;
      v15 = v11 + 1;
      if ( (unsigned __int64)(v11 + 1) > 0x7FFFFFFFFFFFFFFFi64 )
        sub_146165390();
    }
    v16 = sub_14615A5E0(2 * v15);
    v17 = 2 * a3;
    Src[2] = v12;
    Src[3] = v11;
    v18 = 2 * v6;
    v19 = v16;
    v20 = (char *)v16 + 2 * v6;
    if ( v4 <= 7 )
    {
      memcpy(v16, Src, v18);
      memcpy(v20, a2, v17);
      *((_WORD *)v19 + v12) = 0;
    }
    else
    {
      v21 = (_QWORD *)*Src;
      memcpy(v16, (const void *)*Src, v18);
      memcpy(v20, a2, v17);
      *((_WORD *)v19 + v12) = 0;
      sub_1461650D0((__int64)Src, v21, v4);
    }
    *Src = v19;
  }
  else
  {
    v9 = v6 + a3;
    v10 = Src;
    Src[2] = v6 + a3;
    if ( v4 > 7 )
      v10 = (_QWORD *)*Src;
    memmove((char *)v10 + 2 * v6, a2, 2 * a3);
    *((_WORD *)v10 + v9) = 0;
  }
  return Src;
}
// 146165390: using guessed type void __noreturn sub_146165390(void);
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146165560) ----------------------------------------------------
__int64 __fastcall sub_146165560(unsigned __int64 a1)
{
  unsigned __int64 v1; // rax
  __int64 v2; // rax
  __int64 v4; // [rsp+0h] [rbp-59h]
  __int64 v5; // [rsp+8h] [rbp-51h]
  __int64 v6; // [rsp+10h] [rbp-49h]
  __int64 v7; // [rsp+18h] [rbp-41h]
  __int64 v8; // [rsp+20h] [rbp-39h]
  __int64 v9; // [rsp+28h] [rbp-31h]
  __int64 v10; // [rsp+30h] [rbp-29h]
  __int64 v11; // [rsp+38h] [rbp-21h]
  __int64 v12; // [rsp+40h] [rbp-19h]
  __int64 v13; // [rsp+48h] [rbp-11h]
  __int64 v14; // [rsp+50h] [rbp-9h]
  __int64 v15; // [rsp+58h] [rbp-1h]
  __int64 v16; // [rsp+60h] [rbp+7h]
  __int64 v17; // [rsp+68h] [rbp+Fh]
  __int64 v18; // [rsp+70h] [rbp+17h]
  __int64 v19; // [rsp+78h] [rbp+1Fh]
  __int64 v20; // [rsp+80h] [rbp+27h]
  __int64 v21; // [rsp+88h] [rbp+2Fh]
  __int64 v22; // [rsp+90h] [rbp+37h]
  __int64 v23; // [rsp+98h] [rbp+3Fh]
  __int64 v24; // [rsp+A0h] [rbp+47h]

  v4 = 0x2000100010001i64;
  v5 = 0x3000300020002i64;
  _BitScanReverse64(&v1, a1 | 1);
  v6 = 0x4000400040003i64;
  v7 = 0x5000500050004i64;
  v8 = 0x7000600060006i64;
  v9 = 0x8000700070007i64;
  v10 = 0x9000900080008i64;
  v11 = 0xA000A000A0009i64;
  v12 = 0xB000B000B000Ai64;
  v13 = 0xD000C000C000Ci64;
  v14 = 0xE000D000D000Di64;
  v15 = 0xF000F000E000Ei64;
  v16 = 0x1000100010000Fi64;
  v17 = 0x11001100110010i64;
  v18 = 0x13001200120012i64;
  v19 = 0x14001300130013i64;
  v2 = *((unsigned __int16 *)&v4 + (int)v1);
  v15 = 10000000000i64;
  v16 = 100000000000i64;
  v17 = 1000000000000i64;
  v18 = 10000000000000i64;
  v19 = 100000000000000i64;
  v20 = 1000000000000000i64;
  v21 = 10000000000000000i64;
  v22 = 100000000000000000i64;
  v23 = 1000000000000000000i64;
  v4 = 0i64;
  v5 = 0i64;
  v24 = 0x8AC7230489E80000ui64;
  v6 = 10i64;
  v7 = 100i64;
  v8 = 1000i64;
  v9 = 10000i64;
  v10 = 100000i64;
  v11 = 1000000i64;
  v12 = 10000000i64;
  v13 = 100000000i64;
  v14 = 1000000000i64;
  return (unsigned int)v2 - (a1 < *(&v4 + v2));
}

//----- (0000000146165760) ----------------------------------------------------
void __fastcall sub_146165760(_QWORD *a1, size_t a2)
{
  unsigned __int64 v2; // r14
  _QWORD *v4; // rbp
  size_t v5; // rdi
  _QWORD *v6; // rbx

  v2 = a1[3];
  v4 = (_QWORD *)a1[1];
  v5 = v2 + (v2 >> 1);
  if ( a2 > v5 )
    v5 = a2;
  v6 = sub_14615A5E0(v5);
  memmove(v6, v4, a1[2]);
  a1[1] = v6;
  a1[3] = v5;
  if ( v4 != a1 + 4 )
  {
    if ( v2 >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - *(v4 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v4 = (_QWORD *)*(v4 - 1);
    }
    j_j_free(v4);
  }
}

//----- (0000000146165830) ----------------------------------------------------
_BYTE *__fastcall sub_146165830(unsigned int a1, _BYTE *a2)
{
  _BYTE *v2; // r8
  __int64 v4; // r9
  __int64 v5; // rcx
  __int64 v7; // rbx
  __int64 v8; // rcx
  __int64 v9; // rdi
  __int64 v10; // r9
  _BYTE *v11; // rbx
  unsigned int v12; // edx
  unsigned int v13; // r10d
  __int64 v14; // rcx
  unsigned int v15; // ecx
  unsigned int v16; // r10d
  __int64 v17; // r8
  __int64 v18; // rcx
  __int64 v19; // r9
  __int64 v20; // rdx

  v2 = a2;
  if ( a1 < 0x2710 )
  {
    v4 = 2 * (a1 / 0x64);
    v5 = 2 * (a1 % 0x64);
    if ( a1 < 0x3E8 )
    {
      if ( a1 < 0x64 )
      {
        if ( a1 < 0xA )
        {
LABEL_8:
          *v2 = byte_14611D650[(unsigned int)(v5 + 1)];
          return v2 + 1;
        }
      }
      else
      {
        *a2 = byte_14611D650[(unsigned int)(v4 + 1)];
        v2 = a2 + 1;
      }
    }
    else
    {
      *a2 = byte_14611D650[v4];
      a2[1] = byte_14611D650[(unsigned int)(v4 + 1)];
      v2 = a2 + 2;
    }
    *v2++ = byte_14611D650[v5];
    goto LABEL_8;
  }
  if ( a1 < 0x5F5E100 )
  {
    v7 = 2 * (a1 / 0x2710 / 0x64);
    v8 = 2 * (a1 / 0x2710 % 0x64);
    v9 = 2 * (a1 % 0x2710 / 0x64);
    v10 = 2 * (a1 % 0x2710 % 0x64);
    if ( a1 < 0x989680 )
    {
      if ( a1 < 0xF4240 )
      {
        if ( a1 < 0x186A0 )
        {
LABEL_16:
          *v2 = byte_14611D650[(unsigned int)(v8 + 1)];
          v2[1] = byte_14611D650[v9];
          v2[2] = byte_14611D650[(unsigned int)(v9 + 1)];
          v2[3] = byte_14611D650[v10];
          v2[4] = byte_14611D650[(unsigned int)(v10 + 1)];
          return v2 + 5;
        }
      }
      else
      {
        *a2 = byte_14611D650[(unsigned int)(v7 + 1)];
        v2 = a2 + 1;
      }
    }
    else
    {
      *a2 = byte_14611D650[v7];
      a2[1] = byte_14611D650[(unsigned int)(v7 + 1)];
      v2 = a2 + 2;
    }
    *v2++ = byte_14611D650[v8];
    goto LABEL_16;
  }
  v11 = a2 + 1;
  v12 = a1 / 0x5F5E100;
  v13 = a1 % 0x5F5E100;
  if ( a1 / 0x5F5E100 < 0xA )
  {
    *v2 = v12 + 48;
  }
  else
  {
    v14 = 2 * v12;
    *v2 = byte_14611D650[v14];
    *v11 = byte_14611D650[(unsigned int)(v14 + 1)];
    v11 = v2 + 2;
  }
  v15 = v13 / 0x2710;
  v16 = v13 % 0x2710;
  v17 = 2 * (v15 / 0x64);
  v18 = 2 * (v15 % 0x64);
  v19 = 2 * (v16 / 0x64);
  *v11 = byte_14611D650[v17];
  v20 = 2 * (v16 % 0x64);
  v11[1] = byte_14611D650[(unsigned int)(v17 + 1)];
  v11[2] = byte_14611D650[v18];
  v11[3] = byte_14611D650[(unsigned int)(v18 + 1)];
  v11[4] = byte_14611D650[v19];
  v11[5] = byte_14611D650[(unsigned int)(v19 + 1)];
  v11[6] = byte_14611D650[v20];
  v11[7] = byte_14611D650[(unsigned int)(v20 + 1)];
  return v11 + 8;
}
// 14611D650: using guessed type _BYTE byte_14611D650[200];

//----- (0000000146165A90) ----------------------------------------------------
_BYTE *__fastcall sub_146165A90(unsigned __int64 a1, _BYTE *a2)
{
  _BYTE *v2; // r9
  __int64 v3; // r8
  __int64 v4; // rdx
  _BYTE *v5; // r9
  __int64 v7; // r11
  __int64 v8; // r8
  __int64 v9; // rbx
  __int64 v10; // r10
  unsigned int v11; // r10d
  unsigned int v12; // r11d
  unsigned int v13; // r8d
  __int64 v14; // rdi
  __int64 v15; // r11
  __int64 v16; // rbp
  __int64 v17; // r8
  unsigned int v18; // ebx
  __int64 v19; // r14
  __int64 v20; // rbx
  __int64 v21; // r15
  __int64 v22; // r10
  _BYTE *v23; // r14
  unsigned __int64 v24; // rbp
  unsigned __int64 v25; // r10
  __int64 v26; // rcx
  unsigned int v27; // edx
  __int64 v28; // r8
  __int64 v29; // rbx
  __int64 v30; // rcx
  unsigned __int64 v31; // r8
  unsigned int v32; // ebp
  unsigned int v33; // ecx
  __int64 v34; // r9
  __int64 v35; // r10
  __int64 v36; // r11
  __int64 v37; // rbx
  unsigned int v38; // ecx
  __int64 v39; // r8
  __int64 v40; // rcx
  __int64 v41; // rdi
  __int64 v42; // rdx

  v2 = a2;
  if ( a1 < 0x5F5E100 )
  {
    if ( (unsigned int)a1 < 0x2710 )
    {
      v3 = 2 * ((unsigned int)a1 / 0x64);
      v4 = 2 * ((unsigned int)a1 % 0x64);
      if ( (unsigned int)a1 < 0x3E8 )
      {
        if ( (unsigned int)a1 < 0x64 )
        {
          if ( (unsigned int)a1 < 0xA )
          {
LABEL_9:
            *v2 = byte_14611D650[(unsigned int)(v4 + 1)];
            return v2 + 1;
          }
        }
        else
        {
          *v2++ = byte_14611D650[(unsigned int)(v3 + 1)];
        }
      }
      else
      {
        *v2 = byte_14611D650[v3];
        v5 = v2 + 1;
        *v5 = byte_14611D650[(unsigned int)(v3 + 1)];
        v2 = v5 + 1;
      }
      *v2++ = byte_14611D650[v4];
      goto LABEL_9;
    }
    v7 = 2 * ((unsigned int)a1 / 0x2710 / 0x64);
    v8 = 2 * ((unsigned int)a1 / 0x2710 % 0x64);
    v9 = 2 * ((unsigned int)a1 % 0x2710 / 0x64);
    v10 = 2 * ((unsigned int)a1 % 0x2710 % 0x64);
    if ( a1 < 0x989680 )
    {
      if ( a1 < 0xF4240 )
      {
        if ( a1 < 0x186A0 )
        {
LABEL_16:
          *v2 = byte_14611D650[(unsigned int)(v8 + 1)];
          v2[1] = byte_14611D650[v9];
          v2[2] = byte_14611D650[(unsigned int)(v9 + 1)];
          v2[3] = byte_14611D650[v10];
          v2[4] = byte_14611D650[(unsigned int)(v10 + 1)];
          return v2 + 5;
        }
      }
      else
      {
        *a2 = byte_14611D650[(unsigned int)(v7 + 1)];
        v2 = a2 + 1;
      }
    }
    else
    {
      *a2 = byte_14611D650[v7];
      a2[1] = byte_14611D650[(unsigned int)(v7 + 1)];
      v2 = a2 + 2;
    }
    *v2++ = byte_14611D650[v8];
    goto LABEL_16;
  }
  if ( a1 < 0x2386F26FC10000i64 )
  {
    v11 = a1 % 0x5F5E100;
    v12 = (unsigned int)(a1 / 0x5F5E100) / 0x2710;
    v13 = (unsigned int)(a1 / 0x5F5E100) % 0x2710;
    v14 = 2 * (v12 / 0x64);
    v15 = 2 * (v12 % 0x64);
    v16 = 2 * (v13 / 0x64);
    v17 = 2 * (v13 % 0x64);
    v18 = v11 / 0x2710;
    v11 %= 0x2710u;
    v19 = 2 * (v18 / 0x64);
    v20 = 2 * (v18 % 0x64);
    v21 = 2 * (v11 / 0x64);
    v22 = 2 * (v11 % 0x64);
    if ( a1 < 0x38D7EA4C68000i64 )
    {
      if ( a1 < 0x5AF3107A4000i64 )
      {
        if ( a1 < 0x9184E72A000i64 )
        {
          if ( a1 < 0xE8D4A51000i64 )
          {
            if ( a1 < 0x174876E800i64 )
            {
              if ( a1 < 0x2540BE400i64 )
              {
                if ( a1 < 0x3B9ACA00 )
                {
LABEL_32:
                  *v2 = byte_14611D650[(unsigned int)(v17 + 1)];
                  v2[1] = byte_14611D650[v19];
                  v2[2] = byte_14611D650[(unsigned int)(v19 + 1)];
                  v2[3] = byte_14611D650[v20];
                  v2[4] = byte_14611D650[(unsigned int)(v20 + 1)];
                  v2[5] = byte_14611D650[v21];
                  v2[6] = byte_14611D650[(unsigned int)(v21 + 1)];
                  v2[7] = byte_14611D650[v22];
                  v2[8] = byte_14611D650[(unsigned int)(v22 + 1)];
                  return v2 + 9;
                }
              }
              else
              {
                *a2 = byte_14611D650[(unsigned int)(v16 + 1)];
                v2 = a2 + 1;
              }
            }
            else
            {
              *a2 = byte_14611D650[v16];
              a2[1] = byte_14611D650[(unsigned int)(v16 + 1)];
              v2 = a2 + 2;
            }
          }
          else
          {
            *a2 = byte_14611D650[(unsigned int)(v15 + 1)];
            a2[1] = byte_14611D650[v16];
            a2[2] = byte_14611D650[(unsigned int)(v16 + 1)];
            v2 = a2 + 3;
          }
        }
        else
        {
          *a2 = byte_14611D650[v15];
          a2[1] = byte_14611D650[(unsigned int)(v15 + 1)];
          a2[2] = byte_14611D650[v16];
          a2[3] = byte_14611D650[(unsigned int)(v16 + 1)];
          v2 = a2 + 4;
        }
      }
      else
      {
        *a2 = byte_14611D650[(unsigned int)(v14 + 1)];
        a2[1] = byte_14611D650[v15];
        a2[2] = byte_14611D650[(unsigned int)(v15 + 1)];
        a2[3] = byte_14611D650[v16];
        a2[4] = byte_14611D650[(unsigned int)(v16 + 1)];
        v2 = a2 + 5;
      }
    }
    else
    {
      *a2 = byte_14611D650[v14];
      a2[1] = byte_14611D650[(unsigned int)(v14 + 1)];
      a2[2] = byte_14611D650[v15];
      a2[3] = byte_14611D650[(unsigned int)(v15 + 1)];
      a2[4] = byte_14611D650[v16];
      a2[5] = byte_14611D650[(unsigned int)(v16 + 1)];
      v2 = a2 + 6;
    }
    *v2++ = byte_14611D650[v17];
    goto LABEL_32;
  }
  v23 = a2 + 1;
  v24 = a1 % 0x2386F26FC10000i64;
  v25 = a1 / 0x2386F26FC10000i64;
  if ( (unsigned int)(a1 / 0x2386F26FC10000i64) >= 0xA )
  {
    if ( (unsigned int)v25 >= 0x64 )
    {
      v27 = (unsigned int)v25 / 0x64;
      v28 = 2 * ((unsigned int)v25 % 0x64);
      v29 = (unsigned int)(v28 + 1);
      if ( (unsigned int)v25 >= 0x3E8 )
      {
        v30 = 2 * v27;
        *v2 = byte_14611D650[v30];
        *v23 = byte_14611D650[(unsigned int)(v30 + 1)];
        v2[2] = byte_14611D650[v28];
        v2[3] = byte_14611D650[v29];
        v23 = v2 + 4;
      }
      else
      {
        *v2 = v27 + 48;
        *v23 = byte_14611D650[v28];
        v2[2] = byte_14611D650[v29];
        v23 = v2 + 3;
      }
    }
    else
    {
      v26 = 2 * (unsigned int)(a1 / 0x2386F26FC10000i64);
      *a2 = byte_14611D650[v26];
      *v23 = byte_14611D650[(unsigned int)(v26 + 1)];
      v23 = a2 + 2;
    }
  }
  else
  {
    *a2 = v25 + 48;
  }
  v31 = v24 / 0x5F5E100;
  v32 = v24 % 0x5F5E100;
  v33 = (unsigned int)v31 / 0x2710;
  LODWORD(v31) = (unsigned int)v31 % 0x2710;
  v34 = 2 * (v33 / 0x64);
  v35 = 2 * (v33 % 0x64);
  v36 = 2 * ((unsigned int)v31 / 0x64);
  v37 = 2 * ((unsigned int)v31 % 0x64);
  v38 = v32 / 0x2710;
  v32 %= 0x2710u;
  v39 = 2 * (v38 / 0x64);
  v40 = 2 * (v38 % 0x64);
  v41 = 2 * (v32 / 0x64);
  *v23 = byte_14611D650[v34];
  v42 = 2 * (v32 % 0x64);
  v23[1] = byte_14611D650[(unsigned int)(v34 + 1)];
  v23[2] = byte_14611D650[v35];
  v23[3] = byte_14611D650[(unsigned int)(v35 + 1)];
  v23[4] = byte_14611D650[v36];
  v23[5] = byte_14611D650[(unsigned int)(v36 + 1)];
  v23[6] = byte_14611D650[v37];
  v23[7] = byte_14611D650[(unsigned int)(v37 + 1)];
  v23[8] = byte_14611D650[v39];
  v23[9] = byte_14611D650[(unsigned int)(v39 + 1)];
  v23[10] = byte_14611D650[v40];
  v23[11] = byte_14611D650[(unsigned int)(v40 + 1)];
  v23[12] = byte_14611D650[v41];
  v23[13] = byte_14611D650[(unsigned int)(v41 + 1)];
  v23[14] = byte_14611D650[v42];
  v23[15] = byte_14611D650[(unsigned int)(v42 + 1)];
  return v23 + 16;
}
// 14611D650: using guessed type _BYTE byte_14611D650[200];

//----- (00000001461660E0) ----------------------------------------------------
const char *__fastcall sub_1461660E0(__int64 a1)
{
  const char *result; // rax

  result = "Unknown exception";
  if ( *(_QWORD *)(a1 + 8) )
    return *(const char **)(a1 + 8);
  return result;
}

//----- (0000000146166100) ----------------------------------------------------
__int64 *__fastcall sub_146166100(__int64 *a1, __int64 *a2, char a3)
{
  __int64 v3; // rax
  const char *v4; // rbx
  size_t v7; // rax
  __int64 v8; // rdx
  __int64 v10[2]; // [rsp+30h] [rbp-38h] BYREF
  __int128 v11; // [rsp+40h] [rbp-28h] BYREF
  __int64 v12; // [rsp+50h] [rbp-18h]

  v3 = a1[1];
  v4 = "(nil)";
  v11 = *(_OWORD *)v3;
  if ( a3 )
    v4 = "(null)";
  v12 = *(_QWORD *)(v3 + 16);
  BYTE8(v11) = 0;
  v7 = strlen(v4);
  v8 = *a1;
  v10[0] = (__int64)v4;
  v10[1] = v7;
  sub_146160390(a2, v8, (char *)&v11, v7, v7, (__int64)v10);
  return a2;
}

//----- (00000001461661B0) ----------------------------------------------------
__int64 GetErrorData()
{
  __int64 v0; // rdi
  _QWORD *v1; // rbx
  int v2; // eax

  v0 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v1 = (_QWORD *)(v0 + 48);
  v2 = *(_DWORD *)(v0 + 136);
  if ( (v2 & 1) == 0 )
  {
    *(_BYTE *)(v0 + 56) = 0;
    *(_DWORD *)(v0 + 136) = v2 | 1;
    *(_OWORD *)(v0 + 64) = 0i64;
    *(_QWORD *)(v0 + 88) = 15i64;
    *(_QWORD *)(v0 + 80) = 0i64;
    *(_BYTE *)(v0 + 64) = 0;
    *(_BYTE *)(v0 + 96) = 0;
    *(_OWORD *)(v0 + 104) = 0i64;
    *(_QWORD *)(v0 + 120) = 0i64;
    *(_QWORD *)(v0 + 128) = 15i64;
    *(_BYTE *)(v0 + 104) = 0;
    _tlregdtor(sub_1461AE280);
  }
  if ( !*v1 )
  {
    if ( dword_14610A970 > *(_DWORD *)(v0 + 380) )
    {
      sub_1461A7CF4(&dword_14610A970);
      if ( dword_14610A970 == -1 )
      {
        atexit(sub_1461AE260);
        Init_thread_footer(&dword_14610A970);
      }
    }
    *v1 = &unk_146106000;
  }
  return v0 + 48;
}
// 14610A970: using guessed type int dword_14610A970;
// 14611AE78: using guessed type int TlsIndex;
// 1461661B0: using guessed type __int64 GetErrorData();
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);
// 1461A7E18: using guessed type __int64 __fastcall _tlregdtor(_QWORD);

//----- (0000000146166290) ----------------------------------------------------
void *sub_146166290()
{
  return &unk_14610A950;
}

//----- (00000001461662A0) ----------------------------------------------------
int sub_1461662A0(FILE *Stream, char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_146166290();
  return _stdio_common_vfprintf(*v4, Stream, Format, 0i64, va);
}

//----- (00000001461662F0) ----------------------------------------------------
void (__fastcall *__fastcall sub_1461662F0(HMODULE a1, const char *a2))(struct _STARTUPINFOW *a1)
{
  return sub_146166F00(0i64, a1, a2);
}

//----- (0000000146166320) ----------------------------------------------------
__int64 __fastcall sub_146166320(__int64 a1, __int64 a2)
{
  __m128i si128; // xmm6
  char *v4; // rcx
  __int64 v5; // rbx
  char *v6; // rax
  void *v7; // rcx
  void *v8; // rcx
  void *Block[2]; // [rsp+48h] [rbp-49h] BYREF
  __m128i v11; // [rsp+58h] [rbp-39h]
  __int128 v12; // [rsp+68h] [rbp-29h]
  __m128i v13; // [rsp+78h] [rbp-19h]
  char *v14; // [rsp+90h] [rbp-1h]
  __int128 v15; // [rsp+98h] [rbp+7h]
  char v16; // [rsp+A8h] [rbp+17h]
  __int64 v17; // [rsp+B0h] [rbp+1Fh]
  __int64 v18; // [rsp+B8h] [rbp+27h]

  *(_OWORD *)Block = 0i64;
  si128 = _mm_load_si128((const __m128i *)&Size);
  v11 = si128;
  LOBYTE(Block[0]) = 0;
  v12 = 0i64;
  v13 = si128;
  LOBYTE(v12) = 0;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0;
  v17 = qword_14611AD18 + 0x140000000i64;
  v18 = 0i64;
  sub_1461A4170((__int64)Block, a1, 44i64);
  sub_1461A3C40((__int64)Block, 1u);
  v4 = v14;
  if ( (((_QWORD)v15 - (_QWORD)v14) & 0xFFFFFFFFFFFFFFF8ui64) != 8 )
  {
    sub_1461A1C30(
      (wchar_t *)L"m_matches.size() == expected",
      (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\code\\client\\shared\\Hooking.Patterns.h",
      125);
    v4 = v14;
  }
  v5 = *(_QWORD *)v4;
  if ( v4 )
  {
    v6 = v4;
    if ( ((*((_QWORD *)&v15 + 1) - (_QWORD)v4) & 0xFFFFFFFFFFFFFFF8ui64) >= 0x1000 )
    {
      v4 = (char *)*((_QWORD *)v4 - 1);
      if ( (unsigned __int64)(v6 - v4 - 8) > 0x1F )
        goto LABEL_14;
    }
    j_j_free(v4);
    v14 = 0i64;
    v15 = 0i64;
    si128 = _mm_load_si128((const __m128i *)&Size);
  }
  if ( v13.m128i_i64[1] <= 0xFui64 )
    goto LABEL_11;
  v7 = (void *)v12;
  if ( (unsigned __int64)(v13.m128i_i64[1] + 1) >= 0x1000 )
  {
    v7 = *(void **)(v12 - 8);
    if ( (unsigned __int64)(v12 - (_QWORD)v7 - 8) > 0x1F )
LABEL_14:
      invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
  }
  j_j_free(v7);
  si128 = _mm_load_si128((const __m128i *)&Size);
LABEL_11:
  v13 = si128;
  LOBYTE(v12) = 0;
  if ( v11.m128i_i64[1] > 0xFui64 )
  {
    v8 = Block[0];
    if ( (unsigned __int64)(v11.m128i_i64[1] + 1) >= 0x1000 )
    {
      v8 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v8 - 8) > 0x1F )
        goto LABEL_14;
    }
    j_j_free(v8);
  }
  return v5 + a2;
}
// 14611AD18: using guessed type __int64 qword_14611AD18;
// 146166320: using guessed type __m128i var_70;

//----- (0000000146166510) ----------------------------------------------------
__int64 __fastcall sub_146166510(__int64 a1, __int64 a2)
{
  __m128i si128; // xmm6
  char *v4; // rcx
  __int64 v5; // rbx
  char *v6; // rax
  void *v7; // rcx
  void *v8; // rcx
  void *Block[2]; // [rsp+48h] [rbp-49h] BYREF
  __m128i v11; // [rsp+58h] [rbp-39h]
  __int128 v12; // [rsp+68h] [rbp-29h]
  __m128i v13; // [rsp+78h] [rbp-19h]
  char *v14; // [rsp+90h] [rbp-1h]
  __int128 v15; // [rsp+98h] [rbp+7h]
  char v16; // [rsp+A8h] [rbp+17h]
  __int64 v17; // [rsp+B0h] [rbp+1Fh]
  __int64 v18; // [rsp+B8h] [rbp+27h]

  *(_OWORD *)Block = 0i64;
  si128 = _mm_load_si128((const __m128i *)&Size);
  v11 = si128;
  LOBYTE(Block[0]) = 0;
  v12 = 0i64;
  v13 = si128;
  LOBYTE(v12) = 0;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0;
  v17 = qword_14611AD18 + 0x140000000i64;
  v18 = 0i64;
  sub_1461A4170((__int64)Block, a1, 49i64);
  sub_1461A3C40((__int64)Block, 1u);
  v4 = v14;
  if ( (((_QWORD)v15 - (_QWORD)v14) & 0xFFFFFFFFFFFFFFF8ui64) != 8 )
  {
    sub_1461A1C30(
      (wchar_t *)L"m_matches.size() == expected",
      (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\code\\client\\shared\\Hooking.Patterns.h",
      125);
    v4 = v14;
  }
  v5 = *(_QWORD *)v4;
  if ( v4 )
  {
    v6 = v4;
    if ( ((*((_QWORD *)&v15 + 1) - (_QWORD)v4) & 0xFFFFFFFFFFFFFFF8ui64) >= 0x1000 )
    {
      v4 = (char *)*((_QWORD *)v4 - 1);
      if ( (unsigned __int64)(v6 - v4 - 8) > 0x1F )
        goto LABEL_14;
    }
    j_j_free(v4);
    v14 = 0i64;
    v15 = 0i64;
    si128 = _mm_load_si128((const __m128i *)&Size);
  }
  if ( v13.m128i_i64[1] <= 0xFui64 )
    goto LABEL_11;
  v7 = (void *)v12;
  if ( (unsigned __int64)(v13.m128i_i64[1] + 1) >= 0x1000 )
  {
    v7 = *(void **)(v12 - 8);
    if ( (unsigned __int64)(v12 - (_QWORD)v7 - 8) > 0x1F )
LABEL_14:
      invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
  }
  j_j_free(v7);
  si128 = _mm_load_si128((const __m128i *)&Size);
LABEL_11:
  v13 = si128;
  LOBYTE(v12) = 0;
  if ( v11.m128i_i64[1] > 0xFui64 )
  {
    v8 = Block[0];
    if ( (unsigned __int64)(v11.m128i_i64[1] + 1) >= 0x1000 )
    {
      v8 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v8 - 8) > 0x1F )
        goto LABEL_14;
    }
    j_j_free(v8);
  }
  return v5 + a2;
}
// 14611AD18: using guessed type __int64 qword_14611AD18;
// 146166510: using guessed type __m128i var_70;

//----- (0000000146166700) ----------------------------------------------------
__int64 __fastcall sub_146166700(__int64 a1, __int64 *a2)
{
  __int64 v4; // r15
  int v5; // eax
  _OWORD *v6; // rsi
  int v7; // eax
  const char *v8; // rbx
  size_t v9; // r8
  __int64 v10; // rdx
  __int64 v11; // r9
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // rax
  _BYTE *v15; // rcx
  const char *v16; // rax
  __int64 lpName; // rax
  _BYTE *v18; // rcx
  void *v19; // rcx
  DWORD LastError; // ebx
  LPVOID v21; // rax
  const char *v23; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v24; // [rsp+50h] [rbp-B8h]
  __int128 v25; // [rsp+68h] [rbp-A0h] BYREF
  _QWORD v26[3]; // [rsp+78h] [rbp-90h] BYREF
  __int128 v27; // [rsp+90h] [rbp-78h]
  void *v28; // [rsp+A0h] [rbp-68h] BYREF
  __m128i si128; // [rsp+B0h] [rbp-58h]
  __int64 v30[7]; // [rsp+C0h] [rbp-48h] BYREF
  void **v31; // [rsp+F8h] [rbp-10h] BYREF
  void *Block; // [rsp+100h] [rbp-8h]
  size_t v33; // [rsp+108h] [rbp+0h]
  unsigned __int64 v34; // [rsp+110h] [rbp+8h]
  char v35[512]; // [rsp+118h] [rbp+10h] BYREF

  v26[0] = -2i64;
  *(_QWORD *)(a1 + 8) = &unk_146106050;
  v4 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v5 = *(_DWORD *)(v4 + 312);
  v6 = (_OWORD *)(v4 + 280);
  if ( (v5 & 1) == 0 )
  {
    *(_DWORD *)(v4 + 312) = v5 | 1;
    *v6 = 0i64;
    *(_QWORD *)(v4 + 296) = 4i64;
    *(_QWORD *)(v4 + 304) = 15i64;
    strcpy((char *)(v4 + 280), "Five");
    _tlregdtor(qword_1461AE4D0);
  }
  v7 = *(_DWORD *)(v4 + 272);
  if ( (v7 & 1) == 0 )
  {
    *(_DWORD *)(v4 + 272) = v7 | 1;
    v8 = sub_146166FF0();
    *(_OWORD *)(v4 + 240) = 0i64;
    *(_QWORD *)(v4 + 256) = 0i64;
    *(_QWORD *)(v4 + 264) = 0i64;
    v9 = strlen(v8);
    sub_14615A650((_QWORD *)(v4 + 240), v8, v9);
    _tlregdtor(qword_1461AE4B0);
  }
  v10 = v4 + 240;
  if ( *(_QWORD *)(v4 + 264) > 0xFui64 )
    v10 = *(_QWORD *)(v4 + 240);
  v11 = *(_QWORD *)(v4 + 256);
  v12 = v4 + 280;
  if ( *(_QWORD *)(v4 + 304) > 0xFui64 )
    v12 = *(_QWORD *)v6;
  v13 = *(_QWORD *)(v4 + 296);
  v14 = (__int64)a2;
  if ( (unsigned __int64)a2[3] > 0xF )
    v14 = *a2;
  v30[0] = v10;
  v30[1] = v11;
  v30[2] = v12;
  v30[3] = v13;
  v30[4] = v14;
  v30[5] = a2[2];
  v33 = 0i64;
  v31 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  Block = v35;
  v34 = 500i64;
  *(_QWORD *)&v25 = 3549i64;
  *((_QWORD *)&v25 + 1) = v30;
  v23 = "CFX_%s_%s_SharedData_%s";
  v24 = 23i64;
  sub_14615CF80((__int64)&v31, (__int64)&v23, &v25);
  *(_OWORD *)&v26[1] = 0i64;
  v27 = 0i64;
  sub_14615A650(&v26[1], Block, v33);
  v31 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  v15 = Block;
  if ( Block != v35 )
  {
    if ( v34 >= 0x1000 )
    {
      v15 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v15 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v15);
  }
  v16 = (const char *)&v26[1];
  if ( *((_QWORD *)&v27 + 1) > 0xFui64 )
    v16 = (const char *)v26[1];
  v23 = v16;
  v24 = v27;
  lpName = sub_1461A2C60((__int64)&v28, (__int64)&v23);
  if ( *(_QWORD *)(lpName + 24) > 7ui64 )
    lpName = *(_QWORD *)lpName;
  *(_QWORD *)a1 = CreateFileMappingW((HANDLE)0xFFFFFFFFFFFFFFFFi64, 0i64, 4u, 0, 0x3050u, (LPCWSTR)lpName);
  if ( si128.m128i_i64[1] > 7ui64 )
  {
    v18 = v28;
    if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
    {
      v18 = (_BYTE *)*((_QWORD *)v28 - 1);
      if ( (unsigned __int64)((_BYTE *)v28 - v18 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v18);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(v28) = 0;
  if ( *((_QWORD *)&v27 + 1) > 0xFui64 )
  {
    v19 = (void *)v26[1];
    if ( (unsigned __int64)(*((_QWORD *)&v27 + 1) + 1i64) >= 0x1000 )
    {
      v19 = *(void **)(v26[1] - 8i64);
      if ( (unsigned __int64)(v26[1] - (_QWORD)v19 - 8i64) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v19);
  }
  if ( *(_QWORD *)a1 )
  {
    LastError = GetLastError();
    v21 = MapViewOfFile(*(HANDLE *)a1, 0xF001Fu, 0, 0, 0x3050ui64);
    *(_QWORD *)(a1 + 8) = v21;
    if ( LastError != 183 )
      *(_QWORD *)(a1 + 8) = sub_146166BD0((__int64)v21);
  }
  return a1;
}
// 14611AE78: using guessed type int TlsIndex;
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 1461A7E18: using guessed type __int64 __fastcall _tlregdtor(_QWORD);
// 1461AE4B0: using guessed type __int64 qword_1461AE4B0[4];
// 1461AE4D0: using guessed type __int64 qword_1461AE4D0[4];

//----- (0000000146166AC0) ----------------------------------------------------
_QWORD *__fastcall sub_146166AC0(_QWORD *a1, wchar_t *String)
{
  size_t v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rbp
  size_t v10; // rbx
  __int64 v11; // rbx
  unsigned __int64 v12; // rax
  __int64 v13; // rcx
  _QWORD *v14; // rax
  size_t v15; // rbx
  _QWORD *v16; // rdi

  *(_OWORD *)a1 = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  v4 = wcslen(String);
  v9 = 0x7FFFFFFFFFFFFFFEi64;
  v10 = v4;
  if ( v4 > 0x7FFFFFFFFFFFFFFEi64 )
    unknown_libname_4(v6, v5, v7, v8);
  if ( v4 > 7 )
  {
    v12 = v4 | 7;
    if ( v12 <= 0x7FFFFFFFFFFFFFFEi64 )
    {
      v9 = v12;
      if ( v12 < 0xA )
        v9 = 10i64;
      v13 = v9 + 1;
      if ( (unsigned __int64)(v9 + 1) > 0x7FFFFFFFFFFFFFFFi64 )
        sub_146165390(v13, v5, v7);
    }
    else
    {
      v13 = 0x7FFFFFFFFFFFFFFFi64;
    }
    v14 = sub_14615A5E0(2 * v13);
    a1[2] = v10;
    v15 = 2 * v10;
    *a1 = v14;
    a1[3] = v9;
    v16 = v14;
    memcpy(v14, String, v15);
    *(_WORD *)((char *)v16 + v15) = 0;
  }
  else
  {
    v11 = 2 * v4;
    a1[2] = v4;
    a1[3] = 7i64;
    memcpy(a1, String, 2 * v4);
    *(_WORD *)((char *)a1 + v11) = 0;
  }
  return a1;
}
// 146166BB6: variable 'v6' is possibly undefined
// 146166BB6: variable 'v5' is possibly undefined
// 146166BB6: variable 'v7' is possibly undefined
// 146166BB6: variable 'v8' is possibly undefined
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146166BD0) ----------------------------------------------------
__int64 __fastcall sub_146166BD0(__int64 a1)
{
  __int64 result; // rax

  memset((void *)(a1 + 16), 0, 0x800ui64);
  memset((void *)(a1 + 2064), 0, 0x800ui64);
  memset((void *)(a1 + 6160), 0, 0x800ui64);
  memset((void *)(a1 + 4112), 0, 0x800ui64);
  memset((void *)(a1 + 8208), 0, 0x1000ui64);
  *(_OWORD *)(a1 + 12304) = 0i64;
  *(_OWORD *)(a1 + 12320) = 0i64;
  *(_OWORD *)(a1 + 12336) = 0i64;
  *(_OWORD *)(a1 + 12352) = 0i64;
  *(_QWORD *)a1 = 0i64;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 15) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  result = a1;
  *(_WORD *)(a1 + 13) = 1;
  return result;
}

//----- (0000000146166C80) ----------------------------------------------------
void __fastcall sub_146166C80(__int64 a1)
{
  _QWORD *v2; // rcx

  v2 = *(_QWORD **)a1;
  if ( v2 )
  {
    if ( ((*(_QWORD *)(a1 + 16) - (_QWORD)v2) & 0xFFFFFFFFFFFFFFF8ui64) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - *(v2 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v2 = (_QWORD *)*(v2 - 1);
    }
    j_j_free(v2);
    *(_QWORD *)a1 = 0i64;
    *(_QWORD *)(a1 + 8) = 0i64;
    *(_QWORD *)(a1 + 16) = 0i64;
  }
}

//----- (0000000146166CF0) ----------------------------------------------------
void __fastcall sub_146166CF0(_QWORD *a1, __int64 a2)
{
  _QWORD *v3; // rcx
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx

  v3 = (_QWORD *)a1[14];
  if ( v3 )
  {
    if ( ((a1[16] - (_QWORD)v3) & 0xFFFFFFFFFFFFFFF0ui64) >= 0x1000 )
    {
      if ( (unsigned __int64)v3 - *(v3 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v3 = (_QWORD *)*(v3 - 1);
    }
    j_j_free(v3);
    a1[14] = 0i64;
    a1[15] = 0i64;
    a1[16] = 0i64;
  }
  v4 = (_QWORD *)a1[13];
  v5 = a1 + 6;
  if ( v4 )
  {
    LOBYTE(a2) = v4 != v5;
    (*(void (__fastcall **)(_QWORD *, __int64))(*v4 + 32i64))(v4, a2);
    v5[7] = 0i64;
  }
}
// 146166D61: variable 'a2' is possibly undefined

//----- (0000000146166D90) ----------------------------------------------------
void __fastcall sub_146166D90(__int64 a1)
{
  sub_146166C80(a1 + 72);
  sub_1461626B0(a1 + 32);
  sub_1461626B0(a1);
}

//----- (0000000146166DC0) ----------------------------------------------------
void **__fastcall sub_146166DC0(void **a1, void **Src, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rdi
  size_t v6; // rsi
  unsigned __int64 v7; // r14
  void *v8; // rbp
  __int64 v9; // rbp
  unsigned __int64 v10; // rdx
  _QWORD *v11; // rax
  _QWORD *v12; // r15
  _QWORD *v13; // rcx

  v4 = Src;
  if ( a1 != Src )
  {
    v6 = (size_t)Src[2];
    if ( (unsigned __int64)Src[3] > 0xF )
      v4 = *Src;
    v7 = (unsigned __int64)a1[3];
    if ( v6 > v7 )
    {
      v9 = 0x7FFFFFFFFFFFFFFFi64;
      if ( v6 > 0x7FFFFFFFFFFFFFFFi64 )
        unknown_libname_4(a1, Src, a3, a4);
      if ( (v6 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
      {
        v10 = v7 >> 1;
        if ( v7 <= 0x7FFFFFFFFFFFFFFFi64 - (v7 >> 1) )
        {
          v9 = v6 | 0xF;
          if ( (v6 | 0xF) < v7 + v10 )
            v9 = v7 + v10;
        }
      }
      v11 = sub_14615A5E0(v9 + 1);
      a1[2] = (void *)v6;
      a1[3] = (void *)v9;
      v12 = v11;
      memcpy(v11, v4, v6);
      *((_BYTE *)v12 + v6) = 0;
      if ( v7 > 0xF )
      {
        v13 = *a1;
        if ( v7 + 1 >= 0x1000 )
        {
          if ( (unsigned __int64)v13 - *(v13 - 1) - 8 > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          v13 = (_QWORD *)*(v13 - 1);
        }
        j_j_free(v13);
      }
      *a1 = v12;
    }
    else
    {
      v8 = a1;
      if ( v7 > 0xF )
        v8 = *a1;
      a1[2] = (void *)v6;
      memmove(v8, v4, v6);
      *((_BYTE *)v8 + v6) = 0;
    }
  }
  return a1;
}
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146166F00) ----------------------------------------------------
void (__fastcall *__fastcall sub_146166F00(__int64 a1, HMODULE a2, const char *a3))(struct _STARTUPINFOW *a1)
{
  if ( !stricmp(a3, "GetStartupInfoW") )
    return sub_146167910;
  if ( !stricmp(a3, "SetWindowsHookExA") )
    return (void (__fastcall *)(struct _STARTUPINFOW *))charNode::raw_length;
  if ( !stricmp(a3, "CreateFileW") )
    return (void (__fastcall *)(struct _STARTUPINFOW *))sub_146167670;
  if ( !stricmp(a3, "GetFileAttributesExW") )
    return (void (__fastcall *)(struct _STARTUPINFOW *))sub_146167790;
  if ( !stricmp(a3, "GetFileAttributesW") )
    return (void (__fastcall *)(struct _STARTUPINFOW *))sub_146167860;
  return (void (__fastcall *)(struct _STARTUPINFOW *))GetProcAddress(a2, a3);
}

//----- (0000000146166FF0) ----------------------------------------------------
const char *sub_146166FF0()
{
  _DWORD *v0; // rbx
  const char *result; // rax
  const wchar_t *v2; // rax
  const wchar_t *CommandLineW; // rax
  bool v4; // al

  v0 = (_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 380i64);
  if ( dword_14610A9BC > *v0 )
  {
    sub_1461A7CF4(&dword_14610A9BC);
    if ( dword_14610A9BC == -1 )
    {
      CommandLineW = GetCommandLineW();
      v4 = wcsstr(CommandLineW, L"fxdk") && !(unsigned __int8)sub_146167D30();
      byte_14610A9B8 = v4;
      Init_thread_footer(&dword_14610A9BC);
    }
  }
  if ( byte_14610A9B8 || (unsigned __int8)sub_146167D30() )
    return "fxdk";
  if ( dword_14610A9AC > *v0 )
  {
    sub_1461A7CF4(&dword_14610A9AC);
    if ( dword_14610A9AC == -1 )
    {
      v2 = GetCommandLineW();
      byte_14610A9A8 = wcsstr(v2, L"cl2") != 0i64;
      Init_thread_footer(&dword_14610A9AC);
    }
  }
  result = Src;
  if ( byte_14610A9A8 )
    return "cl2";
  return result;
}
// 14610A9A8: using guessed type char byte_14610A9A8;
// 14610A9AC: using guessed type int dword_14610A9AC;
// 14610A9B8: using guessed type char byte_14610A9B8;
// 14610A9BC: using guessed type int dword_14610A9BC;
// 14611AE78: using guessed type int TlsIndex;
// 146167D30: using guessed type __int64 sub_146167D30(void);
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);

//----- (0000000146167110) ----------------------------------------------------
wchar_t *__fastcall sub_146167110(__int64 a1, wchar_t *a2, __int64 (__fastcall *a3)(__int64))
{
  wchar_t *v4; // rax
  wchar_t *v5; // rsi
  const wchar_t *v6; // rdx
  wchar_t *v7; // rbx
  unsigned __int64 v8; // rdi
  wchar_t *v9; // rax
  wchar_t *Source[3]; // [rsp+38h] [rbp-30h] BYREF
  unsigned __int64 v12; // [rsp+50h] [rbp-18h]

  sub_146168400((char *)Source, a2);
  v4 = (wchar_t *)a3(2 * (__int64)Source[2] + 2);
  v5 = v4;
  v6 = (const wchar_t *)Source;
  v7 = Source[0];
  v8 = v12;
  if ( v12 > 7 )
    v6 = Source[0];
  wcscpy(v4, v6);
  if ( v8 > 7 )
  {
    v9 = v7;
    if ( 2 * v8 + 2 >= 0x1000 )
    {
      v7 = (wchar_t *)*((_QWORD *)v7 - 1);
      if ( (unsigned __int64)((char *)v9 - (char *)v7 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v7);
  }
  return v5;
}

//----- (00000001461671F0) ----------------------------------------------------
HMODULE __fastcall sub_1461671F0(__int64 a1, const char *a2)
{
  __int64 v3; // r8
  __int64 v4; // r9
  __int64 v5; // rax
  void *v6; // rcx
  const WCHAR *v7; // rcx
  const WCHAR *v8; // rcx
  HMODULE LibraryW; // rbx
  WCHAR *v10; // r8
  HMODULE result; // rax
  WCHAR *v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rax
  char *v16; // rax
  void *v17; // rcx
  char *v18; // rax
  LPCWSTR lpFileName[2]; // [rsp+38h] [rbp-11h] BYREF
  __int128 v20; // [rsp+48h] [rbp-1h]
  void *Block[3]; // [rsp+58h] [rbp+Fh] BYREF
  unsigned __int64 v22; // [rsp+70h] [rbp+27h]
  void *v23[3]; // [rsp+78h] [rbp+2Fh] BYREF
  unsigned __int64 v24; // [rsp+90h] [rbp+47h]

  if ( !stricmp(a2, "xlive.dll") )
    return (HMODULE)-1i64;
  if ( !stricmp(a2, "d3d9.dll") )
  {
    sub_146166AC0(v23, (wchar_t *)L"bin\\SwiftShaderD3D9_64.dll");
    v5 = sub_1461645B0((__int64)Block, v23, v3, v4);
    *(_OWORD *)lpFileName = 0i64;
    v20 = 0i64;
    *(_OWORD *)lpFileName = *(_OWORD *)v5;
    v20 = *(_OWORD *)(v5 + 16);
    *(_QWORD *)(v5 + 16) = 0i64;
    *(_QWORD *)(v5 + 24) = 7i64;
    *(_WORD *)v5 = 0;
    if ( v22 > 7 )
    {
      v6 = Block[0];
      if ( 2 * v22 + 2 >= 0x1000 )
      {
        v6 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)(Block[0] - v6 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v6);
    }
    v7 = (const WCHAR *)lpFileName;
    if ( *((_QWORD *)&v20 + 1) > 7ui64 )
      v7 = lpFileName[0];
    if ( GetFileAttributesW(v7) != -1 )
    {
      v8 = (const WCHAR *)lpFileName;
      if ( *((_QWORD *)&v20 + 1) > 7ui64 )
        v8 = lpFileName[0];
      LibraryW = LoadLibraryW(v8);
      if ( *((_QWORD *)&v20 + 1) <= 7ui64 )
        return LibraryW;
      v10 = (WCHAR *)lpFileName[0];
      if ( (unsigned __int64)(2i64 * *((_QWORD *)&v20 + 1) + 2) < 0x1000
        || (v10 = (WCHAR *)*((_QWORD *)lpFileName[0] - 1),
            (unsigned __int64)((char *)lpFileName[0] - (char *)v10 - 8) <= 0x1F) )
      {
LABEL_16:
        j_j_free(v10);
        return LibraryW;
      }
LABEL_21:
      invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    if ( *((_QWORD *)&v20 + 1) > 7ui64 )
    {
      v12 = (WCHAR *)lpFileName[0];
      if ( (unsigned __int64)(2i64 * *((_QWORD *)&v20 + 1) + 2) >= 0x1000 )
      {
        v12 = (WCHAR *)*((_QWORD *)lpFileName[0] - 1);
        if ( (unsigned __int64)((char *)lpFileName[0] - (char *)v12 - 8) > 0x1F )
          goto LABEL_21;
      }
      j_j_free(v12);
    }
  }
  if ( (stricmp(a2, "xinput1_3.dll") && stricmp(a2, "xinput1_2.dll") && stricmp(a2, "xinput1_1.dll")
     || (result = LoadLibraryW(L"xinput1_4.dll")) == 0i64)
    && (stricmp(a2, "d3dcompiler_43.dll") || (result = LoadLibraryW(L"d3dcompiler_47.dll")) == 0i64) )
  {
    if ( !stricmp(a2, "gfsdk_shadowlib.win64.dll") )
    {
      sub_146166AC0(Block, (wchar_t *)L"bin/gfsdk_shadowlib.dll");
      v15 = sub_1461645B0((__int64)v23, Block, v13, v14);
      if ( *(_QWORD *)(v15 + 24) > 7ui64 )
        v15 = *(_QWORD *)v15;
      LibraryW = LoadLibraryW((LPCWSTR)v15);
      if ( v24 <= 7 )
        return LibraryW;
      v10 = (WCHAR *)v23[0];
      if ( 2 * v24 + 2 >= 0x1000 )
      {
        v10 = (WCHAR *)*((_QWORD *)v23[0] - 1);
        if ( (unsigned __int64)(v23[0] - (void *)v10 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      goto LABEL_16;
    }
    if ( stricmp(a2, "atl80.dll") )
    {
      if ( !stricmp(a2, "libcef.dll") && getenv("CitizenFX_ToolMode") )
      {
        v16 = sub_146168400((char *)Block, L"Social Club/chrome_elf.dll");
        if ( *((_QWORD *)v16 + 3) > 7ui64 )
          v16 = *(char **)v16;
        LoadLibraryW((LPCWSTR)v16);
        if ( v22 > 7 )
        {
          v17 = Block[0];
          if ( 2 * v22 + 2 >= 0x1000 )
          {
            v17 = (void *)*((_QWORD *)Block[0] - 1);
            if ( (unsigned __int64)(Block[0] - v17 - 8) > 0x1F )
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v17);
        }
        v18 = sub_146168400((char *)Block, L"Social Club/libcef.dll");
        if ( *((_QWORD *)v18 + 3) > 7ui64 )
          v18 = *(char **)v18;
        LibraryW = LoadLibraryW((LPCWSTR)v18);
        if ( v22 <= 7 )
          return LibraryW;
        v10 = (WCHAR *)Block[0];
        if ( 2 * v22 + 2 >= 0x1000 )
        {
          v10 = (WCHAR *)*((_QWORD *)Block[0] - 1);
          if ( (unsigned __int64)(Block[0] - (void *)v10 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        goto LABEL_16;
      }
      return LoadLibraryA(a2);
    }
    return (HMODULE)-1i64;
  }
  return result;
}
// 146167262: variable 'v3' is possibly undefined
// 146167262: variable 'v4' is possibly undefined
// 14616745B: variable 'v13' is possibly undefined
// 14616745B: variable 'v14' is possibly undefined
// 14611DFB0: using guessed type wchar_t aSocialClubChro[27];
// 14611DFE8: using guessed type wchar_t aSocialClubLibc[23];

//----- (0000000146167640) ----------------------------------------------------
PVOID sub_146167640()
{
  struct _PEB *v0; // rax

  v0 = NtCurrentPeb();
  v0->NtGlobalFlag &= 0xFFFFFF8F;
  v0->BeingDebugged = 0;
  return AddVectoredExceptionHandler(0, (PVECTORED_EXCEPTION_HANDLER)Handler);
}

//----- (0000000146167670) ----------------------------------------------------
HANDLE __fastcall sub_146167670(
        wchar_t *a1,
        DWORD a2,
        DWORD a3,
        struct _SECURITY_ATTRIBUTES *a4,
        DWORD dwCreationDisposition,
        DWORD dwFlagsAndAttributes,
        HANDLE hTemplateFile)
{
  const WCHAR *v10; // rcx
  HANDLE FileW; // rbx
  WCHAR *v12; // r8
  LPCWSTR lpFileName[3]; // [rsp+40h] [rbp-68h] BYREF
  unsigned __int64 v15; // [rsp+58h] [rbp-50h]

  sub_146168400((char *)lpFileName, a1);
  v10 = (const WCHAR *)lpFileName;
  if ( v15 > 7 )
    v10 = lpFileName[0];
  FileW = CreateFileW(v10, a2, a3, a4, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
  if ( v15 > 7 )
  {
    v12 = (WCHAR *)lpFileName[0];
    if ( 2 * v15 + 2 >= 0x1000 )
    {
      v12 = (WCHAR *)*((_QWORD *)lpFileName[0] - 1);
      if ( (unsigned __int64)((char *)lpFileName[0] - (char *)v12 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v12);
  }
  return FileW;
}

//----- (0000000146167760) ----------------------------------------------------
__int64 __fastcall sub_146167760(__int64 a1, _DWORD *a2)
{
  __int64 result; // rax
  DWORD flOldProtect; // [rsp+38h] [rbp+10h] BYREF

  VirtualProtect(a2, 4ui64, 4u, &flOldProtect);
  result = 0i64;
  *a2 = 6840686;
  return result;
}

//----- (0000000146167790) ----------------------------------------------------
__int64 __fastcall sub_146167790(wchar_t *a1, GET_FILEEX_INFO_LEVELS a2, void *a3)
{
  const WCHAR *v5; // rcx
  unsigned int FileAttributes; // ebx
  WCHAR *v7; // r8
  LPCWSTR lpFileName[3]; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int64 v10; // [rsp+48h] [rbp-20h]

  sub_146168400((char *)lpFileName, a1);
  v5 = (const WCHAR *)lpFileName;
  if ( v10 > 7 )
    v5 = lpFileName[0];
  FileAttributes = GetFileAttributesExW(v5, a2, a3);
  if ( v10 > 7 )
  {
    v7 = (WCHAR *)lpFileName[0];
    if ( 2 * v10 + 2 >= 0x1000 )
    {
      v7 = (WCHAR *)*((_QWORD *)lpFileName[0] - 1);
      if ( (unsigned __int64)((char *)lpFileName[0] - (char *)v7 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v7);
  }
  return FileAttributes;
}

//----- (0000000146167860) ----------------------------------------------------
__int64 __fastcall sub_146167860(wchar_t *a1)
{
  const WCHAR *v1; // rcx
  DWORD FileAttributesW; // ebx
  WCHAR *v3; // r8
  LPCWSTR lpFileName[3]; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int64 v6; // [rsp+48h] [rbp-20h]

  sub_146168400((char *)lpFileName, a1);
  v1 = (const WCHAR *)lpFileName;
  if ( v6 > 7 )
    v1 = lpFileName[0];
  FileAttributesW = GetFileAttributesW(v1);
  if ( v6 > 7 )
  {
    v3 = (WCHAR *)lpFileName[0];
    if ( 2 * v6 + 2 >= 0x1000 )
    {
      v3 = (WCHAR *)*((_QWORD *)lpFileName[0] - 1);
      if ( (unsigned __int64)((char *)lpFileName[0] - (char *)v3 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v3);
  }
  return FileAttributesW;
}

//----- (0000000146167910) ----------------------------------------------------
void __fastcall sub_146167910(struct _STARTUPINFOW *a1)
{
  HMODULE ModuleHandleW; // rax
  void (*ProcAddress)(void); // rax
  unsigned __int8 (__fastcall *v3)(__int64, HMODULE, _QWORD); // rbx
  HMODULE v4; // rax

  GetStartupInfoW(a1);
  if ( !byte_14610A978 )
  {
    byte_14610A978 = 1;
    qword_14611AD18 = (__int64)(GetModuleHandleW(0i64) - 1342177280);
    if ( getenv("CitizenFX_ToolMode") )
    {
      ModuleHandleW = GetModuleHandleW(L"CoreRT.dll");
      ProcAddress = (void (*)(void))GetProcAddress(ModuleHandleW, "ToolMode_RunPostLaunchRoutine");
      ProcAddress();
    }
    else
    {
      sub_146167A00();
      v3 = *(unsigned __int8 (__fastcall **)(__int64, HMODULE, _QWORD))(*(_QWORD *)qword_14610A980 + 16i64);
      v4 = GetModuleHandleW(0i64);
      if ( !v3(qword_14610A980, v4, 0i64)
        || !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)qword_14610A980 + 24i64))(qword_14610A980) )
      {
        ExitProcess(0);
      }
    }
  }
}
// 14610A978: using guessed type char byte_14610A978;
// 14610A980: using guessed type __int64 qword_14610A980;
// 14611AD18: using guessed type __int64 qword_14611AD18;

//----- (00000001461679E0) ----------------------------------------------------
__int64 __fastcall Handler(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  return (unsigned int)(ExceptionInfo->ExceptionRecord->ExceptionCode != -1073741816) - 1;
}

//----- (0000000146167A00) ----------------------------------------------------
BOOL sub_146167A00()
{
  _BYTE *v0; // rbx
  int v1; // edx
  __int64 v2; // rcx
  int v3; // r8d
  _DWORD *v4; // rbx
  _BYTE *v5; // rcx
  void *v6; // rcx
  void *v7; // rcx
  _BYTE *v8; // rbx
  int v9; // edx
  __int64 v10; // rcx
  int v11; // r8d
  _DWORD *v12; // rbx
  __int64 v13; // rax
  _WORD *v14; // rbx
  DWORD flOldProtect; // [rsp+38h] [rbp-49h] BYREF
  __int64 v17; // [rsp+40h] [rbp-41h]
  void *Block[2]; // [rsp+48h] [rbp-39h] BYREF
  __m128i si128; // [rsp+58h] [rbp-29h]
  __int128 v20; // [rsp+68h] [rbp-19h]
  __m128i v21; // [rsp+78h] [rbp-9h]
  _QWORD *v22; // [rsp+90h] [rbp+Fh]
  __int128 v23; // [rsp+98h] [rbp+17h]
  char v24; // [rsp+A8h] [rbp+27h]
  __int64 v25; // [rsp+B0h] [rbp+2Fh]
  __int64 v26; // [rsp+B8h] [rbp+37h]

  v17 = -2i64;
  *(_OWORD *)Block = 0i64;
  si128 = _mm_load_si128((const __m128i *)&Size);
  LOBYTE(Block[0]) = 0;
  v20 = 0i64;
  v21 = si128;
  LOBYTE(v20) = 0;
  v22 = 0i64;
  v23 = 0i64;
  v24 = 0;
  v25 = qword_14611AD18 + 0x140000000i64;
  v26 = 0i64;
  sub_1461A4170((__int64)Block, (__int64)"84 C0 75 0C B2 01 B9 2F A9 C2 F4", 33i64);
  sub_1461A3C40((__int64)Block, 1u);
  if ( (((_QWORD)v23 - (_QWORD)v22) & 0xFFFFFFFFFFFFFFF8ui64) != 8 )
    sub_1461A1C30(
      (wchar_t *)L"m_matches.size() == expected",
      (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\code\\client\\shared\\Hooking.Patterns.h",
      125);
  sub_1461A3C40((__int64)Block, 0xFFFFFFFF);
  v0 = (_BYTE *)(*v22 - 5i64);
  v1 = sub_1461A3150((__int64)sub_1461689D0, 0);
  if ( (unsigned __int64)(v0 - 0x140000000i64) > 0x6000000 )
  {
    *v0 = -24;
    v3 = (int)v0;
    v2 = qword_14611AD18;
  }
  else
  {
    v0[qword_14611AD18] = -24;
    v2 = qword_14611AD18;
    v3 = (_DWORD)v0 + qword_14611AD18;
  }
  v4 = v0 + 1;
  if ( (unsigned __int64)(v4 - 1342177280) <= 0x6000000 )
    v4 = (_DWORD *)((char *)v4 + v2);
  *v4 = v1 - v3 - 5;
  v5 = v22;
  if ( v22 )
  {
    if ( ((*((_QWORD *)&v23 + 1) - (_QWORD)v22) & 0xFFFFFFFFFFFFFFF8ui64) >= 0x1000 )
    {
      v5 = (_BYTE *)*(v22 - 1);
      if ( (unsigned __int64)((char *)v22 - v5 - 8) > 0x1F )
        goto LABEL_19;
    }
    j_j_free(v5);
    v22 = 0i64;
    v23 = 0i64;
  }
  if ( v21.m128i_i64[1] <= 0xFui64 )
    goto LABEL_16;
  v6 = (void *)v20;
  if ( (unsigned __int64)(v21.m128i_i64[1] + 1) >= 0x1000 )
  {
    v6 = *(void **)(v20 - 8);
    if ( (unsigned __int64)(v20 - (_QWORD)v6 - 8) > 0x1F )
LABEL_19:
      invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
  }
  j_j_free(v6);
LABEL_16:
  v21 = _mm_load_si128((const __m128i *)&Size);
  LOBYTE(v20) = 0;
  if ( si128.m128i_i64[1] > 0xFui64 )
  {
    v7 = Block[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v7 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v7 - 8) > 0x1F )
        goto LABEL_19;
    }
    j_j_free(v7);
  }
  v8 = (_BYTE *)sub_146166320((__int64)"8B F8 48 85 C0 74 47 48 8B C8 E8 ? ? ? ? 4C", -6i64);
  v9 = sub_1461A3150((__int64)sub_146167760, 0);
  if ( (unsigned __int64)(v8 - 0x140000000i64) > 0x6000000 )
  {
    *v8 = -24;
    v11 = (int)v8;
    v10 = qword_14611AD18;
  }
  else
  {
    v8[qword_14611AD18] = -24;
    v10 = qword_14611AD18;
    v11 = (_DWORD)v8 + qword_14611AD18;
  }
  v12 = v8 + 1;
  if ( (unsigned __int64)(v12 - 1342177280) <= 0x6000000 )
    v12 = (_DWORD *)((char *)v12 + v10);
  *v12 = v9 - v11 - 5;
  v13 = sub_146166510((__int64)"85 DB 0F 84 ? ? ? ? 8B 05 ? ? ? ? A8 01 75 15 83", 2i64);
  v14 = (_WORD *)v13;
  if ( (unsigned __int64)(v13 - 0x140000000i64) <= 0x6000000 )
    v14 = (_WORD *)(qword_14611AD18 + v13);
  VirtualProtect(v14, 6ui64, 0x40u, &flOldProtect);
  *(_DWORD *)v14 = -1869574000;
  v14[2] = -28528;
  return VirtualProtect(v14, 6ui64, flOldProtect, &flOldProtect);
}
// 14611AD18: using guessed type __int64 qword_14611AD18;
// 146167A00: using guessed type __m128i var_60;

//----- (0000000146167D30) ----------------------------------------------------
__int64 sub_146167D30()
{
  if ( dword_14610A9B4 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 380i64) )
    return (unsigned __int8)byte_14610A9B0;
  sub_1461A7CF4(&dword_14610A9B4);
  if ( dword_14610A9B4 != -1 )
    return (unsigned __int8)byte_14610A9B0;
  byte_14610A9B0 = getenv("CitizenFX_SDK_Guest") != 0i64;
  Init_thread_footer(&dword_14610A9B4);
  return (unsigned __int8)byte_14610A9B0;
}
// 14610A9B0: using guessed type char byte_14610A9B0;
// 14610A9B4: using guessed type int dword_14610A9B4;
// 14611AE78: using guessed type int TlsIndex;
// 146167D30: using guessed type __int64 sub_146167D30();
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);

//----- (0000000146167DB0) ----------------------------------------------------
void __fastcall sub_146167DB0(wchar_t *a1, char a2)
{
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // rax
  HMODULE LibraryW; // r14
  void *v8; // r8
  signed int LastError; // eax
  __int64 v10; // r8
  __int64 v11; // r9
  HMODULE ModuleHandleW; // rax
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rax
  _BYTE *v16; // rcx
  void (*ProcAddress)(void); // rax
  HMODULE v18; // rax
  void **v19; // rbx
  FARPROC v20; // rax
  HMODULE v21; // rax
  HMODULE v22; // rax
  FARPROC v23; // rax
  __int64 (*v24)(void); // rax
  __int64 v25; // r14
  DWORD *v26; // rbx
  _DWORD *v27; // rbx
  char *v28; // rax
  FILE *v29; // r15
  void *v30; // r8
  unsigned int v31; // ebx
  void *v32; // rdi
  void (*v33)(void); // rbx
  struct _PEB *v34; // rax
  __int64 v35; // rdx
  void *v36; // rcx
  void *v37; // rcx
  void *v38[4]; // [rsp+40h] [rbp-C8h] BYREF
  __m128i v39; // [rsp+68h] [rbp-A0h] BYREF
  __m128i v40; // [rsp+78h] [rbp-90h]
  void *Block[2]; // [rsp+88h] [rbp-80h] BYREF
  __m128i si128; // [rsp+98h] [rbp-70h]
  void *v43; // [rsp+A8h] [rbp-60h] BYREF
  unsigned __int64 v44; // [rsp+C0h] [rbp-48h]
  __int64 v45[6]; // [rsp+C8h] [rbp-40h] BYREF
  char v46; // [rsp+F8h] [rbp-10h] BYREF
  char *v47; // [rsp+130h] [rbp+28h]
  void *v48[2]; // [rsp+138h] [rbp+30h]
  __int64 v49; // [rsp+148h] [rbp+40h]
  WCHAR Filename[264]; // [rsp+158h] [rbp+50h] BYREF

  sub_146166AC0(v38, (wchar_t *)L"CitizenGame.dll");
  v6 = sub_1461645B0((__int64)Block, v38, v4, v5);
  if ( *(_QWORD *)(v6 + 24) > 7ui64 )
    v6 = *(_QWORD *)v6;
  LibraryW = LoadLibraryW((LPCWSTR)v6);
  if ( si128.m128i_i64[1] > 7ui64 )
  {
    v8 = Block[0];
    if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
    {
      v8 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v8 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v8);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(Block[0]) = 0;
  if ( LibraryW )
  {
    ModuleHandleW = GetModuleHandleW(0i64);
    GetModuleFileNameW(ModuleHandleW, Filename, 0x104u);
    if ( !wcsstr(Filename, L"ChromeBrowser") && !wcsstr(Filename, L"ROSLauncher") )
    {
      sub_146166AC0(&v39, (wchar_t *)L"scripthookv.dll");
      v15 = sub_1461645B0((__int64)&v43, (void **)&v39, v13, v14);
      if ( *(_QWORD *)(v15 + 24) > 7ui64 )
        v15 = *(_QWORD *)v15;
      LoadLibraryW((LPCWSTR)v15);
      if ( v44 > 7 )
      {
        v16 = v43;
        if ( 2 * v44 + 2 >= 0x1000 )
        {
          v16 = (_BYTE *)*((_QWORD *)v43 - 1);
          if ( (unsigned __int64)((_BYTE *)v43 - v16 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v16);
      }
    }
    ProcAddress = (void (*)(void))qword_14610A988;
    if ( qword_14610A988
      || (v18 = GetModuleHandleW(L"CoreRT.dll"),
          ProcAddress = (void (*)(void))GetProcAddress(v18, "CoreSetDebuggerPresent"),
          (qword_14610A988 = (__int64)ProcAddress) != 0) )
    {
      ProcAddress();
    }
    v19 = &qword_1461090A0;
    if ( (unsigned __int64)qword_1461090B8 > 0xF )
      v19 = (void **)qword_1461090A0;
    v20 = (FARPROC)qword_14610A9C0;
    if ( qword_14610A9C0
      || (v21 = GetModuleHandleW(L"CoreRT.dll"),
          v20 = GetProcAddress(v21, "CoreSetMinModeManifest"),
          (qword_14610A9C0 = (__int64)v20) != 0) )
    {
      ((void (__fastcall *)(void **))v20)(v19);
    }
    if ( !getenv("CitizenFX_ToolMode") )
    {
      v22 = GetModuleHandleW(L"CoreRT.dll");
      v23 = GetProcAddress(v22, "CoreSetMappingFunction");
      if ( v23 )
        ((void (__fastcall *)(__int64 (__fastcall *)()))v23)(sub_146166300);
    }
    sub_146193230();
    v24 = GetProcAddress(LibraryW, "GetLauncherInterface");
    if ( v24 )
    {
      v25 = v24();
      if ( !(**(unsigned __int8 (__fastcall ***)(__int64))v25)(v25)
        || !(*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v25 + 8i64))(v25, 0i64) )
      {
        ExitProcess(0);
      }
      if ( dword_14610A9D8 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                       + 380i64) )
      {
        sub_1461A7CF4(&dword_14610A9D8);
        if ( dword_14610A9D8 == -1 )
        {
          v40 = _mm_load_si128((const __m128i *)&xmmword_14611E150);
          strcpy(v39.m128i_i8, "CfxInitState");
          v39.m128i_i8[13] = 0;
          v39.m128i_i16[7] = 0;
          sub_146166700((__int64)&hObject, v39.m128i_i64);
          if ( v40.m128i_i64[1] > 0xFui64 )
          {
            v37 = (void *)v39.m128i_i64[0];
            if ( (unsigned __int64)(v40.m128i_i64[1] + 1) >= 0x1000 )
            {
              v37 = *(void **)(v39.m128i_i64[0] - 8);
              if ( (unsigned __int64)(v39.m128i_i64[0] - (_QWORD)v37 - 8) > 0x1F )
                invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
            }
            j_j_free(v37);
          }
          atexit(sub_1461AE460);
          Init_thread_footer(&dword_14610A9D8);
        }
      }
      if ( !a2 )
        goto LABEL_40;
      v26 = (DWORD *)((char *)lpBaseAddress + 4);
      if ( !*((_DWORD *)lpBaseAddress + 1) )
        *v26 = GetCurrentProcessId();
      if ( *v26 == GetCurrentProcessId() || (v27 = lpBaseAddress, v27[2] == GetCurrentProcessId()) )
      {
LABEL_40:
        if ( *((_QWORD *)a1 + 3) > 7ui64 )
          a1 = *(wchar_t **)a1;
        v28 = sub_146168400((char *)Block, a1);
        if ( *((_QWORD *)v28 + 3) > 7ui64 )
          v28 = *(char **)v28;
        v29 = wfopen((const wchar_t *)v28, L"rb");
        if ( si128.m128i_i64[1] > 7ui64 )
        {
          v30 = Block[0];
          if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
          {
            v30 = (void *)*((_QWORD *)Block[0] - 1);
            if ( (unsigned __int64)(Block[0] - v30 - 8) > 0x1F )
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v30);
        }
        si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
        LOWORD(Block[0]) = 0;
        if ( v29 )
        {
          fseek(v29, 0, 2);
          v31 = ftell(v29);
          v32 = operator new(v31);
          fseek(v29, 0, 0);
          fread(v32, 1ui64, v31, v29);
          fclose(v29);
          sub_146175B90(v45, (__int64)v32);
          v45[2] = 0x1A0000000i64;
          v45[4] = (__int64)sub_146166310;
          v45[5] = (__int64)sub_1461662F0;
          sub_146176090(v45, 0x140000000i64);
          j_j_free(v32);
          v33 = (void (*)(void))v45[3];
          qword_14610A980 = v25;
          v34 = NtCurrentPeb();
          v34->BeingDebugged = 0;
          v34->NtGlobalFlag &= 0xFFFFFF8F;
          AddVectoredExceptionHandler(0, (PVECTORED_EXCEPTION_HANDLER)Handler);
          v33();
          v36 = v48[0];
          if ( v48[0] )
          {
            if ( ((v49 - (unsigned __int64)v48[0]) & 0xFFFFFFFFFFFFFFF0ui64) >= 0x1000 )
            {
              v36 = (void *)*((_QWORD *)v48[0] - 1);
              if ( (unsigned __int64)(v48[0] - v36 - 8) > 0x1F )
                invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
            }
            j_j_free(v36);
            *(_OWORD *)v48 = 0i64;
            v49 = 0i64;
          }
          if ( v47 )
          {
            LOBYTE(v35) = v47 != &v46;
            (*(void (__fastcall **)(char *, __int64))(*(_QWORD *)v47 + 32i64))(v47, v35);
          }
        }
      }
    }
  }
  else
  {
    LastError = GetLastError();
    v39.m128i_i64[0] = (__int64)"CitizenGame.dll";
    v39.m128i_i64[1] = 15i64;
    sub_1461878C0(LastError, &v39, v10, v11);
  }
}
// 146167E0D: variable 'v4' is possibly undefined
// 146167E0D: variable 'v5' is possibly undefined
// 146167EB9: variable 'v10' is possibly undefined
// 146167EB9: variable 'v11' is possibly undefined
// 146167F51: variable 'v13' is possibly undefined
// 146167F51: variable 'v14' is possibly undefined
// 146168315: variable 'v35' is possibly undefined
// 1461090B8: using guessed type __int64 qword_1461090B8;
// 14610A980: using guessed type __int64 qword_14610A980;
// 14610A988: using guessed type __int64 qword_14610A988;
// 14610A9C0: using guessed type __int64 qword_14610A9C0;
// 14610A9D8: using guessed type int dword_14610A9D8;
// 14611AE78: using guessed type int TlsIndex;
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 14611E150: using guessed type __int128 xmmword_14611E150;
// 146166300: using guessed type __int64 __fastcall sub_146166300();
// 146166310: using guessed type __int64 __fastcall sub_146166310();
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);

//----- (0000000146168400) ----------------------------------------------------
char *__fastcall sub_146168400(char *a1, wchar_t *a2)
{
  char *v2; // rdi
  __int128 *v3; // rax
  char *v4; // rdx
  unsigned __int64 v5; // r8
  char *v6; // r9
  __int128 *v7; // rcx
  __int128 *v8; // rax
  char *v9; // rax
  __int64 *v10; // rbx
  char *v11; // rdx
  size_t v12; // rax
  char *v13; // rcx
  const char *v14; // r13
  size_t v15; // r14
  void **v16; // r12
  char *v17; // r12
  unsigned __int64 v18; // rsi
  char *v19; // rdi
  const char *v20; // rcx
  int v21; // edi
  __int64 v22; // r9
  __int64 v23; // r8
  char *v24; // rcx
  __int64 **v25; // rcx
  __int64 *i; // rax
  __int64 *j; // rcx
  void *v28; // rcx
  char *v29; // rax
  __int64 v30; // rbx
  __m128i si128; // xmm6
  void *v32; // rcx
  _BYTE *v33; // rcx
  void *v34; // rcx
  void *v35; // rcx
  __int128 v39; // [rsp+58h] [rbp-79h] BYREF
  __m128i v40; // [rsp+68h] [rbp-69h]
  char *String1[2]; // [rsp+78h] [rbp-59h] BYREF
  __int128 v42; // [rsp+88h] [rbp-49h]
  void *v43[2]; // [rsp+98h] [rbp-39h] BYREF
  char *v44; // [rsp+A8h] [rbp-29h]
  unsigned __int64 v45; // [rsp+B0h] [rbp-21h]
  void *Block; // [rsp+B8h] [rbp-19h] BYREF
  unsigned __int64 v47; // [rsp+D0h] [rbp-1h]

  v2 = a1;
  String1[0] = a1;
  sub_146166AC0(&v39, a2);
  v3 = &v39;
  v4 = (char *)v39;
  v5 = v40.m128i_u64[1];
  if ( v40.m128i_i64[1] > 7ui64 )
    v3 = (__int128 *)v39;
  v6 = (char *)v40.m128i_i64[0];
  v7 = (__int128 *)((char *)v3 + 2 * v40.m128i_i64[0]);
  v8 = &v39;
  if ( v40.m128i_i64[1] > 7ui64 )
    v8 = (__int128 *)v39;
  if ( v8 != v7 )
  {
    do
    {
      if ( *(_WORD *)v8 == 92 )
        *(_WORD *)v8 = 47;
      v8 = (__int128 *)((char *)v8 + 2);
    }
    while ( v8 != v7 );
    v5 = v40.m128i_u64[1];
    v6 = (char *)v40.m128i_i64[0];
    v4 = (char *)v39;
  }
  v9 = (char *)&v39;
  if ( v5 > 7 )
    v9 = v4;
  String1[0] = v9;
  String1[1] = v6;
  sub_1461A2B60((__int64)v43, (unsigned __int16 **)String1, v5, (__int64)v6);
  v10 = *(__int64 **)qword_14610AB20;
  if ( *(_BYTE *)(*(_QWORD *)qword_14610AB20 + 25i64) )
  {
LABEL_47:
    sub_146166AC0(v2, a2);
    if ( v45 > 0xF )
    {
      v28 = v43[0];
      if ( v45 + 1 >= 0x1000 )
      {
        v28 = (void *)*((_QWORD *)v43[0] - 1);
        if ( (unsigned __int64)(v43[0] - v28 - 8) > 0x1F )
          goto LABEL_50;
      }
      j_j_free(v28);
    }
    v44 = 0i64;
    v45 = 15i64;
    LOBYTE(v43[0]) = 0;
    if ( v40.m128i_i64[1] > 7ui64 )
    {
      v35 = (void *)v39;
      if ( (unsigned __int64)(2 * v40.m128i_i64[1] + 2) < 0x1000 )
        goto LABEL_72;
      v35 = *(void **)(v39 - 8);
      if ( (unsigned __int64)(v39 - (_QWORD)v35 - 8) <= 0x1F )
        goto LABEL_72;
      goto LABEL_78;
    }
    return v2;
  }
  v11 = v44;
  while ( 1 )
  {
    v12 = v10[6];
    if ( (unsigned __int64)v11 >= v12 )
      break;
LABEL_38:
    v25 = (__int64 **)v10[2];
    if ( *((_BYTE *)v25 + 25) )
    {
      for ( i = (__int64 *)v10[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
      {
        if ( v10 != (__int64 *)i[2] )
          break;
        v10 = i;
      }
      v10 = i;
    }
    else
    {
      v10 = (__int64 *)v10[2];
      for ( j = *v25; !*((_BYTE *)j + 25); j = (__int64 *)*j )
        v10 = j;
    }
    if ( *((_BYTE *)v10 + 25) )
    {
      v2 = a1;
      goto LABEL_47;
    }
  }
  v13 = &v11[-v12];
  v14 = (const char *)(v10 + 4);
  if ( (unsigned __int64)v10[7] > 0xF )
    v14 = (const char *)v10[4];
  *(_OWORD *)String1 = 0i64;
  v42 = 0i64;
  if ( v11 < v13 )
    unknown_libname_5(v13, v11, 0x7FFFFFFFFFFFFFFFi64, 22i64);
  v15 = -1i64;
  if ( v12 != -1i64 )
    v15 = v12;
  v16 = v43;
  if ( v45 > 0xF )
    v16 = (void **)v43[0];
  v17 = (char *)v16 + (_QWORD)v13;
  if ( v15 > 0x7FFFFFFFFFFFFFFFi64 )
    unknown_libname_4(v13, v11, 0x7FFFFFFFFFFFFFFFi64, 22i64);
  if ( v15 > 0xF )
  {
    v18 = v15 | 0xF;
    if ( (v15 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      if ( v18 < 0x16 )
        v18 = 22i64;
    }
    else
    {
      v18 = 0x7FFFFFFFFFFFFFFFi64;
    }
    v19 = (char *)sub_14615A5E0(v18 + 1);
    String1[0] = v19;
    *(_QWORD *)&v42 = v15;
    *((_QWORD *)&v42 + 1) = v18;
    memcpy(v19, v17, v15);
    v19[v15] = 0;
  }
  else
  {
    *(_QWORD *)&v42 = v15;
    *((_QWORD *)&v42 + 1) = 15i64;
    memcpy(String1, v17, v15);
    *((_BYTE *)String1 + v15) = 0;
  }
  v20 = (const char *)String1;
  if ( *((_QWORD *)&v42 + 1) > 0xFui64 )
    v20 = String1[0];
  v21 = stricmp(v20, v14);
  v23 = *((_QWORD *)&v42 + 1);
  if ( *((_QWORD *)&v42 + 1) > 0xFui64 )
  {
    v24 = String1[0];
    if ( (unsigned __int64)(*((_QWORD *)&v42 + 1) + 1i64) >= 0x1000 )
    {
      v24 = (char *)*((_QWORD *)String1[0] - 1);
      if ( (unsigned __int64)(String1[0] - v24 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v24);
  }
  if ( v21 )
  {
    v11 = v44;
    goto LABEL_38;
  }
  sub_146166DC0(v43, (void **)v10 + 8, v23, v22);
  v29 = (char *)v43;
  if ( v45 > 0xF )
    v29 = (char *)v43[0];
  String1[0] = v29;
  String1[1] = v44;
  v30 = sub_1461A2C60((__int64)&Block, (__int64)String1);
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  if ( &v39 == (__int128 *)v30 )
    goto LABEL_60;
  if ( v40.m128i_i64[1] <= 7ui64 )
    goto LABEL_59;
  v32 = (void *)v39;
  if ( (unsigned __int64)(2 * v40.m128i_i64[1] + 2) >= 0x1000 )
  {
    v32 = *(void **)(v39 - 8);
    if ( (unsigned __int64)(v39 - (_QWORD)v32 - 8) > 0x1F )
LABEL_63:
      invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
  }
  j_j_free(v32);
LABEL_59:
  v40 = si128;
  LOWORD(v39) = 0;
  v39 = *(_OWORD *)v30;
  v40 = *(__m128i *)(v30 + 16);
  *(_QWORD *)(v30 + 16) = 0i64;
  *(_QWORD *)(v30 + 24) = 7i64;
  *(_WORD *)v30 = 0;
LABEL_60:
  if ( v47 > 7 )
  {
    v33 = Block;
    if ( 2 * v47 + 2 >= 0x1000 )
    {
      v33 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v33 - 8) > 0x1F )
        goto LABEL_63;
    }
    j_j_free(v33);
    si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  }
  v2 = a1;
  *(_OWORD *)a1 = v39;
  *((__m128i *)a1 + 1) = v40;
  v40 = si128;
  LOWORD(v39) = 0;
  if ( v45 > 0xF )
  {
    v34 = v43[0];
    if ( v45 + 1 < 0x1000 || (v34 = (void *)*((_QWORD *)v43[0] - 1), (unsigned __int64)(v43[0] - v34 - 8) <= 0x1F) )
    {
      j_j_free(v34);
      goto LABEL_69;
    }
LABEL_50:
    invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
  }
LABEL_69:
  v44 = 0i64;
  v45 = 15i64;
  LOBYTE(v43[0]) = 0;
  if ( v40.m128i_i64[1] > 7ui64 )
  {
    v35 = (void *)v39;
    if ( (unsigned __int64)(2 * v40.m128i_i64[1] + 2) < 0x1000
      || (v35 = *(void **)(v39 - 8), (unsigned __int64)(v39 - (_QWORD)v35 - 8) <= 0x1F) )
    {
LABEL_72:
      j_j_free(v35);
      return v2;
    }
LABEL_78:
    invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
  }
  return v2;
}
// 146168712: variable 'v23' is possibly undefined
// 146168712: variable 'v22' is possibly undefined
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);
// 1461689E0: using guessed type void __fastcall __noreturn unknown_libname_5(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146168980) ----------------------------------------------------
FARPROC sub_146168980()
{
  HMODULE ModuleHandleW; // rax
  FARPROC result; // rax

  ModuleHandleW = GetModuleHandleW(L"CoreRT.dll");
  result = GetProcAddress(ModuleHandleW, "CoreSetMappingFunction");
  if ( result )
    return (FARPROC)((__int64 (__fastcall *)(__int64 (__fastcall *)()))result)(sub_146166300);
  return result;
}
// 146166300: using guessed type __int64 __fastcall sub_146166300();

//----- (00000001461689C0) ----------------------------------------------------
void **__fastcall sub_1461689C0(void **Src, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_146166DC0(&qword_1461090A0, Src, a3, a4);
}

//----- (00000001461689D0) ----------------------------------------------------
char sub_1461689D0()
{
  return 1;
}

//----- (0000000146168A00) ----------------------------------------------------
void __fastcall sub_146168A00(_QWORD *a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r14
  unsigned __int64 v5; // rsi
  _QWORD *v6; // rdi
  _QWORD *v7; // rbx

  v3 = a1[3];
  v5 = v3 + (v3 >> 1);
  if ( a2 <= v5 )
  {
    if ( v5 > 0x7FFFFFFFFFFFFFFFi64 )
    {
      v5 = 0x7FFFFFFFFFFFFFFFi64;
      if ( a2 > 0x7FFFFFFFFFFFFFFFi64 )
        v5 = a2;
    }
  }
  else
  {
    v5 = a2;
  }
  v6 = (_QWORD *)a1[1];
  if ( v5 > 0x7FFFFFFFFFFFFFFFi64 )
    sub_146165390(a1, a2, a3);
  v7 = sub_14615A5E0(2 * v5);
  memmove(v7, v6, 2i64 * a1[2]);
  a1[1] = v7;
  a1[3] = v5;
  if ( v6 != a1 + 4 )
  {
    if ( 2 * v3 >= 0x1000 )
    {
      if ( (unsigned __int64)v6 - *(v6 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v6 = (_QWORD *)*(v6 - 1);
    }
    j_j_free(v6);
  }
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);

//----- (0000000146168B00) ----------------------------------------------------
void __fastcall __noreturn StartAddress(PVOID Parameter)
{
  sub_146171E10(0i64, Parameter);
}
// 146171E10: using guessed type void __fastcall __noreturn sub_146171E10(_QWORD, _QWORD);

//----- (0000000146168B10) ----------------------------------------------------
__int64 *__fastcall sub_146168B10(__int64 *a1, __int64 *a2, int a3)
{
  __int64 v3; // rax
  __int64 v5; // r11
  unsigned int v6; // r9d
  unsigned int v8; // ecx

  v3 = a1[2];
  v5 = a1[1];
  v6 = a3;
  if ( a3 >= 0 )
  {
    v8 = dword_14611CFB0[(__int64)(int)(*(_DWORD *)(v5 + 12) << 25) >> 29];
  }
  else
  {
    v8 = 16777261;
    v6 = -a3;
  }
  sub_14616D3E0(a2, *a1, v6 | ((unsigned __int64)v8 << 32), v5, v3);
  return a2;
}
// 14611CFB0: using guessed type int dword_14611CFB0[];

//----- (0000000146168B80) ----------------------------------------------------
__int64 __fastcall sub_146168B80(__int64 a1, unsigned int a2)
{
  const char *pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v4; // [rsp+30h] [rbp-38h]
  void **v5; // [rsp+40h] [rbp-28h] BYREF
  __int128 v6; // [rsp+48h] [rbp-20h]

  if ( a2 > 0x7FFFFFFF )
  {
    v5 = &std::exception::`vftable';
    v6 = 0i64;
    pExceptionObject = "number is too big";
    v4 = 1;
    _std_exception_copy(&pExceptionObject);
    v5 = &fmt::v8::format_error::`vftable';
    sub_146162440((__int64)&pExceptionObject, (__int64)&v5);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  return a2;
}
// 146168BA2: conditional instruction was optimized away because edx.4>=0
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146168C20) ----------------------------------------------------
_QWORD *__fastcall sub_146168C20(__int64 *a1, _QWORD *a2, const wchar_t *a3)
{
  __int64 v3; // rbp
  __int64 v5; // rbx
  char v7; // di
  unsigned __int64 v8; // rax
  int v9; // edi
  __int64 v10; // r9
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rdx
  size_t v13; // rax
  unsigned __int64 v14; // rsi
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rax
  const wchar_t *v18; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int64 v19; // [rsp+38h] [rbp-30h]
  char v20; // [rsp+70h] [rbp+8h] BYREF
  __int64 v21; // [rsp+78h] [rbp+10h] BYREF

  v3 = a1[1];
  v5 = *a1;
  v20 = 0;
  v7 = *(_BYTE *)(v3 + 8);
  if ( !v7 || v7 == 115 )
  {
    v13 = wcslen(a3);
    LOBYTE(v21) = 0;
    v14 = v13;
    v15 = *(unsigned int *)(v3 + 4);
    if ( (v15 & 0x80000000) == 0i64 && v15 < v14 )
      v14 = *(unsigned int *)(v3 + 4);
    v18 = a3;
    v16 = v14;
    if ( !*(_DWORD *)v3 )
      v16 = 0i64;
    v19 = v14;
    sub_14616E970(&v21, v5, (unsigned int *)v3, v14, v16, &v18);
  }
  else
  {
    if ( v7 != 112 )
      sub_14619FE20((__int64)&v20, (__int64)"invalid type specifier");
    v8 = (unsigned __int64)a3;
    v9 = 0;
    do
    {
      ++v9;
      v8 >>= 4;
    }
    while ( v8 );
    if ( v9 < 0 )
      sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
    v10 = (unsigned int)v9 + 2i64;
    v18 = a3;
    LODWORD(v19) = v9;
    if ( v3 )
    {
      sub_14616FAE0(&v21, v5, (unsigned int *)v3, v10, (unsigned int)v9 + 2i64, (__int64)&v18);
    }
    else
    {
      v11 = *(_QWORD *)(v5 + 16) + 1i64;
      if ( v11 > *(_QWORD *)(v5 + 24) )
        (**(void (__fastcall ***)(__int64, unsigned __int64, const wchar_t *, __int64))v5)(v5, v11, a3, v10);
      *(_WORD *)(*(_QWORD *)(v5 + 8) + 2i64 * (*(_QWORD *)(v5 + 16))++) = 48;
      v12 = *(_QWORD *)(v5 + 16) + 1i64;
      if ( v12 > *(_QWORD *)(v5 + 24) )
        (**(void (__fastcall ***)(__int64, unsigned __int64, const wchar_t *, __int64))v5)(v5, v12, a3, v10);
      *(_WORD *)(*(_QWORD *)(v5 + 8) + 2i64 * (*(_QWORD *)(v5 + 16))++) = 120;
      sub_146169B50(&v21, v5, (unsigned __int64)a3, v9, 0);
    }
  }
  *a2 = v21;
  return a2;
}
// 146168D5D: conditional instruction was optimized away because di.1==73
// 146168D0B: variable 'a3' is possibly undefined
// 146168D0B: variable 'v10' is possibly undefined

//----- (0000000146168DE0) ----------------------------------------------------
__int64 __fastcall sub_146168DE0(__int64 a1, __int64 a2)
{
  unsigned int v2; // ebx
  const char *pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v5; // [rsp+30h] [rbp-38h]
  void **v6; // [rsp+40h] [rbp-28h] BYREF
  __int128 v7; // [rsp+48h] [rbp-20h]

  v2 = a2;
  if ( (unsigned __int64)(a2 + 0x80000000i64) > 0xFFFFFFFF )
  {
    v6 = &std::exception::`vftable';
    v7 = 0i64;
    pExceptionObject = "number is too big";
    v5 = 1;
    _std_exception_copy(&pExceptionObject);
    v6 = &fmt::v8::format_error::`vftable';
    sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  if ( (int)a2 < 0 )
    return 0;
  return v2;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146168E90) ----------------------------------------------------
__int64 __fastcall sub_146168E90(__int64 a1, unsigned __int64 a2)
{
  const char *pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v4; // [rsp+30h] [rbp-38h]
  void **v5; // [rsp+40h] [rbp-28h] BYREF
  __int128 v6; // [rsp+48h] [rbp-20h]

  if ( a2 > 0x7FFFFFFF )
  {
    v5 = &std::exception::`vftable';
    v6 = 0i64;
    pExceptionObject = "number is too big";
    v4 = 1;
    _std_exception_copy(&pExceptionObject);
    v5 = &fmt::v8::format_error::`vftable';
    sub_146162440((__int64)&pExceptionObject, (__int64)&v5);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  return (unsigned int)a2;
}
// 146168EB4: conditional instruction was optimized away because edx.4>=0
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146168F30) ----------------------------------------------------
__int64 __fastcall sub_146168F30(_QWORD *a1, const void *a2, unsigned __int64 a3, __int64 a4)
{
  __int64 v4; // rsi
  __int64 v8; // rbx
  __int64 result; // rax
  __int64 v10; // rcx
  _QWORD *v11; // rax
  size_t v12; // rbx
  _QWORD *v13; // rdi

  v4 = 0x7FFFFFFFFFFFFFFEi64;
  if ( a3 > 0x7FFFFFFFFFFFFFFEi64 )
    unknown_libname_4(a1, a2, a3, a4);
  if ( a3 > 7 )
  {
    if ( (a3 | 7) <= 0x7FFFFFFFFFFFFFFEi64 )
    {
      v4 = a3 | 7;
      if ( (a3 | 7) < 0xA )
        v4 = 10i64;
      v10 = v4 + 1;
      if ( (unsigned __int64)(v4 + 1) > 0x7FFFFFFFFFFFFFFFi64 )
        sub_146165390();
    }
    else
    {
      v10 = 0x7FFFFFFFFFFFFFFFi64;
    }
    v11 = sub_14615A5E0(2 * v10);
    a1[2] = a3;
    v12 = 2 * a3;
    *a1 = v11;
    a1[3] = v4;
    v13 = v11;
    memcpy(v11, a2, v12);
    result = 0i64;
    *(_WORD *)((char *)v13 + v12) = 0;
  }
  else
  {
    a1[2] = a3;
    v8 = 2 * a3;
    a1[3] = 7i64;
    memcpy(a1, a2, 2 * a3);
    result = 0i64;
    *(_WORD *)((char *)a1 + v8) = 0;
  }
  return result;
}
// 146165390: using guessed type void __noreturn sub_146165390(void);
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146169020) ----------------------------------------------------
__int64 __fastcall sub_146169020(char a1, __int64 a2)
{
  __int64 result; // rax

  result = a1;
  switch ( a1 )
  {
    case 0:
    case 66:
    case 88:
    case 98:
    case 99:
    case 100:
    case 111:
    case 120:
      return result;
    default:
      sub_14619FE20(a2, (__int64)"invalid type specifier");
  }
}

//----- (00000001461690E0) ----------------------------------------------------
_QWORD *__fastcall sub_1461690E0(_QWORD *a1, char *a2, char *a3, __int64 a4)
{
  char *v6; // rdi
  __int16 v8; // bp

  v6 = a2;
  if ( a2 == a3 )
  {
    *a1 = a4;
  }
  else
  {
    do
    {
      v8 = *v6++;
      if ( (unsigned __int64)(*(_QWORD *)(a4 + 16) + 1i64) > *(_QWORD *)(a4 + 24) )
        (**(void (__fastcall ***)(__int64))a4)(a4);
      *(_WORD *)(*(_QWORD *)(a4 + 8) + 2i64 * (*(_QWORD *)(a4 + 16))++) = v8;
    }
    while ( v6 != a3 );
    *a1 = a4;
  }
  return a1;
}

//----- (0000000146169170) ----------------------------------------------------
char __fastcall sub_146169170(__int64 a1, __int64 a2)
{
  __int64 v3; // rax
  __int64 v5; // r9
  signed __int64 v6; // rbp
  _QWORD *v7; // r8
  __int64 v8; // rsi
  __int64 v9; // rdi
  __int64 v11; // r8
  __int64 v12; // rbx
  __int64 v13; // r13
  signed __int64 v14; // r14
  __int64 v15; // rdi
  unsigned __int64 v16; // rbp

  v3 = *(_QWORD *)(a1 + 32);
  if ( *(_BYTE *)(a1 + 72) )
  {
    v5 = *(_QWORD *)(a1 + 56);
    if ( (unsigned __int64)(*(_QWORD *)(a1 + 48) - v5 - v3) > 0x8000000000000000ui64 )
    {
      if ( (unsigned __int64)(_InterlockedExchangeAdd64((volatile signed __int64 *)(a1 + 48), 1ui64)
                            - *(_QWORD *)(a1 + 32)
                            - v5) > 0x8000000000000000ui64 )
      {
        v6 = _InterlockedExchangeAdd64((volatile signed __int64 *)(a1 + 40), 1ui64);
        v7 = *(_QWORD **)(a1 + 88);
        v8 = *(_QWORD *)(v7[2]
                       + 16
                       * ((*v7 - 1i64) & (v7[1]
                                        + (((v6 & 0xFFFFFFFFFFFFFFE0ui64) - *(_QWORD *)(16i64 * v7[1] + v7[2])) >> 5)))
                       + 8);
        v9 = v8 + ((unsigned __int64)(v6 & 0x1F) << 6);
        sub_146171310(a2 + 32, v9 + 32);
        sub_146171310(a2, v9);
        sub_1461626B0(v9 + 32);
        sub_1461626B0(v9);
        sub_14616A1A0(v8, v6);
        return 1;
      }
      goto LABEL_12;
    }
    return 0;
  }
  v11 = *(_QWORD *)(a1 + 56);
  if ( (unsigned __int64)(*(_QWORD *)(a1 + 48) - v11 - v3) <= 0x8000000000000000ui64 )
    return 0;
  if ( (unsigned __int64)(_InterlockedExchangeAdd64((volatile signed __int64 *)(a1 + 48), 1ui64)
                        - *(_QWORD *)(a1 + 32)
                        - v11) <= 0x8000000000000000ui64 )
  {
LABEL_12:
    _InterlockedIncrement64((volatile signed __int64 *)(a1 + 56));
    return 0;
  }
  v12 = _InterlockedExchangeAdd64((volatile signed __int64 *)(a1 + 40), 1ui64);
  v13 = sub_146173A20(a1, v12);
  v14 = *(_QWORD *)(v13 + 8);
  v15 = ((unsigned __int64)(v12 & 0x1F) << 6) + v14;
  sub_146171310(a2 + 32, v15 + 32);
  sub_146171310(a2, v15);
  sub_1461626B0(v15 + 32);
  sub_1461626B0(v15);
  v16 = _InterlockedExchangeAdd64((volatile signed __int64 *)(v14 + 2056), 1ui64);
  if ( v16 < 0x20 )
  {
    if ( v16 == 31 )
    {
      *(_QWORD *)(v13 + 8) = 0i64;
      sub_1461739D0(*(_QWORD *)(a1 + 80), v14);
    }
    return 1;
  }
  else
  {
    sub_1461A1C30(
      (wchar_t *)L"prevVal < BLOCK_SIZE",
      (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\vendor\\concurrentqueue\\concurrentqueue.h",
      1587);
    return 1;
  }
}

//----- (0000000146169370) ----------------------------------------------------
char __fastcall sub_146169370(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v5; // rdi
  _QWORD *v6; // rcx
  __int64 v7; // rdx
  _QWORD *v8; // rdi
  _QWORD *v9; // r14
  __int64 v10; // rbp
  _QWORD *v11; // rax
  __int64 v13; // rax
  unsigned __int64 v14; // r15

  v2 = a1[4];
  if ( (v2 & 0x1F) == 0 )
  {
    v5 = a1[5];
    if ( (unsigned __int64)(v2 - v5) > 0x8000000000000000ui64 )
      sub_1461A1C30(
        (wchar_t *)L"!details::circular_less_than<index_t>(currentTailIndex, head)",
        (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\vendor\\concurrentqueue\\concurrentqueue.h",
        2479);
    if ( (unsigned __int64)(v5 - v2 - 32) <= 0x8000000000000000ui64 )
      return 0;
    v6 = (_QWORD *)a1[12];
    if ( !v6 )
      return 0;
    v7 = (*v6 - 1i64) & (v6[1] + 1i64);
    v8 = *(_QWORD **)(v6[3] + 8 * v7);
    if ( *v8 == 1i64 || !v8[1] )
    {
      *v8 = v2;
      v6[1] = v7;
    }
    else
    {
      if ( !sub_146173E70((__int64)a1) )
        return 0;
      v9 = (_QWORD *)a1[12];
      v10 = (v9[1] + 1i64) & (*v9 - 1i64);
      v8 = *(_QWORD **)(v9[3] + 8 * v10);
      if ( *v8 != 1i64 )
        sub_1461A1C30(
          (wchar_t *)L"idxEntry->key.load(std::memory_order_relaxed) == INVALID_BLOCK_BASE",
          (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\vendor\\concurrentqueue\\concurrentqueue.h",
          2913);
      *v8 = v2;
      v9[1] = v10;
    }
    v11 = sub_14616A020(a1[10]);
    if ( !v11 )
    {
      *(_QWORD *)(a1[12] + 8i64) = (*(_QWORD *)(a1[12] + 8i64) - 1i64) & (*(_QWORD *)a1[12] - 1i64);
      v8[1] = 0i64;
      return 0;
    }
    v11[257] = 0i64;
    v8[1] = v11;
    a1[8] = v11;
  }
  v13 = a1[8];
  v14 = (unsigned __int64)(v2 & 0x1F) << 6;
  *(_OWORD *)(v14 + v13) = 0i64;
  *(_QWORD *)(v14 + v13 + 16) = 0i64;
  *(_QWORD *)(v14 + v13 + 24) = 0i64;
  *(_OWORD *)(v14 + v13) = *(_OWORD *)a2;
  *(_OWORD *)(v14 + v13 + 16) = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0i64;
  *(_QWORD *)(a2 + 24) = 15i64;
  *(_BYTE *)a2 = 0;
  *(_OWORD *)(v14 + v13 + 32) = 0i64;
  *(_QWORD *)(v14 + v13 + 48) = 0i64;
  *(_QWORD *)(v14 + v13 + 56) = 0i64;
  *(_OWORD *)(v14 + v13 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v14 + v13 + 48) = *(_OWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0i64;
  *(_QWORD *)(a2 + 56) = 15i64;
  *(_BYTE *)(a2 + 32) = 0;
  a1[4] = v2 + 1;
  return 1;
}

//----- (0000000146169570) ----------------------------------------------------
__int64 *__fastcall sub_146169570(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 v6; // r14
  _WORD *v10; // rbp
  _WORD *i; // rdi
  _WORD *v12; // rsi

  v4 = *(unsigned __int8 *)(a4 + 8);
  v6 = a3;
  if ( v4 == 1 )
  {
    sub_146169630(a1, a2, a3, (_WORD *)a4);
    return a1;
  }
  else
  {
    if ( a3 )
    {
      v10 = (_WORD *)(a4 + 2 * v4);
      do
      {
        for ( i = (_WORD *)a4; i != v10; ++*(_QWORD *)(a2 + 16) )
        {
          v12 = i++;
          if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
            (**(void (__fastcall ***)(__int64))a2)(a2);
          *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * *(_QWORD *)(a2 + 16)) = *v12;
        }
        --v6;
      }
      while ( v6 );
    }
    *a1 = a2;
    return a1;
  }
}

//----- (0000000146169630) ----------------------------------------------------
_QWORD *__fastcall sub_146169630(_QWORD *a1, __int64 a2, __int64 a3, _WORD *a4)
{
  __int64 v5; // rdi

  v5 = a3;
  if ( a3 )
  {
    do
    {
      if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
        (**(void (__fastcall ***)(__int64))a2)(a2);
      *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *a4;
      --v5;
    }
    while ( v5 );
    *a1 = a2;
  }
  else
  {
    *a1 = a2;
  }
  return a1;
}

//----- (00000001461696B0) ----------------------------------------------------
_QWORD *__fastcall sub_1461696B0(char **a1, _QWORD *a2, const struct tm *a3, __int64 *a4)
{
  _QWORD *v6; // r13
  __int64 v7; // rdx
  size_t v8; // rbx
  char *v9; // rsi
  char *v10; // r14
  size_t v11; // rdi
  size_t v12; // rdx
  size_t v13; // rdx
  __int64 v14; // rcx
  size_t i; // rsi
  __int64 v16; // rdx
  size_t v17; // rdx
  __int64 v18; // rbx
  char *v19; // rdi
  char *v20; // rsi
  char *v21; // rax
  char *v22; // rcx
  void **v25; // [rsp+40h] [rbp-C0h] BYREF
  char *Format; // [rsp+48h] [rbp-B8h]
  __int64 v27; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v28; // [rsp+58h] [rbp-A8h]
  char v29[512]; // [rsp+60h] [rbp-A0h] BYREF
  void **v30; // [rsp+260h] [rbp+160h] BYREF
  char *v31; // [rsp+268h] [rbp+168h]
  size_t v32; // [rsp+270h] [rbp+170h]
  size_t SizeInBytes; // [rsp+278h] [rbp+178h]
  char Buffer[512]; // [rsp+280h] [rbp+180h] BYREF

  v6 = a2;
  v7 = 0i64;
  v27 = 0i64;
  v25 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  Format = v29;
  v8 = 500i64;
  v28 = 500i64;
  v9 = *a1;
  v10 = &a1[1][(_QWORD)*a1];
  if ( *a1 != v10 )
  {
    do
    {
      v11 = v10 - v9;
      if ( v10 - v9 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( v7 + v11 > v28 )
      {
        v12 = v7 + v11;
        if ( *v25 == sub_146165760 )
          sub_146165760(&v25, v12);
        else
          ((void (__fastcall *)(void ***, size_t))*v25)(&v25, v12);
        v7 = v27;
      }
      if ( v28 - v7 < v11 )
        v11 = v28 - v7;
      if ( v11 )
      {
        memmove(&Format[v7], v9, v11);
        v7 = v27;
      }
      v7 += v11;
      v27 = v7;
      v9 += v11;
    }
    while ( v9 != v10 );
    v6 = a2;
  }
  if ( v7 + 1 > v28 )
  {
    v13 = v7 + 1;
    if ( *v25 == sub_146165760 )
      sub_146165760(&v25, v13);
    else
      ((void (__fastcall *)(void ***, size_t))*v25)(&v25, v13);
    v7 = v27;
  }
  Format[v7] = 32;
  v14 = v27 + 1;
  v27 = v14;
  if ( v14 + 1 > v28 )
  {
    if ( *v25 == sub_146165760 )
      sub_146165760(&v25, v14 + 1);
    else
      ((void (__fastcall *)(void ***))*v25)(&v25);
    v14 = v27;
  }
  Format[v14] = 0;
  ++v27;
  v32 = 0i64;
  v30 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  v31 = Buffer;
  SizeInBytes = 500i64;
  for ( i = strftime(Buffer, 0x1F4ui64, Format, a3); !i; i = strftime(v31, v8, Format, a3) )
  {
    v16 = 10i64;
    if ( v8 > 0xA )
      v16 = v8;
    v8 = SizeInBytes;
    if ( SizeInBytes + v16 > SizeInBytes )
    {
      ((void (__fastcall *)(void ***))*v30)(&v30);
      v8 = SizeInBytes;
    }
  }
  v17 = SizeInBytes;
  if ( i <= SizeInBytes || (((void (__fastcall *)(void ***, size_t))*v30)(&v30, i), v17 = SizeInBytes, i <= SizeInBytes) )
  {
    v32 = i;
  }
  else
  {
    i = SizeInBytes;
    v32 = SizeInBytes;
  }
  v18 = *a4;
  v19 = v31;
  v20 = &v31[i - 1];
  if ( v31 != v20 )
  {
    do
    {
      if ( (unsigned __int64)(*(_QWORD *)(v18 + 16) + 1i64) > *(_QWORD *)(v18 + 24) )
        (**(void (__fastcall ***)(__int64))v18)(v18);
      *(_BYTE *)(*(_QWORD *)(v18 + 8) + (*(_QWORD *)(v18 + 16))++) = *v19++;
    }
    while ( v19 != v20 );
    v17 = SizeInBytes;
    v19 = v31;
  }
  *v6 = v18;
  v30 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  if ( v19 != Buffer )
  {
    v21 = v19;
    if ( v17 >= 0x1000 )
    {
      v19 = (char *)*((_QWORD *)v19 - 1);
      if ( (unsigned __int64)(v21 - v19 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v19);
  }
  v25 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  v22 = Format;
  if ( Format != v29 )
  {
    if ( v28 >= 0x1000 )
    {
      v22 = (char *)*((_QWORD *)Format - 1);
      if ( (unsigned __int64)(Format - v22 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v22);
  }
  return v6;
}
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';

//----- (0000000146169A80) ----------------------------------------------------
__int64 *__fastcall sub_146169A80(const struct tm *a1, __int64 a2, __int64 *a3)
{
  char *v3; // rdi
  char *v5; // r9
  char *i; // rbx
  char *v7; // rbp
  __int64 v8; // rbx
  __int64 *result; // rax
  char *v10[5]; // [rsp+20h] [rbp-28h] BYREF
  __int64 v11; // [rsp+58h] [rbp+10h] BYREF

  v3 = *(char **)a2;
  v5 = (char *)(*(_QWORD *)a2 + *(_QWORD *)(a2 + 8));
  if ( *(char **)a2 != v5 && *v3 == 58 )
    ++v3;
  for ( i = v3; i != v5; ++i )
  {
    if ( *i == 125 )
      break;
  }
  v7 = (char *)(i - v3);
  if ( i - v3 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v8 = (__int64)&i[-*(_QWORD *)a2];
  v10[0] = v3;
  v10[1] = v7;
  if ( v8 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  *(_QWORD *)a2 += v8;
  *(_QWORD *)(a2 + 8) -= v8;
  result = sub_1461696B0(v10, &v11, a1, a3);
  *a3 = *result;
  return result;
}

//----- (0000000146169B50) ----------------------------------------------------
_QWORD *__fastcall sub_146169B50(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4, char a5)
{
  __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  __int64 v10; // rax
  char *v11; // r8
  char *v12; // r14
  char *v13; // rcx
  __int64 v14; // rax
  char *i; // rdi
  __int16 v16; // bp
  __int64 v18; // rax
  __int64 v19; // rcx
  char *v20; // r8
  _WORD *v21; // rdx
  __int64 v22; // rcx
  char v23[24]; // [rsp+20h] [rbp-38h] BYREF

  if ( a4 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v8 = *(_QWORD *)(a2 + 16);
  v9 = v8 + (unsigned int)a4;
  if ( *(_QWORD *)(a2 + 24) < v9 )
  {
    v10 = a4;
LABEL_5:
    v11 = "0123456789abcdef";
    v12 = &v23[v10];
    v13 = &v23[v10];
    if ( a5 )
      v11 = "0123456789ABCDEF";
    do
    {
      --v13;
      v14 = a3 & 0xF;
      a3 >>= 4;
      *v13 = v11[v14];
    }
    while ( a3 );
    for ( i = v23; i != v12; ++*(_QWORD *)(a2 + 16) )
    {
      v16 = *i++;
      if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
        (**(void (__fastcall ***)(__int64))a2)(a2);
      *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * *(_QWORD *)(a2 + 16)) = v16;
    }
    goto LABEL_12;
  }
  v18 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 16) = v9;
  v19 = v18 + 2 * v8;
  v10 = a4;
  if ( !v19 )
    goto LABEL_5;
  v20 = "0123456789abcdef";
  if ( a5 )
    v20 = "0123456789ABCDEF";
  v21 = (_WORD *)(v19 + 2i64 * a4);
  do
  {
    --v21;
    v22 = a3 & 0xF;
    a3 >>= 4;
    *v21 = v20[v22];
  }
  while ( a3 );
LABEL_12:
  *a1 = a2;
  return a1;
}

//----- (0000000146169CC0) ----------------------------------------------------
__int64 __fastcall sub_146169CC0(unsigned __int16 **a1, unsigned __int16 *a2, __int64 a3, __int64 *a4)
{
  unsigned int v8; // r15d
  unsigned __int16 v9; // r14
  unsigned int v10; // esi
  unsigned __int16 *v11; // rax
  unsigned __int16 *v12; // rcx
  unsigned __int16 v13; // ax
  int v15; // eax
  _DWORD *v16; // rax
  const char *v17; // [rsp+28h] [rbp-50h] BYREF
  char v18; // [rsp+30h] [rbp-48h]
  void **v19; // [rsp+38h] [rbp-40h] BYREF
  __int128 v20; // [rsp+40h] [rbp-38h]
  __int64 v21; // [rsp+80h] [rbp+8h] BYREF

  v8 = -1;
  v9 = **a1;
  if ( (unsigned __int16)(v9 - 48) <= 9u )
  {
    v10 = sub_146169F30(a1, a2, 0xFFFFFFFF);
    v11 = *a1;
    if ( *a1 == a2 || *v11 != 36 )
    {
      if ( v9 == 48 )
        *(_WORD *)(a3 + 18) = 48;
      if ( v10 )
      {
        if ( v10 == -1 )
        {
          v19 = &std::exception::`vftable';
          v20 = 0i64;
          v17 = "number is too big";
          v18 = 1;
          _std_exception_copy(&v17);
          v19 = &fmt::v8::format_error::`vftable';
          sub_14615AB90((__int64)&v19);
        }
        *(_DWORD *)a3 = v10;
        return 0xFFFFFFFFi64;
      }
    }
    else
    {
      *a1 = v11 + 1;
      v8 = 0x7FFFFFFF;
      if ( v10 != -1 )
        v8 = v10;
    }
  }
  v12 = *a1;
  if ( *a1 != a2 )
  {
    do
    {
      v13 = *v12;
      if ( *v12 == 32 )
      {
        if ( (*(_DWORD *)(a3 + 12) & 0x70) != 32 )
          *(_DWORD *)(a3 + 12) = *(_DWORD *)(a3 + 12) & 0xFFFFFF8F | 0x30;
      }
      else
      {
        switch ( v13 )
        {
          case '#':
            *(_BYTE *)(a3 + 16) |= 1u;
            break;
          case '+':
            *(_DWORD *)(a3 + 12) &= 0xFFFFFFAF;
            *(_DWORD *)(a3 + 12) |= 0x20u;
            break;
          case '-':
            *(_DWORD *)(a3 + 12) &= 0xFFFFFFF1;
            *(_DWORD *)(a3 + 12) |= 1u;
            break;
          case '0':
            *(_WORD *)(a3 + 18) = 48;
            break;
          default:
            goto LABEL_25;
        }
      }
      v12 = ++*a1;
    }
    while ( *a1 != a2 );
LABEL_25:
    if ( v12 != a2 )
    {
      if ( (unsigned __int16)(*v12 - 48) > 9u )
      {
        if ( *v12 == 42 )
        {
          *a1 = v12 + 1;
          v16 = (_DWORD *)sub_146162AC0(a4, (__int64)&v19, -1);
          v21 = a3;
          *(_DWORD *)a3 = sub_14616ACE0((__int64)&v21, v16);
        }
      }
      else
      {
        v15 = sub_146169F30(a1, a2, 0xFFFFFFFF);
        *(_DWORD *)a3 = v15;
        if ( v15 == -1 )
        {
          v19 = &std::exception::`vftable';
          v20 = 0i64;
          v17 = "number is too big";
          v18 = 1;
          _std_exception_copy(&v17);
          v19 = &fmt::v8::format_error::`vftable';
          sub_14615AB90((__int64)&v19);
        }
      }
    }
  }
  return v8;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146169F30) ----------------------------------------------------
__int64 __fastcall sub_146169F30(unsigned __int16 **a1, unsigned __int16 *a2, unsigned int a3)
{
  unsigned __int16 v5; // ax
  unsigned int v6; // r8d
  unsigned __int16 *v7; // rdx
  unsigned __int16 v8; // ax
  unsigned __int16 *v9; // r10
  __int64 v10; // r11
  __int64 v11; // rax

  if ( *a1 == a2 || (v5 = **a1, v5 < 0x30u) || v5 > 0x39u )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x832u, Src);
  v6 = 0;
  v7 = *a1;
  v8 = **a1;
  do
  {
    v9 = v7;
    v10 = v6;
    v6 = v8 + 2 * (5 * v6 - 24);
    if ( ++v7 == a2 )
      break;
    v8 = *v7;
    if ( *v7 < 0x30u )
      break;
  }
  while ( v8 <= 0x39u );
  v11 = v7 - *a1;
  *a1 = v7;
  if ( v11 > 9 && (v11 != 10 || (unsigned __int64)((unsigned int)*v9 - 48) + 10 * v10 > 0x7FFFFFFF) )
    return a3;
  return v6;
}

//----- (000000014616A020) ----------------------------------------------------
_QWORD *__fastcall sub_14616A020(__int64 a1)
{
  unsigned __int64 v2; // rax
  _QWORD *result; // rax
  signed __int64 v4; // rbx
  volatile signed __int32 *v5; // r9
  signed __int64 v6; // rcx
  signed __int32 v7; // eax
  signed __int64 v8; // rax
  signed __int64 v9; // rdx
  bool v10; // zf
  signed __int64 v11; // rax

  if ( *(_QWORD *)(a1 + 16) < *(_QWORD *)(a1 + 32) )
  {
    v2 = _InterlockedExchangeAdd64((volatile signed __int64 *)(a1 + 16), 1ui64);
    if ( v2 < *(_QWORD *)(a1 + 32) )
    {
      result = (_QWORD *)(*(_QWORD *)(a1 + 24) + 2120 * v2);
      if ( result )
        return result;
    }
  }
  v4 = *(_QWORD *)(a1 + 40);
  if ( !v4 )
  {
LABEL_15:
    result = malloc_0(0x848ui64);
    if ( !result )
      return 0i64;
    result[256] = 0i64;
    result[257] = 0i64;
    *((_OWORD *)result + 129) = 0i64;
    *((_OWORD *)result + 130) = 0i64;
    *((_DWORD *)result + 524) = 0;
    result[263] = 0i64;
    *((_WORD *)result + 1056) = 256;
    return result;
  }
  while ( 1 )
  {
    v5 = (volatile signed __int32 *)(v4 + 2096);
    v6 = v4;
    v7 = *(_DWORD *)(v4 + 2096);
    if ( (v7 & 0x7FFFFFFF) != 0 && v7 == _InterlockedCompareExchange(v5, v7 + 1, v7) )
      break;
    v4 = *(_QWORD *)(a1 + 40);
LABEL_14:
    if ( !v4 )
      goto LABEL_15;
  }
  v8 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 40), *(_QWORD *)(v4 + 2104), v4);
  if ( v4 != v8 )
  {
    v4 = v8;
    if ( _InterlockedExchangeAdd(v5, 0xFFFFFFFF) == -2147483647 )
    {
      v9 = *(_QWORD *)(a1 + 40);
      do
      {
        *(_QWORD *)(v6 + 2104) = v9;
        *(_DWORD *)(v6 + 2096) = 1;
        v11 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 40), v6, v9);
        v10 = v9 == v11;
        v9 = v11;
      }
      while ( !v10 && _InterlockedExchangeAdd((volatile signed __int32 *)(v6 + 2096), 0x7FFFFFFFu) == 1 );
    }
    goto LABEL_14;
  }
  if ( *(int *)(v4 + 2096) < 0 )
    sub_1461A1C30(
      (wchar_t *)L"(head->freeListRefs.load(std::memory_order_relaxed) & SHOULD_BE_ON_FREELIST) == 0",
      (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\vendor\\concurrentqueue\\concurrentqueue.h",
      1472);
  _InterlockedAdd((volatile signed __int32 *)(v4 + 2096), 0xFFFFFFFE);
  return (_QWORD *)v4;
}

//----- (000000014616A1A0) ----------------------------------------------------
char __fastcall sub_14616A1A0(__int64 a1, char a2)
{
  __int64 v2; // rbx
  char result; // al

  v2 = a1 - (a2 & 0x1F);
  if ( *(_BYTE *)(v2 + 2095) )
    sub_1461A1C30(
      (wchar_t *)L"!emptyFlags[BLOCK_SIZE - 1 - static_cast<size_t>(i & static_cast<index_t>(BLOCK_SIZE - 1))].load(std::m"
                  "emory_order_relaxed)",
      (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\vendor\\concurrentqueue\\concurrentqueue.h",
      1580);
  result = 0;
  *(_BYTE *)(v2 + 2095) = 1;
  return result;
}

//----- (000000014616A1F0) ----------------------------------------------------
__int64 __fastcall sub_14616A1F0(__int64 *a1, _DWORD *a2)
{
  __int64 result; // rax
  __int64 v3; // r8
  __int64 v4; // rcx
  __int16 v5; // ax
  __int128 v6; // [rsp+0h] [rbp-20h]
  __int64 v7; // [rsp+10h] [rbp-10h]

  result = a2[4] - 1;
  switch ( a2[4] )
  {
    case 1:
    case 2:
      LODWORD(v3) = *a2;
      goto LABEL_10;
    case 3:
    case 4:
      v3 = *(_QWORD *)a2;
      goto LABEL_10;
    case 7:
      result = *((unsigned __int16 *)a1 + 4);
      if ( (_WORD)result == 115 )
        return result;
      LOBYTE(v3) = *(_BYTE *)a2;
      if ( (_WORD)result != 100 && (_WORD)result != 105 )
        goto LABEL_7;
      LODWORD(v6) = *(char *)a2;
      goto LABEL_13;
    case 8:
      LOWORD(v3) = *(_WORD *)a2;
LABEL_10:
      v5 = *((_WORD *)a1 + 4);
      if ( v5 == 100 || v5 == 105 )
      {
        LODWORD(v6) = (char)v3;
LABEL_13:
        result = *a1;
        LODWORD(v7) = 1;
        *(_OWORD *)result = v6;
        *(_QWORD *)(result + 16) = v7;
      }
      else
      {
LABEL_7:
        v4 = *a1;
        LODWORD(v6) = (unsigned __int8)v3;
        result = HIDWORD(v6);
        LODWORD(v7) = 2;
        *(_OWORD *)v4 = v6;
        *(_QWORD *)(v4 + 16) = v7;
      }
      return result;
    default:
      return result;
  }
}
// 14616A255: variable 'v6' is possibly undefined
// 14616A273: variable 'v7' is possibly undefined

//----- (000000014616A350) ----------------------------------------------------
__int64 __fastcall sub_14616A350(__int64 *a1, _DWORD *a2)
{
  __int64 result; // rax
  __int64 v3; // r8
  __int16 v4; // ax
  __int64 v5; // rcx
  __int16 v6; // ax
  __int128 v7; // [rsp+0h] [rbp-20h]
  __int64 v8; // [rsp+10h] [rbp-10h]

  result = a2[4] - 1;
  switch ( a2[4] )
  {
    case 1:
    case 2:
      LODWORD(v3) = *a2;
      goto LABEL_3;
    case 3:
    case 4:
      v3 = *(_QWORD *)a2;
LABEL_3:
      v4 = *((_WORD *)a1 + 4);
      if ( v4 != 100 && v4 != 105 )
        goto LABEL_5;
      LODWORD(v7) = (__int16)v3;
      goto LABEL_16;
    case 7:
      result = *((unsigned __int16 *)a1 + 4);
      if ( (_WORD)result == 115 )
        return result;
      LODWORD(v3) = *(unsigned __int8 *)a2;
      if ( (_WORD)result == 100 || (_WORD)result == 105 )
      {
LABEL_15:
        LODWORD(v7) = v3;
LABEL_16:
        result = *a1;
        LODWORD(v8) = 1;
        *(_OWORD *)result = v7;
        *(_QWORD *)(result + 16) = v8;
      }
      else
      {
        LODWORD(v7) = *(unsigned __int8 *)a2;
LABEL_6:
        v5 = *a1;
        result = HIDWORD(v7);
        LODWORD(v8) = 2;
        *(_OWORD *)v5 = v7;
        *(_QWORD *)(v5 + 16) = v8;
      }
      return result;
    case 8:
      v6 = *((_WORD *)a1 + 4);
      LODWORD(v3) = *(__int16 *)a2;
      if ( v6 == 100 || v6 == 105 )
        goto LABEL_15;
LABEL_5:
      LODWORD(v7) = (unsigned __int16)v3;
      goto LABEL_6;
    default:
      return result;
  }
}
// 14616A3A0: variable 'v7' is possibly undefined
// 14616A3BE: variable 'v8' is possibly undefined

//----- (000000014616A480) ----------------------------------------------------
__int64 __fastcall sub_14616A480(__int64 *a1, _DWORD *a2)
{
  __int64 result; // rax
  __int64 v3; // r8
  __int64 v4; // rcx
  __int128 v5; // [rsp+0h] [rbp-20h]
  __int64 v6; // [rsp+10h] [rbp-10h]

  result = a2[4] - 1;
  switch ( a2[4] )
  {
    case 1:
    case 2:
      LODWORD(v3) = *a2;
      goto LABEL_7;
    case 3:
    case 4:
      v3 = *(_QWORD *)a2;
      goto LABEL_7;
    case 7:
      result = *((unsigned __int16 *)a1 + 4);
      if ( (_WORD)result == 115 )
        return result;
      LODWORD(v3) = *(unsigned __int8 *)a2;
      goto LABEL_8;
    case 8:
      LODWORD(v3) = *(unsigned __int16 *)a2;
LABEL_7:
      LOWORD(result) = *((_WORD *)a1 + 4);
LABEL_8:
      if ( (_WORD)result == 100 || (_WORD)result == 105 )
      {
        result = *a1;
        LODWORD(v5) = v3;
        LODWORD(v6) = 1;
        *(_OWORD *)result = v5;
        *(_QWORD *)(result + 16) = v6;
      }
      else
      {
        v4 = *a1;
        result = HIDWORD(v5);
        LODWORD(v5) = v3;
        LODWORD(v6) = 2;
        *(_OWORD *)v4 = v5;
        *(_QWORD *)(v4 + 16) = v6;
      }
      break;
    default:
      return result;
  }
  return result;
}
// 14616A4E4: variable 'v5' is possibly undefined
// 14616A506: variable 'v6' is possibly undefined

//----- (000000014616A590) ----------------------------------------------------
__int64 __fastcall sub_14616A590(__int64 *a1, int *a2)
{
  __int64 result; // rax
  int v3; // r8d
  __int16 v4; // ax
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int128 v7; // [rsp+0h] [rbp-20h]
  __int64 v8; // [rsp+10h] [rbp-10h]

  result = a2[4] - 1;
  switch ( a2[4] )
  {
    case 1:
    case 2:
      v3 = *a2;
      goto LABEL_10;
    case 3:
    case 4:
      v4 = *((_WORD *)a1 + 4);
      if ( v4 != 100 && v4 != 105 )
      {
        v5 = *a1;
        result = *((_QWORD *)&v7 + 1);
        *(_QWORD *)&v7 = *(_QWORD *)a2;
        LODWORD(v8) = 4;
        *(_OWORD *)v5 = v7;
        *(_QWORD *)(v5 + 16) = v8;
        return result;
      }
      LODWORD(v8) = 3;
      *(_QWORD *)&v7 = *(_QWORD *)a2;
      goto LABEL_15;
    case 7:
      result = *((unsigned __int16 *)a1 + 4);
      if ( (_WORD)result == 115 )
        return result;
      v3 = *(unsigned __int8 *)a2;
LABEL_11:
      if ( (_WORD)result == 100 || (_WORD)result == 105 )
      {
        LODWORD(v8) = 1;
        LODWORD(v7) = v3;
LABEL_15:
        result = *a1;
        *(_OWORD *)result = v7;
        *(_QWORD *)(result + 16) = v8;
      }
      else
      {
        v6 = *a1;
        result = HIDWORD(v7);
        LODWORD(v7) = v3;
        LODWORD(v8) = 2;
        *(_OWORD *)v6 = v7;
        *(_QWORD *)(v6 + 16) = v8;
      }
      return result;
    case 8:
      v3 = *(unsigned __int16 *)a2;
LABEL_10:
      LOWORD(result) = *((_WORD *)a1 + 4);
      goto LABEL_11;
    default:
      return result;
  }
}
// 14616A5D9: variable 'v7' is possibly undefined
// 14616A5F8: variable 'v8' is possibly undefined

//----- (000000014616A6F0) ----------------------------------------------------
__int64 __fastcall sub_14616A6F0(__int64 *a1, unsigned int *a2)
{
  __int64 result; // rax
  __int64 v3; // r8
  __int16 v4; // ax
  __int16 v5; // ax
  __int64 v6; // rcx
  __int128 v7; // [rsp+0h] [rbp-20h]
  __int64 v8; // [rsp+10h] [rbp-10h]

  result = (int)(a2[4] - 1);
  switch ( a2[4] )
  {
    case 1u:
      v3 = (int)*a2;
      goto LABEL_12;
    case 2u:
      v3 = *a2;
      goto LABEL_12;
    case 3u:
    case 4u:
      v4 = *((_WORD *)a1 + 4);
      v3 = *(_QWORD *)a2;
      if ( v4 == 100 || v4 == 105 )
        goto LABEL_16;
      result = *((_QWORD *)&v7 + 1);
      LODWORD(v8) = 4;
      *(_QWORD *)&v7 = *(_QWORD *)a2;
      goto LABEL_15;
    case 7u:
      result = *((unsigned __int16 *)a1 + 4);
      if ( (_WORD)result == 115 )
        return result;
      v3 = *(unsigned __int8 *)a2;
      if ( (_WORD)result == 100 || (_WORD)result == 105 )
        goto LABEL_16;
      result = HIBYTE(v7);
      LODWORD(v8) = 7;
      LOBYTE(v7) = *(_BYTE *)a2;
      goto LABEL_15;
    case 8u:
      v3 = *(unsigned __int16 *)a2;
LABEL_12:
      v5 = *((_WORD *)a1 + 4);
      if ( v5 == 100 || v5 == 105 )
      {
LABEL_16:
        result = *a1;
        *(_QWORD *)&v7 = v3;
        LODWORD(v8) = 3;
        *(_OWORD *)result = v7;
        *(_QWORD *)(result + 16) = v8;
      }
      else
      {
        result = HIDWORD(v7);
        LODWORD(v7) = v3;
        LODWORD(v8) = 2;
LABEL_15:
        v6 = *a1;
        *(_OWORD *)v6 = v7;
        *(_QWORD *)(v6 + 16) = v8;
      }
      return result;
    default:
      return result;
  }
}
// 14616A746: variable 'v7' is possibly undefined
// 14616A7E3: variable 'v8' is possibly undefined

//----- (000000014616A860) ----------------------------------------------------
__int64 *__fastcall sub_14616A860(__int64 *a1, __int64 *a2, unsigned int *a3)
{
  int v6; // r8d
  __int64 v7; // r8
  __int64 v8; // rax
  __int64 v9; // r9
  int v10; // ecx
  __int64 v11; // rdx
  __int64 v12; // r14
  char v13; // r9
  __int64 v14; // rbx
  char v15; // al
  const char *v16; // rdi
  __m128i *v17; // rax
  __m128i v18; // xmm1
  __int64 v19; // xmm0_8
  char v20; // al
  unsigned int v21; // eax
  int v22; // ecx
  __int64 v23; // rax
  float v24; // xmm2_4
  __int64 v25; // rdx
  __int128 v26; // xmm0
  __int64 v27; // xmm1_8
  __int64 v28; // rax
  double v29; // xmm2_8
  __int64 v30; // rdx
  __int128 v31; // xmm0
  __int64 v32; // xmm1_8
  __int64 v33; // rax
  long double v34; // xmm2_8
  __int64 v35; // rdx
  __int128 v36; // xmm0
  __int64 v37; // xmm1_8
  const wchar_t *v38; // r8
  __int64 v39; // r14
  unsigned __int64 v40; // rdi
  __int64 v41; // rbx
  char v42; // al
  __int64 v43; // r15
  unsigned __int64 v44; // rax
  bool v45; // zf
  unsigned __int64 v46; // rcx
  __int64 v47; // r8
  char *v48; // rcx
  __int64 v50; // [rsp+20h] [rbp-60h]
  __int64 v51; // [rsp+20h] [rbp-60h]
  __int64 v52; // [rsp+20h] [rbp-60h]
  char v53[16]; // [rsp+30h] [rbp-50h] BYREF
  __int128 v54; // [rsp+40h] [rbp-40h] BYREF
  __int128 v55; // [rsp+50h] [rbp-30h] BYREF
  __int64 v56; // [rsp+60h] [rbp-20h]
  int v57; // [rsp+68h] [rbp-18h]

  switch ( a3[4] )
  {
    case 1u:
      v6 = *a3;
      goto LABEL_3;
    case 2u:
      sub_14616D3E0(
        a1,
        *a2,
        *a3 | ((unsigned __int64)(unsigned int)dword_14611CFB0[(__int64)(int)(*(_DWORD *)(a2[1] + 12) << 25) >> 29] << 32),
        a2[1],
        a2[2]);
      return a1;
    case 3u:
      v7 = *(_QWORD *)a3;
      v8 = a2[2];
      v9 = a2[1];
      if ( v7 >= 0 )
      {
        v10 = dword_14611CFB0[(__int64)(int)(*(_DWORD *)(v9 + 12) << 25) >> 29];
      }
      else
      {
        v10 = 16777261;
        v7 = -v7;
      }
      *(_QWORD *)&v54 = v7;
      goto LABEL_9;
    case 4u:
      v9 = a2[1];
      v8 = a2[2];
      *(_QWORD *)&v54 = *(_QWORD *)a3;
      v10 = dword_14611CFB0[(__int64)(int)(*(_DWORD *)(v9 + 12) << 25) >> 29];
LABEL_9:
      v11 = *a2;
      DWORD2(v54) = v10;
      v55 = v54;
      sub_14616DA00(a1, v11, (__int64)&v55, v9, v8);
      break;
    case 5u:
    case 6u:
      sub_146163960(a2, a1, (unsigned __int8)v53[0]);
    case 7u:
      v12 = a2[1];
      v13 = *(_BYTE *)a3;
      v14 = *a2;
      v15 = *(_BYTE *)(v12 + 8);
      if ( !v15 || v15 == 115 )
      {
        v16 = "false";
        if ( v13 )
          v16 = "true";
        *(_QWORD *)&v55 = v16;
        *((_QWORD *)&v55 + 1) = strlen(v16);
        sub_14616E400(
          (__int64 *)&v54,
          v14,
          (unsigned int *)v12,
          *((__int64 *)&v55 + 1),
          *((unsigned __int64 *)&v55 + 1),
          (char **)&v55);
        *a1 = v54;
      }
      else
      {
        sub_14616D3E0(
          (__int64 *)&v54,
          v14,
          (v13 != 0) | ((unsigned __int64)(unsigned int)dword_14611CFB0[(__int64)(int)(*(_DWORD *)(v12 + 12) << 25) >> 29] << 32),
          v12,
          0i64);
        *a1 = v54;
      }
      break;
    case 8u:
      v17 = (__m128i *)a2[1];
      v6 = *(unsigned __int16 *)a3;
      v18 = *v17;
      v19 = v17[1].m128i_i64[0];
      LODWORD(v17) = v17[1].m128i_i32[2];
      v55 = (__int128)v18;
      v57 = (int)v17;
      v20 = _mm_cvtsi128_si32(_mm_srli_si128(v18, 8));
      v56 = v19;
      if ( v20 && v20 != 99 )
      {
LABEL_3:
        sub_146168B10(a2, a1, v6);
      }
      else
      {
        LOBYTE(v56) = v56 & 0xFE;
        v21 = HIDWORD(v55) & 0xFFFFFF8F;
        WORD1(v56) = 32;
        v22 = (int)(HIDWORD(v55) << 28) >> 28;
        HIDWORD(v55) &= 0xFFFFFF8F;
        if ( !v22 || v22 == 4 )
          HIDWORD(v55) = v21 & 0xFFFFFFF0 | 2;
        sub_14616BFB0(a1, *a2, v6, (__int64)&v55, 0i64);
      }
      break;
    case 9u:
      v23 = a2[1];
      v24 = *(float *)a3;
      v25 = *a2;
      v26 = *(_OWORD *)v23;
      v27 = *(_QWORD *)(v23 + 16);
      v57 = *(_DWORD *)(v23 + 24);
      v50 = a2[2];
      v55 = v26;
      v56 = v27;
      sub_14616C0A0(a1, v25, v24, (__int64)&v55, v50);
      break;
    case 0xAu:
      v28 = a2[1];
      v29 = *(double *)a3;
      v30 = *a2;
      v31 = *(_OWORD *)v28;
      v32 = *(_QWORD *)(v28 + 16);
      v57 = *(_DWORD *)(v28 + 24);
      v51 = a2[2];
      v55 = v31;
      v56 = v32;
      sub_14616C530(a1, v30, v29, (__int64)&v55, v51);
      break;
    case 0xBu:
      v33 = a2[1];
      v34 = *(double *)a3;
      v35 = *a2;
      v36 = *(_OWORD *)v33;
      v37 = *(_QWORD *)(v33 + 16);
      v57 = *(_DWORD *)(v33 + 24);
      v52 = a2[2];
      v55 = v36;
      v56 = v37;
      sub_14616C9B0(a1, v35, v34, (__int64)&v55, v52);
      break;
    case 0xCu:
      v38 = *(const wchar_t **)a3;
      if ( v38 )
        sub_146168C20(a2, a1, v38);
      else
        sub_146173FD0(a2, a1, *(_BYTE *)(a2[1] + 8) != 112);
      break;
    case 0xDu:
      v39 = a2[1];
      v40 = *((_QWORD *)a3 + 1);
      v41 = *a2;
      v42 = *(_BYTE *)(v39 + 8);
      v43 = *(_QWORD *)a3;
      v53[0] = 0;
      if ( v42 && v42 != 115 )
        sub_14619FE20((__int64)v53, (__int64)"invalid type specifier");
      v44 = *(unsigned int *)(v39 + 4);
      if ( (v44 & 0x80000000) == 0i64 && v44 < v40 )
        v40 = *(unsigned int *)(v39 + 4);
      *(_QWORD *)&v55 = v43;
      v45 = *(_DWORD *)v39 == 0;
      v46 = v40;
      *((_QWORD *)&v55 + 1) = v40;
      if ( v45 )
        v46 = 0i64;
      sub_14616E970(a1, v41, (unsigned int *)v39, v40, v46, &v55);
      break;
    case 0xEu:
      sub_146172710(a2, a1, *(char **)a3);
      break;
    case 0xFu:
      v47 = a2[3];
      v48 = *(char **)a3;
      v55 = 0ui64;
      LODWORD(v56) = 0;
      (*((void (__fastcall **)(char *, __int128 *, __int64))a3 + 1))(v48, &v55, v47);
      *a1 = *a2;
      break;
    default:
      sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\format.h", 0x73Cu, Src);
  }
  return a1;
}
// 14611CFB0: using guessed type int dword_14611CFB0[];
// 146163960: using guessed type void __fastcall __noreturn sub_146163960(_QWORD, _QWORD, _QWORD);
// 14616A860: using guessed type char var_50[16];

//----- (000000014616ACE0) ----------------------------------------------------
__int64 __fastcall sub_14616ACE0(__int64 a1, _DWORD *a2)
{
  unsigned __int64 v2; // rdi
  __int64 result; // rax
  const char *pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  char v5; // [rsp+30h] [rbp-30h]
  void **v6; // [rsp+40h] [rbp-20h] BYREF
  __int128 v7; // [rsp+48h] [rbp-18h]
  unsigned __int8 v8; // [rsp+78h] [rbp+18h]

  switch ( a2[4] )
  {
    case 1:
      LODWORD(v2) = *a2;
      if ( (int)*a2 < 0 )
      {
        *(_DWORD *)(*(_QWORD *)a1 + 12i64) = *(_DWORD *)(*(_QWORD *)a1 + 12i64) & 0xFFFFFFF0 | 1;
        LODWORD(v2) = -(int)v2;
      }
      if ( (unsigned int)v2 > 0x7FFFFFFF )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "number is too big";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      goto LABEL_5;
    case 2:
      LODWORD(v2) = *a2;
      if ( *a2 > 0x7FFFFFFFu )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "number is too big";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      goto LABEL_5;
    case 3:
      v2 = *(_QWORD *)a2;
      if ( *(__int64 *)a2 < 0 )
      {
        *(_DWORD *)(*(_QWORD *)a1 + 12i64) = *(_DWORD *)(*(_QWORD *)a1 + 12i64) & 0xFFFFFFF0 | 1;
        v2 = -(__int64)v2;
      }
      if ( v2 > 0x7FFFFFFF )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "number is too big";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      goto LABEL_5;
    case 4:
      v2 = *(_QWORD *)a2;
      if ( *(_QWORD *)a2 > 0x7FFFFFFFui64 )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "number is too big";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
LABEL_5:
      result = (unsigned int)v2;
      break;
    case 7:
      result = *(unsigned __int8 *)a2;
      break;
    case 8:
      result = *(unsigned __int16 *)a2;
      break;
    case 9:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xA:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xB:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xC:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xD:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xE:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xF:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    default:
      sub_146159870(a1, v8);
  }
  return result;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 146159870: using guessed type void __fastcall __noreturn sub_146159870(_QWORD, _QWORD);
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014616B250) ----------------------------------------------------
__int64 __fastcall sub_14616B250(__int64 a1, unsigned int *a2)
{
  __int64 result; // rax
  const char *pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  char v4; // [rsp+30h] [rbp-30h]
  void **v5; // [rsp+40h] [rbp-20h] BYREF
  __int128 v6; // [rsp+48h] [rbp-18h]
  unsigned __int8 v7; // [rsp+78h] [rbp+18h]

  switch ( a2[4] )
  {
    case 1u:
      result = *a2;
      if ( (int)result < 0 )
        result = 0i64;
      break;
    case 2u:
      result = sub_146168B80(a1, *a2);
      break;
    case 3u:
      result = sub_146168DE0(a1, *(_QWORD *)a2);
      break;
    case 4u:
      result = sub_146168E90(a1, *(_QWORD *)a2);
      break;
    case 7u:
      result = *(unsigned __int8 *)a2;
      break;
    case 8u:
      result = *(unsigned __int16 *)a2;
      break;
    case 9u:
      sub_1461598F0(a1, a2);
    case 0xAu:
      sub_1461598F0(a1, a2);
    case 0xBu:
      sub_1461598F0(a1, a2);
    case 0xCu:
      v5 = &std::exception::`vftable';
      v6 = 0i64;
      pExceptionObject = "precision is not integer";
      v4 = 1;
      _std_exception_copy(&pExceptionObject);
      v5 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v5);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xDu:
      v5 = &std::exception::`vftable';
      v6 = 0i64;
      pExceptionObject = "precision is not integer";
      v4 = 1;
      _std_exception_copy(&pExceptionObject);
      v5 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v5);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xEu:
      sub_1461598F0(a1, *(_QWORD *)a2);
    case 0xFu:
      v5 = &std::exception::`vftable';
      v6 = 0i64;
      pExceptionObject = "precision is not integer";
      v4 = 1;
      _std_exception_copy(&pExceptionObject);
      v5 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v5);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    default:
      sub_1461598F0(a1, v7);
  }
  return result;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461598F0: using guessed type void __fastcall __noreturn sub_1461598F0(_QWORD, _QWORD);
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014616B4B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_14616B4B0(__int64 a1, __int64 a2, __int128 *a3)
{
  __int64 v3; // rbx
  unsigned __int16 *v4; // rdi
  unsigned __int64 result; // rax
  unsigned __int16 *v6; // r12
  unsigned __int16 *v7; // rsi
  unsigned __int16 *v8; // r14
  __int128 v9; // xmm6
  __int16 v10; // r13
  __int64 v11; // xmm7_8
  __int64 v12; // xmm8_8
  __int64 v13; // xmm9_8
  __int64 v14; // xmm10_8
  __int64 v15; // xmm11_8
  __int64 v16; // xmm12_8
  __int64 v17; // r14
  unsigned __int16 *k; // r14
  unsigned __int16 *v19; // rsi
  unsigned __int16 *v20; // rsi
  unsigned __int16 *i; // r15
  unsigned __int16 *v22; // r14
  __int64 v23; // rsi
  unsigned __int16 *j; // r14
  unsigned __int16 *v25; // rsi
  int v26; // edi
  unsigned __int16 *v27; // rsi
  int v28; // edx
  __int128 v29; // xmm0
  unsigned __int64 v30; // r8
  int v31; // edi
  __int64 v32; // r15
  const __m128i *v33; // rdi
  const __m128i *v34; // rax
  __int64 v35; // r14
  bool v36; // zf
  __int16 v37; // r8
  __int16 v38; // dx
  __int16 v39; // ax
  __int16 v40; // ax
  char v41; // cl
  __int16 v42; // ax
  _QWORD v43[3]; // [rsp+28h] [rbp-E0h] BYREF
  __int64 v44; // [rsp+40h] [rbp-C8h]
  _BYTE v45[24]; // [rsp+48h] [rbp-C0h] BYREF
  __int64 *v46; // [rsp+60h] [rbp-A8h]
  char v47; // [rsp+68h] [rbp-A0h] BYREF
  char v48; // [rsp+69h] [rbp-9Fh] BYREF
  _TBYTE pExceptionObject_6; // [rsp+70h] [rbp-98h] BYREF
  int v50; // [rsp+7Ah] [rbp-8Eh]
  __int16 v51; // [rsp+7Eh] [rbp-8Ah]
  unsigned __int16 *v52; // [rsp+88h] [rbp-80h] BYREF
  __int128 v53; // [rsp+90h] [rbp-78h] BYREF
  int v54; // [rsp+A0h] [rbp-68h]
  __int64 v55; // [rsp+A8h] [rbp-60h] BYREF
  __int128 v56; // [rsp+B0h] [rbp-58h]
  __int128 v57; // [rsp+C8h] [rbp-40h] BYREF
  _QWORD *v58; // [rsp+D8h] [rbp-30h] BYREF
  __int16 v59; // [rsp+E0h] [rbp-28h]
  _QWORD *v60; // [rsp+E8h] [rbp-20h] BYREF
  __int16 v61; // [rsp+F0h] [rbp-18h]
  _QWORD *v62; // [rsp+F8h] [rbp-10h] BYREF
  __int16 v63; // [rsp+100h] [rbp-8h]
  _QWORD *v64; // [rsp+108h] [rbp+0h] BYREF
  __int16 v65; // [rsp+110h] [rbp+8h]
  _QWORD *v66; // [rsp+118h] [rbp+10h] BYREF
  __int16 v67; // [rsp+120h] [rbp+18h]
  _QWORD *v68; // [rsp+128h] [rbp+20h] BYREF
  __int16 v69; // [rsp+130h] [rbp+28h]
  _QWORD *v70; // [rsp+138h] [rbp+30h] BYREF
  __int16 v71; // [rsp+140h] [rbp+38h]
  _QWORD *v72; // [rsp+148h] [rbp+40h] BYREF
  __int16 v73; // [rsp+150h] [rbp+48h]
  __int64 v74; // [rsp+158h] [rbp+50h]
  int v75; // [rsp+160h] [rbp+58h] BYREF
  int v76; // [rsp+164h] [rbp+5Ch]
  char v77; // [rsp+168h] [rbp+60h]
  unsigned int v78; // [rsp+16Ch] [rbp+64h]
  char v79; // [rsp+170h] [rbp+68h]
  __int64 v80; // [rsp+172h] [rbp+6Ah]
  char v81; // [rsp+17Ah] [rbp+72h]

  v74 = -2i64;
  v3 = a1;
  v55 = a1;
  v56 = *a3;
  v53 = *(_OWORD *)a2;
  v54 = 0;
  *(_QWORD *)&v57 = &v53;
  *((_QWORD *)&v57 + 1) = &v55;
  v4 = (unsigned __int16 *)v53;
  result = *(_QWORD *)(a2 + 8);
  v6 = (unsigned __int16 *)(v53 + 2 * result);
  v7 = (unsigned __int16 *)v53;
  v8 = (unsigned __int16 *)v53;
  if ( (unsigned __int16 *)v53 != v6 )
  {
    v9 = v57;
    v10 = v51;
    v11 = *(_QWORD *)((char *)&pExceptionObject_6 + 2);
    v12 = *(_QWORD *)((char *)&pExceptionObject_6 + 2);
    v13 = *(_QWORD *)((char *)&pExceptionObject_6 + 2);
    v14 = *(_QWORD *)((char *)&pExceptionObject_6 + 2);
    v15 = *(_QWORD *)((char *)&pExceptionObject_6 + 2);
    v16 = *(_QWORD *)((char *)&pExceptionObject_6 + 2);
    while ( 1 )
    {
      while ( 1 )
      {
        result = *v7;
        if ( (_WORD)result == 37 )
          break;
        v7 = v8 + 1;
        v8 = v7;
        if ( v7 == v6 )
        {
          v8 = v6;
          goto LABEL_6;
        }
      }
      v20 = v7 + 1;
      v52 = v20;
      if ( v20 == v6 || *v20 != 37 )
        break;
      if ( v20 - v4 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      for ( i = &v4[v20 - v4]; v4 != i; ++*(_QWORD *)(v3 + 16) )
      {
        v22 = v4++;
        if ( (unsigned __int64)(*(_QWORD *)(v3 + 16) + 1i64) > *(_QWORD *)(v3 + 24) )
          (**(void (__fastcall ***)(__int64))v3)(v3);
        result = *v22;
        *(_WORD *)(*(_QWORD *)(v3 + 8) + 2i64 * *(_QWORD *)(v3 + 16)) = result;
      }
      v7 = v20 + 1;
      v4 = v7;
LABEL_128:
      v8 = v4;
      if ( v4 == v6 )
        goto LABEL_6;
    }
    v23 = ((char *)v20 - (char *)v4 - 2) >> 1;
    if ( v23 < 0 )
      sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
    for ( j = &v4[v23]; v4 != j; ++*(_QWORD *)(v3 + 16) )
    {
      v25 = v4++;
      if ( (unsigned __int64)(*(_QWORD *)(v3 + 16) + 1i64) > *(_QWORD *)(v3 + 24) )
        (**(void (__fastcall ***)(__int64))v3)(v3);
      *(_WORD *)(*(_QWORD *)(v3 + 8) + 2i64 * *(_QWORD *)(v3 + 16)) = *v25;
    }
    v75 = 0;
    v76 = -1;
    v77 = 0;
    v79 &= 0xFCu;
    v80 = 32i64;
    v81 = 1;
    v78 = v78 & 0xFFFFFF80 | 2;
    *(_OWORD *)v45 = v9;
    v26 = sub_146169CC0(&v52, v6, (__int64)&v75, (__int64 *)v45);
    if ( !v26 )
      sub_14619FE20((__int64)&v53, (__int64)"argument not found");
    v27 = v52;
    if ( v52 == v6 || *v52 != 46 )
    {
LABEL_50:
      if ( v26 >= 0 )
      {
        v31 = v26 - 1;
        if ( v54 > 0 )
          sub_14619FE20((__int64)&v53, (__int64)"cannot switch from automatic to manual argument indexing");
        v54 = -1;
      }
      else
      {
        v31 = v54;
        if ( v54 < 0 )
          sub_14619FE20((__int64)&v53, (__int64)"cannot switch from manual to automatic argument indexing");
        ++v54;
      }
      LODWORD(v44) = 0;
      if ( (__int64)v56 >= 0 )
      {
        if ( v31 >= 15 )
          goto LABEL_64;
        LODWORD(v44) = ((unsigned __int64)v56 >> (4 * (unsigned __int8)v31)) & 0xF;
        if ( (_DWORD)v44 )
          *(_OWORD *)&v43[1] = *(_OWORD *)(*((_QWORD *)&v56 + 1) + 16i64 * v31);
      }
      else
      {
        if ( v31 >= (int)v56 )
          goto LABEL_64;
        *(_OWORD *)&v43[1] = *(_OWORD *)(*((_QWORD *)&v56 + 1) + 24i64 * v31);
        v44 = *(_QWORD *)(*((_QWORD *)&v56 + 1) + 24i64 * v31 + 16);
      }
      if ( !(_DWORD)v44 )
LABEL_64:
        sub_14619FE20((__int64)&v48, (__int64)"argument not found");
      if ( v76 >= 0 )
      {
        if ( (unsigned int)(v44 - 1) <= 7 )
          LOWORD(v80) = 32;
        if ( (_DWORD)v44 == 12 )
        {
          v32 = v43[1];
          v33 = (const __m128i *)(v43[1] + 2i64 * v76);
          v34 = sub_1461A7830((const __m128i *)v43[1], v33, 0);
          if ( v34 == v33 )
            v35 = v76;
          else
            v35 = ((__int64)v34->m128i_i64 - v32) >> 1;
          if ( v35 < 0 )
            sub_14619F290(
              "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h",
              0x19Eu,
              "negative value");
          *(_DWORD *)&v45[16] = 13;
          *(_QWORD *)v45 = v32;
          *(_QWORD *)&v45[8] = v35;
          *(_OWORD *)&v43[1] = *(_OWORD *)v45;
          v44 = *(_QWORD *)&v45[16];
        }
      }
      if ( (v79 & 1) != 0 )
      {
        switch ( (int)v44 )
        {
          case 1:
          case 2:
            v36 = LODWORD(v43[1]) == 0;
            goto LABEL_81;
          case 3:
          case 4:
            v36 = v43[1] == 0i64;
            goto LABEL_81;
          case 7:
            v36 = LOBYTE(v43[1]) == 0;
            goto LABEL_81;
          case 8:
            v36 = LOWORD(v43[1]) == 0;
LABEL_81:
            if ( v36 )
              v79 &= ~1u;
            break;
          default:
            break;
        }
      }
      if ( (_WORD)v80 == 48 )
      {
        if ( (unsigned int)(v44 - 1) > 0xA || (v78 & 0xF) == 1 )
          LOWORD(v80) = 32;
        else
          v78 = v78 & 0xFFFFFFF0 | 4;
      }
      if ( v27 == v6 )
        v37 = 0;
      else
        v37 = *v27++;
      if ( v27 == v6 )
        v38 = 0;
      else
        v38 = *v27;
      switch ( v37 )
      {
        case 'L':
          break;
        case 'h':
          if ( v38 == 104 )
          {
            if ( ++v27 == v6 )
              v39 = 0;
            else
              v39 = *v27;
            v58 = &v43[1];
            v59 = v39;
            sub_14616A1F0((__int64 *)&v58, &v43[1]);
          }
          else
          {
            v60 = &v43[1];
            v61 = v38;
            sub_14616A350((__int64 *)&v60, &v43[1]);
          }
          break;
        case 'j':
          v66 = &v43[1];
          v67 = v38;
          sub_14616A6F0((__int64 *)&v66, (unsigned int *)&v43[1]);
          break;
        case 'l':
          if ( v38 == 108 )
          {
            if ( ++v27 == v6 )
              v40 = 0;
            else
              v40 = *v27;
            v62 = &v43[1];
            v63 = v40;
            sub_14616A6F0((__int64 *)&v62, (unsigned int *)&v43[1]);
          }
          else
          {
            v64 = &v43[1];
            v65 = v38;
            sub_14616A480((__int64 *)&v64, &v43[1]);
          }
          break;
        case 't':
          v70 = &v43[1];
          v71 = v38;
          sub_14616A6F0((__int64 *)&v70, (unsigned int *)&v43[1]);
          break;
        case 'z':
          v68 = &v43[1];
          v69 = v38;
          sub_14616A6F0((__int64 *)&v68, (unsigned int *)&v43[1]);
          break;
        default:
          --v27;
          v72 = &v43[1];
          v73 = v37;
          sub_14616A590((__int64 *)&v72, (int *)&v43[1]);
          break;
      }
      if ( v27 == v6 )
      {
        *(_QWORD *)v45 = &std::exception::`vftable';
        *(_OWORD *)&v45[8] = 0i64;
        *(_QWORD *)&pExceptionObject_6 = "invalid format string";
        BYTE8(pExceptionObject_6) = 1;
        _std_exception_copy(&pExceptionObject_6);
        *(_QWORD *)v45 = &fmt::v8::format_error::`vftable';
        LOBYTE(v43[0]) = 1;
        sub_146162440((__int64)&pExceptionObject_6, (__int64)v45);
        CxxThrowException(&pExceptionObject_6, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      v41 = *(_BYTE *)v27;
      v77 = *(_BYTE *)v27;
      v7 = v27 + 1;
      if ( (unsigned int)(v44 - 1) <= 7 )
      {
        if ( v41 == 99 )
        {
          switch ( (int)v44 )
          {
            case 1:
              *(_WORD *)v45 = v43[1];
              *(_QWORD *)&v45[2] = v11;
              *(_DWORD *)&v45[10] = v50;
              *(_WORD *)&v45[14] = v10;
              goto LABEL_126;
            case 2:
              *(_QWORD *)&v45[2] = v12;
              goto LABEL_124;
            case 3:
              *(_QWORD *)&v45[2] = v13;
              goto LABEL_124;
            case 4:
              *(_QWORD *)&v45[2] = v14;
              goto LABEL_124;
            case 7:
              v42 = LOBYTE(v43[1]);
              *(_QWORD *)&v45[2] = v15;
              goto LABEL_125;
            case 8:
              *(_QWORD *)&v45[2] = v16;
LABEL_124:
              v42 = v43[1];
LABEL_125:
              *(_WORD *)v45 = v42;
              *(_DWORD *)&v45[10] = v50;
              *(_WORD *)&v45[14] = v51;
LABEL_126:
              *(_DWORD *)&v45[16] = 8;
              v44 = *(_QWORD *)&v45[16];
              *(_OWORD *)&v43[1] = *(_OWORD *)v45;
              break;
            default:
              break;
          }
        }
        else if ( v41 == 105 || v41 == 117 )
        {
          v77 = 100;
        }
      }
      v4 = v7;
      *(_QWORD *)v45 = v3;
      *(_QWORD *)&v45[8] = &v75;
      *(_QWORD *)&v45[16] = 0i64;
      v46 = &v55;
      result = (unsigned __int64)sub_14616A860((__int64 *)&v57, (__int64 *)v45, (unsigned int *)&v43[1]);
      v3 = *(_QWORD *)result;
      goto LABEL_128;
    }
    v27 = v52 + 1;
    v52 = v27;
    if ( v27 == v6 )
      goto LABEL_49;
    if ( (unsigned __int16)(*v27 - 48) <= 9u )
    {
      v76 = sub_146169F30(&v52, v6, 0);
      v27 = v52;
      goto LABEL_50;
    }
    if ( *v27 != 42 )
    {
LABEL_49:
      v76 = 0;
      goto LABEL_50;
    }
    ++v27;
    v28 = v54;
    if ( v54 < 0 )
      sub_14619FE20((__int64)&v53, (__int64)"cannot switch from manual to automatic argument indexing");
    ++v54;
    *(_DWORD *)&v45[16] = 0;
    if ( (__int64)v56 >= 0 )
    {
      if ( v28 >= 15 )
        goto LABEL_47;
      v30 = ((unsigned __int64)v56 >> (4 * (unsigned __int8)v28)) & 0xF;
      *(_DWORD *)&v45[16] = v30;
      if ( !(_DWORD)v30 )
      {
LABEL_46:
        if ( !(_DWORD)v30 )
LABEL_47:
          sub_14619FE20((__int64)&v47, (__int64)"argument not found");
        v76 = sub_14616B250((__int64)v43, (unsigned int *)v45);
        goto LABEL_50;
      }
      v29 = *(_OWORD *)(*((_QWORD *)&v56 + 1) + 16i64 * v28);
    }
    else
    {
      if ( v28 >= (int)v56 )
        goto LABEL_47;
      v29 = *(_OWORD *)(*((_QWORD *)&v56 + 1) + 24i64 * v28);
      *(_QWORD *)&v45[16] = *(_QWORD *)(*((_QWORD *)&v56 + 1) + 24i64 * v28 + 16);
      LODWORD(v30) = *(_DWORD *)&v45[16];
    }
    *(_OWORD *)v45 = v29;
    goto LABEL_46;
  }
LABEL_6:
  v17 = v8 - v4;
  if ( v17 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  for ( k = &v4[v17]; v4 != k; ++*(_QWORD *)(v3 + 16) )
  {
    v19 = v4++;
    if ( (unsigned __int64)(*(_QWORD *)(v3 + 16) + 1i64) > *(_QWORD *)(v3 + 24) )
      (**(void (__fastcall ***)(__int64))v3)(v3);
    result = *v19;
    *(_WORD *)(*(_QWORD *)(v3 + 8) + 2i64 * *(_QWORD *)(v3 + 16)) = result;
  }
  return result;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014616BE70) ----------------------------------------------------
_QWORD *__fastcall sub_14616BE70(_QWORD *a1, __int128 *a2, __int128 *a3)
{
  __int64 v4; // r9
  _BYTE *v5; // rcx
  __int128 v7; // [rsp+40h] [rbp-458h] BYREF
  __int64 v8; // [rsp+50h] [rbp-448h]
  __int128 v9; // [rsp+60h] [rbp-438h] BYREF
  void **v10; // [rsp+70h] [rbp-428h] BYREF
  void *Block; // [rsp+78h] [rbp-420h]
  unsigned __int64 v12; // [rsp+80h] [rbp-418h]
  __int64 v13; // [rsp+88h] [rbp-410h]
  char v14[1008]; // [rsp+90h] [rbp-408h] BYREF

  v8 = -2i64;
  *(_QWORD *)&v7 = a1;
  v12 = 0i64;
  v10 = &fmt::v8::basic_memory_buffer<wchar_t,500,std::allocator<wchar_t>>::`vftable';
  Block = v14;
  v13 = 500i64;
  v7 = *a3;
  v9 = *a2;
  sub_14616B4B0((__int64)&v10, (__int64)&v9, &v7);
  *(_OWORD *)a1 = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  sub_146168F30(a1, Block, v12, v4);
  v10 = &fmt::v8::basic_memory_buffer<wchar_t,500,std::allocator<wchar_t>>::`vftable';
  v5 = Block;
  if ( Block != v14 )
  {
    if ( (unsigned __int64)(2 * v13) >= 0x1000 )
    {
      v5 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v5 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v5);
  }
  return a1;
}
// 14616BF15: variable 'v4' is possibly undefined
// 14611E348: using guessed type void *fmt::v8::basic_memory_buffer<wchar_t,500,std::allocator<wchar_t>>::`vftable';

//----- (000000014616BFB0) ----------------------------------------------------
__int64 *__fastcall sub_14616BFB0(__int64 *a1, __int64 a2, unsigned __int16 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // rbp
  char v7; // cl
  __int64 v10; // rax
  int v11; // ecx
  __int64 v13[5]; // [rsp+30h] [rbp-28h] BYREF
  char v14; // [rsp+60h] [rbp+8h] BYREF
  __int64 v15; // [rsp+78h] [rbp+20h] BYREF

  v6 = a3;
  v7 = *(_BYTE *)(a4 + 8);
  v14 = 0;
  if ( !v7 || v7 == 99 )
  {
    v11 = *(_DWORD *)(a4 + 12);
    if ( (v11 & 0xF) == 4 || (v11 & 0x70) != 0 || (*(_BYTE *)(a4 + 16) & 1) != 0 )
      sub_14619FE20((__int64)&v14, (__int64)"invalid format specifier for char");
    LOWORD(v15) = a3;
    sub_14616E7C0(v13, a2, (unsigned int *)a4, 1i64, 1ui64, &v15);
    v10 = v13[0];
  }
  else
  {
    sub_146169020(v7, (__int64)&v14);
    sub_14616D3E0(
      &v15,
      a2,
      v6 | ((unsigned __int64)(unsigned int)dword_14611CFB0[(__int64)(int)(*(_DWORD *)(a4 + 12) << 25) >> 29] << 32),
      a4,
      a5);
    v10 = v15;
  }
  *a1 = v10;
  return a1;
}
// 14611CFB0: using guessed type int dword_14611CFB0[];
// 14616BFB0: using guessed type __int64 var_28[5];

//----- (000000014616C0A0) ----------------------------------------------------
__int64 *__fastcall sub_14616C0A0(__int64 *a1, __int64 a2, float a3, __int64 a4, __int64 a5)
{
  float v6; // xmm6_4
  int v9; // esi
  unsigned int v10; // edi
  int v11; // edx
  const char *v12; // rax
  const char *v13; // rcx
  __int16 v14; // si
  void *v15; // rcx
  int v16; // r15d
  __int8 v17; // di
  int v18; // r13d
  __int16 v19; // cx
  char v21[8]; // [rsp+38h] [rbp-D0h] BYREF
  __m128i v22; // [rsp+48h] [rbp-C0h] BYREF
  __m128i v23; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v24; // [rsp+68h] [rbp-A0h]
  __int64 v25; // [rsp+70h] [rbp-98h]
  void **v26; // [rsp+78h] [rbp-90h] BYREF
  __int128 v27; // [rsp+80h] [rbp-88h]
  __int64 v28; // [rsp+90h] [rbp-78h] BYREF
  int v29; // [rsp+98h] [rbp-70h]
  int v30; // [rsp+9Ch] [rbp-6Ch]
  __int64 v31; // [rsp+A0h] [rbp-68h]
  void **v32; // [rsp+A8h] [rbp-60h] BYREF
  __m128i Block; // [rsp+B0h] [rbp-58h]
  unsigned __int64 v34; // [rsp+C0h] [rbp-48h]
  char v35[512]; // [rsp+C8h] [rbp-40h] BYREF

  v31 = -2i64;
  v6 = a3;
  v21[0] = 0;
  v22 = *(__m128i *)sub_14615B550((__int64)&v23, a4, (__int64)v21);
  v9 = *(_DWORD *)(a4 + 12);
  v10 = _mm_cvtsi128_si32(_mm_srli_si128(v22, 8)) & 0xFFFFFF00 | (unsigned __int8)(v9 << 25 >> 29);
  v22.m128i_i32[2] = v10;
  if ( fdsign(a3) )
  {
    v10 = v10 & 0xFFFFFF00 | 1;
    v6 = -a3;
  }
  else
  {
    if ( (_BYTE)v10 != 1 )
      goto LABEL_6;
    v10 &= 0xFFFFFF00;
  }
  v22.m128i_i32[2] = v10;
LABEL_6:
  if ( fdclass(v6) > 0 )
  {
    v23 = *(__m128i *)a4;
    v24 = *(_QWORD *)(a4 + 16);
    v11 = *(_DWORD *)(a4 + 24);
    LODWORD(v25) = v11;
    if ( fabs(v6) >= INFINITY )
    {
      v12 = "INF";
      v13 = "inf";
    }
    else
    {
      v12 = "NAN";
      v13 = "nan";
    }
    if ( (v22.m128i_i8[12] & 1) != 0 )
      v13 = v12;
    if ( BYTE2(v11) == 1 && WORD1(v24) == 48 )
      WORD1(v24) = 32;
    LODWORD(v26) = (char)v10;
    *(_QWORD *)&v27 = v13;
    *((_QWORD *)&v27 + 1) = 3i64;
    sub_14616E5D0(a1, a2, (unsigned int *)&v23, ((_BYTE)v10 != 0) + 3i64, ((_BYTE)v10 != 0) + 3i64, (int *)&v26);
    return a1;
  }
  if ( (v9 & 0xF) == 4 )
  {
    if ( !(_BYTE)v10 )
      goto LABEL_23;
    v14 = byte_14611CFAC[(char)v10];
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = v14;
    v22.m128i_i32[2] = v10 & 0xFFFFFF00;
    if ( *(_DWORD *)a4 )
      --*(_DWORD *)a4;
  }
  LOBYTE(v10) = v22.m128i_i8[8];
LABEL_23:
  Block.m128i_i64[1] = 0i64;
  v32 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  Block.m128i_i64[0] = (__int64)v35;
  v34 = 500i64;
  if ( v22.m128i_i8[4] == 3 )
  {
    if ( (_BYTE)v10 )
    {
      v35[0] = byte_14611CFAC[(char)v10];
      Block.m128i_i64[1] = 1i64;
    }
    v23 = v22;
    sub_146199D60(v6, *(_DWORD *)(a4 + 4), (__int64)&v23, (__int64)&v32);
    v22 = Block;
    sub_1461702A0(a1, a2, (unsigned int *)a4, Block.m128i_i64[1], Block.m128i_u64[1], (char **)&v22);
    v32 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
    v15 = (void *)Block.m128i_i64[0];
    if ( (char *)Block.m128i_i64[0] != v35 )
    {
      if ( v34 >= 0x1000 )
      {
        v15 = *(void **)(Block.m128i_i64[0] - 8);
        if ( (unsigned __int64)(Block.m128i_i64[0] - (_QWORD)v15 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
LABEL_44:
      j_j_free(v15);
    }
  }
  else
  {
    v16 = *(_DWORD *)(a4 + 4);
    if ( v16 < 0 && *(_BYTE *)(a4 + 8) )
      v16 = 6;
    if ( v22.m128i_i8[4] == 1 )
    {
      if ( v16 == 0x7FFFFFFF )
      {
        v26 = &std::exception::`vftable';
        v27 = 0i64;
        v23.m128i_i64[0] = (__int64)"number is too big";
        v23.m128i_i8[8] = 1;
        _std_exception_copy(&v23);
        v26 = &fmt::v8::format_error::`vftable';
        sub_14615AB90((__int64)&v26);
      }
      ++v16;
    }
    v22.m128i_i8[12] |= 0xCu;
    v17 = v22.m128i_i8[12];
    v23 = v22;
    v18 = sub_146196120(v6, v16, (__int64)&v23, &v32);
    v22.m128i_i32[0] = v16;
    if ( (v17 & 2) != 0 )
      v19 = sub_146196810(a5);
    else
      v19 = 46;
    v28 = Block.m128i_i64[0];
    v29 = Block.m128i_i32[2];
    v30 = v18;
    v23 = v22;
    sub_14616D020(a1, a2, (__int64)&v28, (unsigned int *)a4, (__int64)&v23, v19);
    v32 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
    v15 = (void *)Block.m128i_i64[0];
    if ( (char *)Block.m128i_i64[0] != v35 )
    {
      if ( v34 >= 0x1000 )
      {
        v15 = *(void **)(Block.m128i_i64[0] - 8);
        if ( (unsigned __int64)(Block.m128i_i64[0] - (_QWORD)v15 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      goto LABEL_44;
    }
  }
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 14616C0A0: using guessed type char anonymous_0[8];

//----- (000000014616C530) ----------------------------------------------------
__int64 *__fastcall sub_14616C530(__int64 *a1, __int64 a2, double a3, __int64 a4, __int64 a5)
{
  double v6; // xmm6_8
  int v9; // esi
  unsigned int v10; // edi
  int v11; // edx
  const char *v12; // rax
  const char *v13; // rcx
  __int16 v14; // si
  void *v15; // rcx
  int v16; // r15d
  __int8 v17; // di
  int v18; // r13d
  __int16 v19; // cx
  char v21[8]; // [rsp+38h] [rbp-D0h] BYREF
  __m128i v22; // [rsp+48h] [rbp-C0h] BYREF
  __m128i v23; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v24; // [rsp+68h] [rbp-A0h]
  __int64 v25; // [rsp+70h] [rbp-98h]
  void **v26; // [rsp+78h] [rbp-90h] BYREF
  __int128 v27; // [rsp+80h] [rbp-88h]
  __int64 v28; // [rsp+90h] [rbp-78h] BYREF
  int v29; // [rsp+98h] [rbp-70h]
  int v30; // [rsp+9Ch] [rbp-6Ch]
  __int64 v31; // [rsp+A0h] [rbp-68h]
  void **v32; // [rsp+A8h] [rbp-60h] BYREF
  __m128i Block; // [rsp+B0h] [rbp-58h]
  unsigned __int64 v34; // [rsp+C0h] [rbp-48h]
  char v35[512]; // [rsp+C8h] [rbp-40h] BYREF

  v31 = -2i64;
  v6 = a3;
  v21[0] = 0;
  v22 = *(__m128i *)sub_14615B550((__int64)&v23, a4, (__int64)v21);
  v9 = *(_DWORD *)(a4 + 12);
  v10 = _mm_cvtsi128_si32(_mm_srli_si128(v22, 8)) & 0xFFFFFF00 | (unsigned __int8)(v9 << 25 >> 29);
  v22.m128i_i32[2] = v10;
  if ( dsign(a3) )
  {
    v10 = v10 & 0xFFFFFF00 | 1;
    v6 = -a3;
  }
  else
  {
    if ( (_BYTE)v10 != 1 )
      goto LABEL_6;
    v10 &= 0xFFFFFF00;
  }
  v22.m128i_i32[2] = v10;
LABEL_6:
  if ( dclass(v6) > 0 )
  {
    v23 = *(__m128i *)a4;
    v24 = *(_QWORD *)(a4 + 16);
    v11 = *(_DWORD *)(a4 + 24);
    LODWORD(v25) = v11;
    if ( fabs(v6) >= INFINITY )
    {
      v12 = "INF";
      v13 = "inf";
    }
    else
    {
      v12 = "NAN";
      v13 = "nan";
    }
    if ( (v22.m128i_i8[12] & 1) != 0 )
      v13 = v12;
    if ( BYTE2(v11) == 1 && WORD1(v24) == 48 )
      WORD1(v24) = 32;
    LODWORD(v26) = (char)v10;
    *(_QWORD *)&v27 = v13;
    *((_QWORD *)&v27 + 1) = 3i64;
    sub_14616E5D0(a1, a2, (unsigned int *)&v23, ((_BYTE)v10 != 0) + 3i64, ((_BYTE)v10 != 0) + 3i64, (int *)&v26);
    return a1;
  }
  if ( (v9 & 0xF) == 4 )
  {
    if ( !(_BYTE)v10 )
      goto LABEL_23;
    v14 = byte_14611CFAC[(char)v10];
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = v14;
    v22.m128i_i32[2] = v10 & 0xFFFFFF00;
    if ( *(_DWORD *)a4 )
      --*(_DWORD *)a4;
  }
  LOBYTE(v10) = v22.m128i_i8[8];
LABEL_23:
  Block.m128i_i64[1] = 0i64;
  v32 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  Block.m128i_i64[0] = (__int64)v35;
  v34 = 500i64;
  if ( v22.m128i_i8[4] == 3 )
  {
    if ( (_BYTE)v10 )
    {
      v35[0] = byte_14611CFAC[(char)v10];
      Block.m128i_i64[1] = 1i64;
    }
    v23 = v22;
    sub_146199D60(v6, *(_DWORD *)(a4 + 4), (__int64)&v23, (__int64)&v32);
    v22 = Block;
    sub_1461702A0(a1, a2, (unsigned int *)a4, Block.m128i_i64[1], Block.m128i_u64[1], (char **)&v22);
    v32 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
    v15 = (void *)Block.m128i_i64[0];
    if ( (char *)Block.m128i_i64[0] != v35 )
    {
      if ( v34 >= 0x1000 )
      {
        v15 = *(void **)(Block.m128i_i64[0] - 8);
        if ( (unsigned __int64)(Block.m128i_i64[0] - (_QWORD)v15 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
LABEL_44:
      j_j_free(v15);
    }
  }
  else
  {
    v16 = *(_DWORD *)(a4 + 4);
    if ( v16 < 0 && *(_BYTE *)(a4 + 8) )
      v16 = 6;
    if ( v22.m128i_i8[4] == 1 )
    {
      if ( v16 == 0x7FFFFFFF )
      {
        v26 = &std::exception::`vftable';
        v27 = 0i64;
        v23.m128i_i64[0] = (__int64)"number is too big";
        v23.m128i_i8[8] = 1;
        _std_exception_copy(&v23);
        v26 = &fmt::v8::format_error::`vftable';
        sub_14615AB90((__int64)&v26);
      }
      ++v16;
    }
    v22.m128i_i8[12] |= 8u;
    v17 = v22.m128i_i8[12];
    v23 = v22;
    v18 = sub_146196120(v6, v16, (__int64)&v23, &v32);
    v22.m128i_i32[0] = v16;
    if ( (v17 & 2) != 0 )
      v19 = sub_146196810(a5);
    else
      v19 = 46;
    v28 = Block.m128i_i64[0];
    v29 = Block.m128i_i32[2];
    v30 = v18;
    v23 = v22;
    sub_14616D020(a1, a2, (__int64)&v28, (unsigned int *)a4, (__int64)&v23, v19);
    v32 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
    v15 = (void *)Block.m128i_i64[0];
    if ( (char *)Block.m128i_i64[0] != v35 )
    {
      if ( v34 >= 0x1000 )
      {
        v15 = *(void **)(Block.m128i_i64[0] - 8);
        if ( (unsigned __int64)(Block.m128i_i64[0] - (_QWORD)v15 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      goto LABEL_44;
    }
  }
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 14616C530: using guessed type char anonymous_0[8];

//----- (000000014616C9B0) ----------------------------------------------------
__int64 *__fastcall sub_14616C9B0(__int64 *a1, __int64 a2, long double a3, __int64 a4, __int64 a5)
{
  double v6; // xmm6_8
  int v9; // esi
  unsigned int v10; // edi
  int v11; // edx
  const char *v12; // rax
  const char *v13; // rcx
  __int16 v14; // si
  void *v15; // rcx
  int v16; // r15d
  __int8 v17; // di
  int v18; // r13d
  __int16 v19; // cx
  char v21[8]; // [rsp+38h] [rbp-D0h] BYREF
  __m128i v22; // [rsp+48h] [rbp-C0h] BYREF
  __m128i v23; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v24; // [rsp+68h] [rbp-A0h]
  __int64 v25; // [rsp+70h] [rbp-98h]
  void **v26; // [rsp+78h] [rbp-90h] BYREF
  __int128 v27; // [rsp+80h] [rbp-88h]
  __int64 v28; // [rsp+90h] [rbp-78h] BYREF
  int v29; // [rsp+98h] [rbp-70h]
  int v30; // [rsp+9Ch] [rbp-6Ch]
  __int64 v31; // [rsp+A0h] [rbp-68h]
  void **v32; // [rsp+A8h] [rbp-60h] BYREF
  __m128i Block; // [rsp+B0h] [rbp-58h]
  unsigned __int64 v34; // [rsp+C0h] [rbp-48h]
  char v35[512]; // [rsp+C8h] [rbp-40h] BYREF

  v31 = -2i64;
  v6 = a3;
  v21[0] = 0;
  v22 = *(__m128i *)sub_14615B550((__int64)&v23, a4, (__int64)v21);
  v9 = *(_DWORD *)(a4 + 12);
  v10 = _mm_cvtsi128_si32(_mm_srli_si128(v22, 8)) & 0xFFFFFF00 | (unsigned __int8)(v9 << 25 >> 29);
  v22.m128i_i32[2] = v10;
  if ( ldsign(a3) )
  {
    v10 = v10 & 0xFFFFFF00 | 1;
    v6 = -a3;
  }
  else
  {
    if ( (_BYTE)v10 != 1 )
      goto LABEL_6;
    v10 &= 0xFFFFFF00;
  }
  v22.m128i_i32[2] = v10;
LABEL_6:
  if ( ldclass(v6) > 0 )
  {
    v23 = *(__m128i *)a4;
    v24 = *(_QWORD *)(a4 + 16);
    v11 = *(_DWORD *)(a4 + 24);
    LODWORD(v25) = v11;
    if ( fabs(v6) >= INFINITY )
    {
      v12 = "INF";
      v13 = "inf";
    }
    else
    {
      v12 = "NAN";
      v13 = "nan";
    }
    if ( (v22.m128i_i8[12] & 1) != 0 )
      v13 = v12;
    if ( BYTE2(v11) == 1 && WORD1(v24) == 48 )
      WORD1(v24) = 32;
    LODWORD(v26) = (char)v10;
    *(_QWORD *)&v27 = v13;
    *((_QWORD *)&v27 + 1) = 3i64;
    sub_14616E5D0(a1, a2, (unsigned int *)&v23, ((_BYTE)v10 != 0) + 3i64, ((_BYTE)v10 != 0) + 3i64, (int *)&v26);
    return a1;
  }
  if ( (v9 & 0xF) == 4 )
  {
    if ( !(_BYTE)v10 )
      goto LABEL_23;
    v14 = byte_14611CFAC[(char)v10];
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = v14;
    v22.m128i_i32[2] = v10 & 0xFFFFFF00;
    if ( *(_DWORD *)a4 )
      --*(_DWORD *)a4;
  }
  LOBYTE(v10) = v22.m128i_i8[8];
LABEL_23:
  Block.m128i_i64[1] = 0i64;
  v32 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  Block.m128i_i64[0] = (__int64)v35;
  v34 = 500i64;
  if ( v22.m128i_i8[4] == 3 )
  {
    if ( (_BYTE)v10 )
    {
      v35[0] = byte_14611CFAC[(char)v10];
      Block.m128i_i64[1] = 1i64;
    }
    v23 = v22;
    sub_146199FE0(v6, *(_DWORD *)(a4 + 4), (__int64)&v23, (__int64)&v32);
    v22 = Block;
    sub_1461702A0(a1, a2, (unsigned int *)a4, Block.m128i_i64[1], Block.m128i_u64[1], (char **)&v22);
    v32 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
    v15 = (void *)Block.m128i_i64[0];
    if ( (char *)Block.m128i_i64[0] != v35 )
    {
      if ( v34 >= 0x1000 )
      {
        v15 = *(void **)(Block.m128i_i64[0] - 8);
        if ( (unsigned __int64)(Block.m128i_i64[0] - (_QWORD)v15 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
LABEL_44:
      j_j_free(v15);
    }
  }
  else
  {
    v16 = *(_DWORD *)(a4 + 4);
    if ( v16 < 0 && *(_BYTE *)(a4 + 8) )
      v16 = 6;
    if ( v22.m128i_i8[4] == 1 )
    {
      if ( v16 == 0x7FFFFFFF )
      {
        v26 = &std::exception::`vftable';
        v27 = 0i64;
        v23.m128i_i64[0] = (__int64)"number is too big";
        v23.m128i_i8[8] = 1;
        _std_exception_copy(&v23);
        v26 = &fmt::v8::format_error::`vftable';
        sub_14615AB90((__int64)&v26);
      }
      ++v16;
    }
    v22.m128i_i8[12] |= 8u;
    v17 = v22.m128i_i8[12];
    v23 = v22;
    v18 = sub_1461982F0(v6, v16, (__int64)&v23, &v32);
    v22.m128i_i32[0] = v16;
    if ( (v17 & 2) != 0 )
      v19 = sub_146196810(a5);
    else
      v19 = 46;
    v28 = Block.m128i_i64[0];
    v29 = Block.m128i_i32[2];
    v30 = v18;
    v23 = v22;
    sub_14616D020(a1, a2, (__int64)&v28, (unsigned int *)a4, (__int64)&v23, v19);
    v32 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
    v15 = (void *)Block.m128i_i64[0];
    if ( (char *)Block.m128i_i64[0] != v35 )
    {
      if ( v34 >= 0x1000 )
      {
        v15 = *(void **)(Block.m128i_i64[0] - 8);
        if ( (unsigned __int64)(Block.m128i_i64[0] - (_QWORD)v15 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      goto LABEL_44;
    }
  }
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 14616C9B0: using guessed type char anonymous_0[8];

//----- (000000014616CE30) ----------------------------------------------------
__int64 *__fastcall sub_14616CE30(__int64 *a1, __int64 a2, __int16 a3, unsigned int *a4)
{
  __int16 v6; // [rsp+50h] [rbp+18h] BYREF

  v6 = a3;
  sub_14616E7C0(a1, a2, a4, 1i64, 1ui64, &v6);
  return a1;
}

//----- (000000014616CE70) ----------------------------------------------------
_QWORD *__fastcall sub_14616CE70(_QWORD *a1, int a2, __int64 a3)
{
  int v4; // edi
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rdx
  __int64 v8; // rcx
  char *v9; // rbp
  __int16 v10; // r15
  __int16 v11; // bp
  char *v12; // rdi
  __int16 v13; // si
  __int16 v14; // di
  __int64 v15; // rcx
  __int64 v16; // rax
  _QWORD *result; // rax

  v4 = a2;
  if ( (unsigned int)(a2 + 9999) > 0x4E1E )
    sub_14619F290(
      "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\format.h",
      0x4CEu,
      "exponent out of range");
  v6 = *(_QWORD *)(a3 + 24);
  v7 = *(_QWORD *)(a3 + 16) + 1i64;
  if ( v4 >= 0 )
  {
    if ( v7 > v6 )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_WORD *)(*(_QWORD *)(a3 + 8) + 2i64 * (*(_QWORD *)(a3 + 16))++) = 43;
  }
  else
  {
    if ( v7 > v6 )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_WORD *)(*(_QWORD *)(a3 + 8) + 2i64 * (*(_QWORD *)(a3 + 16))++) = 45;
    v4 = -v4;
  }
  v8 = *(_QWORD *)(a3 + 16);
  if ( v4 >= 100 )
  {
    v9 = &a00010203040506[2 * (v4 / 100)];
    if ( v4 >= 1000 )
    {
      v10 = *v9;
      if ( (unsigned __int64)(v8 + 1) > *(_QWORD *)(a3 + 24) )
        (**(void (__fastcall ***)(__int64))a3)(a3);
      *(_WORD *)(*(_QWORD *)(a3 + 8) + 2i64 * (*(_QWORD *)(a3 + 16))++) = v10;
      v8 = *(_QWORD *)(a3 + 16);
    }
    v11 = v9[1];
    if ( (unsigned __int64)(v8 + 1) > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_WORD *)(*(_QWORD *)(a3 + 8) + 2i64 * (*(_QWORD *)(a3 + 16))++) = v11;
    v8 = *(_QWORD *)(a3 + 16);
    v4 %= 100;
  }
  v12 = &a00010203040506[2 * v4];
  v13 = *v12;
  if ( (unsigned __int64)(v8 + 1) > *(_QWORD *)(a3 + 24) )
    (**(void (__fastcall ***)(__int64))a3)(a3);
  *(_WORD *)(*(_QWORD *)(a3 + 8) + 2i64 * (*(_QWORD *)(a3 + 16))++) = v13;
  v14 = v12[1];
  if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
    (**(void (__fastcall ***)(__int64))a3)(a3);
  v15 = *(_QWORD *)(a3 + 16);
  v16 = *(_QWORD *)(a3 + 8);
  *a1 = a3;
  *(_WORD *)(v16 + 2 * v15) = v14;
  result = a1;
  ++*(_QWORD *)(a3 + 16);
  return result;
}

//----- (000000014616D020) ----------------------------------------------------
__int64 *__fastcall sub_14616D020(__int64 *a1, __int64 a2, __int64 a3, unsigned int *a4, __int64 a5, __int16 a6)
{
  int v6; // r15d
  int v8; // edx
  __int64 v9; // rax
  int v11; // r10d
  __int64 v12; // r8
  __int64 v13; // rdi
  int v14; // ecx
  __int64 v15; // r15
  int v16; // r12d
  __int64 v17; // rax
  int v18; // eax
  unsigned __int64 v19; // r15
  int v20; // esi
  bool v21; // zf
  int v22; // ecx
  int v23; // r12d
  int v24; // eax
  char v25; // cl
  int v26; // esi
  __int16 v27; // r9
  __int64 v28; // r8
  int v29; // eax
  unsigned __int64 v30; // r8
  bool v31; // cc
  __int64 v32; // rax
  char v34; // [rsp+30h] [rbp-59h] BYREF
  int v35; // [rsp+34h] [rbp-55h] BYREF
  int v36; // [rsp+38h] [rbp-51h] BYREF
  int v37; // [rsp+3Ch] [rbp-4Dh] BYREF
  int v38; // [rsp+40h] [rbp-49h] BYREF
  unsigned int *v39; // [rsp+48h] [rbp-41h] BYREF
  __int64 *v40; // [rsp+50h] [rbp-39h] BYREF
  int *v41; // [rsp+58h] [rbp-31h] BYREF
  __int64 *v42; // [rsp+60h] [rbp-29h]
  __int16 *v43; // [rsp+68h] [rbp-21h]
  int *v44; // [rsp+70h] [rbp-19h]
  __int16 *v45; // [rsp+78h] [rbp-11h]
  int *v46; // [rsp+80h] [rbp-9h]
  int *v47; // [rsp+88h] [rbp-1h]
  int v48; // [rsp+90h] [rbp+7h] BYREF
  int *v49; // [rsp+98h] [rbp+Fh] BYREF

  v6 = *(_DWORD *)(a3 + 8);
  v8 = v6;
  v9 = *(_QWORD *)a3;
  v39 = a4;
  v49 = (int *)a3;
  v11 = *(char *)(a5 + 8);
  v36 = v11;
  v40 = (__int64 *)v9;
  v35 = v6;
  if ( v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v12 = *(unsigned int *)(a3 + 12);
  v13 = 0i64;
  v14 = v12 + v6;
  v15 = (unsigned int)(v11 != 0) + v6;
  v16 = v12 + v8 - 1;
  v17 = HIDWORD(*(_QWORD *)a5);
  if ( (_BYTE)v17 == 1 )
    goto LABEL_35;
  if ( !(_BYTE)v17 )
  {
    if ( v16 < -4 )
      goto LABEL_35;
    v18 = 16;
    if ( (int)*(_QWORD *)a5 > 0 )
      v18 = *(_QWORD *)a5;
    if ( v16 >= v18 )
    {
LABEL_35:
      v25 = *(_BYTE *)(a5 + 12);
      v26 = 0;
      if ( (v25 & 0x10) != 0 )
      {
        if ( *(_DWORD *)a5 - v8 >= 0 )
          v26 = *(_DWORD *)a5 - v8;
        if ( v26 < 0 )
          sub_14619F290(
            "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h",
            0x19Eu,
            "negative value");
        v15 += (unsigned int)v26;
      }
      else if ( v8 == 1 )
      {
        v27 = 0;
        a6 = 0;
        goto LABEL_42;
      }
      v27 = a6;
LABEL_42:
      v28 = 2i64;
      v29 = -v16;
      if ( v16 > 0 )
        v29 = v16;
      if ( v29 >= 100 )
        v28 = (v29 >= 1000) + 3i64;
      v42 = v40;
      LOBYTE(v13) = v27 != 0;
      LODWORD(v41) = v11;
      LODWORD(v43) = v8;
      WORD2(v43) = v27;
      BYTE4(v44) = ~(32 * v25) & 0x20 | 0x45;
      v30 = v15 + v13 + 2 + v28;
      LODWORD(v44) = v26;
      v31 = (int)*v39 <= 0;
      LODWORD(v45) = v16;
      if ( v31 )
      {
        v32 = *sub_146171BE0((int *)&v41, &v39, a2);
      }
      else
      {
        sub_14616F540((__int64 *)&v49, a2, v39, v30, v30, (int *)&v41);
        v32 = (__int64)v49;
      }
      *a1 = v32;
      return a1;
    }
  }
  v48 = v14;
  if ( (int)v12 >= 0 )
  {
    v19 = v12 + v15;
    v20 = *(_DWORD *)a5 - v14;
    v21 = (*(_BYTE *)(a5 + 12) & 0x10) == 0;
    v37 = v20;
    if ( !v21 )
    {
      if ( v20 > 0 )
      {
LABEL_14:
        v19 += (unsigned int)sub_14615B9F0(v20) + 1;
        goto LABEL_15;
      }
      if ( *(_BYTE *)(a5 + 4) != 2 )
      {
        v20 = 1;
        v37 = 1;
        goto LABEL_14;
      }
    }
LABEL_15:
    v41 = &v36;
    v45 = (__int16 *)a5;
    v42 = (__int64 *)&v40;
    v43 = (__int16 *)&v35;
    v44 = v49;
    v46 = (int *)&a6;
    v47 = &v37;
    sub_14616EF60(a1, a2, v39, v19, v19, &v41);
    return a1;
  }
  if ( v14 <= 0 )
  {
    v22 = -v14;
    v38 = v22;
    v23 = v22;
    if ( !v8 )
    {
      v24 = *(_DWORD *)a5;
      if ( *(int *)a5 >= 0 && v24 < v22 )
      {
        v38 = *(_DWORD *)a5;
        v23 = v24;
      }
    }
    if ( v23 || v8 || (*(_BYTE *)(a5 + 12) & 0x10) != 0 )
    {
      v34 = 1;
      LODWORD(v13) = 1;
      if ( v23 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
    }
    else
    {
      v34 = 0;
    }
    v41 = &v36;
    v42 = (__int64 *)&v34;
    v43 = &a6;
    v44 = &v38;
    v45 = (__int16 *)&v40;
    v46 = &v35;
    sub_14616FF10(a1, a2, v39, v15 + (unsigned int)(v23 + v13 + 1), v15 + (unsigned int)(v23 + v13 + 1), &v41);
  }
  else
  {
    if ( (*(_BYTE *)(a5 + 12) & 0x10) != 0 )
    {
      v21 = *(_DWORD *)a5 == v8;
      v37 = *(_DWORD *)a5 - v8;
      if ( v37 >= 0 && !v21 )
        LODWORD(v13) = v37;
      if ( (int)v13 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
    }
    else
    {
      v37 = 0;
    }
    v41 = &v36;
    v42 = (__int64 *)&v40;
    v43 = (__int16 *)&v35;
    v44 = &v48;
    v45 = &a6;
    v46 = &v37;
    sub_14616F0E0(a1, a2, v39, v15 + (unsigned int)(v13 + 1), v15 + (unsigned int)(v13 + 1), &v41);
  }
  return a1;
}

//----- (000000014616D3E0) ----------------------------------------------------
__int64 *__fastcall sub_14616D3E0(__int64 *a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5)
{
  unsigned int v6; // edi
  __int64 v7; // rbx
  unsigned __int64 v9; // rsi
  int v10; // r8d
  unsigned int v11; // ecx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rdi
  unsigned int i; // esi
  __int64 *v15; // rax
  int v17; // eax
  int v18; // esi
  int v19; // r9d
  int v20; // eax
  int v21; // edx
  unsigned int k; // esi
  unsigned int v23; // r8d
  unsigned int v24; // eax
  int v25; // esi
  int v26; // r9d
  unsigned int v27; // edx
  int v28; // edx
  unsigned __int64 v29; // rdi
  unsigned int j; // esi
  int v31; // ecx
  int v32; // edx
  int v33; // eax
  unsigned __int64 v34; // rdi
  unsigned int m; // esi
  void **v36; // [rsp+30h] [rbp-51h] BYREF
  __int128 v37; // [rsp+38h] [rbp-49h]
  unsigned __int64 v38; // [rsp+48h] [rbp-39h]
  __int128 pExceptionObject[2]; // [rsp+50h] [rbp-31h] BYREF
  __int64 v40; // [rsp+70h] [rbp-11h]
  int v41; // [rsp+78h] [rbp-9h] BYREF
  __int128 v42; // [rsp+80h] [rbp-1h]
  void **v43; // [rsp+90h] [rbp+Fh]
  int v44; // [rsp+98h] [rbp+17h]
  __int64 v45; // [rsp+E8h] [rbp+67h] BYREF
  unsigned __int64 v46; // [rsp+F0h] [rbp+6Fh] BYREF
  __int64 v47; // [rsp+F8h] [rbp+77h] BYREF

  v45 = a2;
  v40 = -2i64;
  v6 = a3;
  v7 = a2;
  v9 = HIDWORD(a3);
  v10 = *(char *)(a4 + 8);
  switch ( *(_BYTE *)(a4 + 8) )
  {
    case 0:
    case 0x64:
      if ( (*(_BYTE *)(a4 + 16) & 2) == 0 )
        goto LABEL_6;
      if ( (unsigned __int8)sub_14616E030(&v45, v6, v9, a4, a5) )
      {
        *a1 = v45;
        return a1;
      }
      v7 = v45;
LABEL_6:
      LODWORD(v46) = 0;
      _BitScanReverse(&v11, v6 | 1);
      v12 = ((unsigned __int64)v6 + qword_14611CFD0[v11]) >> 32;
      v46 = __PAIR64__(v12, v6);
      v13 = __PAIR64__(v12, v6);
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)pExceptionObject, v12, v9, (unsigned int *)a4);
        LODWORD(v36) = v9;
        v37 = pExceptionObject[0];
        v38 = v13;
        sub_14616EB40(
          a1,
          v7,
          (unsigned int *)a4,
          *(__int64 *)&pExceptionObject[0],
          *(unsigned __int64 *)&pExceptionObject[0],
          &v36);
        return a1;
      }
      if ( (v12 & 0x80000000) != 0i64 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( (_DWORD)v9 )
      {
        for ( i = v9 & 0xFFFFFF; i; i >>= 8 )
        {
          if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
            (**(void (__fastcall ***)(__int64))v7)(v7);
          *(_WORD *)(*(_QWORD *)(v7 + 8) + 2i64 * (*(_QWORD *)(v7 + 16))++) = (unsigned __int8)i;
        }
      }
      v15 = sub_146171510((unsigned int *)&v46, &v47, v7);
      goto LABEL_15;
    case 0x42:
    case 0x62:
      if ( (*(_BYTE *)(a4 + 16) & 1) != 0 )
      {
        v23 = (v10 << 8) | 0x30;
        v24 = v23 << 8;
        if ( !(_DWORD)v9 )
          v24 = v23;
        v25 = v24 | v9;
        v26 = 0x1000000;
        if ( v23 > 0xFF )
          v26 = 0x2000000;
        LODWORD(v9) = v26 + v25;
      }
      _BitScanReverse(&v27, v6 | 1);
      v28 = v27 + 1;
      v46 = __PAIR64__(v28, v6);
      v29 = __PAIR64__(v28, v6);
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)pExceptionObject, v28, v9, (unsigned int *)a4);
        LODWORD(v36) = v9;
        v37 = pExceptionObject[0];
        v38 = v29;
        sub_146170090(
          a1,
          v7,
          (unsigned int *)a4,
          *(__int64 *)&pExceptionObject[0],
          *(unsigned __int64 *)&pExceptionObject[0],
          &v36);
        return a1;
      }
      if ( v28 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( (_DWORD)v9 )
      {
        for ( j = v9 & 0xFFFFFF; j; j >>= 8 )
        {
          if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
            (**(void (__fastcall ***)(__int64))v7)(v7);
          *(_WORD *)(*(_QWORD *)(v7 + 8) + 2i64 * (*(_QWORD *)(v7 + 16))++) = (unsigned __int8)j;
        }
      }
      v15 = sub_146171810((unsigned int *)&v46, &v47, v7);
      goto LABEL_15;
    case 0x58:
    case 0x78:
      if ( (*(_BYTE *)(a4 + 16) & 1) != 0 )
      {
        v17 = ((v10 << 8) | 0x30) << 8;
        if ( !(_DWORD)v9 )
          v17 = (v10 << 8) | 0x30;
        v18 = v17 | v9;
        v19 = 0x1000000;
        if ( ((v10 << 8) | 0x30u) > 0xFF )
          v19 = 0x2000000;
        LODWORD(v9) = v19 + v18;
      }
      LODWORD(v46) = 0;
      _BitScanReverse((unsigned int *)&v20, v6 | 1);
      v21 = v20 / 4 + 1;
      v36 = (void **)__PAIR64__(v21, v6);
      LOBYTE(v37) = v10 != 120;
      *(_QWORD *)&pExceptionObject[0] = __PAIR64__(v21, v6);
      DWORD2(pExceptionObject[0]) = v37;
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)pExceptionObject, v21, v9, (unsigned int *)a4);
        v41 = v9;
        v42 = pExceptionObject[0];
        v43 = v36;
        v44 = v37;
        sub_14616F6C0(
          a1,
          v7,
          (unsigned int *)a4,
          *(__int64 *)&pExceptionObject[0],
          *(unsigned __int64 *)&pExceptionObject[0],
          &v41);
        return a1;
      }
      if ( v21 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( (_DWORD)v9 )
      {
        for ( k = v9 & 0xFFFFFF; k; k >>= 8 )
        {
          if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
            (**(void (__fastcall ***)(__int64))v7)(v7);
          *(_WORD *)(*(_QWORD *)(v7 + 8) + 2i64 * (*(_QWORD *)(v7 + 16))++) = (unsigned __int8)k;
        }
      }
      v15 = sub_146171A70((int *)pExceptionObject, &v46, v7);
      goto LABEL_15;
    case 0x63:
      sub_14616CE30(a1, a2, v6, (unsigned int *)a4);
      return a1;
    case 0x6F:
      LODWORD(v46) = 0;
      _BitScanReverse((unsigned int *)&v31, v6 | 1);
      v32 = ((unsigned int)((unsigned __int64)(1431655766i64 * v31) >> 32) >> 31)
          + ((unsigned __int64)(1431655766i64 * v31) >> 32)
          + 1;
      if ( (*(_BYTE *)(a4 + 16) & 1) != 0 && *(_DWORD *)(a4 + 4) <= v32 && v6 )
      {
        v33 = 12288;
        if ( !(_DWORD)v9 )
          v33 = 48;
        LODWORD(v9) = (v33 | v9) + 0x1000000;
      }
      v46 = __PAIR64__(v32, v6);
      v34 = __PAIR64__(v32, v6);
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)pExceptionObject, v32, v9, (unsigned int *)a4);
        LODWORD(v36) = v9;
        v37 = pExceptionObject[0];
        v38 = v34;
        sub_14616ED50(
          a1,
          v7,
          (unsigned int *)a4,
          *(__int64 *)&pExceptionObject[0],
          *(unsigned __int64 *)&pExceptionObject[0],
          &v36);
      }
      else
      {
        if ( v32 < 0 )
          sub_14619F290(
            "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h",
            0x19Eu,
            "negative value");
        if ( (_DWORD)v9 )
        {
          for ( m = v9 & 0xFFFFFF; m; m >>= 8 )
          {
            if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
              (**(void (__fastcall ***)(__int64))v7)(v7);
            *(_WORD *)(*(_QWORD *)(v7 + 8) + 2i64 * (*(_QWORD *)(v7 + 16))++) = (unsigned __int8)m;
          }
        }
        v15 = sub_146171940((unsigned int *)&v46, &v47, v7);
LABEL_15:
        *a1 = *v15;
      }
      return a1;
    default:
      v37 = 0i64;
      *(_QWORD *)&pExceptionObject[0] = "invalid type specifier";
      BYTE8(pExceptionObject[0]) = 1;
      _std_exception_copy(pExceptionObject);
      v36 = &fmt::v8::format_error::`vftable';
      LOBYTE(v46) = 1;
      sub_146162440((__int64)pExceptionObject, (__int64)&v36);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
}
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 14611CFD0: using guessed type __int64 qword_14611CFD0[32];
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014616DA00) ----------------------------------------------------
__int64 *__fastcall sub_14616DA00(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // rbx
  unsigned __int64 v8; // r12
  int v9; // edi
  int v10; // r8d
  int v11; // eax
  __int128 v12; // xmm6
  unsigned int i; // edi
  __int64 *v14; // rax
  int v16; // eax
  int v17; // eax
  int v18; // edi
  unsigned __int64 v19; // rax
  int v20; // esi
  unsigned int k; // edi
  unsigned int v22; // r8d
  unsigned int v23; // eax
  int v24; // eax
  int v25; // edi
  unsigned __int64 v26; // rax
  int v27; // esi
  __int128 v28; // xmm6
  unsigned int j; // edi
  unsigned __int64 v30; // rax
  int v31; // esi
  int v32; // eax
  __int128 v33; // xmm6
  unsigned int m; // edi
  __int128 pExceptionObject[2]; // [rsp+48h] [rbp-41h] BYREF
  void **v36; // [rsp+68h] [rbp-21h] BYREF
  __int128 v37; // [rsp+70h] [rbp-19h]
  __int128 v38; // [rsp+80h] [rbp-9h]
  __int64 v39; // [rsp+F0h] [rbp+67h] BYREF
  __int64 v40; // [rsp+F8h] [rbp+6Fh] BYREF

  v39 = a2;
  v6 = a2;
  v8 = *(_QWORD *)a3;
  v9 = *(_DWORD *)(a3 + 8);
  v10 = *(char *)(a4 + 8);
  switch ( *(_BYTE *)(a4 + 8) )
  {
    case 0:
    case 0x64:
      if ( (*(_BYTE *)(a4 + 16) & 2) == 0 )
        goto LABEL_6;
      if ( (unsigned __int8)sub_14616E030(&v39, v8, v9, a4, a5) )
      {
        *a1 = v39;
        return a1;
      }
      v6 = v39;
LABEL_6:
      v11 = sub_146165560(v8);
      *(_QWORD *)&pExceptionObject[0] = v8;
      DWORD2(pExceptionObject[0]) = v11;
      v12 = pExceptionObject[0];
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)pExceptionObject, v11, v9, (unsigned int *)a4);
        LODWORD(v36) = v9;
        v37 = pExceptionObject[0];
        v38 = v12;
        sub_14616F8D0(
          a1,
          v6,
          (unsigned int *)a4,
          *(__int64 *)&pExceptionObject[0],
          *(unsigned __int64 *)&pExceptionObject[0],
          &v36);
        return a1;
      }
      if ( v11 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( v9 )
      {
        for ( i = v9 & 0xFFFFFF; i; i >>= 8 )
        {
          if ( (unsigned __int64)(*(_QWORD *)(v6 + 16) + 1i64) > *(_QWORD *)(v6 + 24) )
            (**(void (__fastcall ***)(__int64))v6)(v6);
          *(_WORD *)(*(_QWORD *)(v6 + 8) + 2i64 * (*(_QWORD *)(v6 + 16))++) = (unsigned __int8)i;
        }
      }
      v14 = sub_1461713B0((__int64)pExceptionObject, &v40, v6);
      goto LABEL_15;
    case 0x42:
    case 0x62:
      if ( (*(_BYTE *)(a4 + 16) & 1) != 0 )
      {
        v22 = (v10 << 8) | 0x30;
        v23 = v22 << 8;
        if ( !v9 )
          v23 = v22;
        v24 = v9 | v23;
        v25 = 0x1000000;
        if ( v22 > 0xFF )
          v25 = 0x2000000;
        v9 = v24 + v25;
      }
      v26 = v8;
      v27 = 0;
      do
      {
        ++v27;
        v26 >>= 1;
      }
      while ( v26 );
      *(_QWORD *)&pExceptionObject[0] = v8;
      DWORD2(pExceptionObject[0]) = v27;
      v28 = pExceptionObject[0];
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)pExceptionObject, v27, v9, (unsigned int *)a4);
        LODWORD(v36) = v9;
        v37 = pExceptionObject[0];
        v38 = v28;
        sub_14616F330(
          a1,
          v6,
          (unsigned int *)a4,
          *(__int64 *)&pExceptionObject[0],
          *(unsigned __int64 *)&pExceptionObject[0],
          &v36);
        return a1;
      }
      if ( v27 < 0 )
        sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
      if ( v9 )
      {
        for ( j = v9 & 0xFFFFFF; j; j >>= 8 )
        {
          if ( (unsigned __int64)(*(_QWORD *)(v6 + 16) + 1i64) > *(_QWORD *)(v6 + 24) )
            (**(void (__fastcall ***)(__int64))v6)(v6);
          *(_WORD *)(*(_QWORD *)(v6 + 8) + 2i64 * (*(_QWORD *)(v6 + 16))++) = (unsigned __int8)j;
        }
      }
      v14 = sub_146172330((unsigned __int64 *)pExceptionObject, &v40, v6);
      goto LABEL_15;
    case 0x58:
    case 0x78:
      if ( (*(_BYTE *)(a4 + 16) & 1) != 0 )
      {
        v16 = ((v10 << 8) | 0x30) << 8;
        if ( !v9 )
          v16 = (v10 << 8) | 0x30;
        v17 = v9 | v16;
        v18 = 0x1000000;
        if ( ((v10 << 8) | 0x30u) > 0xFF )
          v18 = 0x2000000;
        v9 = v17 + v18;
      }
      LOBYTE(v40) = v10 != 120;
      v19 = v8;
      v20 = 0;
      do
      {
        ++v20;
        v19 >>= 4;
      }
      while ( v19 );
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)pExceptionObject, v20, v9, (unsigned int *)a4);
        LODWORD(v36) = v9;
        v37 = pExceptionObject[0];
        *(_QWORD *)&v38 = v8;
        DWORD2(v38) = v20;
        BYTE12(v38) = v40;
        *(_WORD *)((char *)&v38 + 13) = *(_WORD *)((char *)pExceptionObject + 13);
        HIBYTE(v38) = HIBYTE(pExceptionObject[0]);
        sub_14616FCE0(
          a1,
          v6,
          (unsigned int *)a4,
          *(__int64 *)&pExceptionObject[0],
          *(unsigned __int64 *)&pExceptionObject[0],
          &v36);
      }
      else
      {
        if ( v20 < 0 )
          sub_14619F290(
            "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h",
            0x19Eu,
            "negative value");
        if ( v9 )
        {
          for ( k = v9 & 0xFFFFFF; k; k >>= 8 )
          {
            if ( (unsigned __int64)(*(_QWORD *)(v6 + 16) + 1i64) > *(_QWORD *)(v6 + 24) )
              (**(void (__fastcall ***)(__int64))v6)(v6);
            *(_WORD *)(*(_QWORD *)(v6 + 8) + 2i64 * (*(_QWORD *)(v6 + 16))++) = (unsigned __int8)k;
          }
        }
        sub_146169B50(&v40, v6, v8, v20, v40);
        *a1 = v40;
      }
      return a1;
    case 0x63:
      sub_14616CE30(a1, a2, v8, (unsigned int *)a4);
      return a1;
    case 0x6F:
      v30 = v8;
      v31 = 0;
      do
      {
        ++v31;
        v30 >>= 3;
      }
      while ( v30 );
      if ( (*(_BYTE *)(a4 + 16) & 1) != 0 && *(_DWORD *)(a4 + 4) <= v31 && v8 )
      {
        v32 = 12288;
        if ( !v9 )
          v32 = 48;
        v9 = (v9 | v32) + 0x1000000;
      }
      *(_QWORD *)&pExceptionObject[0] = v8;
      DWORD2(pExceptionObject[0]) = v31;
      v33 = pExceptionObject[0];
      if ( *(_DWORD *)a4 | (*(_DWORD *)(a4 + 4) + 1) )
      {
        sub_146162240((unsigned __int64 *)pExceptionObject, v31, v9, (unsigned int *)a4);
        LODWORD(v36) = v9;
        v37 = pExceptionObject[0];
        v38 = v33;
        sub_146170470(
          a1,
          v6,
          (unsigned int *)a4,
          *(__int64 *)&pExceptionObject[0],
          *(unsigned __int64 *)&pExceptionObject[0],
          &v36);
      }
      else
      {
        if ( v31 < 0 )
          sub_14619F290(
            "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h",
            0x19Eu,
            "negative value");
        if ( v9 )
        {
          for ( m = v9 & 0xFFFFFF; m; m >>= 8 )
          {
            if ( (unsigned __int64)(*(_QWORD *)(v6 + 16) + 1i64) > *(_QWORD *)(v6 + 24) )
              (**(void (__fastcall ***)(__int64))v6)(v6);
            *(_WORD *)(*(_QWORD *)(v6 + 8) + 2i64 * (*(_QWORD *)(v6 + 16))++) = (unsigned __int8)m;
          }
        }
        v14 = sub_146172460((unsigned __int64 *)pExceptionObject, &v40, v6);
LABEL_15:
        *a1 = *v14;
      }
      return a1;
    default:
      v36 = &std::exception::`vftable';
      v37 = 0i64;
      *(_QWORD *)&pExceptionObject[0] = "invalid type specifier";
      BYTE8(pExceptionObject[0]) = 1;
      _std_exception_copy(pExceptionObject);
      v36 = &fmt::v8::format_error::`vftable';
      LOBYTE(v40) = 1;
      sub_146162440((__int64)pExceptionObject, (__int64)&v36);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014616E030) ----------------------------------------------------
__int64 __fastcall sub_14616E030(__int64 *a1, unsigned __int64 a2, int a3, __int64 a4, __int64 a5)
{
  unsigned int *v5; // r15
  unsigned __int8 v9; // bl
  signed int v10; // eax
  __int64 v11; // rsi
  unsigned int v12; // edi
  signed int v13; // edx
  __int64 *v14; // rax
  __int64 *v15; // rcx
  int v16; // ecx
  __int64 *v17; // rcx
  __int64 *v18; // rax
  char *i; // r8
  unsigned int v20; // r14d
  int v21; // r11d
  __int64 *v22; // rbx
  _WORD *v23; // r10
  __int64 v24; // r8
  char *v25; // rbx
  char *v26; // rsi
  int v27; // r9d
  int v28; // r15d
  __int64 *v29; // rcx
  char *v30; // rdx
  _BYTE *v31; // rcx
  unsigned int *v33; // [rsp+30h] [rbp-D0h] BYREF
  void *v34; // [rsp+40h] [rbp-C0h] BYREF
  unsigned int v35; // [rsp+48h] [rbp-B8h]
  __int64 v36; // [rsp+50h] [rbp-B0h]
  __int64 v37[2]; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v38; // [rsp+68h] [rbp-98h]
  unsigned __int64 v39; // [rsp+70h] [rbp-90h]
  __int16 v40; // [rsp+78h] [rbp-88h]
  void **v41; // [rsp+80h] [rbp-80h] BYREF
  void *Block; // [rsp+88h] [rbp-78h]
  unsigned __int64 v43; // [rsp+90h] [rbp-70h]
  unsigned __int64 v44; // [rsp+98h] [rbp-68h]
  char v45[1008]; // [rsp+A0h] [rbp-60h] BYREF
  char v46[40]; // [rsp+490h] [rbp+390h] BYREF

  v36 = -2i64;
  v5 = (unsigned int *)a4;
  v33 = (unsigned int *)a4;
  sub_14619A3D0((__int64)v37, a5);
  if ( v40 )
  {
    v10 = sub_146165560(a2);
    v11 = v10;
    v12 = v10;
    v13 = v10;
    v14 = v37;
    if ( v39 > 0xF )
      v14 = (__int64 *)v37[0];
    while ( 1 )
    {
      v15 = v37;
      if ( v39 > 0xF )
        v15 = (__int64 *)v37[0];
      if ( v14 == (__int64 *)((char *)v15 + v38) )
        break;
      v16 = *(char *)v14;
      if ( v13 <= v16 || (unsigned __int8)(v16 - 1) > 0x7Du )
        break;
      ++v12;
      v13 -= v16;
      v14 = (__int64 *)((char *)v14 + 1);
    }
    v17 = v37;
    if ( v39 > 0xF )
      v17 = (__int64 *)v37[0];
    if ( v14 == (__int64 *)((char *)v17 + v38) )
    {
      v18 = v37;
      if ( v39 > 0xF )
        v18 = (__int64 *)v37[0];
      v12 += (v13 - 1) / *((char *)v18 + v38 - 1);
    }
    if ( (int)v11 < (int)sub_146165560(a2) )
      sub_14619F290(
        "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\format.h",
        0x41Cu,
        "invalid digit count");
    for ( i = &v46[v11]; a2 >= 0x64; a2 /= 0x64ui64 )
    {
      i -= 2;
      *(_WORD *)i = *(_WORD *)&a00010203040506[2 * (a2 % 0x64)];
    }
    if ( a2 >= 0xA )
      *((_WORD *)i - 1) = *(_WORD *)&a00010203040506[2 * a2];
    else
      *(i - 1) = a2 + 48;
    v43 = 0i64;
    v41 = &fmt::v8::basic_memory_buffer<wchar_t,500,std::allocator<wchar_t>>::`vftable';
    Block = v45;
    v44 = 500i64;
    v20 = v12 + 1;
    if ( !a3 )
      v20 = v12;
    if ( (v20 & 0x80000000) != 0 )
      sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
    if ( v20 <= 0x1F4ui64 )
      goto LABEL_33;
    if ( fmt::v8::basic_memory_buffer<wchar_t,500,std::allocator<wchar_t>>::`vftable' == sub_146168A00 )
      sub_146168A00(&v41, v20, (__int64)i);
    else
      ((void (__fastcall *)(void ***, _QWORD, char *, const char *))fmt::v8::basic_memory_buffer<wchar_t,500,std::allocator<wchar_t>>::`vftable')(
        &v41,
        v20,
        i,
        "0001020304050607080910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455"
        "56575859606162636465666768697071727374757677787980818283848586878889909192939495969798990123456789abcdef");
    v43 = v44;
    if ( v20 <= v44 )
LABEL_33:
      v43 = v20;
    v21 = 0;
    v22 = v37;
    if ( v39 > 0xF )
      v22 = (__int64 *)v37[0];
    v23 = (char *)Block + 2 * (int)v20 - 2;
    v24 = (int)v11 - 1;
    if ( (int)v11 - 1 > 0 )
    {
      v25 = (char *)v22 + 1;
      do
      {
        v26 = v25;
        *v23-- = v46[v24];
        v27 = *(v25 - 1);
        if ( *(v25 - 1) > 0 )
        {
          v28 = ++v21;
          if ( !(v21 % v27) && (_BYTE)v27 != 127 )
          {
            v29 = v37;
            if ( v39 > 0xF )
              v29 = (__int64 *)v37[0];
            v30 = (char *)v29 + v38;
            *v23-- = v40;
            v21 = 0;
            if ( v25 == v30 )
              v21 = v28;
            ++v25;
            if ( v26 == v30 )
              v25 = v26;
          }
        }
        --v24;
      }
      while ( v24 > 0 );
      v5 = v33;
    }
    *v23 = v46[0];
    if ( a3 )
      *(v23 - 1) = a3;
    v34 = Block;
    v35 = v20;
    *a1 = *sub_146170680((__int64 *)&v33, *a1, v5, v20, v20, (__int64)&v34);
    v9 = 1;
    v41 = &fmt::v8::basic_memory_buffer<wchar_t,500,std::allocator<wchar_t>>::`vftable';
    v31 = Block;
    if ( Block != v45 )
    {
      if ( 2 * v44 >= 0x1000 )
      {
        v31 = (_BYTE *)*((_QWORD *)Block - 1);
        if ( (unsigned __int64)((_BYTE *)Block - v31 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v31);
    }
  }
  else
  {
    v9 = 0;
  }
  sub_1461626B0((__int64)v37);
  return v9;
}
// 14611E348: using guessed type void *fmt::v8::basic_memory_buffer<wchar_t,500,std::allocator<wchar_t>>::`vftable';
// 14616E030: using guessed type char var_60[40];

//----- (000000014616E400) ----------------------------------------------------
__int64 *__fastcall sub_14616E400(
        __int64 *a1,
        __int64 a2,
        unsigned int *a3,
        __int64 a4,
        unsigned __int64 a5,
        char **a6)
{
  unsigned __int64 v8; // rdi
  unsigned __int64 v10; // r15
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // r15
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  char *v19; // rdi
  char *v20; // rbp
  __int16 v21; // si

  v8 = *a3;
  if ( (v8 & 0x80000000) != 0i64 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v8 - a5;
  if ( v8 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC0[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
    }
    v13 = a5;
  }
  v19 = *a6;
  v20 = &a6[1][(_QWORD)*a6];
  if ( *a6 != v20 )
  {
    do
    {
      v21 = *v19++;
      if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
        (**(void (__fastcall ***)(__int64))a2)(a2);
      *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = v21;
    }
    while ( v19 != v20 );
  }
  if ( v13 )
    *a1 = *sub_146169570((__int64 *)&a5, a2, v13, (__int64)a3 + 18);
  else
    *a1 = a2;
  return a1;
}
// 14611CFC0: using guessed type _BYTE byte_14611CFC0[8];

//----- (000000014616E5D0) ----------------------------------------------------
__int64 *__fastcall sub_14616E5D0(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, int *a6)
{
  unsigned __int64 v6; // rdi
  unsigned __int64 v10; // r15
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // r15
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  int *v19; // rsi
  __int64 v20; // rax
  __int16 v21; // di
  char *v22; // rdi
  char *i; // rbp
  __int16 v24; // si

  v6 = *a3;
  if ( (v6 & 0x80000000) != 0i64 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( v6 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC0[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
    }
    v13 = a5;
  }
  v19 = a6;
  v20 = *a6;
  if ( (_DWORD)v20 )
  {
    v21 = byte_14611CFAC[v20];
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = v21;
  }
  v22 = (char *)*((_QWORD *)v19 + 1);
  for ( i = &v22[*((_QWORD *)v19 + 2)]; v22 != i; ++*(_QWORD *)(a2 + 16) )
  {
    v24 = *v22++;
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * *(_QWORD *)(a2 + 16)) = v24;
  }
  if ( v13 )
    *a1 = *sub_146169570((__int64 *)&a5, a2, v13, (__int64)a3 + 18);
  else
    *a1 = a2;
  return a1;
}
// 14611CFC0: using guessed type _BYTE byte_14611CFC0[8];

//----- (000000014616E7C0) ----------------------------------------------------
__int64 *__fastcall sub_14616E7C0(
        __int64 *a1,
        __int64 a2,
        unsigned int *a3,
        __int64 a4,
        unsigned __int64 a5,
        _WORD *a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // rdi
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi

  v6 = *a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC0[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
      v13 = a5;
    }
  }
  if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
    (**(void (__fastcall ***)(__int64))a2)(a2);
  *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *a6;
  if ( v13 )
    *a1 = *sub_146169570((__int64 *)&a5, a2, v13, (__int64)a3 + 18);
  else
    *a1 = a2;
  return a1;
}
// 14611CFC0: using guessed type _BYTE byte_14611CFC0[8];

//----- (000000014616E970) ----------------------------------------------------
__int64 *__fastcall sub_14616E970(
        __int64 *a1,
        __int64 a2,
        unsigned int *a3,
        __int64 a4,
        unsigned __int64 a5,
        _QWORD *a6)
{
  unsigned __int64 v8; // rdi
  unsigned __int64 v10; // r15
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // r15
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  _WORD *v19; // rdi
  __int64 v20; // rbp
  _WORD *v21; // rsi

  v8 = *a3;
  if ( (v8 & 0x80000000) != 0i64 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v8 - a5;
  if ( v8 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC0[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
    }
    v13 = a5;
  }
  v19 = (_WORD *)*a6;
  v20 = *a6 + 2i64 * a6[1];
  if ( *a6 != v20 )
  {
    do
    {
      v21 = v19++;
      if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
        (**(void (__fastcall ***)(__int64))a2)(a2);
      *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v21;
    }
    while ( v19 != (_WORD *)v20 );
  }
  if ( v13 )
    *a1 = *sub_146169570((__int64 *)&a5, a2, v13, (__int64)a3 + 18);
  else
    *a1 = a2;
  return a1;
}
// 14611CFC0: using guessed type _BYTE byte_14611CFC0[8];

//----- (000000014616EB40) ----------------------------------------------------
__int64 *__fastcall sub_14616EB40(
        __int64 *a1,
        __int64 a2,
        unsigned int *a3,
        __int64 a4,
        unsigned __int64 a5,
        _DWORD *a6)
{
  unsigned __int64 v8; // rdi
  unsigned __int64 v10; // rbp
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // rbp
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  _DWORD *v19; // r14
  unsigned int i; // edi
  __int16 v21; // si
  __int64 j; // rdi
  __int64 v23; // rax

  v8 = *a3;
  if ( (v8 & 0x80000000) != 0i64 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v8 - a5;
  if ( v8 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
      v13 = a5;
    }
  }
  v19 = a6;
  for ( i = *a6 & 0xFFFFFF; i; ++*(_QWORD *)(a2 + 16) )
  {
    v21 = (unsigned __int8)i;
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    i >>= 8;
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * *(_QWORD *)(a2 + 16)) = v21;
  }
  for ( j = *((_QWORD *)v19 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = 48;
  }
  sub_146171510(v19 + 6, &a5, a2);
  v23 = a5;
  if ( v13 )
    v23 = *sub_146169570((__int64 *)&a5, a5, v13, (__int64)a3 + 18);
  *a1 = v23;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014616ED50) ----------------------------------------------------
__int64 *__fastcall sub_14616ED50(
        __int64 *a1,
        __int64 a2,
        unsigned int *a3,
        __int64 a4,
        unsigned __int64 a5,
        _DWORD *a6)
{
  unsigned __int64 v8; // rdi
  unsigned __int64 v10; // rbp
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // rbp
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  _DWORD *v19; // r14
  unsigned int i; // edi
  __int16 v21; // si
  __int64 j; // rdi
  __int64 v23; // rax

  v8 = *a3;
  if ( (v8 & 0x80000000) != 0i64 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v8 - a5;
  if ( v8 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
      v13 = a5;
    }
  }
  v19 = a6;
  for ( i = *a6 & 0xFFFFFF; i; ++*(_QWORD *)(a2 + 16) )
  {
    v21 = (unsigned __int8)i;
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    i >>= 8;
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * *(_QWORD *)(a2 + 16)) = v21;
  }
  for ( j = *((_QWORD *)v19 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = 48;
  }
  sub_146171940(v19 + 6, &a5, a2);
  v23 = a5;
  if ( v13 )
    v23 = *sub_146169570((__int64 *)&a5, a5, v13, (__int64)a3 + 18);
  *a1 = v23;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014616EF60) ----------------------------------------------------
__int64 *__fastcall sub_14616EF60(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, int **a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // rdi
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  __int64 v19; // rax

  v6 = *a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
      v13 = a5;
    }
  }
  v19 = *sub_146171670(a6, &a5, a2);
  if ( v13 )
    v19 = *sub_146169570((__int64 *)&a5, v19, v13, (__int64)a3 + 18);
  *a1 = v19;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014616F0E0) ----------------------------------------------------
__int64 *__fastcall sub_14616F0E0(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, int **a6)
{
  unsigned __int64 v7; // rdi
  unsigned __int64 v10; // rbp
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // rbp
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  int **v19; // rdi
  __int64 v20; // rcx
  __int16 v21; // si
  __int64 v22; // rbx
  int v23; // ecx
  __int64 v24; // rdi

  v7 = *a3;
  if ( (v7 & 0x80000000) != 0i64 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v7 - a5;
  if ( v7 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
      v13 = a5;
    }
  }
  v19 = a6;
  v20 = **a6;
  if ( (_DWORD)v20 )
  {
    v21 = byte_14611CFAC[v20];
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = v21;
  }
  v22 = *sub_146170850((__int64 *)&a5, a2, *(char **)v19[1], *v19[2], *v19[3], *(_WORD *)v19[4]);
  v23 = *v19[5];
  if ( v23 > 0 )
  {
    v24 = (unsigned int)v23;
    do
    {
      if ( (unsigned __int64)(*(_QWORD *)(v22 + 16) + 1i64) > *(_QWORD *)(v22 + 24) )
        (**(void (__fastcall ***)(__int64))v22)(v22);
      *(_WORD *)(*(_QWORD *)(v22 + 8) + 2i64 * (*(_QWORD *)(v22 + 16))++) = 48;
      --v24;
    }
    while ( v24 );
  }
  if ( v13 )
    *a1 = *sub_146169570((__int64 *)&a5, v22, v13, (__int64)a3 + 18);
  else
    *a1 = v22;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014616F330) ----------------------------------------------------
__int64 *__fastcall sub_14616F330(
        __int64 *a1,
        __int64 a2,
        unsigned int *a3,
        __int64 a4,
        unsigned __int64 a5,
        _DWORD *a6)
{
  unsigned __int64 v8; // rdi
  unsigned __int64 v10; // rbp
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // rbp
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  _DWORD *v19; // r14
  unsigned int i; // edi
  __int16 v21; // si
  __int64 j; // rdi
  __int64 v23; // rax

  v8 = *a3;
  if ( (v8 & 0x80000000) != 0i64 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v8 - a5;
  if ( v8 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
      v13 = a5;
    }
  }
  v19 = a6;
  for ( i = *a6 & 0xFFFFFF; i; ++*(_QWORD *)(a2 + 16) )
  {
    v21 = (unsigned __int8)i;
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    i >>= 8;
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * *(_QWORD *)(a2 + 16)) = v21;
  }
  for ( j = *((_QWORD *)v19 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = 48;
  }
  sub_146172330((unsigned __int64 *)v19 + 3, &a5, a2);
  v23 = a5;
  if ( v13 )
    v23 = *sub_146169570((__int64 *)&a5, a5, v13, (__int64)a3 + 18);
  *a1 = v23;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014616F540) ----------------------------------------------------
__int64 *__fastcall sub_14616F540(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, int *a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // rdi
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  __int64 v19; // rax

  v6 = *a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
      v13 = a5;
    }
  }
  v19 = *sub_146171BE0(a6, &a5, a2);
  if ( v13 )
    v19 = *sub_146169570((__int64 *)&a5, v19, v13, (__int64)a3 + 18);
  *a1 = v19;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014616F6C0) ----------------------------------------------------
__int64 *__fastcall sub_14616F6C0(
        __int64 *a1,
        __int64 a2,
        unsigned int *a3,
        __int64 a4,
        unsigned __int64 a5,
        _DWORD *a6)
{
  unsigned __int64 v8; // rdi
  unsigned __int64 v10; // rbp
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // rbp
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  _DWORD *v19; // r14
  unsigned int i; // edi
  __int16 v21; // si
  __int64 j; // rdi
  __int64 v23; // rax

  v8 = *a3;
  if ( (v8 & 0x80000000) != 0i64 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v8 - a5;
  if ( v8 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
      v13 = a5;
    }
  }
  v19 = a6;
  for ( i = *a6 & 0xFFFFFF; i; ++*(_QWORD *)(a2 + 16) )
  {
    v21 = (unsigned __int8)i;
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    i >>= 8;
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * *(_QWORD *)(a2 + 16)) = v21;
  }
  for ( j = *((_QWORD *)v19 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = 48;
  }
  sub_146171A70(v19 + 6, &a5, a2);
  v23 = a5;
  if ( v13 )
    v23 = *sub_146169570((__int64 *)&a5, a5, v13, (__int64)a3 + 18);
  *a1 = v23;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014616F8D0) ----------------------------------------------------
__int64 *__fastcall sub_14616F8D0(
        __int64 *a1,
        __int64 a2,
        unsigned int *a3,
        __int64 a4,
        unsigned __int64 a5,
        _DWORD *a6)
{
  unsigned __int64 v8; // rdi
  unsigned __int64 v10; // rbp
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // rbp
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  _DWORD *v19; // r14
  unsigned int i; // edi
  __int16 v21; // si
  __int64 j; // rdi
  __int64 v23; // rax

  v8 = *a3;
  if ( (v8 & 0x80000000) != 0i64 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v8 - a5;
  if ( v8 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
      v13 = a5;
    }
  }
  v19 = a6;
  for ( i = *a6 & 0xFFFFFF; i; ++*(_QWORD *)(a2 + 16) )
  {
    v21 = (unsigned __int8)i;
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    i >>= 8;
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * *(_QWORD *)(a2 + 16)) = v21;
  }
  for ( j = *((_QWORD *)v19 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = 48;
  }
  sub_1461713B0((__int64)(v19 + 6), &a5, a2);
  v23 = a5;
  if ( v13 )
    v23 = *sub_146169570((__int64 *)&a5, a5, v13, (__int64)a3 + 18);
  *a1 = v23;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014616FAE0) ----------------------------------------------------
__int64 *__fastcall sub_14616FAE0(
        __int64 *a1,
        __int64 a2,
        unsigned int *a3,
        __int64 a4,
        unsigned __int64 a5,
        __int64 a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // rdi
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  __int64 v19; // r8
  __int64 v20; // rax

  v6 = *a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
      v13 = a5;
    }
  }
  if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
    (**(void (__fastcall ***)(__int64))a2)(a2);
  *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = 48;
  if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
    (**(void (__fastcall ***)(__int64))a2)(a2);
  v19 = a6;
  *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = 120;
  sub_146169B50(&a5, a2, *(_QWORD *)v19, *(_DWORD *)(v19 + 8), 0);
  v20 = a5;
  if ( v13 )
    v20 = *sub_146169570((__int64 *)&a5, a5, v13, (__int64)a3 + 18);
  *a1 = v20;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014616FCE0) ----------------------------------------------------
__int64 *__fastcall sub_14616FCE0(
        __int64 *a1,
        __int64 a2,
        unsigned int *a3,
        __int64 a4,
        unsigned __int64 a5,
        _DWORD *a6)
{
  unsigned __int64 v8; // rdi
  unsigned __int64 v10; // rbp
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // rbp
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  _DWORD *v19; // r14
  unsigned int i; // edi
  __int16 v21; // si
  __int64 j; // rdi
  __int64 v23; // rax

  v8 = *a3;
  if ( (v8 & 0x80000000) != 0i64 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v8 - a5;
  if ( v8 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
      v13 = a5;
    }
  }
  v19 = a6;
  for ( i = *a6 & 0xFFFFFF; i; ++*(_QWORD *)(a2 + 16) )
  {
    v21 = (unsigned __int8)i;
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    i >>= 8;
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * *(_QWORD *)(a2 + 16)) = v21;
  }
  for ( j = *((_QWORD *)v19 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = 48;
  }
  sub_146169B50(&a5, a2, *((_QWORD *)v19 + 3), v19[8], *((_BYTE *)v19 + 36));
  v23 = a5;
  if ( v13 )
    v23 = *sub_146169570((__int64 *)&a5, a5, v13, (__int64)a3 + 18);
  *a1 = v23;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014616FF10) ----------------------------------------------------
__int64 *__fastcall sub_14616FF10(__int64 *a1, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, int **a6)
{
  __int64 v6; // rdi
  unsigned __int64 v10; // rdi
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // rdi
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  __int64 v19; // rax

  v6 = *a3;
  if ( (int)v6 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v6 - a5;
  if ( *a3 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
      v13 = a5;
    }
  }
  v19 = *sub_1461725A0(a6, (__int64 *)&a5, a2);
  if ( v13 )
    v19 = *sub_146169570((__int64 *)&a5, v19, v13, (__int64)a3 + 18);
  *a1 = v19;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (0000000146170090) ----------------------------------------------------
__int64 *__fastcall sub_146170090(
        __int64 *a1,
        __int64 a2,
        unsigned int *a3,
        __int64 a4,
        unsigned __int64 a5,
        _DWORD *a6)
{
  unsigned __int64 v8; // rdi
  unsigned __int64 v10; // rbp
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // rbp
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  _DWORD *v19; // r14
  unsigned int i; // edi
  __int16 v21; // si
  __int64 j; // rdi
  __int64 v23; // rax

  v8 = *a3;
  if ( (v8 & 0x80000000) != 0i64 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v8 - a5;
  if ( v8 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
      v13 = a5;
    }
  }
  v19 = a6;
  for ( i = *a6 & 0xFFFFFF; i; ++*(_QWORD *)(a2 + 16) )
  {
    v21 = (unsigned __int8)i;
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    i >>= 8;
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * *(_QWORD *)(a2 + 16)) = v21;
  }
  for ( j = *((_QWORD *)v19 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = 48;
  }
  sub_146171810(v19 + 6, &a5, a2);
  v23 = a5;
  if ( v13 )
    v23 = *sub_146169570((__int64 *)&a5, a5, v13, (__int64)a3 + 18);
  *a1 = v23;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (00000001461702A0) ----------------------------------------------------
__int64 *__fastcall sub_1461702A0(
        __int64 *a1,
        __int64 a2,
        unsigned int *a3,
        __int64 a4,
        unsigned __int64 a5,
        char **a6)
{
  unsigned __int64 v8; // rdi
  unsigned __int64 v10; // r15
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // r15
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  char *v19; // rdi
  char *v20; // rbp
  __int16 v21; // si

  v8 = *a3;
  if ( (v8 & 0x80000000) != 0i64 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v8 - a5;
  if ( v8 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
    }
    v13 = a5;
  }
  v19 = *a6;
  v20 = &a6[1][(_QWORD)*a6];
  if ( *a6 != v20 )
  {
    do
    {
      v21 = *v19++;
      if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
        (**(void (__fastcall ***)(__int64))a2)(a2);
      *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = v21;
    }
    while ( v19 != v20 );
  }
  if ( v13 )
    *a1 = *sub_146169570((__int64 *)&a5, a2, v13, (__int64)a3 + 18);
  else
    *a1 = a2;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (0000000146170470) ----------------------------------------------------
__int64 *__fastcall sub_146170470(
        __int64 *a1,
        __int64 a2,
        unsigned int *a3,
        __int64 a4,
        unsigned __int64 a5,
        _DWORD *a6)
{
  unsigned __int64 v8; // rdi
  unsigned __int64 v10; // rbp
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // rbp
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  _DWORD *v19; // r14
  unsigned int i; // edi
  __int16 v21; // si
  __int64 j; // rdi
  __int64 v23; // rax

  v8 = *a3;
  if ( (v8 & 0x80000000) != 0i64 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v8 - a5;
  if ( v8 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
      v13 = a5;
    }
  }
  v19 = a6;
  for ( i = *a6 & 0xFFFFFF; i; ++*(_QWORD *)(a2 + 16) )
  {
    v21 = (unsigned __int8)i;
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    i >>= 8;
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * *(_QWORD *)(a2 + 16)) = v21;
  }
  for ( j = *((_QWORD *)v19 + 2); j; --j )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = 48;
  }
  sub_146172460((unsigned __int64 *)v19 + 3, &a5, a2);
  v23 = a5;
  if ( v13 )
    v23 = *sub_146169570((__int64 *)&a5, a5, v13, (__int64)a3 + 18);
  *a1 = v23;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (0000000146170680) ----------------------------------------------------
__int64 *__fastcall sub_146170680(
        __int64 *a1,
        __int64 a2,
        unsigned int *a3,
        __int64 a4,
        unsigned __int64 a5,
        __int64 a6)
{
  unsigned __int64 v8; // rdi
  unsigned __int64 v10; // r15
  char v11; // cl
  unsigned __int64 v12; // r14
  __int64 v13; // r15
  __int64 v14; // rax
  _WORD *v15; // r15
  _WORD *v16; // rbp
  _WORD *v17; // rdi
  _WORD *v18; // rsi
  _WORD *v19; // rdi
  __int64 v20; // rbp
  _WORD *v21; // rsi

  v8 = *a3;
  if ( (v8 & 0x80000000) != 0i64 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v10 = v8 - a5;
  if ( v8 <= a5 )
    v10 = 0i64;
  v11 = byte_14611CFC8[(__int64)(int)(a3[3] << 28) >> 28];
  v12 = v10 >> v11;
  v13 = v10 - (v10 >> v11);
  a5 = v13;
  if ( v12 )
  {
    v14 = *((unsigned __int8 *)a3 + 26);
    v15 = (_WORD *)a3 + 9;
    if ( v14 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v15;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v16 = &v15[v14];
      do
      {
        v17 = (_WORD *)a3 + 9;
        if ( v15 != v16 )
        {
          do
          {
            v18 = v17++;
            if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
              (**(void (__fastcall ***)(__int64))a2)(a2);
            *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v18;
          }
          while ( v17 != v16 );
        }
        --v12;
      }
      while ( v12 );
    }
    v13 = a5;
  }
  v19 = *(_WORD **)a6;
  v20 = *(_QWORD *)a6 + 2i64 * *(int *)(a6 + 8);
  if ( *(_QWORD *)a6 != v20 )
  {
    do
    {
      v21 = v19++;
      if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
        (**(void (__fastcall ***)(__int64))a2)(a2);
      *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = *v21;
    }
    while ( v19 != (_WORD *)v20 );
  }
  if ( v13 )
    *a1 = *sub_146169570((__int64 *)&a5, a2, v13, (__int64)a3 + 18);
  else
    *a1 = a2;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (0000000146170850) ----------------------------------------------------
__int64 *__fastcall sub_146170850(__int64 *a1, __int64 a2, char *a3, int a4, int a5, __int16 a6)
{
  __int64 v8; // r13
  char *v10; // rdi
  char *v11; // rbp
  __int16 v12; // si
  __int64 v13; // rdx

  v8 = a4;
  v10 = a3;
  v11 = &a3[a5];
  if ( a3 != v11 )
  {
    do
    {
      v12 = *v10++;
      if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
        (**(void (__fastcall ***)(__int64))a2)(a2);
      *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = v12;
    }
    while ( v10 != v11 );
  }
  v13 = a5;
  if ( a6 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
    {
      (**(void (__fastcall ***)(__int64, __int64))a2)(a2, *(_QWORD *)(a2 + 16) + 1i64);
      v13 = a5;
    }
    *(_WORD *)(*(_QWORD *)(a2 + 8) + 2i64 * (*(_QWORD *)(a2 + 16))++) = a6;
    sub_1461690E0(a1, &a3[v13], &a3[v8], a2);
  }
  else
  {
    *a1 = a2;
  }
  return a1;
}

//----- (0000000146170930) ----------------------------------------------------
__int64 __fastcall sub_146170930(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 v4; // rdx
  __int64 v6; // r8
  _DWORD *v7; // rax
  __int64 v8; // rcx
  unsigned __int64 v9; // rsi
  char *v11; // rax
  char *v12; // rcx
  char *v13; // rax
  __int64 v14; // rcx

  v2 = 0i64;
  *(_QWORD *)a1 = 0i64;
  *(_DWORD *)(a1 + 8) = 0;
  v4 = 32i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  v6 = 32i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  v7 = (_DWORD *)(a1 + 88);
  v8 = a1 + 88;
  do
  {
    *(_DWORD *)v8 = 0;
    *(_QWORD *)(v8 + 8) = 0i64;
    v8 += 16i64;
    --v6;
  }
  while ( v6 );
  *(_QWORD *)(a1 + 600) = 0i64;
  *(_DWORD *)(a1 + 608) = 0;
  *(_DWORD *)(a1 + 600) = 0;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_QWORD *)(a1 + 64) = 32i64;
  *(_QWORD *)(a1 + 72) = v7;
  do
  {
    *v7 = 0;
    v7 += 4;
    --v4;
  }
  while ( v4 );
  *(_QWORD *)(a1 + 80) = 0i64;
  *(_QWORD *)(a1 + 48) = a1 + 64;
  v9 = ((a2 & 0x1F) != 0) + (a2 >> 5);
  *(_QWORD *)(a1 + 32) = v9;
  if ( v9 )
  {
    v11 = (char *)malloc_0(2120 * v9);
    v12 = v11;
    if ( v11 )
    {
      v13 = v11 + 2056;
      do
      {
        *((_QWORD *)v13 - 1) = 0i64;
        *(_QWORD *)v13 = 0i64;
        *(_OWORD *)(v13 + 8) = 0i64;
        *(_OWORD *)(v13 + 24) = 0i64;
        *((_DWORD *)v13 + 10) = 0;
        *((_QWORD *)v13 + 6) = 0i64;
        *((_WORD *)v13 + 28) = 256;
        v13 += 2120;
        --v9;
      }
      while ( v9 );
      *(_QWORD *)(a1 + 24) = v12;
    }
    else
    {
      *(_QWORD *)(a1 + 24) = 0i64;
      *(_QWORD *)(a1 + 32) = 0i64;
    }
    if ( *(_QWORD *)(a1 + 32) )
    {
      v14 = 0i64;
      do
      {
        v14 += 2120i64;
        ++v2;
        *(_BYTE *)(v14 + *(_QWORD *)(a1 + 24) - 7) = 0;
      }
      while ( v2 < *(_QWORD *)(a1 + 32) );
    }
    return a1;
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0i64;
    return a1;
  }
}

//----- (0000000146170A90) ----------------------------------------------------
__int64 __fastcall sub_146170A90(__int64 a1, __int64 *a2)
{
  __int64 v4; // r15
  int v5; // eax
  _OWORD *v6; // rsi
  int v7; // eax
  const char *v8; // rbx
  size_t v9; // r8
  __int64 v10; // rdx
  __int64 v11; // r9
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // rax
  _BYTE *v15; // rcx
  const char *v16; // rax
  __int64 lpName; // rax
  _BYTE *v18; // rcx
  void *v19; // rcx
  DWORD LastError; // ebx
  char *v21; // rdi
  const char *v23; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v24; // [rsp+50h] [rbp-B8h]
  __int128 v25; // [rsp+68h] [rbp-A0h] BYREF
  _QWORD v26[3]; // [rsp+78h] [rbp-90h] BYREF
  __int128 v27; // [rsp+90h] [rbp-78h]
  void *v28; // [rsp+A0h] [rbp-68h] BYREF
  __m128i si128; // [rsp+B0h] [rbp-58h]
  __int64 v30[7]; // [rsp+C0h] [rbp-48h] BYREF
  void **v31; // [rsp+F8h] [rbp-10h] BYREF
  void *Block; // [rsp+100h] [rbp-8h]
  size_t v33; // [rsp+108h] [rbp+0h]
  unsigned __int64 v34; // [rsp+110h] [rbp+8h]
  char v35[512]; // [rsp+118h] [rbp+10h] BYREF

  v26[0] = -2i64;
  *(_QWORD *)(a1 + 8) = &qword_14610AA88;
  v4 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v5 = *(_DWORD *)(v4 + 312);
  v6 = (_OWORD *)(v4 + 280);
  if ( (v5 & 1) == 0 )
  {
    *(_DWORD *)(v4 + 312) = v5 | 1;
    *v6 = 0i64;
    *(_QWORD *)(v4 + 296) = 4i64;
    *(_QWORD *)(v4 + 304) = 15i64;
    strcpy((char *)(v4 + 280), "Five");
    _tlregdtor(qword_1461AE4D0);
  }
  v7 = *(_DWORD *)(v4 + 272);
  if ( (v7 & 1) == 0 )
  {
    *(_DWORD *)(v4 + 272) = v7 | 1;
    v8 = sub_146166FF0();
    *(_OWORD *)(v4 + 240) = 0i64;
    *(_QWORD *)(v4 + 256) = 0i64;
    *(_QWORD *)(v4 + 264) = 0i64;
    v9 = strlen(v8);
    sub_14615A650((_QWORD *)(v4 + 240), v8, v9);
    _tlregdtor(qword_1461AE4B0);
  }
  v10 = v4 + 240;
  if ( *(_QWORD *)(v4 + 264) > 0xFui64 )
    v10 = *(_QWORD *)(v4 + 240);
  v11 = *(_QWORD *)(v4 + 256);
  v12 = v4 + 280;
  if ( *(_QWORD *)(v4 + 304) > 0xFui64 )
    v12 = *(_QWORD *)v6;
  v13 = *(_QWORD *)(v4 + 296);
  v14 = (__int64)a2;
  if ( (unsigned __int64)a2[3] > 0xF )
    v14 = *a2;
  v30[0] = v10;
  v30[1] = v11;
  v30[2] = v12;
  v30[3] = v13;
  v30[4] = v14;
  v30[5] = a2[2];
  v33 = 0i64;
  v31 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  Block = v35;
  v34 = 500i64;
  *(_QWORD *)&v25 = 3549i64;
  *((_QWORD *)&v25 + 1) = v30;
  v23 = "CFX_%s_%s_SharedData_%s";
  v24 = 23i64;
  sub_14615CF80((__int64)&v31, (__int64)&v23, &v25);
  *(_OWORD *)&v26[1] = 0i64;
  v27 = 0i64;
  sub_14615A650(&v26[1], Block, v33);
  v31 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  v15 = Block;
  if ( Block != v35 )
  {
    if ( v34 >= 0x1000 )
    {
      v15 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v15 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v15);
  }
  v16 = (const char *)&v26[1];
  if ( *((_QWORD *)&v27 + 1) > 0xFui64 )
    v16 = (const char *)v26[1];
  v23 = v16;
  v24 = v27;
  lpName = sub_1461A2C60((__int64)&v28, (__int64)&v23);
  if ( *(_QWORD *)(lpName + 24) > 7ui64 )
    lpName = *(_QWORD *)lpName;
  *(_QWORD *)a1 = CreateFileMappingW((HANDLE)0xFFFFFFFFFFFFFFFFi64, 0i64, 4u, 0, 0x18u, (LPCWSTR)lpName);
  if ( si128.m128i_i64[1] > 7ui64 )
  {
    v18 = v28;
    if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
    {
      v18 = (_BYTE *)*((_QWORD *)v28 - 1);
      if ( (unsigned __int64)((_BYTE *)v28 - v18 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v18);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(v28) = 0;
  if ( *((_QWORD *)&v27 + 1) > 0xFui64 )
  {
    v19 = (void *)v26[1];
    if ( (unsigned __int64)(*((_QWORD *)&v27 + 1) + 1i64) >= 0x1000 )
    {
      v19 = *(void **)(v26[1] - 8i64);
      if ( (unsigned __int64)(v26[1] - (_QWORD)v19 - 8i64) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v19);
  }
  if ( *(_QWORD *)a1 )
  {
    LastError = GetLastError();
    v21 = (char *)MapViewOfFile(*(HANDLE *)a1, 0xF001Fu, 0, 0, 0x18ui64);
    *(_QWORD *)(a1 + 8) = v21;
    if ( LastError != 183 )
    {
      *(_QWORD *)v21 = GetTickCount64();
      GetSystemTime((LPSYSTEMTIME)(v21 + 8));
      *(_QWORD *)(a1 + 8) = v21;
    }
  }
  return a1;
}
// 14610AA88: using guessed type __int64 qword_14610AA88;
// 14611AE78: using guessed type int TlsIndex;
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 1461A7E18: using guessed type __int64 __fastcall _tlregdtor(_QWORD);
// 1461AE4B0: using guessed type __int64 qword_1461AE4B0[4];
// 1461AE4D0: using guessed type __int64 qword_1461AE4D0[4];

//----- (0000000146170E60) ----------------------------------------------------
__int64 __fastcall sub_146170E60(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _OWORD *v4; // r14
  unsigned __int64 v6; // rsi
  __int64 v7; // rdi
  _QWORD *v8; // rax

  *(_OWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  v4 = (_OWORD *)a2;
  *(_QWORD *)(a1 + 24) = 0i64;
  v6 = *(_QWORD *)(a2 + 16);
  if ( *(_QWORD *)(a2 + 24) > 0xFui64 )
    v4 = *(_OWORD **)a2;
  v7 = 0x7FFFFFFFFFFFFFFFi64;
  if ( v6 > 0x7FFFFFFFFFFFFFFFi64 )
    unknown_libname_4(a1, a2, a3, a4);
  if ( v6 > 0xF )
  {
    if ( (v6 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      v7 = v6 | 0xF;
      if ( (v6 | 0xF) < 0x16 )
        v7 = 22i64;
    }
    v8 = sub_14615A5E0(v7 + 1);
    *(_QWORD *)a1 = v8;
    *(_QWORD *)(a1 + 16) = v6;
    *(_QWORD *)(a1 + 24) = v7;
    memcpy(v8, v4, v6 + 1);
  }
  else
  {
    *(_QWORD *)(a1 + 16) = v6;
    *(_QWORD *)(a1 + 24) = 15i64;
    *(_OWORD *)a1 = *v4;
  }
  return a1;
}
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146170F20) ----------------------------------------------------
__int64 __fastcall sub_146170F20(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _OWORD *v4; // r14
  unsigned __int64 v6; // rdi
  __int64 v7; // rsi
  __int64 v8; // rcx
  _QWORD *v9; // rax

  *(_OWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  v4 = (_OWORD *)a2;
  *(_QWORD *)(a1 + 24) = 0i64;
  v6 = *(_QWORD *)(a2 + 16);
  if ( *(_QWORD *)(a2 + 24) > 7ui64 )
    v4 = *(_OWORD **)a2;
  v7 = 0x7FFFFFFFFFFFFFFEi64;
  if ( v6 > 0x7FFFFFFFFFFFFFFEi64 )
    unknown_libname_4(a1, a2, a3, a4);
  if ( v6 > 7 )
  {
    if ( (v6 | 7) <= 0x7FFFFFFFFFFFFFFEi64 )
    {
      v7 = v6 | 7;
      if ( (v6 | 7) < 0xA )
        v7 = 10i64;
      v8 = v7 + 1;
      if ( (unsigned __int64)(v7 + 1) > 0x7FFFFFFFFFFFFFFFi64 )
        sub_146165390();
    }
    else
    {
      v8 = 0x7FFFFFFFFFFFFFFFi64;
    }
    v9 = sub_14615A5E0(2 * v8);
    *(_QWORD *)a1 = v9;
    *(_QWORD *)(a1 + 16) = v6;
    *(_QWORD *)(a1 + 24) = v7;
    memcpy(v9, v4, 2 * v6 + 2);
  }
  else
  {
    *(_QWORD *)(a1 + 16) = v6;
    *(_QWORD *)(a1 + 24) = 7i64;
    *(_OWORD *)a1 = *v4;
  }
  return a1;
}
// 146165390: using guessed type void __noreturn sub_146165390(void);
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146171010) ----------------------------------------------------
void __fastcall sub_146171010(_QWORD *a1)
{
  _QWORD *v2; // rcx

  *a1 = &fmt::v8::basic_memory_buffer<wchar_t,500,std::allocator<wchar_t>>::`vftable';
  v2 = (_QWORD *)a1[1];
  if ( v2 != a1 + 4 )
  {
    if ( (unsigned __int64)(2i64 * a1[3]) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - *(v2 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v2 = (_QWORD *)*(v2 - 1);
    }
    j_j_free(v2);
  }
}
// 14611E348: using guessed type void *fmt::v8::basic_memory_buffer<wchar_t,500,std::allocator<wchar_t>>::`vftable';

//----- (0000000146171080) ----------------------------------------------------
void __fastcall sub_146171080(__int64 a1)
{
  sub_1461626B0(a1 + 32);
  sub_1461626B0(a1);
}

//----- (00000001461710A0) ----------------------------------------------------
void **__fastcall sub_1461710A0(_QWORD *a1)
{
  signed __int64 v1; // rbx
  __int64 v3; // r13
  __int64 v4; // rax
  __int64 v5; // rbp
  __int64 v6; // rcx
  signed __int64 v7; // rdx
  bool v8; // zf
  signed __int64 v9; // rax
  _QWORD *v10; // rbx
  unsigned __int64 v11; // rdi
  __int64 v12; // rsi
  __int64 v13; // r15
  __int64 v14; // rsi
  unsigned __int64 v15; // r14
  signed __int64 v16; // rcx
  __int64 v17; // r8
  signed __int64 v18; // rdx
  signed __int64 v19; // rax
  _QWORD *v20; // rcx
  _QWORD *v21; // rbx
  void **result; // rax
  __int64 v23; // [rsp+50h] [rbp+8h]

  *a1 = &moodycamel::ConcurrentQueue<std::tuple<std::string,std::string>,moodycamel::ConcurrentQueueDefaultTraits>::ImplicitProducer::`vftable';
  v1 = 0i64;
  v3 = a1[4];
  v4 = a1[5];
  v23 = v4;
  v5 = v4;
  if ( v4 == v3 )
    goto LABEL_20;
  if ( (unsigned __int64)(v4 - v3) <= 0x8000000000000000ui64 )
    sub_1461A1C30(
      (wchar_t *)L"index == tail || details::circular_less_than(index, tail)",
      (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\vendor\\concurrentqueue\\concurrentqueue.h",
      2434);
  do
  {
    if ( (v5 & 0x1F) != 0 )
    {
      if ( v1 )
        goto LABEL_18;
    }
    else if ( v1 )
    {
      v6 = a1[10];
      if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v1 + 2096), 0x80000000) )
      {
        v7 = *(_QWORD *)(v6 + 40);
        do
        {
          *(_QWORD *)(v1 + 2104) = v7;
          *(_DWORD *)(v1 + 2096) = 1;
          v9 = _InterlockedCompareExchange64((volatile signed __int64 *)(v6 + 40), v1, v7);
          v8 = v7 == v9;
          v7 = v9;
        }
        while ( !v8 && _InterlockedExchangeAdd((volatile signed __int32 *)(v1 + 2096), 0x7FFFFFFFu) == 1 );
      }
    }
    v10 = (_QWORD *)a1[12];
    v11 = v5 & 0xFFFFFFFFFFFFFFE0ui64;
    v12 = v10[1];
    v13 = **(_QWORD **)(v10[3] + 8 * v12);
    if ( v13 == 1 )
      sub_1461A1C30(
        (wchar_t *)L"tailBase != INVALID_BLOCK_BASE",
        (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\vendor\\concurrentqueue\\concurrentqueue.h",
        2942);
    v14 = 8 * ((*v10 - 1i64) & (v12 + ((v11 - v13) >> 5)));
    if ( **(_QWORD **)(v14 + v10[3]) != v11 || !*(_QWORD *)(*(_QWORD *)(v10[3] + v14) + 8i64) )
      sub_1461A1C30(
        (wchar_t *)L"localBlockIndex->index[idx]->key.load(std::memory_order_relaxed) == index && localBlockIndex->index[i"
                    "dx]->value.load(std::memory_order_relaxed) != nullptr",
        (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\vendor\\concurrentqueue\\concurrentqueue.h",
        2947);
    v1 = *(_QWORD *)(*(_QWORD *)(v10[3] + v14) + 8i64);
LABEL_18:
    v15 = (unsigned __int64)(v5 & 0x1F) << 6;
    sub_1461626B0(v15 + v1 + 32);
    sub_1461626B0(v15 + v1);
    ++v5;
  }
  while ( v5 != v3 );
  v4 = v23;
LABEL_20:
  v16 = a1[8];
  if ( v16 && (v4 != v3 || (v3 & 0x1F) != 0) )
  {
    v17 = a1[10];
    if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(v16 + 2096), 0x80000000) )
    {
      v18 = *(_QWORD *)(v17 + 40);
      do
      {
        *(_QWORD *)(v16 + 2104) = v18;
        *(_DWORD *)(v16 + 2096) = 1;
        v19 = _InterlockedCompareExchange64((volatile signed __int64 *)(v17 + 40), v16, v18);
        v8 = v18 == v19;
        v18 = v19;
      }
      while ( !v8 && _InterlockedExchangeAdd((volatile signed __int32 *)(v16 + 2096), 0x7FFFFFFFu) == 1 );
    }
  }
  v20 = (_QWORD *)a1[12];
  if ( v20 )
  {
    do
    {
      v21 = (_QWORD *)v20[4];
      free_0(v20);
      v20 = v21;
    }
    while ( v21 );
  }
  result = &moodycamel::ConcurrentQueue<std::tuple<std::string,std::string>,moodycamel::ConcurrentQueueDefaultTraits>::ProducerBase::`vftable';
  *a1 = &moodycamel::ConcurrentQueue<std::tuple<std::string,std::string>,moodycamel::ConcurrentQueueDefaultTraits>::ProducerBase::`vftable';
  return result;
}
// 14611EA10: using guessed type void *moodycamel::ConcurrentQueue<std::tuple<std::string,std::string>,moodycamel::ConcurrentQueueDefaultTraits>::ProducerBase::`vftable';
// 14611EA20: using guessed type void *moodycamel::ConcurrentQueue<std::tuple<std::string,std::string>,moodycamel::ConcurrentQueueDefaultTraits>::ImplicitProducer::`vftable';

//----- (0000000146171310) ----------------------------------------------------
__int64 __fastcall sub_146171310(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // rdx
  _QWORD *v5; // rcx

  if ( a1 != a2 )
  {
    v4 = *(_QWORD *)(a1 + 24);
    if ( v4 > 0xF )
    {
      v5 = *(_QWORD **)a1;
      if ( v4 + 1 >= 0x1000 )
      {
        if ( (unsigned __int64)v5 - *(v5 - 1) - 8 > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        v5 = (_QWORD *)*(v5 - 1);
      }
      j_j_free(v5);
    }
    *(_QWORD *)(a1 + 24) = 15i64;
    *(_QWORD *)(a1 + 16) = 0i64;
    *(_BYTE *)a1 = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
    *(_QWORD *)(a2 + 16) = 0i64;
    *(_QWORD *)(a2 + 24) = 15i64;
    *(_BYTE *)a2 = 0;
  }
  return a1;
}

//----- (00000001461713B0) ----------------------------------------------------
_QWORD *__fastcall sub_1461713B0(__int64 a1, _QWORD *a2, __int64 a3)
{
  unsigned __int64 v3; // rdi
  __int64 v5; // rsi
  _WORD *v7; // r8
  const char *v8; // r9
  _WORD *v9; // rbp
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rdi
  __int16 v12; // ax
  _WORD *i; // rdi
  _WORD *v14; // rsi
  unsigned __int64 v15; // rdx
  _QWORD *result; // rax
  _WORD v17[20]; // [rsp+20h] [rbp-48h] BYREF

  v3 = *(_QWORD *)a1;
  v5 = *(int *)(a1 + 8);
  if ( (int)v5 < (int)sub_146165560(*(_QWORD *)a1) )
    sub_14619F290(
      "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\format.h",
      0x41Cu,
      "invalid digit count");
  v7 = &v17[v5];
  v8 = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555"
       "6575859606162636465666768697071727374757677787980818283848586878889909192939495969798990123456789abcdef";
  v9 = v7;
  if ( v3 >= 0x64 )
  {
    do
    {
      v7 -= 2;
      v10 = v3 / 0x64;
      v11 = v3 % 0x64;
      *v7 = a00010203040506[2 * v11];
      v12 = a00010203040506[2 * v11 + 1];
      v3 = v10;
      v7[1] = v12;
    }
    while ( v10 >= 0x64 );
  }
  if ( v3 >= 0xA )
  {
    *(v7 - 2) = a00010203040506[2 * v3];
    *(v7 - 1) = a00010203040506[2 * v3 + 1];
  }
  else
  {
    *(v7 - 1) = v3 + 48;
  }
  for ( i = v17; i != v9; ++*(_QWORD *)(a3 + 16) )
  {
    v14 = i;
    v15 = *(_QWORD *)(a3 + 16) + 1i64;
    ++i;
    if ( v15 > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64, unsigned __int64, _WORD *, const char *))a3)(a3, v15, v7, v8);
    v7 = *(_WORD **)(a3 + 16);
    *(_WORD *)(*(_QWORD *)(a3 + 8) + 2i64 * (_QWORD)v7) = *v14;
  }
  result = a2;
  *a2 = a3;
  return result;
}
// 1461714CA: variable 'v8' is possibly undefined

//----- (0000000146171510) ----------------------------------------------------
_QWORD *__fastcall sub_146171510(unsigned int *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rsi
  int v5; // eax
  unsigned int v6; // ecx
  _WORD *v9; // r8
  _WORD *i; // rbp
  __int64 v11; // rcx
  __int64 v12; // rcx
  _WORD *j; // rdi
  _WORD *v14; // rsi
  _QWORD *result; // rax
  int v16; // [rsp+20h] [rbp-58h]
  _WORD v17[12]; // [rsp+28h] [rbp-50h] BYREF

  v3 = *a1;
  v4 = (int)a1[1];
  v5 = *a1 | 1;
  v16 = 0;
  _BitScanReverse(&v6, v5);
  if ( (int)v4 < (int)((unsigned __int64)(v3 + qword_14611CFD0[v6]) >> 32) )
    sub_14619F290(
      "F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\format.h",
      0x41Cu,
      "invalid digit count");
  v9 = &v17[v4];
  for ( i = v9; (unsigned int)v3 >= 0x64; v9[1] = *(char *)(v11 + 0x140000001i64) )
  {
    v9 -= 2;
    v11 = 2i64 * ((unsigned int)v3 % 0x64) + 101830352;
    LODWORD(v3) = (unsigned int)v3 / 0x64;
    *v9 = *(char *)(v11 + 0x140000000i64);
  }
  if ( (unsigned int)v3 >= 0xA )
  {
    v12 = 2i64 * (unsigned int)v3 + 101830352;
    *(v9 - 2) = *(char *)(v12 + 0x140000000i64);
    *(v9 - 1) = *(char *)(v12 + 0x140000001i64);
  }
  else
  {
    *(v9 - 1) = v3 + 48;
  }
  for ( j = v17; j != i; ++*(_QWORD *)(a3 + 16) )
  {
    v14 = j++;
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_WORD *)(*(_QWORD *)(a3 + 8) + 2i64 * *(_QWORD *)(a3 + 16)) = *v14;
  }
  result = a2;
  *a2 = a3;
  return result;
}
// 14611CFD0: using guessed type __int64 qword_14611CFD0[32];

//----- (0000000146171670) ----------------------------------------------------
_QWORD *__fastcall sub_146171670(int **a1, _QWORD *a2, __int64 a3)
{
  _QWORD *v3; // rbp
  __int64 *v5; // rdi
  __int64 v8; // rdx
  __int16 v9; // si
  char *v10; // rsi
  char *v11; // r12
  __int16 v12; // r14
  int v13; // ecx
  __int64 v14; // rsi
  int *v15; // rsi
  __int64 v16; // rdx
  int v17; // ecx
  __int64 v18; // rsi
  _QWORD *result; // rax

  v3 = (_QWORD *)(a3 + 24);
  v5 = (__int64 *)(a3 + 16);
  v8 = **a1;
  if ( (_DWORD)v8 )
  {
    v9 = byte_14611CFAC[v8];
    if ( (unsigned __int64)(*v5 + 1) > *v3 )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_WORD *)(*(_QWORD *)(a3 + 8) + 2 * (*v5)++) = v9;
  }
  v10 = *(char **)a1[1];
  v11 = &v10[*a1[2]];
  if ( v10 != v11 )
  {
    do
    {
      v12 = *v10++;
      if ( (unsigned __int64)(*v5 + 1) > *v3 )
        (**(void (__fastcall ***)(__int64))a3)(a3);
      *(_WORD *)(*(_QWORD *)(a3 + 8) + 2 * (*v5)++) = v12;
    }
    while ( v10 != v11 );
    v3 = (_QWORD *)(a3 + 24);
    v5 = (__int64 *)(a3 + 16);
  }
  v13 = a1[3][3];
  if ( v13 > 0 )
  {
    v14 = (unsigned int)v13;
    do
    {
      if ( (unsigned __int64)(*v5 + 1) > *v3 )
        (**(void (__fastcall ***)(__int64))a3)(a3);
      *(_WORD *)(*(_QWORD *)(a3 + 8) + 2 * (*v5)++) = 48;
      --v14;
    }
    while ( v14 );
    v5 = (__int64 *)(a3 + 16);
    v3 = (_QWORD *)(a3 + 24);
  }
  if ( (a1[4][3] & 0x10) != 0 )
  {
    v15 = a1[5];
    if ( (unsigned __int64)(*v5 + 1) > *v3 )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_WORD *)(*(_QWORD *)(a3 + 8) + 2 * *v5) = *(_WORD *)v15;
    v16 = *v5 + 1;
    *v5 = v16;
    v17 = *a1[6];
    if ( v17 > 0 )
    {
      v18 = (unsigned int)v17;
      do
      {
        if ( (unsigned __int64)(v16 + 1) > *v3 )
          (**(void (__fastcall ***)(__int64))a3)(a3);
        *(_WORD *)(*(_QWORD *)(a3 + 8) + 2 * (*v5)++) = 48;
        v16 = *v5;
        --v18;
      }
      while ( v18 );
    }
  }
  result = a2;
  *a2 = a3;
  return result;
}

//----- (0000000146171810) ----------------------------------------------------
_QWORD *__fastcall sub_146171810(unsigned int *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rbp
  unsigned int v5; // edi
  __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  __int64 v9; // rax
  char *v10; // r14
  char *v11; // rcx
  char v12; // al
  char *i; // rdi
  __int16 v14; // bp
  __int64 v16; // rax
  __int64 v17; // rcx
  _WORD *v18; // rdx
  __int16 v19; // cx
  char v20[40]; // [rsp+20h] [rbp-48h] BYREF

  v3 = (int)a1[1];
  v5 = *a1;
  if ( (int)v3 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v7 = *(_QWORD *)(a3 + 16);
  v8 = v7 + (unsigned int)v3;
  if ( *(_QWORD *)(a3 + 24) >= v8 )
  {
    v16 = *(_QWORD *)(a3 + 8);
    *(_QWORD *)(a3 + 16) = v8;
    v17 = v16 + 2 * v7;
    v9 = v3;
    if ( v17 )
    {
      v18 = (_WORD *)(v17 + 2 * v3);
      do
      {
        --v18;
        v19 = (v5 & 1) + 48;
        v5 >>= 1;
        *v18 = v19;
      }
      while ( v5 );
      *a2 = a3;
      return a2;
    }
  }
  else
  {
    v9 = v3;
  }
  v10 = &v20[v9];
  v11 = &v20[v9];
  do
  {
    --v11;
    v12 = (v5 & 1) + 48;
    v5 >>= 1;
    *v11 = v12;
  }
  while ( v5 );
  for ( i = v20; i != v10; ++*(_QWORD *)(a3 + 16) )
  {
    v14 = *i++;
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_WORD *)(*(_QWORD *)(a3 + 8) + 2i64 * *(_QWORD *)(a3 + 16)) = v14;
  }
  *a2 = a3;
  return a2;
}

//----- (0000000146171940) ----------------------------------------------------
_QWORD *__fastcall sub_146171940(unsigned int *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rbp
  unsigned int v5; // edi
  __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  __int64 v9; // rax
  char *v10; // r14
  char *v11; // rcx
  char v12; // al
  char *i; // rdi
  __int16 v14; // bp
  __int64 v16; // rax
  __int64 v17; // rcx
  _WORD *v18; // rdx
  __int16 v19; // cx
  char v20[16]; // [rsp+20h] [rbp-38h] BYREF

  v3 = (int)a1[1];
  v5 = *a1;
  if ( (int)v3 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v7 = *(_QWORD *)(a3 + 16);
  v8 = v7 + (unsigned int)v3;
  if ( *(_QWORD *)(a3 + 24) >= v8 )
  {
    v16 = *(_QWORD *)(a3 + 8);
    *(_QWORD *)(a3 + 16) = v8;
    v17 = v16 + 2 * v7;
    v9 = v3;
    if ( v17 )
    {
      v18 = (_WORD *)(v17 + 2 * v3);
      do
      {
        --v18;
        v19 = v5 & 7;
        v5 >>= 3;
        *v18 = v19 + 48;
      }
      while ( v5 );
      *a2 = a3;
      return a2;
    }
  }
  else
  {
    v9 = v3;
  }
  v10 = &v20[v9];
  v11 = &v20[v9];
  do
  {
    --v11;
    v12 = v5 & 7;
    v5 >>= 3;
    *v11 = v12 + 48;
  }
  while ( v5 );
  for ( i = v20; i != v10; ++*(_QWORD *)(a3 + 16) )
  {
    v14 = *i++;
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_WORD *)(*(_QWORD *)(a3 + 8) + 2i64 * *(_QWORD *)(a3 + 16)) = v14;
  }
  *a2 = a3;
  return a2;
}

//----- (0000000146171A70) ----------------------------------------------------
_QWORD *__fastcall sub_146171A70(int *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rbp
  char v5; // r15
  unsigned int v7; // edi
  __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  __int64 v10; // rax
  char *v11; // r8
  char *v12; // r14
  char *v13; // rcx
  __int64 v14; // rax
  char *i; // rdi
  __int16 v16; // bp
  __int64 v18; // rax
  __int64 v19; // rcx
  char *v20; // r8
  _WORD *v21; // rdx
  __int64 v22; // rcx
  char v23[16]; // [rsp+20h] [rbp-48h] BYREF

  v3 = a1[1];
  v5 = *((_BYTE *)a1 + 8);
  v7 = *a1;
  if ( (int)v3 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v8 = *(_QWORD *)(a3 + 16);
  v9 = v8 + (unsigned int)v3;
  if ( *(_QWORD *)(a3 + 24) < v9 )
  {
    v10 = v3;
LABEL_5:
    v11 = "0123456789abcdef";
    v12 = &v23[v10];
    v13 = &v23[v10];
    if ( v5 )
      v11 = "0123456789ABCDEF";
    do
    {
      --v13;
      v14 = v7 & 0xF;
      v7 >>= 4;
      *v13 = v11[v14];
    }
    while ( v7 );
    for ( i = v23; i != v12; ++*(_QWORD *)(a3 + 16) )
    {
      v16 = *i++;
      if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
        (**(void (__fastcall ***)(__int64))a3)(a3);
      *(_WORD *)(*(_QWORD *)(a3 + 8) + 2i64 * *(_QWORD *)(a3 + 16)) = v16;
    }
    *a2 = a3;
    return a2;
  }
  v18 = *(_QWORD *)(a3 + 8);
  *(_QWORD *)(a3 + 16) = v9;
  v19 = v18 + 2 * v8;
  v10 = v3;
  if ( !v19 )
    goto LABEL_5;
  v20 = "0123456789abcdef";
  if ( v5 )
    v20 = "0123456789ABCDEF";
  v21 = (_WORD *)(v19 + 2 * v3);
  do
  {
    --v21;
    v22 = v7 & 0xF;
    v7 >>= 4;
    *v21 = v20[v22];
  }
  while ( v7 );
  *a2 = a3;
  return a2;
}

//----- (0000000146171BE0) ----------------------------------------------------
_QWORD *__fastcall sub_146171BE0(int *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rax
  __int16 v7; // di
  __int64 v8; // rbx
  int v9; // eax
  __int64 v10; // rdi
  __int16 v11; // di
  __int64 v13; // [rsp+50h] [rbp+8h] BYREF

  v3 = *a1;
  if ( (_DWORD)v3 )
  {
    v7 = byte_14611CFAC[v3];
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_WORD *)(*(_QWORD *)(a3 + 8) + 2i64 * (*(_QWORD *)(a3 + 16))++) = v7;
  }
  v8 = *sub_146170850(&v13, a3, *((char **)a1 + 1), a1[4], 1, *((_WORD *)a1 + 10));
  v9 = a1[6];
  if ( v9 > 0 )
  {
    v10 = (unsigned int)v9;
    do
    {
      if ( (unsigned __int64)(*(_QWORD *)(v8 + 16) + 1i64) > *(_QWORD *)(v8 + 24) )
        (**(void (__fastcall ***)(__int64))v8)(v8);
      *(_WORD *)(*(_QWORD *)(v8 + 8) + 2i64 * (*(_QWORD *)(v8 + 16))++) = 48;
      --v10;
    }
    while ( v10 );
  }
  v11 = *((char *)a1 + 28);
  if ( (unsigned __int64)(*(_QWORD *)(v8 + 16) + 1i64) > *(_QWORD *)(v8 + 24) )
    (**(void (__fastcall ***)(__int64))v8)(v8);
  *(_WORD *)(*(_QWORD *)(v8 + 8) + 2i64 * (*(_QWORD *)(v8 + 16))++) = v11;
  sub_14616CE70(a2, a1[8], v8);
  return a2;
}

//----- (0000000146171CE0) ----------------------------------------------------
__int64 __fastcall sub_146171CE0(__int64 a1, __int64 a2)
{
  void *v3; // rcx
  __int64 *v4; // rcx
  HANDLE hObject; // [rsp+30h] [rbp-48h] BYREF
  LPCVOID lpBaseAddress; // [rsp+38h] [rbp-40h]
  __int64 v8; // [rsp+40h] [rbp-38h]
  void *Block[2]; // [rsp+48h] [rbp-30h] BYREF
  __m128i si128; // [rsp+58h] [rbp-20h]

  v8 = -2i64;
  *(_OWORD *)Block = 0i64;
  Block[0] = sub_14615A5E0(0x20ui64);
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611ECC0);
  strcpy((char *)Block[0], "CFX_SharedTickCount");
  sub_146170A90((__int64)&hObject, (__int64 *)Block);
  if ( si128.m128i_i64[1] > 0xFui64 )
  {
    v3 = Block[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v3 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v3 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v3);
  }
  v4 = (__int64 *)lpBaseAddress;
  *(_OWORD *)a2 = *(_OWORD *)lpBaseAddress;
  *(_QWORD *)(a2 + 16) = v4[2];
  if ( v4 && v4 != &qword_14610AA88 )
    UnmapViewOfFile(v4);
  if ( hObject )
    CloseHandle(hObject);
  return a2;
}
// 14610AA88: using guessed type __int64 qword_14610AA88;
// 14611ECC0: using guessed type __int128 xmmword_14611ECC0;

//----- (0000000146171E10) ----------------------------------------------------
void __noreturn sub_146171E10()
{
  __m128i si128; // xmm6
  __int64 *v1; // rbx
  unsigned __int64 v2; // r10
  __int64 v3; // r12
  unsigned __int64 v4; // r9
  _QWORD *v5; // r8
  unsigned __int64 v6; // r11
  __int64 v7; // rdx
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  _QWORD *v10; // rax
  __int64 v11; // rax
  __int64 v12; // rbx
  __int64 v13; // rcx
  __int64 v14; // rdx
  __int64 v15; // rax
  signed __int64 v16; // r14
  _QWORD *v17; // r8
  __int64 v18; // r15
  __int64 v19; // rdi
  __int128 *v20; // rsi
  void *v21; // rcx
  void *v22; // rcx
  char v23; // al
  __int64 v24; // rdi
  __int64 v25; // r15
  signed __int64 v26; // r14
  __int64 v27; // rdi
  __int128 *v28; // rsi
  void *v29; // rcx
  void *v30; // rcx
  unsigned __int64 v31; // rax
  __int64 v32; // rax
  __int128 v33; // [rsp+48h] [rbp-29h] BYREF
  __m128i v34; // [rsp+58h] [rbp-19h]
  __int128 v35; // [rsp+68h] [rbp-9h] BYREF
  __m128i v36; // [rsp+78h] [rbp+7h]

  sub_1461A1A40(-1, "[Cfx] File Log Thread");
  si128 = _mm_load_si128((const __m128i *)&Size);
  while ( 1 )
  {
    AcquireSRWLockExclusive(&SRWLock);
    SleepConditionVariableSRW(&ConditionVariable, &SRWLock, 0xFFFFFFFF, 0);
    ReleaseSRWLockExclusive(&SRWLock);
    v33 = 0i64;
    v34 = si128;
    LOBYTE(v33) = 0;
    v35 = 0i64;
    v36 = si128;
    LOBYTE(v35) = 0;
    while ( 1 )
    {
      v1 = (__int64 *)qword_14610A9F8;
      v2 = 0i64;
      v3 = 0i64;
      v4 = 0i64;
      v5 = *(_QWORD **)qword_14610A9F8;
      do
      {
        v6 = v4;
        if ( !v5 )
          break;
        v7 = v5[4];
        v8 = v5[5] - v7;
        v9 = v7 - v5[5];
        if ( v8 <= 0x8000000000000000ui64 )
          v9 = 0i64;
        if ( v9 )
        {
          if ( v9 > v4 )
            v4 = v9;
          ++v2;
          v10 = v5;
          if ( v9 <= v6 )
            v10 = (_QWORD *)v3;
          v3 = (__int64)v10;
        }
        v11 = v5[1];
        v5 = (_QWORD *)(v11 - 8);
        if ( !v11 )
          v5 = 0i64;
      }
      while ( v2 < 3 );
      if ( !v2 )
        goto LABEL_61;
      if ( !sub_146169170(v3, (__int64)&v33) )
        break;
LABEL_65:
      sub_146173110((__int64)&v33);
    }
    v12 = *v1;
    if ( v12 )
      break;
LABEL_61:
    if ( v36.m128i_i64[1] > 0xFui64 )
      sub_146173950((__int64)&v35, (void *)v35, v36.m128i_i64[1]);
    v36 = si128;
    LOBYTE(v35) = 0;
    if ( v34.m128i_i64[1] > 0xFui64 )
      sub_146173950((__int64)&v33, (void *)v33, v34.m128i_i64[1]);
  }
  while ( v12 == v3 )
  {
LABEL_58:
    v32 = *(_QWORD *)(v12 + 8);
    v12 = v32 - 8;
    if ( !v32 )
      v12 = 0i64;
    if ( !v12 )
      goto LABEL_61;
  }
  v13 = *(_QWORD *)(v12 + 32);
  v14 = *(_QWORD *)(v12 + 56);
  v15 = *(_QWORD *)(v12 + 48);
  if ( *(_BYTE *)(v12 + 72) )
  {
    if ( (unsigned __int64)(v15 - v14 - v13) > 0x8000000000000000ui64 )
    {
      if ( (unsigned __int64)(_InterlockedExchangeAdd64((volatile signed __int64 *)(v12 + 48), 1ui64)
                            - *(_QWORD *)(v12 + 32)
                            - v14) > 0x8000000000000000ui64 )
      {
        v16 = _InterlockedExchangeAdd64((volatile signed __int64 *)(v12 + 40), 1ui64);
        v17 = *(_QWORD **)(v12 + 88);
        v18 = *(_QWORD *)(v17[2]
                        + 16
                        * ((*v17 - 1i64) & (v17[1]
                                          + (((v16 & 0xFFFFFFFFFFFFFFE0ui64) - *(_QWORD *)(16i64 * v17[1] + v17[2])) >> 5)))
                        + 8);
        v19 = v18 + ((unsigned __int64)(v16 & 0x1F) << 6);
        v20 = (__int128 *)(v19 + 32);
        if ( &v35 != (__int128 *)(v19 + 32) )
        {
          if ( v36.m128i_i64[1] > 0xFui64 )
          {
            v21 = (void *)v35;
            if ( (unsigned __int64)(v36.m128i_i64[1] + 1) >= 0x1000 )
            {
              v21 = *(void **)(v35 - 8);
              if ( (unsigned __int64)(v35 - (_QWORD)v21 - 8) > 0x1F )
                goto LABEL_66;
            }
            j_j_free(v21);
          }
          v36 = si128;
          LOBYTE(v35) = 0;
          v35 = *v20;
          v36 = *(__m128i *)(v19 + 48);
          *(_QWORD *)(v19 + 48) = 0i64;
          *(_QWORD *)(v19 + 56) = 15i64;
          *(_BYTE *)v20 = 0;
        }
        if ( &v33 != (__int128 *)v19 )
        {
          if ( v34.m128i_i64[1] > 0xFui64 )
          {
            v22 = (void *)v33;
            if ( (unsigned __int64)(v34.m128i_i64[1] + 1) >= 0x1000 )
            {
              v22 = *(void **)(v33 - 8);
              if ( (unsigned __int64)(v33 - (_QWORD)v22 - 8) > 0x1F )
                goto LABEL_66;
            }
            j_j_free(v22);
          }
          v34 = si128;
          LOBYTE(v33) = 0;
          v33 = *(_OWORD *)v19;
          v34 = *(__m128i *)(v19 + 16);
          *(_QWORD *)(v19 + 16) = 0i64;
          *(_QWORD *)(v19 + 24) = 15i64;
          *(_BYTE *)v19 = 0;
        }
        sub_1461626B0(v19 + 32);
        sub_1461626B0(v19);
        sub_14616A1A0(v18, v16);
        v23 = 1;
        goto LABEL_57;
      }
      goto LABEL_55;
    }
  }
  else if ( (unsigned __int64)(v15 - v14 - v13) > 0x8000000000000000ui64 )
  {
    if ( (unsigned __int64)(_InterlockedExchangeAdd64((volatile signed __int64 *)(v12 + 48), 1ui64)
                          - *(_QWORD *)(v12 + 32)
                          - v14) > 0x8000000000000000ui64 )
    {
      v24 = _InterlockedExchangeAdd64((volatile signed __int64 *)(v12 + 40), 1ui64);
      v25 = sub_146173A20(v12, v24);
      v26 = *(_QWORD *)(v25 + 8);
      v27 = v26 + ((unsigned __int64)(v24 & 0x1F) << 6);
      v28 = (__int128 *)(v27 + 32);
      if ( &v35 != (__int128 *)(v27 + 32) )
      {
        if ( v36.m128i_i64[1] > 0xFui64 )
        {
          v29 = (void *)v35;
          if ( (unsigned __int64)(v36.m128i_i64[1] + 1) >= 0x1000 )
          {
            v29 = *(void **)(v35 - 8);
            if ( (unsigned __int64)(v35 - (_QWORD)v29 - 8) > 0x1F )
LABEL_66:
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v29);
        }
        v36 = si128;
        LOBYTE(v35) = 0;
        v35 = *v28;
        v36 = *(__m128i *)(v27 + 48);
        *(_QWORD *)(v27 + 48) = 0i64;
        *(_QWORD *)(v27 + 56) = 15i64;
        *(_BYTE *)v28 = 0;
      }
      if ( &v33 != (__int128 *)v27 )
      {
        if ( v34.m128i_i64[1] > 0xFui64 )
        {
          v30 = (void *)v33;
          if ( (unsigned __int64)(v34.m128i_i64[1] + 1) >= 0x1000 )
          {
            v30 = *(void **)(v33 - 8);
            if ( (unsigned __int64)(v33 - (_QWORD)v30 - 8) > 0x1F )
              goto LABEL_66;
          }
          j_j_free(v30);
        }
        v34 = si128;
        LOBYTE(v33) = 0;
        v33 = *(_OWORD *)v27;
        v34 = *(__m128i *)(v27 + 16);
        *(_QWORD *)(v27 + 16) = 0i64;
        *(_QWORD *)(v27 + 24) = 15i64;
        *(_BYTE *)v27 = 0;
      }
      sub_1461626B0(v27 + 32);
      sub_1461626B0(v27);
      v31 = _InterlockedExchangeAdd64((volatile signed __int64 *)(v26 + 2056), 1ui64);
      if ( v31 < 0x20 )
      {
        if ( v31 == 31 )
        {
          *(_QWORD *)(v25 + 8) = 0i64;
          sub_1461739D0(*(_QWORD *)(v12 + 80), v26);
        }
        v23 = 1;
      }
      else
      {
        sub_1461A1C30(
          (wchar_t *)L"prevVal < BLOCK_SIZE",
          (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\vendor\\concurrentqueue\\concurrentqueue.h",
          1587);
        v23 = 1;
      }
      goto LABEL_57;
    }
LABEL_55:
    _InterlockedIncrement64((volatile signed __int64 *)(v12 + 56));
  }
  v23 = 0;
LABEL_57:
  if ( v23 )
    goto LABEL_65;
  goto LABEL_58;
}
// 14610A9F8: using guessed type __int64 qword_14610A9F8;
// 146171E10: using guessed type void __noreturn sub_146171E10();

//----- (0000000146172330) ----------------------------------------------------
_QWORD *__fastcall sub_146172330(unsigned __int64 *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rbp
  unsigned __int64 v5; // rdi
  __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  __int64 v9; // rax
  char *v10; // r14
  char *v11; // rcx
  char v12; // al
  char *i; // rdi
  __int16 v14; // bp
  __int64 v16; // rax
  __int64 v17; // rcx
  _WORD *v18; // rdx
  __int16 v19; // cx
  char v20[80]; // [rsp+20h] [rbp-78h] BYREF

  v3 = *((int *)a1 + 2);
  v5 = *a1;
  if ( (int)v3 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v7 = *(_QWORD *)(a3 + 16);
  v8 = v7 + (unsigned int)v3;
  if ( *(_QWORD *)(a3 + 24) >= v8 )
  {
    v16 = *(_QWORD *)(a3 + 8);
    *(_QWORD *)(a3 + 16) = v8;
    v17 = v16 + 2 * v7;
    v9 = v3;
    if ( v17 )
    {
      v18 = (_WORD *)(v17 + 2 * v3);
      do
      {
        --v18;
        v19 = (v5 & 1) + 48;
        v5 >>= 1;
        *v18 = v19;
      }
      while ( v5 );
      *a2 = a3;
      return a2;
    }
  }
  else
  {
    v9 = v3;
  }
  v10 = &v20[v9];
  v11 = &v20[v9];
  do
  {
    --v11;
    v12 = (v5 & 1) + 48;
    v5 >>= 1;
    *v11 = v12;
  }
  while ( v5 );
  for ( i = v20; i != v10; ++*(_QWORD *)(a3 + 16) )
  {
    v14 = *i++;
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_WORD *)(*(_QWORD *)(a3 + 8) + 2i64 * *(_QWORD *)(a3 + 16)) = v14;
  }
  *a2 = a3;
  return a2;
}

//----- (0000000146172460) ----------------------------------------------------
_QWORD *__fastcall sub_146172460(unsigned __int64 *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rbp
  unsigned __int64 v5; // rdi
  __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  __int64 v9; // rax
  char *v10; // r14
  char *v11; // rcx
  char v12; // al
  char *i; // rdi
  __int16 v14; // bp
  __int64 v16; // rax
  __int64 v17; // rcx
  _WORD *v18; // rdx
  __int16 v19; // cx
  char v20[24]; // [rsp+20h] [rbp-38h] BYREF

  v3 = *((int *)a1 + 2);
  v5 = *a1;
  if ( (int)v3 < 0 )
    sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
  v7 = *(_QWORD *)(a3 + 16);
  v8 = v7 + (unsigned int)v3;
  if ( *(_QWORD *)(a3 + 24) >= v8 )
  {
    v16 = *(_QWORD *)(a3 + 8);
    *(_QWORD *)(a3 + 16) = v8;
    v17 = v16 + 2 * v7;
    v9 = v3;
    if ( v17 )
    {
      v18 = (_WORD *)(v17 + 2 * v3);
      do
      {
        --v18;
        v19 = v5 & 7;
        v5 >>= 3;
        *v18 = v19 + 48;
      }
      while ( v5 );
      *a2 = a3;
      return a2;
    }
  }
  else
  {
    v9 = v3;
  }
  v10 = &v20[v9];
  v11 = &v20[v9];
  do
  {
    --v11;
    v12 = v5 & 7;
    v5 >>= 3;
    *v11 = v12 + 48;
  }
  while ( v5 );
  for ( i = v20; i != v10; ++*(_QWORD *)(a3 + 16) )
  {
    v14 = *i++;
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_WORD *)(*(_QWORD *)(a3 + 8) + 2i64 * *(_QWORD *)(a3 + 16)) = v14;
  }
  *a2 = a3;
  return a2;
}

//----- (00000001461725A0) ----------------------------------------------------
__int64 *__fastcall sub_1461725A0(int **a1, __int64 *a2, __int64 a3)
{
  _QWORD *v3; // rbp
  __int64 v7; // rcx
  __int16 v8; // di
  _QWORD *v9; // r15
  __int64 v10; // rdx
  int *v11; // rax
  __int64 *v12; // rdi
  _QWORD *v13; // r14
  __int64 v14; // rdx
  int v15; // ecx
  __int64 v16; // rsi
  int *v18; // [rsp+50h] [rbp+8h]

  v3 = (_QWORD *)(a3 + 24);
  v7 = **a1;
  if ( (_DWORD)v7 )
  {
    v8 = byte_14611CFAC[v7];
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *v3 )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    v9 = (_QWORD *)(a3 + 8);
    *(_WORD *)(*(_QWORD *)(a3 + 8) + 2i64 * (*(_QWORD *)(a3 + 16))++) = v8;
  }
  else
  {
    v9 = (_QWORD *)(a3 + 8);
  }
  if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *v3 )
    (**(void (__fastcall ***)(__int64))a3)(a3);
  *(_WORD *)(*v9 + 2i64 * *(_QWORD *)(a3 + 16)) = 48;
  v10 = *(_QWORD *)(a3 + 16) + 1i64;
  *(_QWORD *)(a3 + 16) = v10;
  if ( *(_BYTE *)a1[1] )
  {
    v11 = a1[2];
    v12 = (__int64 *)(a3 + 16);
    v13 = v9;
    v18 = v11;
    if ( (unsigned __int64)(v10 + 1) > *v3 )
    {
      (**(void (__fastcall ***)(__int64))a3)(a3);
      v11 = v18;
      v3 = (_QWORD *)(a3 + 24);
      v13 = (_QWORD *)(a3 + 8);
      v12 = (__int64 *)(a3 + 16);
    }
    *(_WORD *)(*v9 + 2i64 * *(_QWORD *)(a3 + 16)) = *(_WORD *)v11;
    v14 = *(_QWORD *)(a3 + 16) + 1i64;
    *(_QWORD *)(a3 + 16) = v14;
    v15 = *a1[3];
    if ( v15 > 0 )
    {
      v16 = (unsigned int)v15;
      do
      {
        if ( (unsigned __int64)(v14 + 1) > *v3 )
          (**(void (__fastcall ***)(__int64))a3)(a3);
        *(_WORD *)(*v13 + 2 * (*v12)++) = 48;
        v14 = *v12;
        --v16;
      }
      while ( v16 );
    }
    sub_1461690E0(a2, *(char **)a1[4], (char *)(*(_QWORD *)a1[4] + *a1[5]), a3);
  }
  else
  {
    *a2 = a3;
  }
  return a2;
}

//----- (0000000146172710) ----------------------------------------------------
_QWORD *__fastcall sub_146172710(__int64 *a1, _QWORD *a2, char *a3)
{
  __int64 v3; // rsi
  char v6; // al
  __int64 v7; // rbx
  unsigned __int64 v8; // rax
  int v9; // edi
  __int64 v10; // r9
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rdx
  __int128 v13; // xmm0
  __int64 v14; // rdx
  __int64 v15; // xmm1_8
  __int64 v17; // [rsp+30h] [rbp-78h] BYREF
  __int64 v18; // [rsp+38h] [rbp-70h] BYREF
  char *v19; // [rsp+40h] [rbp-68h] BYREF
  __int64 v20; // [rsp+48h] [rbp-60h]
  __int128 v21; // [rsp+50h] [rbp-58h] BYREF
  __int64 v22; // [rsp+60h] [rbp-48h]
  int v23; // [rsp+68h] [rbp-40h]

  v3 = a1[1];
  if ( a3 )
  {
    v6 = *(_BYTE *)(v3 + 8);
    v7 = *a1;
    if ( v6 && v6 != 112 )
      sub_14619FE20((__int64)&v17, (__int64)"invalid type specifier");
    v8 = (unsigned __int64)a3;
    v9 = 0;
    do
    {
      ++v9;
      v8 >>= 4;
    }
    while ( v8 );
    if ( v9 < 0 )
      sub_14619F290("F:\\NewBuildFivem\\LauncherGTA\\vendor\\fmtlib\\include\\fmt\\core.h", 0x19Eu, "negative value");
    v10 = (unsigned int)v9 + 2i64;
    v19 = a3;
    LODWORD(v20) = v9;
    if ( v3 )
    {
      sub_14616FAE0(&v18, v7, (unsigned int *)v3, v10, (unsigned int)v9 + 2i64, (__int64)&v19);
    }
    else
    {
      v11 = *(_QWORD *)(v7 + 16) + 1i64;
      if ( v11 > *(_QWORD *)(v7 + 24) )
        (**(void (__fastcall ***)(__int64, unsigned __int64, char *, __int64))v7)(v7, v11, a3, v10);
      *(_WORD *)(*(_QWORD *)(v7 + 8) + 2i64 * (*(_QWORD *)(v7 + 16))++) = 48;
      v12 = *(_QWORD *)(v7 + 16) + 1i64;
      if ( v12 > *(_QWORD *)(v7 + 24) )
        (**(void (__fastcall ***)(__int64, unsigned __int64, char *, __int64))v7)(v7, v12, a3, v10);
      *(_WORD *)(*(_QWORD *)(v7 + 8) + 2i64 * (*(_QWORD *)(v7 + 16))++) = 120;
      sub_146169B50(&v18, v7, (unsigned __int64)a3, v9, 0);
    }
  }
  else
  {
    v13 = *(_OWORD *)v3;
    v14 = *a1;
    v15 = *(_QWORD *)(v3 + 16);
    v23 = *(_DWORD *)(v3 + 24);
    v19 = "(nil)";
    v21 = v13;
    v22 = v15;
    BYTE8(v21) = 0;
    v20 = 5i64;
    sub_14616E400(&v18, v14, (unsigned int *)&v21, 5i64, 5ui64, &v19);
  }
  *a2 = v18;
  return a2;
}
// 146172807: variable 'a3' is possibly undefined
// 146172807: variable 'v10' is possibly undefined

//----- (0000000146172910) ----------------------------------------------------
_QWORD *__fastcall sub_146172910(_QWORD *a1, char a2)
{
  *a1 = &moodycamel::ConcurrentQueue<std::tuple<std::string,std::string>,moodycamel::ConcurrentQueueDefaultTraits>::ProducerBase::`vftable';
  if ( (a2 & 1) != 0 )
    j_j_free(a1);
  return a1;
}
// 14611EA10: using guessed type void *moodycamel::ConcurrentQueue<std::tuple<std::string,std::string>,moodycamel::ConcurrentQueueDefaultTraits>::ProducerBase::`vftable';

//----- (0000000146172940) ----------------------------------------------------
_QWORD *__fastcall sub_146172940(_QWORD *a1)
{
  HMODULE ModuleHandleW; // rax
  WCHAR *v3; // rbx
  wchar_t *v4; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  _QWORD *v7; // rcx
  void *v8; // rcx
  void *Block[2]; // [rsp+50h] [rbp-238h] BYREF
  __m128i si128; // [rsp+60h] [rbp-228h]
  WCHAR Filename[256]; // [rsp+70h] [rbp-218h] BYREF

  ModuleHandleW = GetModuleHandleW(0i64);
  GetModuleFileNameW(ModuleHandleW, Filename, 0x100u);
  v3 = Filename;
  if ( wcschr(Filename, 0x5Fu) )
    v3 = wcschr(Filename, 0x5Fu) + 1;
  if ( wcsrchr(v3, 0x5Cu) )
    v3 = wcsrchr(v3, 0x5Cu) + 1;
  v4 = wcsrchr(v3, 0x2Eu);
  if ( v4 )
    *v4 = 0;
  Block[0] = v3;
  Block[1] = (void *)wcslen(v3);
  sub_1461A2B60((__int64)a1, (unsigned __int16 **)Block, v5, v6);
  if ( a1[2] > 0xEui64 )
  {
    *(_OWORD *)Block = 0i64;
    v7 = a1;
    if ( a1[3] > 0xFui64 )
      v7 = (_QWORD *)*a1;
    si128 = _mm_load_si128((const __m128i *)&xmmword_14611ECB0);
    Block[0] = *(void **)v7;
    LODWORD(Block[1]) = *((_DWORD *)v7 + 2);
    WORD2(Block[1]) = *((_WORD *)v7 + 6);
    BYTE6(Block[1]) = 0;
    sub_146171310((__int64)a1, (__int64)Block);
    if ( si128.m128i_i64[1] > 0xFui64 )
    {
      v8 = Block[0];
      if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
      {
        v8 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)(Block[0] - v8 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v8);
    }
  }
  return a1;
}
// 146172A16: variable 'v5' is possibly undefined
// 146172A16: variable 'v6' is possibly undefined
// 14611ECB0: using guessed type __int128 xmmword_14611ECB0;

//----- (0000000146172B00) ----------------------------------------------------
unsigned __int16 *__fastcall sub_146172B00(unsigned __int16 *a1)
{
  DWORD CurrentThreadId; // r8d
  __int64 v3; // r9
  char *v4; // rsi
  __int64 v5; // rdx
  __int64 v6; // rcx
  unsigned __int64 v7; // r15
  unsigned __int64 v8; // r14
  __int64 v9; // r13
  _QWORD *v10; // rbx
  int (__fastcall *v11)(HANDLE, wchar_t **); // rbx
  HANDLE CurrentThread; // rax
  int v13; // eax
  wchar_t *v14; // rbx
  unsigned __int16 *v15; // rax
  __int64 v16; // r8
  __int64 v17; // r9
  unsigned __int16 *v18; // rbx
  unsigned __int64 v19; // rdx
  unsigned __int16 *v20; // rcx
  _BYTE *v21; // rcx
  unsigned __int16 *v22; // rbx
  _QWORD *v23; // rcx
  __m128i si128; // xmm6
  unsigned __int64 v25; // rdx
  unsigned __int16 *v26; // rcx
  char *v27; // rax
  wchar_t *String; // [rsp+38h] [rbp-69h] BYREF
  int v30; // [rsp+40h] [rbp-61h]
  unsigned __int16 *v31[4]; // [rsp+48h] [rbp-59h] BYREF
  __int128 v32; // [rsp+68h] [rbp-39h] BYREF
  __m128i v33; // [rsp+78h] [rbp-29h]
  void *Block; // [rsp+88h] [rbp-19h] BYREF
  unsigned __int64 v35; // [rsp+A0h] [rbp-1h]
  char v36[3]; // [rsp+BDh] [rbp+1Ch] BYREF

  v31[2] = (unsigned __int16 *)-2i64;
  v31[3] = a1;
  v30 = 0;
  CurrentThreadId = GetCurrentThreadId();
  v4 = v36;
  do
  {
    --v4;
    v5 = CurrentThreadId / 0xA;
    v6 = (unsigned __int8)(4 * v5) + (unsigned int)v5;
    *v4 = CurrentThreadId % 0xA + 48;
    CurrentThreadId = v5;
  }
  while ( (_DWORD)v5 );
  *(_OWORD *)a1 = 0i64;
  *((_QWORD *)a1 + 2) = 0i64;
  *((_QWORD *)a1 + 3) = 0i64;
  v7 = 15i64;
  if ( v4 == v36 )
  {
    *((_QWORD *)a1 + 3) = 15i64;
    *(_BYTE *)a1 = 0;
  }
  else
  {
    v8 = v36 - v4;
    v9 = 0x7FFFFFFFFFFFFFFFi64;
    if ( (unsigned __int64)(v36 - v4) > 0x7FFFFFFFFFFFFFFFi64 )
    {
      LOBYTE(v6) = 10 * v5;
      unknown_libname_4(v6, v5, v5, v3);
    }
    if ( v8 > 0xF )
    {
      if ( (v8 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
      {
        v9 = v8 | 0xF;
        if ( (v8 | 0xF) < 0x16 )
          v9 = 22i64;
      }
      v10 = sub_14615A5E0(v9 + 1);
      *(_QWORD *)a1 = v10;
      *((_QWORD *)a1 + 2) = v8;
      *((_QWORD *)a1 + 3) = v9;
      memcpy(v10, v4, v36 - v4);
      *((_BYTE *)v10 + v8) = 0;
    }
    else
    {
      *((_QWORD *)a1 + 2) = v8;
      *((_QWORD *)a1 + 3) = 15i64;
      memcpy(a1, v4, v36 - v4);
      *((_BYTE *)a1 + v8) = 0;
    }
  }
  v30 = 7;
  v11 = (int (__fastcall *)(HANDLE, wchar_t **))qword_14610A9F0;
  if ( qword_14610A9F0 )
  {
    CurrentThread = GetCurrentThread();
    if ( v11(CurrentThread, &String) >= 0 )
    {
      v13 = isalnum(*String);
      v14 = String;
      if ( v13 || *String == 91 )
      {
        v15 = (unsigned __int16 *)wcslen(String);
        v31[0] = String;
        v31[1] = v15;
        v18 = (unsigned __int16 *)sub_1461A2B60((__int64)&Block, v31, v16, v17);
        if ( a1 != v18 )
        {
          v19 = *((_QWORD *)a1 + 3);
          if ( v19 > 0xF )
          {
            v20 = *(unsigned __int16 **)a1;
            if ( v19 + 1 >= 0x1000 )
            {
              if ( (unsigned __int64)v20 - *((_QWORD *)v20 - 1) - 8 > 0x1F )
                goto LABEL_26;
              v20 = (unsigned __int16 *)*((_QWORD *)v20 - 1);
            }
            j_j_free(v20);
          }
          *((_QWORD *)a1 + 2) = 0i64;
          *((_QWORD *)a1 + 3) = 15i64;
          *(_BYTE *)a1 = 0;
          *(_OWORD *)a1 = *(_OWORD *)v18;
          *((_OWORD *)a1 + 1) = *((_OWORD *)v18 + 1);
          *((_QWORD *)v18 + 2) = 0i64;
          *((_QWORD *)v18 + 3) = 15i64;
          *(_BYTE *)v18 = 0;
        }
        if ( v35 > 0xF )
        {
          v21 = Block;
          if ( v35 + 1 >= 0x1000 )
          {
            v21 = (_BYTE *)*((_QWORD *)Block - 1);
            if ( (unsigned __int64)((_BYTE *)Block - v21 - 8) > 0x1F )
LABEL_26:
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v21);
        }
        v14 = String;
      }
      LocalFree(v14);
    }
  }
  if ( *((_QWORD *)a1 + 2) > 0x14ui64 )
  {
    v32 = 0i64;
    v22 = a1;
    if ( *((_QWORD *)a1 + 3) > 0xFui64 )
      v22 = *(unsigned __int16 **)a1;
    v23 = sub_14615A5E0(0x20ui64);
    *(_QWORD *)&v32 = v23;
    si128 = _mm_load_si128((const __m128i *)&xmmword_14611ECD0);
    v33 = si128;
    *(_OWORD *)v23 = *(_OWORD *)v22;
    *((_DWORD *)v23 + 4) = *((_DWORD *)v22 + 4);
    *((_BYTE *)v23 + 20) = 0;
    if ( a1 == (unsigned __int16 *)&v32 )
    {
      v7 = v33.m128i_u64[1];
    }
    else
    {
      v25 = *((_QWORD *)a1 + 3);
      if ( v25 > 0xF )
      {
        v26 = *(unsigned __int16 **)a1;
        if ( v25 + 1 >= 0x1000 )
        {
          if ( (unsigned __int64)v26 - *((_QWORD *)v26 - 1) - 8 > 0x1F )
            goto LABEL_44;
          v26 = (unsigned __int16 *)*((_QWORD *)v26 - 1);
        }
        j_j_free(v26);
      }
      *(_BYTE *)a1 = 0;
      *(_OWORD *)a1 = v32;
      *((__m128i *)a1 + 1) = si128;
      LOBYTE(v32) = 0;
      v23 = (_QWORD *)v32;
    }
    if ( v7 > 0xF )
    {
      v27 = (char *)v23;
      if ( v7 + 1 >= 0x1000 )
      {
        v23 = (_QWORD *)*(v23 - 1);
        if ( (unsigned __int64)(v27 - (char *)v23 - 8) > 0x1F )
LABEL_44:
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v23);
    }
  }
  return a1;
}
// 146172C93: variable 'v16' is possibly undefined
// 146172C93: variable 'v17' is possibly undefined
// 146172E77: variable 'v3' is possibly undefined
// 14610A9F0: using guessed type __int64 qword_14610A9F0;
// 14611ECD0: using guessed type __int128 xmmword_14611ECD0;
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146172E80) ----------------------------------------------------
void sub_146172E80()
{
  __int64 v0; // r9
  __int64 v1; // r8
  __int64 v2; // r9
  __int64 v3; // rax
  void *v4; // rcx
  char *v5; // rcx
  void *v6; // rcx
  _BYTE v7[24]; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v8; // [rsp+60h] [rbp-A8h]
  __int128 pExceptionObject[2]; // [rsp+68h] [rbp-A0h] BYREF
  __int64 v10; // [rsp+88h] [rbp-80h]
  const char *v11; // [rsp+90h] [rbp-78h] BYREF
  __int64 *(__fastcall *v12)(const struct tm *, __int64, __int64 *); // [rsp+98h] [rbp-70h]
  void *Block[2]; // [rsp+A0h] [rbp-68h] BYREF
  __m128i si128; // [rsp+B0h] [rbp-58h]
  __time64_t Time; // [rsp+C0h] [rbp-48h] BYREF
  struct tm Tm; // [rsp+C8h] [rbp-40h] BYREF
  struct tm v17; // [rsp+F0h] [rbp-18h] BYREF

  v10 = -2i64;
  sub_1461A1A40(-1, "MainThrd");
  if ( !OpenMutexW(0x100000u, 0, L"CitizenFX_LogMutex_Mod") )
  {
    CreateMutexW(0i64, 1, L"CitizenFX_LogMutex_Mod");
    memset(v7, 0, sizeof(v7));
    v8 = 0i64;
    sub_146168F30(v7, L"logs/", 5ui64, v0);
    v3 = sub_1461645B0((__int64)Block, (void **)v7, v1, v2);
    if ( *(_QWORD *)(v3 + 24) > 7ui64 )
      v3 = *(_QWORD *)v3;
    CreateDirectoryW((LPCWSTR)v3, 0i64);
    if ( si128.m128i_i64[1] > 7ui64 )
    {
      v4 = Block[0];
      if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
      {
        v4 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)(Block[0] - v4 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v4);
    }
    si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
    LOWORD(Block[0]) = 0;
    Time = time64(0i64);
    if ( gmtime64_s(&Tm, &Time) )
    {
      *(_QWORD *)v7 = &std::exception::`vftable';
      *(_OWORD *)&v7[8] = 0i64;
      v11 = "time_t value out of range";
      LOBYTE(v12) = 1;
      _std_exception_copy(&v11);
      *(_QWORD *)v7 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)pExceptionObject, (__int64)v7);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    }
    v17 = Tm;
    v11 = (const char *)&v17;
    v12 = sub_146169A80;
    *(_QWORD *)&pExceptionObject[0] = 15i64;
    *((_QWORD *)&pExceptionObject[0] + 1) = &v11;
    *(_QWORD *)v7 = "--- BEGIN LOGGING AT {:%c} ---\n";
    *(_QWORD *)&v7[8] = 31i64;
    sub_1461A09D0(Block, (__int128 *)v7, pExceptionObject);
    v5 = (char *)Block;
    if ( si128.m128i_i64[1] > 0xFui64 )
      v5 = (char *)Block[0];
    AsyncTrace(v5);
    if ( si128.m128i_i64[1] > 0xFui64 )
    {
      v6 = Block[0];
      if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
      {
        v6 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)(Block[0] - v6 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v6);
    }
  }
}
// 146172F15: variable 'v0' is possibly undefined
// 146172F23: variable 'v1' is possibly undefined
// 146172F23: variable 'v2' is possibly undefined
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 14611E9D8: using guessed type wchar_t aLogs[6];
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146173110) ----------------------------------------------------
void __fastcall sub_146173110(__int64 a1)
{
  char *v1; // rbx
  int v2; // r13d
  _DWORD *v3; // rsi
  __int64 v4; // rdx
  char *v5; // rax
  char v6; // cl
  __int64 v7; // rbx
  __int64 v8; // rdi
  unsigned __int64 v9; // r14
  const wchar_t *v10; // rcx
  FILE *v11; // r15
  __int64 *v12; // r8
  __int64 v13; // r12
  __int64 v14; // r14
  _QWORD *v15; // rsi
  __int64 v16; // rdi
  ULONGLONG v17; // rax
  _QWORD *v18; // rdx
  __int64 v19; // r8
  void *v20; // rcx
  _BYTE *v21; // rcx
  char *v22; // r12
  size_t v23; // r15
  unsigned __int64 v24; // rsi
  unsigned __int64 v25; // rcx
  unsigned __int64 v26; // rdx
  size_t v27; // r14
  _QWORD *v28; // r12
  _QWORD *v29; // rcx
  _QWORD *v30; // rax
  _QWORD *v31; // rdi
  void *v32; // rax
  _QWORD *v33; // rbx
  char *v34; // rax
  __int64 v35; // r8
  __int64 v36; // r9
  void *v37; // rcx
  void *v38; // rax
  __int64 v39; // rdi
  void **v40; // rcx
  __int64 v41; // r8
  __int64 v42; // r9
  __int64 v43; // r8
  __int64 v44; // r9
  void *v45; // rcx
  __int64 v46; // [rsp+38h] [rbp-D0h] BYREF
  char *v47; // [rsp+40h] [rbp-C8h]
  __int64 v48; // [rsp+48h] [rbp-C0h]
  char *v49; // [rsp+50h] [rbp-B8h]
  __int128 v50; // [rsp+58h] [rbp-B0h] BYREF
  _DWORD *v51; // [rsp+68h] [rbp-A0h]
  void *v52; // [rsp+70h] [rbp-98h]
  __int128 v53; // [rsp+78h] [rbp-90h] BYREF
  __int128 v54; // [rsp+88h] [rbp-80h] BYREF
  __int128 v55; // [rsp+98h] [rbp-70h] BYREF
  __int128 v56; // [rsp+A8h] [rbp-60h] BYREF
  __int128 v57; // [rsp+B8h] [rbp-50h] BYREF
  __int128 v58; // [rsp+C8h] [rbp-40h]
  __int64 v59; // [rsp+D8h] [rbp-30h]
  __int128 v60; // [rsp+E0h] [rbp-28h]
  __int128 v61; // [rsp+F0h] [rbp-18h]
  __int128 v62; // [rsp+100h] [rbp-8h]
  __int128 v63; // [rsp+110h] [rbp+8h]
  __int64 v64[3]; // [rsp+120h] [rbp+18h] BYREF
  unsigned __int64 v65; // [rsp+138h] [rbp+30h]
  __int128 v66; // [rsp+148h] [rbp+40h] BYREF
  __int128 v67; // [rsp+158h] [rbp+50h]
  void *v68[2]; // [rsp+168h] [rbp+60h]
  __int128 v69; // [rsp+178h] [rbp+70h]
  __int128 v70; // [rsp+188h] [rbp+80h]
  __int128 v71; // [rsp+198h] [rbp+90h]
  __int64 v72[2]; // [rsp+1A8h] [rbp+A0h] BYREF
  void **v73; // [rsp+1B8h] [rbp+B0h] BYREF
  void *Buffer; // [rsp+1C0h] [rbp+B8h]
  size_t ElementCount; // [rsp+1C8h] [rbp+C0h]
  unsigned __int64 v76; // [rsp+1D0h] [rbp+C8h]
  char v77[72]; // [rsp+1D8h] [rbp+D0h] BYREF

  v59 = -2i64;
  v1 = (char *)a1;
  v49 = (char *)a1;
  v2 = 0;
  LODWORD(v48) = 0;
  v3 = (_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 380i64);
  v51 = v3;
  if ( dword_14610AA10 > *v3 )
  {
    sub_1461A7CF4(&dword_14610AA10);
    if ( dword_14610AA10 == -1 )
    {
      v30 = operator new(0x18ui64);
      v31 = v30;
      v47 = (char *)v30;
      if ( v30 )
      {
        *v30 = 0i64;
        v30[1] = 0i64;
        v30[2] = 0i64;
        v32 = operator new(0x2027ui64);
        if ( !v32 )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        v33 = (_QWORD *)(((unsigned __int64)v32 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
        *(v33 - 1) = v32;
        *v31 = v33;
        v31[2] = v33 + 1024;
        memset(v33, 0, 0x2000ui64);
        v31[1] = v33 + 1024;
        v1 = v49;
      }
      else
      {
        v31 = 0i64;
      }
      qword_14610AA08 = (__int64)v31;
      Init_thread_footer(&dword_14610AA10);
    }
  }
  if ( dword_14610AA40 > *v3 )
  {
    sub_1461A7CF4(&dword_14610AA40);
    if ( dword_14610AA40 == -1 )
    {
      sub_146171CE0((__int64)&v46, (__int64)&qword_14610AA28);
      Init_thread_footer(&dword_14610AA40);
    }
  }
  if ( dword_14610AA50 > *v3 )
  {
    sub_1461A7CF4(&dword_14610AA50);
    if ( dword_14610AA50 == -1 )
    {
      v34 = (char *)operator new(0x20ui64);
      v47 = v34;
      if ( v34 )
        v34 = (char *)sub_146172940(v34);
      qword_14610AA48 = (__int64)v34;
      Init_thread_footer(&dword_14610AA50);
    }
  }
  AcquireSRWLockExclusive(&stru_14610AA20);
  v5 = v1;
  v47 = v1;
  if ( *((_QWORD *)v1 + 3) > 0xFui64 )
  {
    v5 = *(char **)v1;
    v47 = *(char **)v1;
  }
  v6 = *v5;
  if ( *v5 )
  {
    v7 = *((_QWORD *)&v58 + 1);
    v8 = qword_14610AA08;
    v9 = qword_14610AA18;
    while ( 1 )
    {
      if ( v6 == 10 )
      {
        if ( dword_14610AA78 > *v3 )
        {
          sub_1461A7CF4(&dword_14610AA78);
          if ( dword_14610AA78 == -1 )
          {
            LODWORD(v60) = (unsigned __int16)word_14610AA32;
            LODWORD(v61) = (unsigned __int16)word_14610AA36;
            LODWORD(v62) = (unsigned __int16)word_14610AA38;
            LODWORD(v63) = (unsigned __int16)word_14610AA3A;
            LODWORD(v58) = (unsigned __int16)word_14610AA3C;
            LODWORD(v66) = (unsigned __int16)word_14610AA30;
            *(_QWORD *)((char *)&v66 + 4) = *(_QWORD *)((char *)&v50 + 4);
            HIDWORD(v66) = HIDWORD(v50);
            v67 = v60;
            *(_OWORD *)v68 = v61;
            v69 = v62;
            v70 = v63;
            v71 = v58;
            *(_QWORD *)&v54 = L"%04d-%02d-%02dT%02d%02d%02d";
            *((_QWORD *)&v54 + 1) = 27i64;
            *(_QWORD *)&v53 = 2236962i64;
            *((_QWORD *)&v53 + 1) = &v66;
            sub_14616BE70(v64, &v54, &v53);
            v2 |= 2u;
            sub_146170F20((__int64)&qword_14610AA58, (__int64)v64, v35, v36);
            if ( v65 > 7 )
            {
              v37 = (void *)v64[0];
              if ( 2 * v65 + 2 >= 0x1000 )
              {
                v37 = *(void **)(v64[0] - 8);
                if ( (unsigned __int64)(v64[0] - (_QWORD)v37 - 8) > 0x1F )
                  invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
              }
              j_j_free(v37);
            }
            atexit(sub_1461AE4F0);
            Init_thread_footer(&dword_14610AA78);
          }
        }
        if ( dword_14610A9DC > *v3 )
        {
          sub_1461A7CF4(&dword_14610A9DC);
          if ( dword_14610A9DC == -1 )
          {
            v38 = operator new(0x20ui64);
            v39 = (__int64)v38;
            v52 = v38;
            if ( v38 )
            {
              v40 = &qword_14610AA58;
              if ( *((_QWORD *)&xmmword_14610AA68 + 1) > 7ui64 )
                v40 = (void **)qword_14610AA58;
              v72[0] = (__int64)v40;
              v72[1] = xmmword_14610AA68;
              *(_QWORD *)&v56 = L"logs/CitizenFX_log_%s.log";
              *((_QWORD *)&v56 + 1) = 25i64;
              *(_QWORD *)&v55 = 13i64;
              *((_QWORD *)&v55 + 1) = v72;
              sub_14616BE70(v64, &v56, &v55);
              v2 |= 5u;
              LODWORD(v48) = v2;
              sub_146170F20((__int64)&v66, (__int64)v64, v41, v42);
              v38 = (void *)sub_1461645B0(v39, (void **)&v66, v43, v44);
            }
            qword_14610AA80 = (__int64)v38;
            if ( (v2 & 1) != 0 )
            {
              v2 &= ~1u;
              if ( v65 > 7 )
              {
                v45 = (void *)v64[0];
                if ( 2 * v65 + 2 >= 0x1000 )
                {
                  v45 = *(void **)(v64[0] - 8);
                  if ( (unsigned __int64)(v64[0] - (_QWORD)v45 - 8) > 0x1F )
                    invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
                }
                j_j_free(v45);
              }
            }
            Init_thread_footer(&dword_14610A9DC);
          }
        }
        v10 = (const wchar_t *)qword_14610AA80;
        if ( *(_QWORD *)(qword_14610AA80 + 24) > 7ui64 )
          v10 = *(const wchar_t **)qword_14610AA80;
        v11 = wfopen(v10, L"ab");
        if ( v11 )
        {
          v12 = (__int64 *)qword_14610AA08;
          *(_BYTE *)(qword_14610AA18 + *(_QWORD *)qword_14610AA08) = 0;
          v13 = *v12;
          v14 = (__int64)v49;
          v15 = (_QWORD *)qword_14610AA48;
          v16 = qword_14610AA28;
          v17 = GetTickCount64() - v16;
          v18 = v15;
          if ( v15[3] > 0xFui64 )
            v18 = (_QWORD *)*v15;
          v19 = v15[2];
          v20 = (void *)(v14 + 32);
          if ( *(_QWORD *)(v14 + 56) > 0xFui64 )
            v20 = *(void **)(v14 + 32);
          *(_QWORD *)&v66 = v17;
          *((_QWORD *)&v66 + 1) = v7;
          *(_QWORD *)&v67 = v18;
          *((_QWORD *)&v67 + 1) = v19;
          v68[0] = v20;
          v68[1] = *(void **)(v14 + 48);
          *(_QWORD *)&v69 = v13;
          *((_QWORD *)&v69 + 1) = v52;
          ElementCount = 0i64;
          v73 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
          Buffer = v77;
          v76 = 500i64;
          *(_QWORD *)&v57 = 52692i64;
          *((_QWORD *)&v57 + 1) = &v66;
          *(_QWORD *)&v50 = "[%10lld] [%14s] %20s/ %s\r\n";
          *((_QWORD *)&v50 + 1) = 26i64;
          sub_14615CF80((__int64)&v73, (__int64)&v50, &v57);
          fwrite(Buffer, 1ui64, ElementCount, v11);
          v73 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
          v21 = Buffer;
          if ( Buffer != v77 )
          {
            if ( v76 >= 0x1000 )
            {
              v21 = (_BYTE *)*((_QWORD *)Buffer - 1);
              if ( (unsigned __int64)((_BYTE *)Buffer - v21 - 8) > 0x1F )
                invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
            }
            j_j_free(v21);
          }
          fclose(v11);
        }
        v9 = 0i64;
        qword_14610AA18 = 0i64;
        v8 = qword_14610AA08;
      }
      else
      {
        *(_BYTE *)(v9 + *(_QWORD *)v8) = v6;
        qword_14610AA18 = ++v9;
        v22 = *(char **)v8;
        v23 = *(_QWORD *)(v8 + 8) - *(_QWORD *)v8;
        if ( v9 >= v23 - 1 )
        {
          v24 = 2 * v23;
          if ( 2 * v23 >= v23 )
          {
            if ( 2 * v23 > v23 )
            {
              v25 = *(_QWORD *)(v8 + 16) - (_QWORD)v22;
              if ( v24 <= v25 )
              {
                memset(*(void **)(v8 + 8), 0, *(_QWORD *)(v8 + 8) - *(_QWORD *)v8);
                *(_QWORD *)(v8 + 8) = &v22[v24];
              }
              else
              {
                if ( v24 > 0x7FFFFFFFFFFFFFFFi64 )
                  unknown_libname_6(v25, v4, 0x7FFFFFFFFFFFFFFFi64);
                v26 = v25 >> 1;
                if ( v25 <= 0x7FFFFFFFFFFFFFFFi64 - (v25 >> 1) )
                {
                  v27 = v26 + v25;
                  if ( v26 + v25 < v24 )
                    v27 = 2 * v23;
                }
                else
                {
                  v27 = 0x7FFFFFFFFFFFFFFFi64;
                }
                v28 = sub_14615A5E0(v27);
                memset((char *)v28 + v23, 0, v23);
                memmove(v28, *(const void **)v8, *(_QWORD *)(v8 + 8) - *(_QWORD *)v8);
                v29 = *(_QWORD **)v8;
                if ( *(_QWORD *)v8 )
                {
                  if ( *(_QWORD *)(v8 + 16) - (_QWORD)v29 >= 0x1000ui64 )
                  {
                    if ( (unsigned __int64)v29 - *(v29 - 1) - 8 > 0x1F )
                      invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
                    v29 = (_QWORD *)*(v29 - 1);
                  }
                  j_j_free(v29);
                }
                *(_QWORD *)v8 = v28;
                *(_QWORD *)(v8 + 8) = (char *)v28 + v24;
                *(_QWORD *)(v8 + 16) = (char *)v28 + v27;
                v8 = qword_14610AA08;
                v9 = qword_14610AA18;
              }
            }
          }
          else
          {
            *(_QWORD *)(v8 + 8) = &v22[v24];
          }
        }
      }
      v6 = *++v47;
      if ( !*v47 )
        break;
      v3 = v51;
    }
  }
  ReleaseSRWLockExclusive(&stru_14610AA20);
}
// 1461735AB: variable 'v4' is possibly undefined
// 1461737D1: variable 'v35' is possibly undefined
// 1461737D1: variable 'v36' is possibly undefined
// 1461738DA: variable 'v41' is possibly undefined
// 1461738DA: variable 'v42' is possibly undefined
// 1461738E6: variable 'v43' is possibly undefined
// 1461738E6: variable 'v44' is possibly undefined
// 14610A9DC: using guessed type int dword_14610A9DC;
// 14610AA08: using guessed type __int64 qword_14610AA08;
// 14610AA10: using guessed type int dword_14610AA10;
// 14610AA18: using guessed type __int64 qword_14610AA18;
// 14610AA28: using guessed type __int64 qword_14610AA28;
// 14610AA30: using guessed type __int16 word_14610AA30;
// 14610AA32: using guessed type __int16 word_14610AA32;
// 14610AA36: using guessed type __int16 word_14610AA36;
// 14610AA38: using guessed type __int16 word_14610AA38;
// 14610AA3A: using guessed type __int16 word_14610AA3A;
// 14610AA3C: using guessed type __int16 word_14610AA3C;
// 14610AA40: using guessed type int dword_14610AA40;
// 14610AA48: using guessed type __int64 qword_14610AA48;
// 14610AA50: using guessed type int dword_14610AA50;
// 14610AA68: using guessed type __int128 xmmword_14610AA68;
// 14610AA78: using guessed type int dword_14610AA78;
// 14610AA80: using guessed type __int64 qword_14610AA80;
// 14611AE78: using guessed type int TlsIndex;
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
// 14611E160: using guessed type wchar_t a04d02d02dt02d0[28];
// 14611E198: using guessed type wchar_t aLogsCitizenfxL[26];
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);

//----- (0000000146173950) ----------------------------------------------------
void __fastcall sub_146173950(__int64 a1, void *a2, __int64 a3)
{
  void *v3; // rax

  v3 = a2;
  if ( (unsigned __int64)(a3 + 1) >= 0x1000 )
  {
    if ( (unsigned __int64)a2 - *((_QWORD *)a2 - 1) - 8 > 0x1F )
      invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    v3 = (void *)*((_QWORD *)a2 - 1);
  }
  j_j_free(v3);
}

//----- (00000001461739D0) ----------------------------------------------------
signed __int64 __fastcall sub_1461739D0(__int64 a1, signed __int64 a2)
{
  signed __int64 result; // rax
  signed __int64 v3; // r8
  bool v4; // zf

  result = (unsigned int)_InterlockedExchangeAdd((volatile signed __int32 *)(a2 + 2096), 0x80000000);
  if ( !(_DWORD)result )
  {
    v3 = *(_QWORD *)(a1 + 40);
    do
    {
      *(_QWORD *)(a2 + 2104) = v3;
      *(_DWORD *)(a2 + 2096) = 1;
      result = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 40), a2, v3);
      v4 = v3 == result;
      v3 = result;
      if ( v4 )
        break;
      result = (unsigned int)_InterlockedExchangeAdd((volatile signed __int32 *)(a2 + 2096), 0x7FFFFFFFu);
    }
    while ( (_DWORD)result == 1 );
  }
  return result;
}

//----- (0000000146173A20) ----------------------------------------------------
__int64 __fastcall sub_146173A20(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rbx
  unsigned __int64 v3; // rsi
  __int64 v4; // rdi
  __int64 v5; // rbp
  __int64 v6; // rdi

  v2 = *(_QWORD **)(a1 + 96);
  v3 = a2 & 0xFFFFFFFFFFFFFFE0ui64;
  v4 = v2[1];
  v5 = **(_QWORD **)(v2[3] + 8 * v4);
  if ( v5 == 1 )
    sub_1461A1C30(
      (wchar_t *)L"tailBase != INVALID_BLOCK_BASE",
      (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\vendor\\concurrentqueue\\concurrentqueue.h",
      2942);
  v6 = 8 * ((*v2 - 1i64) & (v4 + ((v3 - v5) >> 5)));
  if ( **(_QWORD **)(v6 + v2[3]) != v3 || !*(_QWORD *)(*(_QWORD *)(v2[3] + v6) + 8i64) )
    sub_1461A1C30(
      (wchar_t *)L"localBlockIndex->index[idx]->key.load(std::memory_order_relaxed) == index && localBlockIndex->index[idx"
                  "]->value.load(std::memory_order_relaxed) != nullptr",
      (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\vendor\\concurrentqueue\\concurrentqueue.h",
      2947);
  return *(_QWORD *)(v6 + v2[3]);
}

//----- (0000000146173AF0) ----------------------------------------------------
signed __int64 __fastcall sub_146173AF0(__int64 a1)
{
  DWORD CurrentThreadId; // eax
  _QWORD *v3; // rdi
  signed __int32 v4; // r15d
  unsigned __int64 v5; // rbp
  _QWORD *v6; // r9
  unsigned __int64 i; // rax
  __int64 v8; // rax
  int v9; // r8d
  unsigned __int64 v10; // r14
  unsigned __int64 j; // rbx
  _QWORD *v12; // rax
  _QWORD *v13; // r8
  __int64 v14; // rcx
  __int64 v15; // rax
  signed __int64 result; // rax
  signed __int64 v17; // rbx
  __int64 v18; // rax
  char v19; // r14
  _QWORD *v20; // rax
  signed __int64 v21; // rax
  signed __int64 v22; // rcx
  signed __int64 v23; // rtt
  __int64 v24; // rbp
  __int64 v25; // rdx
  __int64 v26; // r8
  __int64 v27; // rbp
  __int64 v28; // rdx

  CurrentThreadId = GetCurrentThreadId();
  v3 = *(_QWORD **)(a1 + 48);
  v4 = CurrentThreadId;
  v5 = (-1028477387
      * ((-2048144789 * (CurrentThreadId ^ HIWORD(CurrentThreadId))) ^ ((-2048144789
                                                                       * (CurrentThreadId ^ HIWORD(CurrentThreadId))) >> 13))) ^ ((unsigned __int64)(-1028477387 * ((-2048144789 * (CurrentThreadId ^ HIWORD(CurrentThreadId))) ^ ((-2048144789 * (CurrentThreadId ^ HIWORD(CurrentThreadId))) >> 13))) >> 16);
  if ( v3 )
  {
    v6 = *(_QWORD **)(a1 + 48);
    while ( 2 )
    {
      for ( i = v5; ; i = v8 + 1 )
      {
        v8 = (*v6 - 1i64) & i;
        v9 = *(_DWORD *)(v6[1] + 16 * v8);
        if ( v9 == v4 )
        {
          v26 = *(_QWORD *)(v6[1] + 16 * v8 + 8);
          if ( v6 != v3 )
          {
            while ( 1 )
            {
              v27 = (*v3 - 1i64) & v5;
              v28 = 16 * v27;
              if ( !*(_DWORD *)(16 * v27 + v3[1])
                && !_InterlockedCompareExchange((volatile signed __int32 *)(v3[1] + v28), v4, 0) )
              {
                break;
              }
              v5 = v27 + 1;
            }
            *(_QWORD *)(v28 + v3[1] + 8) = v26;
          }
          return v26;
        }
        if ( !v9 )
          break;
      }
      v6 = (_QWORD *)v6[2];
      if ( v6 )
        continue;
      break;
    }
  }
  else
  {
    sub_1461A1C30(
      (wchar_t *)L"mainHash != nullptr",
      (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\vendor\\concurrentqueue\\concurrentqueue.h",
      3396);
  }
  v10 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 56));
  while ( 1 )
  {
    if ( v10 >= *v3 >> 1 && !_InterlockedExchange((volatile __int32 *)(a1 + 600), 1) )
    {
      v3 = *(_QWORD **)(a1 + 48);
      if ( v10 >= *v3 >> 1 )
      {
        for ( j = 2i64 * *v3; v10 >= j >> 1; j *= 2i64 )
          ;
        v12 = malloc_0(16 * j + 31);
        v13 = v12;
        if ( !v12 )
        {
          _InterlockedDecrement64((volatile signed __int64 *)(a1 + 56));
          *(_DWORD *)(a1 + 600) = 0;
          return 0i64;
        }
        *v12 = j;
        v12[1] = (char *)v12 + (-((_DWORD)v12 + 24) & 7) + 24;
        if ( j )
        {
          v14 = 0i64;
          do
          {
            v15 = v13[1];
            v14 += 16i64;
            *(_DWORD *)(v14 + v15 - 16) = 0;
            *(_QWORD *)(v14 + v15 - 8) = 0i64;
            *(_DWORD *)(v14 + v13[1] - 16) = 0;
            --j;
          }
          while ( j );
        }
        v13[2] = v3;
        *(_QWORD *)(a1 + 48) = v13;
        v3 = v13;
      }
      *(_DWORD *)(a1 + 600) = 0;
    }
    if ( v10 < (*v3 >> 1) + (*v3 >> 2) )
      break;
    v3 = *(_QWORD **)(a1 + 48);
  }
  v17 = *(_QWORD *)a1;
  if ( *(_QWORD *)a1 )
  {
    while ( !*(_BYTE *)(v17 + 16)
         || *(_BYTE *)(v17 + 72)
         || _InterlockedCompareExchange8((volatile signed __int8 *)(v17 + 16), 0, 1) != 1 )
    {
      v18 = *(_QWORD *)(v17 + 8);
      v17 = v18 - 8;
      if ( !v18 )
        v17 = 0i64;
      if ( !v17 )
        goto LABEL_33;
    }
    v19 = 1;
  }
  else
  {
LABEL_33:
    v19 = 0;
    v20 = malloc_0(0x68ui64);
    v17 = (signed __int64)v20;
    if ( v20 )
    {
      v20[1] = 0i64;
      *((_BYTE *)v20 + 16) = 0;
      v20[3] = 0i64;
      v20[4] = 0i64;
      v20[5] = 0i64;
      v20[6] = 0i64;
      v20[7] = 0i64;
      v20[8] = 0i64;
      *((_BYTE *)v20 + 72) = 0;
      v20[10] = a1;
      *v20 = &moodycamel::ConcurrentQueue<std::tuple<std::string,std::string>,moodycamel::ConcurrentQueueDefaultTraits>::ImplicitProducer::`vftable';
      v20[11] = 32i64;
      v20[12] = 0i64;
      sub_146173E70((__int64)v20);
      _InterlockedIncrement((volatile signed __int32 *)(a1 + 8));
      v21 = *(_QWORD *)a1;
      do
      {
        v22 = v21 + 8;
        if ( !v21 )
          v22 = 0i64;
        *(_QWORD *)(v17 + 8) = v22;
        v23 = v21;
        v21 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v17, v21);
      }
      while ( v23 != v21 );
    }
    else
    {
      v17 = 0i64;
    }
  }
  if ( !v17 )
  {
    _InterlockedDecrement64((volatile signed __int64 *)(a1 + 56));
    return 0i64;
  }
  if ( v19 )
    _InterlockedDecrement64((volatile signed __int64 *)(a1 + 56));
  while ( 1 )
  {
    v24 = (*v3 - 1i64) & v5;
    v25 = 16 * v24;
    if ( !*(_DWORD *)(16 * v24 + v3[1]) && !_InterlockedCompareExchange((volatile signed __int32 *)(v3[1] + v25), v4, 0) )
      break;
    v5 = v24 + 1;
  }
  result = v17;
  *(_QWORD *)(v3[1] + v25 + 8) = v17;
  return result;
}
// 14611EA20: using guessed type void *moodycamel::ConcurrentQueue<std::tuple<std::string,std::string>,moodycamel::ConcurrentQueueDefaultTraits>::ImplicitProducer::`vftable';

//----- (0000000146173E70) ----------------------------------------------------
char __fastcall sub_146173E70(__int64 a1)
{
  __int64 *v1; // rsi
  __int64 v2; // rdi
  __int64 v4; // rbx
  __int64 v5; // r15
  _QWORD *v6; // rax
  _QWORD *v7; // r14
  __int64 v8; // r13
  __int64 v9; // r12
  __int64 v10; // r8
  __int64 v11; // rdx
  _QWORD *v12; // rax
  __int64 v13; // rcx

  v1 = *(__int64 **)(a1 + 96);
  v2 = 0i64;
  if ( v1 )
  {
    v5 = *v1;
    v4 = *v1;
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 88);
    v5 = 0i64;
  }
  v6 = malloc_0(8 * (*(_QWORD *)(a1 + 88) + 2 * v4) + 54);
  v7 = v6;
  if ( v6 )
  {
    v6[1] = 0i64;
    v8 = (__int64)v6 + (-((_DWORD)v6 + 40) & 7) + 40;
    v9 = v8 + 16 * v4 + (-((_DWORD)v8 + 16 * (_DWORD)v4) & 7);
    if ( v1 )
    {
      v10 = v1[1];
      v11 = v10;
      do
      {
        v11 = (v11 + 1) & (*v1 - 1);
        *(_QWORD *)(v9 + 8 * v2++) = *(_QWORD *)(v1[3] + 8 * v11);
      }
      while ( v11 != v10 );
      if ( v2 != v5 )
        sub_1461A1C30(
          (wchar_t *)L"i == prevCapacity",
          (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\vendor\\concurrentqueue\\concurrentqueue.h",
          2975);
    }
    if ( v4 )
    {
      v12 = (_QWORD *)((char *)v7 + (-((_DWORD)v7 + 40) & 7) + 40);
      v13 = v9 + 8 * v5;
      do
      {
        v13 += 8i64;
        *v12 = 0i64;
        v12[1] = 0i64;
        *v12 = 1i64;
        *(_QWORD *)(v13 - 8) = v12;
        v12 += 2;
        --v4;
      }
      while ( v4 );
    }
    v7[2] = v8;
    v7[3] = v9;
    v7[4] = v1;
    *v7 = *(_QWORD *)(a1 + 88);
    LOBYTE(v6) = 1;
    v7[1] = (v5 - 1) & (*(_QWORD *)(a1 + 88) - 1i64);
    *(_QWORD *)(a1 + 96) = v7;
    *(_QWORD *)(a1 + 88) *= 2i64;
  }
  return (char)v6;
}

//----- (0000000146173FD0) ----------------------------------------------------
__int64 *__fastcall sub_146173FD0(__int64 *a1, __int64 *a2, char a3)
{
  __int64 v3; // rax
  const char *v4; // rbx
  __int128 v7; // xmm0
  __int64 v8; // xmm1_8
  char *v9; // rax
  __int64 v10; // rdx
  char *v12[2]; // [rsp+30h] [rbp-48h] BYREF
  __int128 v13; // [rsp+40h] [rbp-38h] BYREF
  __int64 v14; // [rsp+50h] [rbp-28h]
  int v15; // [rsp+58h] [rbp-20h]

  v3 = a1[1];
  v4 = "(nil)";
  v7 = *(_OWORD *)v3;
  v8 = *(_QWORD *)(v3 + 16);
  v15 = *(_DWORD *)(v3 + 24);
  if ( a3 )
    v4 = "(null)";
  v14 = v8;
  v13 = v7;
  BYTE8(v13) = 0;
  v9 = (char *)strlen(v4);
  v10 = *a1;
  v12[0] = (char *)v4;
  v12[1] = v9;
  sub_14616E400(a2, v10, (unsigned int *)&v13, (__int64)v9, (unsigned __int64)v9, v12);
  return a2;
}

//----- (0000000146174090) ----------------------------------------------------
void __fastcall AsyncTrace(char *Str)
{
  size_t v2; // rax
  __int64 v3; // r8
  __int64 v4; // r9
  _QWORD *v5; // rax
  void *v6; // rcx
  void *v7; // rcx
  void *Block[3]; // [rsp+30h] [rbp-78h] BYREF
  unsigned __int64 v9; // [rsp+48h] [rbp-60h]
  __int128 v10; // [rsp+50h] [rbp-58h] BYREF
  __int128 v11; // [rsp+60h] [rbp-48h]
  char v12[32]; // [rsp+70h] [rbp-38h] BYREF

  sub_146172B00((unsigned __int16 *)Block);
  v11 = 0i64;
  v10 = 0i64;
  v2 = strlen(Str);
  sub_14615A650(&v10, Str, v2);
  sub_146170E60((__int64)v12, (__int64)Block, v3, v4);
  v5 = (_QWORD *)sub_146173AF0(qword_14610A9F8);
  if ( v5 )
    sub_146169370(v5, (__int64)&v10);
  sub_1461626B0((__int64)v12);
  if ( *((_QWORD *)&v11 + 1) > 0xFui64 )
  {
    v6 = (void *)v10;
    if ( (unsigned __int64)(*((_QWORD *)&v11 + 1) + 1i64) >= 0x1000 )
    {
      v6 = *(void **)(v10 - 8);
      if ( (unsigned __int64)(v10 - (_QWORD)v6 - 8) > 0x1F )
LABEL_10:
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v6);
  }
  WakeAllConditionVariable(&ConditionVariable);
  if ( v9 > 0xF )
  {
    v7 = Block[0];
    if ( v9 + 1 >= 0x1000 )
    {
      v7 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v7 - 8) > 0x1F )
        goto LABEL_10;
    }
    j_j_free(v7);
  }
}
// 1461740EB: variable 'v3' is possibly undefined
// 1461740EB: variable 'v4' is possibly undefined
// 14610A9F8: using guessed type __int64 qword_14610A9F8;

//----- (00000001461741D0) ----------------------------------------------------
__int64 __fastcall sub_1461741D0(HANDLE *a1)
{
  HANDLE v2; // rcx
  __int64 v3; // rdx
  HANDLE *v4; // rcx
  __int64 v6[2]; // [rsp+20h] [rbp-4F8h] BYREF
  CONTEXT Context; // [rsp+30h] [rbp-4E8h] BYREF

  v6[1] = -2i64;
  SuspendThread(*a1);
  Context.ContextFlags = 1048592;
  GetThreadContext(*a1, &Context);
  v6[0] = (__int64)&Context;
  v2 = a1[8];
  if ( !v2 )
  {
    std::_Xbad_function_call();
    JUMPOUT(0x1461742AEi64);
  }
  (*(void (__fastcall **)(HANDLE, __int64 *))(*(_QWORD *)v2 + 16i64))(v2, v6);
  SetThreadContext(*a1, &Context);
  ResumeThread(*a1);
  Cnd_do_broadcast_at_thread_exit();
  v4 = (HANDLE *)a1[8];
  if ( v4 )
  {
    LOBYTE(v3) = v4 != a1 + 1;
    (*((void (__fastcall **)(HANDLE *, __int64))*v4 + 4))(v4, v3);
    a1[8] = 0i64;
  }
  j_j_free(a1);
  return 0i64;
}
// 1461742A9: control flows out of bounds to 1461742AE
// 14617426E: variable 'v3' is possibly undefined

//----- (00000001461742B0) ----------------------------------------------------
__int64 __fastcall sub_1461742B0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rcx
  __int64 result; // rax

  v2 = a1 + 8;
  v3 = *(_QWORD *)(a1 + 64);
  if ( v3 )
  {
    LOBYTE(a2) = v3 != v2;
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 32i64))(v3, a2);
    *(_QWORD *)(v2 + 56) = 0i64;
  }
  return result;
}

//----- (00000001461742E0) ----------------------------------------------------
__int64 __fastcall sub_1461742E0(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 result; // rax

  v3 = *(_QWORD *)(a1 + 56);
  if ( v3 )
  {
    LOBYTE(a2) = v3 != a1;
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 32i64))(v3, a2);
    *(_QWORD *)(a1 + 56) = 0i64;
  }
  return result;
}

//----- (0000000146174320) ----------------------------------------------------
void __fastcall sub_146174320(_QWORD **a1, __int64 a2)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rcx

  v2 = *a1;
  if ( *a1 )
  {
    v3 = (_QWORD *)v2[8];
    if ( v3 )
    {
      LOBYTE(a2) = v3 != v2 + 1;
      (*(void (__fastcall **)(_QWORD *, __int64))(*v3 + 32i64))(v3, a2);
      v2[8] = 0i64;
    }
    j_j_free(v2);
  }
}

//----- (0000000146174370) ----------------------------------------------------
void __fastcall sub_146174370(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 8) )
  {
    terminate();
    JUMPOUT(0x146174384i64);
  }
}
// 14617437F: control flows out of bounds to 146174384
// 1461A8FE2: using guessed type __int64 terminate(void);

//----- (0000000146174390) ----------------------------------------------------
int __fastcall sub_146174390(__int64 a1, const wchar_t *a2)
{
  size_t v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned __int64 v9; // rdi
  size_t v10; // rsi
  __int64 v11; // rbx
  wchar_t **v12; // rbp
  __int64 v13; // rbx
  __int64 v14; // rdx
  __int64 v15; // rcx
  wchar_t *v16; // rax
  wchar_t *v17; // r14
  __int64 v19[13]; // [rsp+20h] [rbp-68h] BYREF

  qword_14610AAB0 = a1;
  v4 = wcslen(a2);
  v9 = *((_QWORD *)&xmmword_1461090D8 + 1);
  v10 = v4;
  if ( v4 > *((_QWORD *)&xmmword_1461090D8 + 1) )
  {
    v13 = 0x7FFFFFFFFFFFFFFEi64;
    if ( v4 > 0x7FFFFFFFFFFFFFFEi64 )
      unknown_libname_4(v6, v5, v7, v8);
    if ( (v4 | 7) > 0x7FFFFFFFFFFFFFFEi64
      || (v14 = *((_QWORD *)&xmmword_1461090D8 + 1) >> 1,
          *((_QWORD *)&xmmword_1461090D8 + 1) > (unsigned __int64)(0x7FFFFFFFFFFFFFFEi64
                                                                 - (*((_QWORD *)&xmmword_1461090D8 + 1) >> 1))) )
    {
      v15 = 0x7FFFFFFFFFFFFFFFi64;
    }
    else
    {
      v13 = v4 | 7;
      if ( (v4 | 7) < *((_QWORD *)&xmmword_1461090D8 + 1) + v14 )
        v13 = *((_QWORD *)&xmmword_1461090D8 + 1) + v14;
      v15 = v13 + 1;
      if ( (unsigned __int64)(v13 + 1) > 0x7FFFFFFFFFFFFFFFi64 )
        sub_146165390(v15, v14, v7);
    }
    v16 = (wchar_t *)sub_14615A5E0(2 * v15);
    *((_QWORD *)&xmmword_1461090D8 + 1) = v13;
    *(_QWORD *)&xmmword_1461090D8 = v10;
    v17 = v16;
    memcpy(v16, a2, 2 * v10);
    v17[v10] = 0;
    if ( v9 > 7 )
      sub_1461650D0((__int64)&FileName, FileName, v9);
    FileName = v17;
  }
  else
  {
    v11 = 2 * v4;
    *(_QWORD *)&xmmword_1461090D8 = v4;
    v12 = &FileName;
    if ( *((_QWORD *)&xmmword_1461090D8 + 1) > 7ui64 )
      v12 = (wchar_t **)FileName;
    memmove(v12, a2, 2 * v4);
    *(_WORD *)((char *)v12 + v11) = 0;
  }
  AddVectoredExceptionHandler(1u, (PVECTORED_EXCEPTION_HANDLER)sub_146174520);
  v19[1] = a1;
  v19[0] = (__int64)&std::_Func_impl_no_alloc<_lambda_4cf28de73b92b3a2e651a2f1f6480e01_,void,_CONTEXT *>::`vftable';
  v19[7] = (__int64)v19;
  return sub_146174E40((__int64)v19, 0i64);
}
// 14617450E: variable 'v6' is possibly undefined
// 14617450E: variable 'v5' is possibly undefined
// 14617450E: variable 'v7' is possibly undefined
// 14617450E: variable 'v8' is possibly undefined
// 1461090D8: using guessed type __int128 xmmword_1461090D8;
// 14610AAB0: using guessed type __int64 qword_14610AAB0;
// 14611EFB0: using guessed type void *std::_Func_impl_no_alloc<_lambda_4cf28de73b92b3a2e651a2f1f6480e01_,void,_CONTEXT *>::`vftable';
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146174520) ----------------------------------------------------
__int64 __fastcall sub_146174520(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  PCONTEXT ContextRecord; // rdx
  __int64 v2; // rcx
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // r15
  unsigned __int64 v5; // rax
  unsigned int *v6; // rbp
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // r14
  int v10; // r12d
  __int64 v11; // rsi
  char *v12; // rdi
  __int64 v13; // rbx
  char *v14; // rbx
  size_t v15; // rax
  const wchar_t *v16; // rcx
  FILE *v17; // rax
  int v18; // r8d
  FILE *v19; // rdi
  _DWORD *v20; // rdx
  unsigned int *v21; // rbp
  unsigned int v22; // eax
  __int64 v23; // rsi
  __int64 v24; // rax
  int v25; // ebx
  unsigned __int64 v26; // rax
  char *v27; // rcx
  HANDLE CurrentProcess; // rax
  _QWORD v30[8]; // [rsp+20h] [rbp-68h] BYREF
  char Buffer; // [rsp+90h] [rbp+8h] BYREF

  if ( ExceptionInfo->ExceptionRecord->ExceptionAddress == (PVOID)qword_14610AAB0 )
  {
    ContextRecord = ExceptionInfo->ContextRecord;
    v30[0] = &std::_Func_impl_no_alloc<_lambda_0f47cb7c548717280bc83b7ce23c8970_,void,_CONTEXT *>::`vftable';
    v30[7] = v30;
    sub_146174E40((__int64)v30, ContextRecord);
    sub_146175490(0);
    v2 = qword_14611AD18;
    v3 = *(unsigned int *)(qword_14611AD18 + 0x14000003Ci64);
    v4 = v3 + 0x140000000i64;
    if ( v3 <= 0x6000000 )
      v4 += qword_14611AD18;
    v5 = *(unsigned int *)(v4 + 144);
    v6 = (unsigned int *)(v4 + *(unsigned __int16 *)(v4 + 20));
    v7 = v5 + 0x140000000i64;
    if ( v5 <= 0x6000000 )
      v7 += qword_14611AD18;
    v8 = *(unsigned int *)(v7 + 12);
    v9 = v7 + 12;
    v10 = 0;
    if ( (_DWORD)v8 )
    {
      v11 = 0i64;
      while ( 1 )
      {
        v12 = (char *)(v8 + 0x140000000i64);
        if ( v8 <= 0x6000000 )
          v12 += v2;
        v13 = v11++;
        v14 = (char *)qword_14610A990 + 32 * v13;
        if ( *((_QWORD *)v14 + 3) > 0xFui64 )
          v14 = *(char **)v14;
        v15 = strlen(v14);
        memcpy(v12, v14, v15 + 1);
        v8 = *(unsigned int *)(v9 + 20);
        v9 += 20i64;
        if ( !(_DWORD)v8 )
          break;
        v2 = qword_14611AD18;
      }
    }
    v16 = (const wchar_t *)&FileName;
    if ( *((_QWORD *)&xmmword_1461090D8 + 1) > 7ui64 )
      v16 = FileName;
    v17 = wfopen(v16, L"wb");
    v18 = 0;
    v19 = v17;
    if ( *(_WORD *)(v4 + 6) )
    {
      v20 = v6 + 15;
      do
      {
        if ( (*v20 & 0x20000000) != 0 )
          *v20 |= 0x80000000;
        ++v18;
        v20 += 10;
      }
      while ( v18 < *(unsigned __int16 *)(v4 + 6) );
    }
    *(_DWORD *)(v4 + 40) += 13;
    if ( v17 )
      fwrite((const void *)(0x140000000i64 + qword_14611AD18), 1ui64, v6[11], v17);
    if ( *(_WORD *)(v4 + 6) )
    {
      v21 = v6 + 10;
      do
      {
        if ( v19 )
        {
          v22 = v21[1];
          if ( v22 )
          {
            v23 = v22;
            v24 = ftelli64(v19);
            v25 = v24;
            if ( v24 > v23 )
              sub_1461A1C30(
                (wchar_t *)L"curPos <= point",
                (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\code\\client\\launcher\\ExecutableLoader.Snapshot.cpp",
                400);
            for ( ; v25 < v23; ++v25 )
            {
              Buffer = 0;
              fwrite(&Buffer, 1ui64, 1ui64, v19);
            }
            v26 = *(v21 - 1);
            v27 = (char *)(v26 + 0x140000000i64);
            if ( v26 <= 0x6000000 )
              v27 += qword_14611AD18;
            fwrite(v27, 1ui64, *v21, v19);
          }
        }
        v21 += 10;
        ++v10;
      }
      while ( v10 < *(unsigned __int16 *)(v4 + 6) );
    }
    if ( v19 )
      fclose(v19);
    CurrentProcess = GetCurrentProcess();
    TerminateProcess(CurrentProcess, 0x1092u);
  }
  return 0i64;
}
// 1461090D8: using guessed type __int128 xmmword_1461090D8;
// 14610AAB0: using guessed type __int64 qword_14610AAB0;
// 14611AD18: using guessed type __int64 qword_14611AD18;
// 14611EF78: using guessed type void *std::_Func_impl_no_alloc<_lambda_0f47cb7c548717280bc83b7ce23c8970_,void,_CONTEXT *>::`vftable';

//----- (00000001461747F0) ----------------------------------------------------
__int64 sub_1461747F0()
{
  __int64 v0; // rcx
  __int64 result; // rax
  __int64 v2; // rdx
  __int64 v3; // r8
  __int64 v4; // r9
  __int64 v5; // rcx
  int v6; // eax
  char v7; // al

  v0 = (unsigned int)TlsIndex;
  if ( dword_14610AABC > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                   + 380i64) )
  {
    sub_1461A7CF4(&dword_14610AABC);
    if ( dword_14610AABC == -1 )
    {
      if ( !sub_1461A4660(v0, v2, v3, v4) )
        goto LABEL_18;
      v6 = dword_1461090C0;
      if ( dword_1461090C0 == -1 )
      {
        v6 = sub_1461A48B0(v5);
        dword_1461090C0 = v6;
      }
      if ( v6 == 1 )
LABEL_18:
        v7 = 0;
      else
        v7 = 1;
      byte_14610AAB8 = v7;
      Init_thread_footer(&dword_14610AABC);
    }
  }
  result = (unsigned int)dword_1461090C0;
  if ( byte_14610AAB8 )
    goto LABEL_8;
  if ( dword_1461090C0 == -1 )
  {
    result = sub_1461A48B0(v0);
    dword_1461090C0 = result;
  }
  if ( (unsigned int)result >= 0xB80 )
  {
LABEL_8:
    if ( (_DWORD)result == -1 )
    {
      result = sub_1461A48B0(v0);
      dword_1461090C0 = result;
    }
  }
  else
  {
    result = (unsigned int)dword_1461090C4;
    if ( dword_1461090C4 == -1 )
    {
      result = 2944i64;
      dword_1461090C4 = 2944;
    }
  }
  return result;
}
// 146174834: variable 'v0' is possibly undefined
// 14617489F: variable 'v2' is possibly undefined
// 14617489F: variable 'v3' is possibly undefined
// 14617489F: variable 'v4' is possibly undefined
// 1461748B3: variable 'v5' is possibly undefined
// 1461090C0: using guessed type int dword_1461090C0;
// 1461090C4: using guessed type int dword_1461090C4;
// 14610AAB8: using guessed type char byte_14610AAB8;
// 14610AABC: using guessed type int dword_14610AABC;
// 14611AE78: using guessed type int TlsIndex;
// 1461747F0: using guessed type __int64 sub_1461747F0();
// 1461A48B0: using guessed type __int64 __fastcall sub_1461A48B0(_QWORD);
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);

//----- (00000001461748D0) ----------------------------------------------------
__int64 sub_1461748D0()
{
  const wchar_t *CommandLineW; // rax
  int v2; // eax
  __int64 v3; // rcx

  if ( getenv("CitizenFX_ToolMode") )
  {
    CommandLineW = GetCommandLineW();
    if ( wcsstr(CommandLineW, L"launcher.exe") )
      return 0x14020B70Ci64;
  }
  if ( (unsigned int)sub_1461747F0() == 3407 )
    return 0x14185CFACi64;
  if ( (unsigned int)sub_1461747F0() == 3323 )
    return 0x1418492F0i64;
  if ( (unsigned int)sub_1461747F0() == 3258 )
    return 0x14183A44Ci64;
  if ( (unsigned int)sub_1461747F0() == 3095 )
    return 0x141821200i64;
  if ( (unsigned int)sub_1461747F0() == 2944 )
    return 0x14180CCF4i64;
  if ( (unsigned int)sub_1461747F0() == 2802 )
    return 0x1417E6648i64;
  if ( (unsigned int)sub_1461747F0() == 2699 )
    return 0x1417D3600i64;
  if ( (unsigned int)sub_1461747F0() == 2612 )
    return 0x1417DB78Ci64;
  if ( (unsigned int)sub_1461747F0() == 2545 )
    return 0x1417DB000i64;
  if ( (unsigned int)sub_1461747F0() == 2372 )
    return 0x1417C9104i64;
  if ( (unsigned int)sub_1461747F0() == 2189 )
    return 0x1417ACE74i64;
  v2 = sub_1461747F0();
  v3 = 0x14175DE00i64;
  if ( v2 == 2060 )
    return 0x141796A34i64;
  return v3;
}
// 1461747F0: using guessed type __int64 sub_1461747F0(void);
// 1461748D0: using guessed type __int64 sub_1461748D0();

//----- (0000000146174A70) ----------------------------------------------------
__int64 __fastcall sub_146174A70(__int64 a1, __int64 a2)
{
  __int64 v4; // r8
  __int64 v5; // r9
  void **v6; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rax
  _BYTE *v10; // rcx
  void *v11; // rcx
  const WCHAR *v12; // rcx
  __int64 v13; // rdi
  const wchar_t *v14; // rcx
  FILE *v15; // rbx
  int v16; // r14d
  unsigned int *v17; // rdi
  void *v18; // r15
  SIZE_T v19; // rsi
  unsigned __int8 v20; // bl
  WCHAR *v21; // rcx
  __int128 v23; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v24[8]; // [rsp+40h] [rbp-C0h] BYREF
  DWORD v25; // [rsp+80h] [rbp-80h] BYREF
  __int128 v26; // [rsp+88h] [rbp-78h] BYREF
  __int64 v27; // [rsp+98h] [rbp-68h]
  DWORD flOldProtect[4]; // [rsp+A0h] [rbp-60h] BYREF
  LPCWSTR lpFileName[2]; // [rsp+B0h] [rbp-50h] BYREF
  __int128 v30; // [rsp+C0h] [rbp-40h]
  void *v31[3]; // [rsp+D0h] [rbp-30h] BYREF
  unsigned __int64 v32; // [rsp+E8h] [rbp-18h]
  void **v33; // [rsp+108h] [rbp+8h]
  void *Block; // [rsp+110h] [rbp+10h] BYREF
  __m128i si128; // [rsp+120h] [rbp+20h]
  int v36[28]; // [rsp+130h] [rbp+30h] BYREF
  char Buffer[32]; // [rsp+1A0h] [rbp+A0h] BYREF
  char Buf1[32]; // [rsp+1C0h] [rbp+C0h] BYREF

  v27 = -2i64;
  LODWORD(v23) = *(_DWORD *)(a2 + 40);
  *(_OWORD *)flOldProtect = v23;
  *(_QWORD *)&v26 = L"data\\cache\\executable_snapshot_%x.bin";
  *((_QWORD *)&v26 + 1) = 37i64;
  *(_QWORD *)&v23 = 2i64;
  *((_QWORD *)&v23 + 1) = flOldProtect;
  sub_14616BE70(v31, &v26, &v23);
  v6 = (void **)sub_146170F20((__int64)v24, (__int64)v31, v4, v5);
  v9 = sub_1461645B0((__int64)&Block, v6, v7, v8);
  *(_OWORD *)lpFileName = 0i64;
  v30 = 0i64;
  *(_OWORD *)lpFileName = *(_OWORD *)v9;
  v30 = *(_OWORD *)(v9 + 16);
  *(_QWORD *)(v9 + 16) = 0i64;
  *(_QWORD *)(v9 + 24) = 7i64;
  *(_WORD *)v9 = 0;
  if ( si128.m128i_i64[1] > 7ui64 )
  {
    v10 = Block;
    if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
    {
      v10 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v10 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v10);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(Block) = 0;
  if ( v32 > 7 )
  {
    v11 = v31[0];
    if ( 2 * v32 + 2 >= 0x1000 )
    {
      v11 = (void *)*((_QWORD *)v31[0] - 1);
      if ( (unsigned __int64)(v31[0] - v11 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v11);
  }
  v12 = (const WCHAR *)lpFileName;
  if ( *((_QWORD *)&v30 + 1) > 7ui64 )
    v12 = lpFileName[0];
  if ( GetFileAttributesW(v12) == -1 )
    goto LABEL_25;
  v13 = *(unsigned __int16 *)(a2 + 20) + 40i64;
  sub_146195CE0((__int64)v36);
  v14 = (const wchar_t *)lpFileName;
  if ( *((_QWORD *)&v30 + 1) > 7ui64 )
    v14 = lpFileName[0];
  v15 = wfopen(v14, L"rb");
  *(_QWORD *)&v26 = v15;
  if ( !v15 )
    goto LABEL_22;
  v16 = 0;
  if ( *(_WORD *)(a2 + 6) )
  {
    v17 = (unsigned int *)(a2 + v13);
    while ( 1 )
    {
      v18 = (void *)(*(_QWORD *)(a1 + 8) + *(v17 - 1));
      v19 = *v17;
      VirtualProtect(v18, v19, 0x40u, flOldProtect);
      if ( fread(v18, 1ui64, (unsigned int)v19, v15) != v19 )
        break;
      sub_146195D40(v36, (char *)v18, (unsigned int)v19);
      v17 += 10;
      if ( ++v16 >= *(unsigned __int16 *)(a2 + 6) )
        goto LABEL_21;
    }
LABEL_22:
    AddVectoredExceptionHandler(1u, (PVECTORED_EXCEPTION_HANDLER)sub_146175100);
    v24[0] = (__int64)&std::_Func_impl_no_alloc<_lambda_f42722e5fe4e40ac09c541a5093d66ae_,void,_CONTEXT *>::`vftable';
    v24[7] = (__int64)v24;
    sub_146174E40((__int64)v24, 0i64);
    if ( v15 )
    {
      fclose(v15);
      v20 = 0;
      goto LABEL_28;
    }
    goto LABEL_26;
  }
LABEL_21:
  if ( fread(Buffer, 1ui64, 0x20ui64, v15) != 32 )
    goto LABEL_22;
  fclose(v15);
  sub_1461959C0(Buf1, v36);
  if ( memcmp(Buf1, Buffer, 0x20ui64) )
  {
LABEL_25:
    AddVectoredExceptionHandler(1u, (PVECTORED_EXCEPTION_HANDLER)sub_146175100);
    v31[0] = &std::_Func_impl_no_alloc<_lambda_f42722e5fe4e40ac09c541a5093d66ae_,void,_CONTEXT *>::`vftable';
    v33 = v31;
    sub_146174E40((__int64)v31, 0i64);
LABEL_26:
    v20 = 0;
    goto LABEL_28;
  }
  VirtualProtect((LPVOID)a2, 0x1000ui64, 4u, &v25);
  *(_DWORD *)(a2 + 40) = sub_1461748D0() - 0x40000000;
  v20 = 1;
LABEL_28:
  if ( *((_QWORD *)&v30 + 1) > 7ui64 )
  {
    v21 = (WCHAR *)lpFileName[0];
    if ( (unsigned __int64)(2i64 * *((_QWORD *)&v30 + 1) + 2) >= 0x1000 )
    {
      v21 = (WCHAR *)*((_QWORD *)lpFileName[0] - 1);
      if ( (unsigned __int64)((char *)lpFileName[0] - (char *)v21 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v21);
  }
  return v20;
}
// 146174B06: variable 'v4' is possibly undefined
// 146174B06: variable 'v5' is possibly undefined
// 146174B12: variable 'v7' is possibly undefined
// 146174B12: variable 'v8' is possibly undefined
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 14611EDF0: using guessed type wchar_t aDataCacheExecu[38];
// 14611EF40: using guessed type void *std::_Func_impl_no_alloc<_lambda_f42722e5fe4e40ac09c541a5093d66ae_,void,_CONTEXT *>::`vftable';
// 1461748D0: using guessed type __int64 sub_1461748D0(void);
// 146174A70: using guessed type int var_F0[28];

//----- (0000000146174E40) ----------------------------------------------------
int __fastcall sub_146174E40(__int64 a1, void *a2)
{
  DWORD CurrentThreadId; // eax
  HANDLE v5; // r15
  ULONGLONG v6; // rax
  ULONGLONG v7; // rax
  DWORDLONG v8; // rax
  __int64 (__fastcall ***v9)(_QWORD, char *); // rcx
  _QWORD *v10; // rbx
  __int64 v11; // rdx
  __int64 v12; // rdx
  __int64 v13; // rcx
  int result; // eax
  __int64 v15; // rdx
  __int64 v16; // rcx
  _Thrd_t ThrdAddr_8; // [rsp+38h] [rbp-D0h] BYREF
  _Thrd_t ThrdAddr; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v19; // [rsp+58h] [rbp-B0h]
  __int64 v20; // [rsp+60h] [rbp-A8h]
  HANDLE v21; // [rsp+68h] [rbp-A0h]
  char v22[56]; // [rsp+70h] [rbp-98h] BYREF
  char *v23; // [rsp+A8h] [rbp-60h]
  struct _OSVERSIONINFOEXW VersionInformation; // [rsp+B8h] [rbp-50h] BYREF

  v19 = -2i64;
  v20 = a1;
  CurrentThreadId = GetCurrentThreadId();
  v5 = OpenThread(0x1FFFFFu, 0, CurrentThreadId);
  VersionInformation.dwOSVersionInfoSize = 284;
  memset(&VersionInformation.dwBuildNumber, 0, 264);
  VersionInformation.wServicePackMinor = 0;
  *(_DWORD *)&VersionInformation.wSuiteMask = 0;
  v6 = VerSetConditionMask(0i64, 2u, 3u);
  v7 = VerSetConditionMask(v6, 1u, 3u);
  v8 = VerSetConditionMask(v7, 0x20u, 3u);
  VersionInformation.dwMajorVersion = 6;
  VersionInformation.dwMinorVersion = 3;
  VersionInformation.wServicePackMajor = 0;
  if ( VerifyVersionInfoW(&VersionInformation, 0x23u, v8) && a2 )
    goto LABEL_19;
  v21 = v5;
  ThrdAddr_8._Hnd = v22;
  v23 = 0i64;
  v9 = *(__int64 (__fastcall ****)(_QWORD, char *))(a1 + 56);
  if ( v9 )
    v23 = (char *)(**v9)(v9, v22);
  v10 = operator new(0x48ui64);
  if ( v10 )
  {
    *v10 = v21;
    v10[8] = 0i64;
    if ( v23 )
    {
      if ( v23 == v22 )
      {
        v10[8] = (*(__int64 (__fastcall **)(char *, _QWORD *))(*(_QWORD *)v23 + 8i64))(v23, v10 + 1);
        if ( v23 )
        {
          LOBYTE(v11) = v23 != v22;
          (*(void (__fastcall **)(char *, __int64))(*(_QWORD *)v23 + 32i64))(v23, v11);
          v23 = 0i64;
        }
      }
      else
      {
        v10[8] = v23;
        v23 = 0i64;
      }
    }
  }
  else
  {
    v10 = 0i64;
  }
  ThrdAddr_8._Hnd = v10;
  ThrdAddr._Hnd = (void *)beginthreadex(0i64, 0, (_beginthreadex_proc_type)sub_1461741D0, v10, 0, &ThrdAddr._Id);
  if ( !ThrdAddr._Hnd )
  {
LABEL_25:
    ThrdAddr._Id = 0;
    std::_Throw_Cpp_error(6);
LABEL_26:
    std::_Throw_Cpp_error(1);
    __debugbreak();
  }
  if ( !ThrdAddr._Id )
    goto LABEL_26;
  if ( ThrdAddr._Id == Thrd_id() )
  {
    std::_Throw_Cpp_error(5);
    __debugbreak();
  }
  ThrdAddr_8 = ThrdAddr;
  if ( Thrd_join(&ThrdAddr_8, 0i64) )
  {
    std::_Throw_Cpp_error(2);
    JUMPOUT(0x1461750FEi64);
  }
  ThrdAddr = 0i64;
  if ( v23 )
  {
    LOBYTE(v12) = v23 != v22;
    (*(void (__fastcall **)(char *, __int64))(*(_QWORD *)v23 + 32i64))(v23, v12);
  }
  if ( a2 )
  {
LABEL_19:
    ThrdAddr_8._Hnd = a2;
    v13 = *(_QWORD *)(a1 + 56);
    if ( v13 )
    {
      (*(void (__fastcall **)(__int64, _Thrd_t *))(*(_QWORD *)v13 + 16i64))(v13, &ThrdAddr_8);
      goto LABEL_21;
    }
    std::_Xbad_function_call();
    goto LABEL_25;
  }
LABEL_21:
  result = CloseHandle(v5);
  v16 = *(_QWORD *)(a1 + 56);
  if ( v16 )
  {
    LOBYTE(v15) = v16 != a1;
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v16 + 32i64))(v16, v15);
    *(_QWORD *)(a1 + 56) = 0i64;
  }
  return result;
}
// 1461750F9: control flows out of bounds to 1461750FE
// 146174FB5: variable 'v11' is possibly undefined
// 146175059: variable 'v12' is possibly undefined
// 146175096: variable 'v15' is possibly undefined

//----- (0000000146175100) ----------------------------------------------------
__int64 __fastcall sub_146175100(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  int v2; // esi
  __int64 v3; // rax
  PVOID v4; // rdx
  __int64 v5; // rcx
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // r12
  unsigned __int64 v8; // r13
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // r15
  unsigned int *v11; // r15
  unsigned __int64 v12; // rax
  __int64 v13; // r14
  char *v14; // rdi
  char *v15; // rbx
  size_t v16; // rax
  __int64 v17; // r8
  __int64 v18; // r9
  void **v19; // rax
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // rax
  FILE *v23; // r14
  _BYTE *v24; // rcx
  void *v25; // rcx
  unsigned int *v26; // rdi
  size_t v27; // r15
  unsigned __int64 v28; // rax
  char *v29; // rbx
  __int128 v31; // [rsp+30h] [rbp-D0h] BYREF
  __int128 v32; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v33; // [rsp+50h] [rbp-B0h]
  void *Block; // [rsp+58h] [rbp-A8h] BYREF
  __m128i si128; // [rsp+68h] [rbp-98h]
  __int128 v36; // [rsp+80h] [rbp-80h] BYREF
  void *v37[3]; // [rsp+90h] [rbp-70h] BYREF
  unsigned __int64 v38; // [rsp+A8h] [rbp-58h]
  int v39[28]; // [rsp+B0h] [rbp-50h] BYREF
  __int64 Buffer[8]; // [rsp+120h] [rbp+20h] BYREF

  v33 = -2i64;
  v2 = 0;
  v3 = sub_1461748D0();
  v4 = (PVOID)v3;
  if ( (unsigned __int64)(v3 - 0x140000000i64) <= 0x6000000 )
    v4 = (PVOID)(qword_14611AD18 + v3);
  if ( ExceptionInfo->ExceptionRecord->ExceptionAddress != v4 )
    return 0i64;
  Buffer[0] = (__int64)&std::_Func_impl_no_alloc<_lambda_b697347c6c0928237e401262969d5641_,void,_CONTEXT *>::`vftable';
  Buffer[7] = (__int64)Buffer;
  sub_146174E40((__int64)Buffer, ExceptionInfo->ContextRecord);
  sub_146175490(0);
  v5 = qword_14611AD18;
  v6 = *(unsigned int *)(qword_14611AD18 + 0x14000003Ci64);
  v7 = v6 + 0x140000000i64;
  if ( v6 <= 0x6000000 )
    v7 += qword_14611AD18;
  v8 = v7 + *(unsigned __int16 *)(v7 + 20);
  *(_QWORD *)&v31 = v8;
  v9 = *(unsigned int *)(v7 + 144);
  v10 = v9 + 0x140000000i64;
  if ( v9 <= 0x6000000 )
    v10 += qword_14611AD18;
  v11 = (unsigned int *)(v10 + 12);
  v12 = *v11;
  if ( (_DWORD)v12 )
  {
    v13 = 0i64;
    while ( 1 )
    {
      v14 = (char *)(v12 + 0x140000000i64);
      if ( v12 <= 0x6000000 )
        v14 += v5;
      v15 = (char *)qword_14610A990 + v13;
      v13 += 32i64;
      if ( *((_QWORD *)v15 + 3) > 0xFui64 )
        v15 = *(char **)v15;
      v16 = strlen(v15);
      memcpy(v14, v15, v16 + 1);
      v11 += 5;
      v12 = *v11;
      if ( !(_DWORD)v12 )
        break;
      v5 = qword_14611AD18;
    }
    v8 = v31;
  }
  LODWORD(v32) = *(_DWORD *)(v7 + 40);
  v36 = v32;
  *(_QWORD *)&v32 = L"data\\cache\\executable_snapshot_%x.bin";
  *((_QWORD *)&v32 + 1) = 37i64;
  *(_QWORD *)&v31 = 2i64;
  *((_QWORD *)&v31 + 1) = &v36;
  sub_14616BE70(v37, &v32, &v31);
  v19 = (void **)sub_146170F20((__int64)Buffer, (__int64)v37, v17, v18);
  v22 = sub_1461645B0((__int64)&Block, v19, v20, v21);
  if ( *(_QWORD *)(v22 + 24) > 7ui64 )
    v22 = *(_QWORD *)v22;
  v23 = wfopen((const wchar_t *)v22, L"wb");
  if ( si128.m128i_i64[1] > 7ui64 )
  {
    v24 = Block;
    if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
    {
      v24 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v24 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v24);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(Block) = 0;
  if ( v38 > 7 )
  {
    v25 = v37[0];
    if ( 2 * v38 + 2 >= 0x1000 )
    {
      v25 = (void *)*((_QWORD *)v37[0] - 1);
      if ( (unsigned __int64)(v37[0] - v25 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v25);
  }
  sub_146195CE0((__int64)v39);
  if ( *(_WORD *)(v7 + 6) )
  {
    v26 = (unsigned int *)(v8 + 36);
    do
    {
      v27 = v26[1];
      v28 = *v26;
      v29 = (char *)(v28 + 0x140000000i64);
      if ( v28 <= 0x6000000 )
        v29 += qword_14611AD18;
      if ( v23 )
        fwrite(v29, 1ui64, v26[1], v23);
      sub_146195D40(v39, v29, v27);
      v26 += 10;
      ++v2;
    }
    while ( v2 < *(unsigned __int16 *)(v7 + 6) );
  }
  if ( v23 )
  {
    sub_1461959C0(Buffer, v39);
    fwrite(Buffer, 1ui64, 0x20ui64, v23);
    fclose(v23);
  }
  sub_146175490(1);
  return 0xFFFFFFFFi64;
}
// 1461752B7: variable 'v17' is possibly undefined
// 1461752B7: variable 'v18' is possibly undefined
// 1461752C4: variable 'v20' is possibly undefined
// 1461752C4: variable 'v21' is possibly undefined
// 14611AD18: using guessed type __int64 qword_14611AD18;
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 14611EDF0: using guessed type wchar_t aDataCacheExecu[38];
// 14611EF08: using guessed type void *std::_Func_impl_no_alloc<_lambda_b697347c6c0928237e401262969d5641_,void,_CONTEXT *>::`vftable';
// 1461748D0: using guessed type __int64 sub_1461748D0(void);
// 146175100: using guessed type int var_E0[28];

//----- (0000000146175490) ----------------------------------------------------
int __fastcall sub_146175490(char a1)
{
  __int64 v1; // rdx
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // r8
  unsigned __int64 v5; // rax
  char *v6; // r14
  char *v7; // r13
  __int64 v8; // rsi
  unsigned __int64 v9; // rbp
  unsigned __int64 v10; // r15
  unsigned __int64 v11; // rax
  __int16 v12; // di
  _DWORD *v13; // rbx
  int v14; // eax
  __int64 v15; // rax
  __int64 v16; // rax
  DWORD flOldProtect; // [rsp+58h] [rbp+10h] BYREF

  v1 = qword_14611AD18;
  v3 = *(unsigned int *)(qword_14611AD18 + 0x14000003Ci64);
  v4 = v3 + 0x140000000i64;
  if ( v3 <= 0x6000000 )
    v4 += qword_14611AD18;
  v5 = *(unsigned int *)(v4 + 176);
  v6 = (char *)(v5 + 0x140000000i64);
  if ( v5 <= 0x6000000 )
    v6 += qword_14611AD18;
  v7 = &v6[*(unsigned int *)(v4 + 180)];
  v8 = qword_14611AD18;
  if ( qword_14611AD18 != 0 && v6 < v7 )
  {
    do
    {
      v5 = *((unsigned int *)v6 + 1);
      if ( !(_DWORD)v5 )
        break;
      v9 = 0i64;
      v10 = (v5 - 8) >> 1;
      if ( v10 )
      {
        do
        {
          v11 = *(_DWORD *)v6 + (*(_WORD *)&v6[2 * v9 + 8] & 0xFFFu);
          v12 = *(_WORD *)&v6[2 * v9 + 8] >> 12;
          v13 = (_DWORD *)(v11 + 0x140000000i64);
          if ( v11 <= 0x6000000 )
            v13 = (_DWORD *)((char *)v13 + v1);
          LODWORD(v5) = VirtualProtect(v13, 4ui64, 0x40u, &flOldProtect);
          if ( v12 == 3 )
          {
            v14 = v8 + *v13;
            if ( !a1 )
              v14 = *v13 - v8;
            *v13 = v14;
          }
          else if ( v12 == 10 )
          {
            v15 = *(_QWORD *)v13;
            if ( a1 )
              v16 = v8 + v15;
            else
              v16 = v15 - v8;
            *(_QWORD *)v13 = v16;
          }
          else if ( v12 )
          {
            return v5;
          }
          VirtualProtect(v13, 4ui64, flOldProtect, &flOldProtect);
          v1 = qword_14611AD18;
          ++v9;
        }
        while ( v9 < v10 );
      }
      v5 = *((unsigned int *)v6 + 1);
      v6 += v5;
    }
    while ( v6 < v7 );
  }
  return v5;
}
// 14611AD18: using guessed type __int64 qword_14611AD18;

//----- (0000000146175620) ----------------------------------------------------
_QWORD *__fastcall sub_146175620(__int64 a1, _QWORD *a2)
{
  *a2 = &std::_Func_impl_no_alloc<_lambda_0f47cb7c548717280bc83b7ce23c8970_,void,_CONTEXT *>::`vftable';
  return a2;
}
// 14611EF78: using guessed type void *std::_Func_impl_no_alloc<_lambda_0f47cb7c548717280bc83b7ce23c8970_,void,_CONTEXT *>::`vftable';

//----- (0000000146175630) ----------------------------------------------------
_QWORD *__fastcall sub_146175630(__int64 a1, _QWORD *a2)
{
  *a2 = &std::_Func_impl_no_alloc<_lambda_4cf28de73b92b3a2e651a2f1f6480e01_,void,_CONTEXT *>::`vftable';
  a2[1] = *(_QWORD *)(a1 + 8);
  return a2;
}
// 14611EFB0: using guessed type void *std::_Func_impl_no_alloc<_lambda_4cf28de73b92b3a2e651a2f1f6480e01_,void,_CONTEXT *>::`vftable';

//----- (0000000146175650) ----------------------------------------------------
_QWORD *__fastcall sub_146175650(__int64 a1, _QWORD *a2)
{
  *a2 = &std::_Func_impl_no_alloc<_lambda_b697347c6c0928237e401262969d5641_,void,_CONTEXT *>::`vftable';
  return a2;
}
// 14611EF08: using guessed type void *std::_Func_impl_no_alloc<_lambda_b697347c6c0928237e401262969d5641_,void,_CONTEXT *>::`vftable';

//----- (0000000146175660) ----------------------------------------------------
_QWORD *__fastcall sub_146175660(__int64 a1, _QWORD *a2)
{
  *a2 = &std::_Func_impl_no_alloc<_lambda_f42722e5fe4e40ac09c541a5093d66ae_,void,_CONTEXT *>::`vftable';
  return a2;
}
// 14611EF40: using guessed type void *std::_Func_impl_no_alloc<_lambda_f42722e5fe4e40ac09c541a5093d66ae_,void,_CONTEXT *>::`vftable';

//----- (0000000146175670) ----------------------------------------------------
void __fastcall sub_146175670(void *a1, char a2)
{
  if ( a2 )
    j_j_free(a1);
}

//----- (0000000146175680) ----------------------------------------------------
__int64 __fastcall sub_146175680(__int64 a1, __int64 *a2)
{
  __int64 result; // rax

  result = *a2;
  *(_QWORD *)(*a2 + 112) &= 0x3F3FFF3Fui64;
  return result;
}

//----- (0000000146175690) ----------------------------------------------------
__int64 __fastcall sub_146175690(__int64 a1, __int64 *a2)
{
  __int64 v2; // r8
  __int64 result; // rax

  v2 = *a2;
  *(_QWORD *)(v2 + 112) &= 0xFFFFF3Fui64;
  *(_QWORD *)(v2 + 112) |= 0x40ui64;
  result = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(v2 + 96) = result;
  return result;
}

//----- (00000001461756B0) ----------------------------------------------------
__int64 __fastcall sub_1461756B0(__int64 a1, __int64 *a2)
{
  __int64 v2; // rbx
  __int64 result; // rax

  v2 = *a2;
  *(_QWORD *)(v2 + 112) &= 0xFFFFF3Fui64;
  *(_QWORD *)(v2 + 112) |= 0x40ui64;
  result = sub_1461748D0();
  if ( (unsigned __int64)(result - 0x140000000i64) <= 0x6000000 )
    result += qword_14611AD18;
  *(_QWORD *)(v2 + 96) = result;
  return result;
}
// 14611AD18: using guessed type __int64 qword_14611AD18;
// 1461748D0: using guessed type __int64 sub_1461748D0(void);

//----- (0000000146175710) ----------------------------------------------------
void *sub_146175710()
{
  return &_lambda_0f47cb7c548717280bc83b7ce23c8970_ `RTTI Type Descriptor';
}

//----- (0000000146175720) ----------------------------------------------------
void *sub_146175720()
{
  return &_lambda_4cf28de73b92b3a2e651a2f1f6480e01_ `RTTI Type Descriptor';
}

//----- (0000000146175730) ----------------------------------------------------
void *sub_146175730()
{
  return &_lambda_b697347c6c0928237e401262969d5641_ `RTTI Type Descriptor';
}

//----- (0000000146175740) ----------------------------------------------------
void *sub_146175740()
{
  return &_lambda_f42722e5fe4e40ac09c541a5093d66ae_ `RTTI Type Descriptor';
}

//----- (0000000146175770) ----------------------------------------------------
char *__fastcall sub_146175770(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rbx
  __int64 v5; // rbp
  unsigned __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r15
  size_t v12; // r15
  _QWORD *v13; // rax
  unsigned __int64 v14; // rbx
  _QWORD *v15; // r14
  char *v16; // r13
  _OWORD *v17; // rbx
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rbx
  __int64 i; // rsi
  _QWORD *v22; // rcx
  char *result; // rax

  v4 = a2 - *a1;
  v5 = (a1[1] - *a1) >> 5;
  if ( v5 == 0x7FFFFFFFFFFFFFFi64 )
    unknown_libname_6(a1, a2, 0x7FFFFFFFFFFFFFFi64);
  v8 = v5 + 1;
  v9 = (a1[2] - *a1) >> 5;
  v10 = v9 >> 1;
  if ( v9 <= 0x7FFFFFFFFFFFFFFi64 - (v9 >> 1) )
  {
    v11 = v8;
    if ( v10 + v9 >= v8 )
      v11 = v10 + v9;
    if ( v11 > 0x7FFFFFFFFFFFFFFi64 )
      sub_146165390(v9, v10, 0x7FFFFFFFFFFFFFFi64);
  }
  else
  {
    v11 = 0x7FFFFFFFFFFFFFFi64;
  }
  v12 = 4 * v11;
  v13 = sub_14615A5E0(v12 * 8);
  v14 = v4 & 0xFFFFFFFFFFFFFFE0ui64;
  *(_OWORD *)((char *)v13 + v14) = 0i64;
  v15 = v13;
  v16 = (char *)v13 + v14;
  *((_QWORD *)v16 + 2) = 0i64;
  v17 = (_OWORD *)((char *)v13 + v14 + 32);
  *((_QWORD *)v16 + 3) = 0i64;
  *(_OWORD *)v16 = *(_OWORD *)a3;
  *((_OWORD *)v16 + 1) = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(a3 + 16) = 0i64;
  *(_QWORD *)(a3 + 24) = 15i64;
  *(_BYTE *)a3 = 0;
  v18 = a1[1];
  v19 = *a1;
  if ( a2 == v18 )
  {
    v17 = v13;
  }
  else
  {
    sub_146175B20(v19, a2, v13);
    v18 = a1[1];
    v19 = a2;
  }
  sub_146175B20(v19, v18, v17);
  v20 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v20 != i; v20 += 32i64 )
      sub_1461626B0(v20);
    v22 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFE0ui64) >= 0x1000 )
    {
      if ( (unsigned __int64)v22 - *(v22 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v22 = (_QWORD *)*(v22 - 1);
    }
    j_j_free(v22);
  }
  *a1 = (__int64)v15;
  result = v16;
  a1[1] = (__int64)&v15[4 * v8];
  a1[2] = (__int64)&v15[v12];
  return result;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (0000000146175930) ----------------------------------------------------
char *__fastcall sub_146175930(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r14
  __int64 v4; // r15
  __int64 v5; // rsi
  __int64 v7; // rbx
  unsigned __int64 v9; // rsi
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rcx
  size_t v14; // r15
  _QWORD *v15; // rax
  char *v16; // r14
  _QWORD *v17; // rbp
  _QWORD *v18; // r8
  _QWORD *v19; // rcx
  _QWORD *v20; // rdx
  __int64 v21; // rax
  _QWORD *v22; // rdx
  __int64 v23; // rax
  __int64 v24; // rdx
  char *v25; // rcx
  __int64 v26; // rax
  _QWORD *v27; // rcx
  char *result; // rax

  v3 = a2 - *a1;
  v4 = 0xFFFFFFFFFFFFFFFi64;
  v5 = (__int64)(a1[1] - *a1) >> 4;
  v7 = a2;
  if ( v5 == 0xFFFFFFFFFFFFFFFi64 )
    unknown_libname_6(a1, a2, a3);
  v9 = v5 + 1;
  v10 = (__int64)(a1[2] - *a1) >> 4;
  v11 = v10 >> 1;
  if ( v10 <= 0xFFFFFFFFFFFFFFFi64 - (v10 >> 1) )
  {
    v12 = v11 + v10;
    v13 = v9;
    if ( v12 >= v9 )
      v13 = v12;
    if ( v13 > 0xFFFFFFFFFFFFFFFi64 )
      sub_146165390(v13, v11, a3);
    v4 = v13;
  }
  v14 = 2 * v4;
  v15 = sub_14615A5E0(v14 * 8);
  v16 = (char *)v15 + (v3 & 0xFFFFFFFFFFFFFFF0ui64);
  v17 = v15;
  *(_DWORD *)v16 = *(_DWORD *)a3;
  *((_DWORD *)v16 + 1) = *(_DWORD *)(a3 + 4);
  *((_QWORD *)v16 + 1) = *(_QWORD *)(a3 + 8);
  v18 = (_QWORD *)a1[1];
  v19 = (_QWORD *)*a1;
  if ( (_QWORD *)v7 == v18 )
  {
    if ( v19 != v18 )
    {
      v20 = v15 + 1;
      do
      {
        *((_DWORD *)v20 - 2) = *(_DWORD *)v19;
        v20 += 2;
        *((_DWORD *)v20 - 5) = *((_DWORD *)v19 + 1);
        v21 = v19[1];
        v19 += 2;
        *(v20 - 2) = v21;
      }
      while ( v19 != v18 );
    }
  }
  else
  {
    if ( v19 != (_QWORD *)v7 )
    {
      v22 = v15 + 1;
      do
      {
        *((_DWORD *)v22 - 2) = *(_DWORD *)v19;
        v22 += 2;
        *((_DWORD *)v22 - 5) = *((_DWORD *)v19 + 1);
        v23 = v19[1];
        v19 += 2;
        *(v22 - 2) = v23;
      }
      while ( v19 != (_QWORD *)v7 );
    }
    v24 = a1[1];
    if ( v7 != v24 )
    {
      v25 = v16 + 24;
      do
      {
        *((_DWORD *)v25 - 2) = *(_DWORD *)v7;
        v25 += 16;
        *((_DWORD *)v25 - 5) = *(_DWORD *)(v7 + 4);
        v26 = *(_QWORD *)(v7 + 8);
        v7 += 16i64;
        *((_QWORD *)v25 - 2) = v26;
      }
      while ( v7 != v24 );
    }
  }
  v27 = (_QWORD *)*a1;
  if ( *a1 )
  {
    if ( ((a1[2] - (_QWORD)v27) & 0xFFFFFFFFFFFFFFF0ui64) >= 0x1000 )
    {
      if ( (unsigned __int64)v27 - *(v27 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v27 = (_QWORD *)*(v27 - 1);
    }
    j_j_free(v27);
  }
  *a1 = v17;
  result = v16;
  a1[1] = &v17[2 * v9];
  a1[2] = &v17[v14];
  return result;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (0000000146175B20) ----------------------------------------------------
_OWORD *__fastcall sub_146175B20(__int64 a1, __int64 a2, _OWORD *a3)
{
  _OWORD *result; // rax
  __int64 v4; // r8
  char *v5; // r9

  result = a3;
  if ( a1 != a2 )
  {
    v4 = a1 + 24;
    v5 = (char *)result - a1;
    do
    {
      v4 += 32i64;
      *result = 0i64;
      *(_QWORD *)&v5[v4 - 40] = 0i64;
      *(_QWORD *)&v5[v4 - 32] = 0i64;
      *result = *(_OWORD *)(v4 - 56);
      result[1] = *(_OWORD *)(v4 - 40);
      *(_QWORD *)(v4 - 40) = 0i64;
      result += 2;
      *(_QWORD *)(v4 - 32) = 15i64;
      *(_BYTE *)(v4 - 56) = 0;
    }
    while ( v4 - 24 != a2 );
  }
  return result;
}

//----- (0000000146175B90) ----------------------------------------------------
_QWORD *__fastcall sub_146175B90(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // rax

  a1[13] = 0i64;
  a1[14] = 0i64;
  a1[15] = 0i64;
  a1[16] = 0i64;
  qword_14611AD18 = (__int64)(GetModuleHandleW(0i64) - 1342177280);
  a1[4] = LoadLibraryA;
  a1[5] = GetProcAddress;
  result = a1;
  *a1 = a2;
  a1[2] = -1i64;
  return result;
}
// 14611AD18: using guessed type __int64 qword_14611AD18;

//----- (0000000146175C00) ----------------------------------------------------
void **__fastcall sub_146175C00(__int64 a1, __int64 a2)
{
  void **result; // rax
  unsigned int *v4; // rdi
  __m128i si128; // xmm6
  const char *v6; // r12
  size_t v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  size_t v12; // rsi
  unsigned __int64 v13; // rdi
  _QWORD *v14; // rbx
  __m128i *v15; // rdx
  unsigned __int64 v16; // rdx
  void *v17; // rcx
  HMODULE v18; // r15
  DWORD LastError; // ebx
  unsigned __int16 *v20; // rax
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 *v23; // rax
  __int64 v24; // rcx
  unsigned int v25; // ebx
  void *v26; // rcx
  __int64 v27; // rdx
  __int64 v28; // rcx
  FARPROC *v29; // r14
  unsigned __int16 *v30; // rdi
  __int64 v31; // rax
  bool v32; // sf
  FARPROC ProcAddress; // rbx
  __int64 v34; // rsi
  __int64 v35; // [rsp+48h] [rbp-C0h]
  unsigned int *v36; // [rsp+50h] [rbp-B8h]
  unsigned __int16 *v37[2]; // [rsp+58h] [rbp-B0h] BYREF
  __int128 v38; // [rsp+68h] [rbp-A0h] BYREF
  __int128 v39; // [rsp+78h] [rbp-90h] BYREF
  __int128 v40; // [rsp+88h] [rbp-80h] BYREF
  __int128 v41; // [rsp+98h] [rbp-70h] BYREF
  __int64 v42; // [rsp+A8h] [rbp-60h]
  __int128 v43; // [rsp+B0h] [rbp-58h]
  __int128 v44; // [rsp+C8h] [rbp-40h]
  __int128 v45; // [rsp+D8h] [rbp-30h] BYREF
  __m128i v46; // [rsp+E8h] [rbp-20h]
  WCHAR *v47; // [rsp+F8h] [rbp-10h]
  __int64 v48; // [rsp+100h] [rbp-8h]
  __int64 v49[2]; // [rsp+108h] [rbp+0h] BYREF
  __int128 v50; // [rsp+118h] [rbp+10h]
  __int64 v51; // [rsp+128h] [rbp+20h]
  __int64 v52; // [rsp+130h] [rbp+28h]
  WCHAR Buffer[512]; // [rsp+138h] [rbp+30h] BYREF
  void *retaddr; // [rsp+590h] [rbp+488h] BYREF

  result = &retaddr;
  v42 = -2i64;
  v4 = (unsigned int *)(*(_QWORD *)(a1 + 8) + *(unsigned int *)(a2 + 144));
  v36 = v4;
  if ( v4[3] )
  {
    si128 = _mm_load_si128((const __m128i *)&Size);
    do
    {
      v35 = (__int64)v4;
      v6 = (const char *)(*(_QWORD *)(a1 + 8) + v4[3]);
      v45 = 0i64;
      v46 = 0i64;
      v7 = strlen(v6);
      v12 = v7;
      if ( v7 > 0x7FFFFFFFFFFFFFFFi64 )
        unknown_libname_4(v9, v8, v10, v11);
      if ( v7 > 0xF )
      {
        v13 = v7 | 0xF;
        if ( (v7 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
        {
          if ( v13 < 0x16 )
            v13 = 22i64;
        }
        else
        {
          v13 = 0x7FFFFFFFFFFFFFFFi64;
        }
        v14 = sub_14615A5E0(v13 + 1);
        *(_QWORD *)&v45 = v14;
        v46.m128i_i64[0] = v12;
        v46.m128i_i64[1] = v13;
        memcpy(v14, v6, v12);
        *((_BYTE *)v14 + v12) = 0;
        v4 = v36;
      }
      else
      {
        v46.m128i_i64[0] = v7;
        v46.m128i_i64[1] = 15i64;
        memcpy(&v45, v6, v7);
        *((_BYTE *)&v45 + v12) = 0;
      }
      v15 = (__m128i *)xmmword_14610A998;
      if ( (_QWORD)xmmword_14610A998 == *((_QWORD *)&xmmword_14610A998 + 1) )
      {
        sub_146175770((__int64 *)&qword_14610A990, xmmword_14610A998, (__int64)&v45);
        v16 = v46.m128i_u64[1];
      }
      else
      {
        *(_OWORD *)xmmword_14610A998 = v45;
        v15[1] = v46;
        v16 = 15i64;
        LOBYTE(v45) = 0;
        *(_QWORD *)&xmmword_14610A998 = xmmword_14610A998 + 32;
      }
      if ( v16 > 0xF )
      {
        v17 = (void *)v45;
        if ( v16 + 1 >= 0x1000 )
        {
          v17 = *(void **)(v45 - 8);
          if ( (unsigned __int64)(v45 - (_QWORD)v17 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v17);
      }
      v18 = (HMODULE)(*(__int64 (__fastcall **)(const char *))(a1 + 32))(v6);
      if ( !v18 )
      {
        LastError = GetLastError();
        Buffer[0] = 0;
        FormatMessageW(0x12FFu, 0i64, LastError, 0x400u, Buffer, 0x200u, 0i64);
        v20 = (unsigned __int16 *)wcslen(Buffer);
        v37[0] = Buffer;
        v37[1] = v20;
        v23 = (__int64 *)sub_1461A2B60((__int64)&v45, v37, v21, v22);
        LODWORD(v43) = LastError;
        v24 = (__int64)v23;
        if ( (unsigned __int64)v23[3] > 0xF )
          v24 = *v23;
        v49[0] = (__int64)v6;
        v49[1] = v35;
        v50 = v43;
        v51 = v24;
        v52 = v23[2];
        *(_QWORD *)&v38 = 3372i64;
        *((_QWORD *)&v38 + 1) = v49;
        v25 = (unsigned int)sub_146163F20(
                              "F:\\NewBuildFivem\\LauncherGTA\\code\\client\\launcher\\ExecutableLoader.cpp",
                              55,
                              -1664114264,
                              "Could not load dependent module %s. Error code %i -> %s\n",
                              &v38) >> 31;
        if ( v46.m128i_i64[1] > 0xFui64 )
        {
          v26 = (void *)v45;
          if ( (unsigned __int64)(v46.m128i_i64[1] + 1) >= 0x1000 )
          {
            v26 = *(void **)(v45 - 8);
            if ( (unsigned __int64)(v45 - (_QWORD)v26 - 8) > 0x1F )
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v26);
        }
        v46 = si128;
        LOBYTE(v45) = 0;
        if ( (_BYTE)v25 )
          MEMORY[0xDEED] = 0;
      }
      if ( (_DWORD)v18 != -1 )
      {
        v27 = *(_QWORD *)(a1 + 8);
        v28 = v4[4];
        v29 = (FARPROC *)(v28 + v27);
        if ( *v4 )
          v28 = *v4;
        v30 = (unsigned __int16 *)(v28 + v27);
        v31 = *(_QWORD *)(v28 + v27);
        v32 = v31 < 0;
        if ( v31 )
        {
          do
          {
            if ( v32 )
            {
              ProcAddress = GetProcAddress(v18, (LPCSTR)(unsigned __int16)v31);
              *(_QWORD *)&v44 = *v30;
              v45 = v44;
              *(_QWORD *)&v39 = 4i64;
              *((_QWORD *)&v39 + 1) = &v45;
              *(_QWORD *)&v40 = "#%d";
              *((_QWORD *)&v40 + 1) = 3i64;
              v34 = sub_1461A30D0(&v40, &v39);
            }
            else
            {
              v34 = (unsigned int)v31 + *(_QWORD *)(a1 + 8) + 2i64;
              ProcAddress = (FARPROC)(*(__int64 (__fastcall **)(HMODULE, __int64))(a1 + 40))(v18, v34);
            }
            if ( !ProcAddress )
            {
              GetModuleFileNameA(v18, (LPSTR)Buffer, 0x104u);
              *(_QWORD *)&v45 = v34;
              *((_QWORD *)&v45 + 1) = v35;
              v46.m128i_i64[0] = (__int64)v6;
              v46.m128i_i64[1] = v35;
              v47 = Buffer;
              v48 = v35;
              *(_QWORD *)&v41 = 3276i64;
              *((_QWORD *)&v41 + 1) = &v45;
              if ( (int)sub_146163F20(
                          "F:\\NewBuildFivem\\LauncherGTA\\code\\client\\launcher\\ExecutableLoader.cpp",
                          98,
                          -390961158,
                          "Could not load function %s in dependent module %s (%s).\n",
                          &v41) < 0 )
                MEMORY[0xDEED] = 0;
            }
            *v29 = ProcAddress;
            v30 += 4;
            ++v29;
            v31 = *(_QWORD *)v30;
            v32 = *(__int64 *)v30 < 0;
          }
          while ( *(_QWORD *)v30 );
        }
        v4 = v36;
      }
      v4 += 5;
      v36 = v4;
      result = (void **)v35;
    }
    while ( *(_DWORD *)(v35 + 32) );
  }
  return result;
}
// 146175DFF: variable 'v21' is possibly undefined
// 146175DFF: variable 'v22' is possibly undefined
// 146176084: variable 'v9' is possibly undefined
// 146176084: variable 'v8' is possibly undefined
// 146176084: variable 'v10' is possibly undefined
// 146176084: variable 'v11' is possibly undefined
// 14610A998: using guessed type __int128 xmmword_14610A998;
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146176090) ----------------------------------------------------
__int64 __fastcall sub_146176090(__int64 *a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 result; // rax
  __int64 v5; // r13
  __int64 v6; // r14
  __int64 v7; // rsi
  __int64 v8; // rcx
  __int64 v9; // rax
  char *v10; // r8
  char *v11; // r11
  __int64 v12; // r10
  __int64 v13; // rax
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // r9
  _DWORD *v16; // rax
  __int16 v17; // cx
  struct _RUNTIME_FUNCTION *v18; // r12
  unsigned int v19; // ebx
  HMODULE ModuleHandleW; // rax
  HMODULE v21; // rax
  __int64 (*ProcAddress)(void); // rax
  _QWORD **v23; // r13
  _QWORD *v24; // r14
  __int64 v25; // rbx
  __int64 v26; // rdi
  int v27; // esi
  DWORD v28; // r8d
  HMODULE v29; // rax
  FARPROC v30; // rax
  void **ThreadLocalStoragePointer; // rdi
  __int64 v32; // rbx
  FARPROC v33; // rax
  DWORD *v34; // rcx
  DWORD flNewProtect; // [rsp+38h] [rbp-69h] BYREF
  LPVOID lpAddress; // [rsp+40h] [rbp-61h] BYREF
  int v37; // [rsp+48h] [rbp-59h]
  unsigned int v38; // [rsp+4Ch] [rbp-55h]
  DWORD v39[2]; // [rsp+50h] [rbp-51h] BYREF
  __int64 v40; // [rsp+58h] [rbp-49h]
  __int128 v41; // [rsp+68h] [rbp-39h] BYREF
  DWORD flOldProtect; // [rsp+78h] [rbp-29h] BYREF
  __int64 v43; // [rsp+80h] [rbp-21h]
  __int128 v44; // [rsp+88h] [rbp-19h] BYREF
  __int64 v45[4]; // [rsp+98h] [rbp-9h] BYREF

  a1[1] = a2;
  v3 = *a1;
  result = 23117i64;
  if ( *(_WORD *)v3 == 23117 )
  {
    v5 = a2 + *(unsigned int *)(a2 + 60);
    v6 = v3 + *(int *)(v3 + 60);
    v40 = v5;
    *(_QWORD *)v39 = v6;
    v7 = *(_QWORD *)(v5 + 184);
    v37 = *(_DWORD *)(v5 + 88);
    v38 = *(_DWORD *)(v5 + 8);
    v43 = v7;
    if ( !(unsigned __int8)sub_146174A70((__int64)a1, v6) )
      sub_146176540(a1, v6);
    VirtualProtect((LPVOID)v5, 0x1000ui64, 0x40u, &flOldProtect);
    *(_QWORD *)(v5 + 176) = *(_QWORD *)(v6 + 176);
    v8 = a1[1];
    v9 = *(unsigned int *)(v8 + 60);
    v10 = (char *)(v8 + *(unsigned int *)(v9 + v8 + 176));
    v11 = &v10[*(unsigned int *)(v9 + v8 + 180)];
    v12 = v8 - 0x140000000i64;
    if ( v8 != 0x140000000i64 && v10 < v11 )
    {
      do
      {
        v13 = *((unsigned int *)v10 + 1);
        if ( !(_DWORD)v13 )
          break;
        v14 = 0i64;
        v15 = (unsigned __int64)(v13 - 8) >> 1;
        if ( v15 )
        {
          do
          {
            v16 = (_DWORD *)(a1[1] + *(_DWORD *)v10 + (*(_WORD *)&v10[2 * v14 + 8] & 0xFFFu));
            v17 = *(_WORD *)&v10[2 * v14 + 8] >> 12;
            if ( v17 == 3 )
            {
              *v16 += v12;
            }
            else if ( v17 == 10 )
            {
              *(_QWORD *)v16 += v12;
            }
            else if ( v17 )
            {
              goto LABEL_15;
            }
            ++v14;
          }
          while ( v14 < v15 );
        }
        v10 += *((unsigned int *)v10 + 1);
      }
      while ( v10 < v11 );
    }
LABEL_15:
    sub_146175C00((__int64)a1, v6);
    v18 = (struct _RUNTIME_FUNCTION *)(a1[1] + *(unsigned int *)(v6 + 160));
    lpAddress = (LPVOID)(*(unsigned int *)(v6 + 164) / 0xCui64);
    v19 = (unsigned int)lpAddress;
    ModuleHandleW = GetModuleHandleW(0i64);
    if ( !RtlAddFunctionTable(v18, (ULONG)lpAddress, (ULONG64)ModuleHandleW) )
    {
      *(_QWORD *)&v41 = 0i64;
      *((_QWORD *)&v41 + 1) = &v44;
      if ( (int)sub_146163F20(
                  "F:\\NewBuildFivem\\LauncherGTA\\code\\client\\launcher\\ExecutableLoader.cpp",
                  250,
                  958814806,
                  "Setting exception handlers failed.",
                  &v41) < 0 )
        MEMORY[0xDEED] = 0;
    }
    v21 = GetModuleHandleW(L"ntdll.dll");
    ProcAddress = GetProcAddress(v21, "RtlGetFunctionTableListHead");
    if ( ProcAddress )
    {
      v23 = (_QWORD **)ProcAddress();
      v24 = *v23;
      if ( *v23 != v23 )
      {
        v25 = *((_QWORD *)&v44 + 1);
        v26 = *((_QWORD *)&v44 + 1);
        v27 = (int)lpAddress;
        do
        {
          if ( v24[6] == a1[1] )
          {
            v45[0] = v24[2];
            *(_QWORD *)&v44 = "Replacing function table list entry %p with %p\n";
            *((_QWORD *)&v41 + 1) = v45;
            v45[1] = v26;
            v45[2] = (__int64)v18;
            v45[3] = v25;
            *(_QWORD *)&v41 = 238i64;
            *((_QWORD *)&v44 + 1) = 47i64;
            sub_1461A2D50(
              (__int64)"Launcher",
              (__int64)"LoadExceptionTable",
              (__int64)"F:\\NewBuildFivem\\LauncherGTA\\code\\client\\launcher\\ExecutableLoader.cpp",
              0x10Du,
              &v44,
              &v41);
            if ( (struct _RUNTIME_FUNCTION *)v24[2] != v18 )
            {
              VirtualProtect(v24, 0x58ui64, 4u, &flNewProtect);
              v28 = flNewProtect;
              *((_DWORD *)v24 + 21) = v27;
              v24[2] = v18;
              VirtualProtect(v24, 0x58ui64, v28, &flNewProtect);
            }
          }
          v24 = (_QWORD *)*v24;
        }
        while ( v24 != v23 );
        v7 = v43;
        v19 = (unsigned int)lpAddress;
      }
      v5 = v40;
      v6 = *(_QWORD *)v39;
    }
    v29 = GetModuleHandleW(L"CoreRT.dll");
    if ( v29 )
    {
      v30 = GetProcAddress(v29, "CoreRT_SetupSEHHandler");
      ((void (__fastcall *)(__int64, __int64, struct _RUNTIME_FUNCTION *, _QWORD))v30)(
        a1[1],
        a1[1] + *(unsigned int *)(v6 + 80),
        v18,
        v19);
    }
    if ( *(_DWORD *)(v6 + 212) )
    {
      ThreadLocalStoragePointer = (void **)NtCurrentTeb()->ThreadLocalStoragePointer;
      v32 = a1[1] + *(unsigned int *)(v6 + 208);
      flNewProtect = 0;
      lpAddress = 0i64;
      v33 = GetProcAddress(hModule, "GetThreadLocalStorage");
      ((void (__fastcall *)(LPVOID *, DWORD *))v33)(&lpAddress, &flNewProtect);
      if ( flNewProtect >= 0x40 )
        sub_1461A1C30(
          (wchar_t *)L"tlsIndex < 64",
          (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\code\\client\\launcher\\ExecutableLoader.cpp",
          361);
      if ( *(_QWORD *)v32 )
      {
        VirtualProtect(lpAddress, *(_QWORD *)(v32 + 8) - *(_QWORD *)v32, 4u, v39);
        memcpy(ThreadLocalStoragePointer[flNewProtect], *(const void **)v32, *(_QWORD *)(v32 + 8) - *(_QWORD *)v32);
        memcpy(lpAddress, *(const void **)v32, *(_QWORD *)(v32 + 8) - *(_QWORD *)v32);
      }
      v34 = *(DWORD **)(v32 + 16);
      if ( v34 )
      {
        if ( (unsigned __int64)(v34 - 1342177280) <= 0x6000000 )
          v34 = (DWORD *)((char *)v34 + qword_14611AD18);
        *v34 = flNewProtect;
      }
    }
    a1[3] = a1[1] + *(unsigned int *)(v6 + 40);
    *(_QWORD *)(v5 + 144) = *(_QWORD *)(v6 + 144);
    memcpy((void *)v5, (const void *)v6, 40i64 * *(unsigned __int16 *)(v6 + 6) + 264);
    *(_DWORD *)(v5 + 88) = v37;
    result = v38;
    *(_DWORD *)(v5 + 8) = v38;
    *(_QWORD *)(v5 + 184) = v7;
  }
  return result;
}
// 14611AD18: using guessed type __int64 qword_14611AD18;

//----- (0000000146176540) ----------------------------------------------------
__int64 __fastcall sub_146176540(_QWORD *a1, __int64 a2)
{
  int v2; // ebp
  __int64 result; // rax
  unsigned int *i; // rbx
  void *v7; // rsi
  unsigned int v8; // ecx
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  int v12; // eax
  bool v13; // zf
  int v14; // ecx
  __int64 v15; // rdx
  int v16; // r8d
  int v17[2]; // [rsp+20h] [rbp-38h] BYREF
  void *v18; // [rsp+28h] [rbp-30h]
  DWORD flOldProtect; // [rsp+68h] [rbp+10h] BYREF

  v2 = 0;
  result = *(unsigned __int16 *)(a2 + 20) + 40i64;
  if ( *(_WORD *)(a2 + 6) )
  {
    for ( i = (unsigned int *)(result + a2); ; i += 10 )
    {
      v7 = (void *)(a1[1] + *(i - 1));
      if ( (unsigned __int64)v7 < qword_14611AD18 + a1[2] )
        break;
LABEL_32:
      result = *(unsigned __int16 *)(a2 + 6);
      if ( ++v2 >= (int)result )
        return result;
    }
    v8 = *i;
    if ( *i )
    {
      if ( *(i - 2) < v8 )
        v8 = *(i - 2);
      memcpy((void *)(a1[1] + *(i - 1)), (const void *)(*a1 + i[1]), v8);
    }
    VirtualProtect(v7, *(i - 2), 0x40u, &flOldProtect);
    v9 = i[5];
    v10 = v9 & 0x4000000;
    v11 = v9 & 0x40000000;
    if ( (v9 & 0x20000000) != 0 )
    {
      if ( v11 )
      {
        if ( v9 < 0 )
        {
          v12 = 576;
          if ( !v10 )
            v12 = 64;
LABEL_29:
          v15 = a1[15];
          v16 = *(i - 2);
          v17[0] = v12;
          v17[1] = v16;
          v18 = v7;
          if ( v15 == a1[16] )
          {
            sub_146175930(a1 + 14, v15, (__int64)v17);
          }
          else
          {
            *(_DWORD *)v15 = v12;
            *(_DWORD *)(v15 + 4) = v16;
            *(_QWORD *)(v15 + 8) = v7;
            a1[15] += 16i64;
          }
          goto LABEL_32;
        }
        v13 = v10 == 0;
        v12 = 544;
        v14 = 32;
      }
      else
      {
        if ( v9 < 0 )
        {
          v12 = 640;
          if ( !v10 )
            v12 = 128;
          goto LABEL_29;
        }
        v13 = v10 == 0;
        v12 = 528;
        v14 = 16;
      }
    }
    else if ( v11 )
    {
      v13 = v10 == 0;
      if ( v9 >= 0 )
      {
        v12 = 514;
        v14 = 2;
      }
      else
      {
        v12 = 516;
        v14 = 4;
      }
    }
    else
    {
      v13 = v10 == 0;
      if ( v9 >= 0 )
      {
        v12 = 513;
        v14 = 1;
      }
      else
      {
        v12 = 520;
        v14 = 8;
      }
    }
    if ( v13 )
      v12 = v14;
    goto LABEL_29;
  }
  return result;
}
// 14611AD18: using guessed type __int64 qword_14611AD18;

//----- (00000001461766F0) ----------------------------------------------------
BOOL (__fastcall *__fastcall sub_1461766F0(HMODULE a1, const CHAR *a2))(struct _STARTUPINFOW *a1)
{
  if ( !stricmp(a2, "GetStartupInfoW") )
    return sub_146176770;
  else
    return (BOOL (__fastcall *)(struct _STARTUPINFOW *))GetProcAddress(a1, a2);
}

//----- (0000000146176740) ----------------------------------------------------
HMODULE __fastcall sub_146176740(const CHAR *a1)
{
  HMODULE result; // rax

  result = LoadLibraryA(a1);
  if ( !result )
    return (HMODULE)-1i64;
  return result;
}

//----- (0000000146176770) ----------------------------------------------------
BOOL __fastcall sub_146176770(struct _STARTUPINFOW *a1)
{
  _QWORD *v1; // rax
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v4; // rax
  FILE *v5; // rbx
  _BYTE *v6; // r8
  HANDLE CurrentProcess; // rax
  HMODULE ModuleHandleW; // rax
  HANDLE v9; // rax
  __int128 v11; // [rsp+30h] [rbp-68h] BYREF
  __int64 v12; // [rsp+40h] [rbp-58h]
  __int64 v13; // [rsp+48h] [rbp-50h]
  void *Block; // [rsp+60h] [rbp-38h] BYREF
  __m128i si128; // [rsp+70h] [rbp-28h]

  GetStartupInfoW(a1);
  v11 = 0i64;
  v1 = sub_14615A5E0(0x30ui64);
  *(_QWORD *)&v11 = v1;
  v12 = 18i64;
  v13 = 23i64;
  *(_OWORD *)v1 = xmmword_14611F2A0;
  *((_OWORD *)v1 + 1) = xmmword_14611F2B0;
  *((_DWORD *)v1 + 8) = 7209065;
  *((_WORD *)v1 + 18) = 0;
  v4 = sub_1461645B0((__int64)&Block, (void **)&v11, v2, v3);
  if ( *(_QWORD *)(v4 + 24) > 7ui64 )
    v4 = *(_QWORD *)v4;
  v5 = wfopen((const wchar_t *)v4, aW);
  if ( si128.m128i_i64[1] > 7ui64 )
  {
    v6 = Block;
    if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
    {
      v6 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v6 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v6);
  }
  LOWORD(Block) = 0;
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  if ( !v5 )
  {
    CurrentProcess = GetCurrentProcess();
    TerminateProcess(CurrentProcess, 0);
  }
  ModuleHandleW = GetModuleHandleW(0i64);
  fwrite((char *)ModuleHandleW + *((int *)ModuleHandleW + 15) + 40, 1ui64, 4ui64, v5);
  fclose(v5);
  v9 = GetCurrentProcess();
  return TerminateProcess(v9, 0x10F7u);
}
// 1461767F6: variable 'v2' is possibly undefined
// 1461767F6: variable 'v3' is possibly undefined
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 14611F2A0: using guessed type __int128 xmmword_14611F2A0;
// 14611F2B0: using guessed type __int128 xmmword_14611F2B0;

//----- (0000000146176900) ----------------------------------------------------
char sub_146176900()
{
  const WCHAR *CommandLineW; // rax
  LPWSTR *v1; // rbx
  int v2; // eax
  unsigned __int64 v3; // rax
  const wchar_t *v4; // rsi
  unsigned __int64 v5; // rdi
  char v6; // al
  HMODULE ModuleHandleW; // rax
  char v9; // al
  int pNumArgs; // [rsp+30h] [rbp+8h] BYREF
  void (*v11)(void); // [rsp+38h] [rbp+10h] BYREF

  CommandLineW = GetCommandLineW();
  v1 = CommandLineToArgvW(CommandLineW, &pNumArgs);
  v2 = pNumArgs;
  if ( pNumArgs == 5 )
  {
    if ( !wcsicmp(v1[1], L"-dump_exe") )
    {
      v3 = wcstoull(v1[4], 0i64, 10);
      v4 = v1[3];
      v5 = v3;
      sub_146176A20(v1[2], &v11);
      if ( v6 )
      {
        sub_146167640();
        ModuleHandleW = GetModuleHandleW(0i64);
        sub_146174390((__int64)ModuleHandleW + v5 + 9, v4);
        v11();
        LocalFree(v1);
        return 0;
      }
      goto LABEL_10;
    }
    v2 = pNumArgs;
  }
  if ( v2 == 3 && !wcsicmp(v1[1], L"-find_ep") )
  {
    sub_146176A20(v1[2], &v11);
    if ( v9 )
    {
      sub_146167640();
      v11();
    }
LABEL_10:
    LocalFree(v1);
    return 0;
  }
  LocalFree(v1);
  return 1;
}
// 14617696D: variable 'v6' is possibly undefined
// 1461769D8: variable 'v9' is possibly undefined

//----- (0000000146176A20) ----------------------------------------------------
void __fastcall sub_146176A20(const wchar_t *a1, _QWORD *a2)
{
  FILE *v3; // rax
  FILE *v4; // rbp
  unsigned int v5; // eax
  size_t v6; // rsi
  char *v7; // rdi
  _QWORD *v8; // rbx
  HMODULE ModuleHandleW; // rdx
  __int64 v10; // rdx
  void *v11; // rcx
  char *v12; // rax
  __int64 v13[6]; // [rsp+50h] [rbp-C8h] BYREF
  char v14; // [rsp+80h] [rbp-98h] BYREF
  char *v15; // [rsp+B8h] [rbp-60h]
  void *Block[2]; // [rsp+C0h] [rbp-58h]
  __int64 v17; // [rsp+D0h] [rbp-48h]

  v3 = wfopen(a1, L"rb");
  v4 = v3;
  if ( v3 )
  {
    fseek(v3, 0, 2);
    v5 = ftell(v4);
    v6 = v5;
    v7 = 0i64;
    if ( v5 )
    {
      v8 = sub_14615A5E0(v5);
      v7 = (char *)v8 + v6;
      memset(v8, 0, (unsigned int)v6);
    }
    else
    {
      v8 = 0i64;
    }
    fseek(v4, 0, 0);
    fread(v8, 1ui64, v6, v4);
    fclose(v4);
    sub_146175B90(v13, (__int64)v8);
    v13[2] = 0x1A0000000i64;
    v13[4] = (__int64)sub_146176740;
    v13[5] = (__int64)sub_1461766F0;
    ModuleHandleW = GetModuleHandleW(0i64);
    sub_146176090(v13, (__int64)ModuleHandleW);
    if ( a2 )
      *a2 = v13[3];
    v11 = Block[0];
    if ( Block[0] )
    {
      if ( ((v17 - (unsigned __int64)Block[0]) & 0xFFFFFFFFFFFFFFF0ui64) >= 0x1000 )
      {
        v11 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)(Block[0] - v11 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v11);
      *(_OWORD *)Block = 0i64;
      v17 = 0i64;
    }
    if ( v15 )
    {
      LOBYTE(v10) = v15 != &v14;
      (*(void (__fastcall **)(char *, __int64))(*(_QWORD *)v15 + 32i64))(v15, v10);
      v15 = 0i64;
    }
    if ( v8 )
    {
      v12 = (char *)v8;
      if ( (unsigned __int64)(v7 - (char *)v8) >= 0x1000 )
      {
        v8 = (_QWORD *)*(v8 - 1);
        if ( (unsigned __int64)(v12 - (char *)v8 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v8);
    }
  }
}
// 146176BDF: variable 'v10' is possibly undefined

//----- (0000000146176C60) ----------------------------------------------------
void __fastcall sub_146176C60(__int64 a1)
{
  _QWORD *v2; // rcx

  v2 = *(_QWORD **)a1;
  if ( v2 )
  {
    if ( *(_QWORD *)(a1 + 16) - (_QWORD)v2 >= 0x1000ui64 )
    {
      if ( (unsigned __int64)v2 - *(v2 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v2 = (_QWORD *)*(v2 - 1);
    }
    j_j_free(v2);
    *(_QWORD *)a1 = 0i64;
    *(_QWORD *)(a1 + 8) = 0i64;
    *(_QWORD *)(a1 + 16) = 0i64;
  }
}

//----- (0000000146176CD0) ----------------------------------------------------
__int64 __fastcall sub_146176CD0(__int64 a1, _DWORD *a2, _QWORD *a3)
{
  *(_DWORD *)a1 = *a2;
  sub_1461787F0((__int64 *)(a1 + 8), a3);
  return a1;
}

//----- (0000000146176D00) ----------------------------------------------------
__int64 __fastcall sub_146176D00(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4)
{
  __int64 v6; // r8

  sub_146170E60(a1, a2, (__int64)a3, a4);
  sub_146178F20((_QWORD *)(a1 + 32), a3, v6);
  return a1;
}
// 146176D2B: variable 'v6' is possibly undefined

//----- (0000000146176D40) ----------------------------------------------------
__int64 __fastcall sub_146176D40(__int64 a1, _QWORD *a2)
{
  unsigned __int8 *v2; // r11
  char *v3; // r10
  __int64 v5; // rbx
  char *v6; // rdx
  unsigned __int8 v7; // cl
  char v8; // r9
  unsigned __int8 v9; // r8
  char *v10; // rdx
  unsigned __int8 v11; // cl
  char v12; // r9
  unsigned __int8 v13; // r8
  char *v14; // rdx
  unsigned __int8 v15; // cl
  char v16; // r9
  unsigned __int8 v17; // r8
  char *v18; // rdx
  unsigned __int8 v19; // cl
  char v20; // r9
  unsigned __int8 v21; // r8
  char *v22; // rdx
  unsigned __int8 v23; // cl
  char v24; // r9
  unsigned __int8 v25; // r8
  char v27; // [rsp+0h] [rbp-10h] BYREF
  char v28; // [rsp+1h] [rbp-Fh]
  char v29[14]; // [rsp+2h] [rbp-Eh] BYREF

  v2 = (unsigned __int8 *)(a1 + 2);
  v3 = (char *)(*a2 + 5i64);
  v5 = 4i64;
  do
  {
    v6 = &v27;
    v27 = *(v3 - 5);
    v7 = 0;
    v8 = 0;
    v28 = *(v3 - 4);
    v29[0] = 0;
    do
    {
      v9 = byte_146127D10[(unsigned __int8)*v6];
      if ( v9 >= 0x10u )
        break;
      if ( v7 < 0x10u )
        v7 = v9 + 16 * v7;
      else
        v8 = 1;
      ++v6;
    }
    while ( v6 != v29 );
    if ( v6 != &v27 && !v8 )
      *(v2 - 2) = v7;
    v10 = &v27;
    v27 = *(v3 - 3);
    v11 = 0;
    v12 = 0;
    v28 = *(v3 - 2);
    do
    {
      v13 = byte_146127D10[(unsigned __int8)*v10];
      if ( v13 >= 0x10u )
        break;
      if ( v11 < 0x10u )
        v11 = v13 + 16 * v11;
      else
        v12 = 1;
      ++v10;
    }
    while ( v10 != v29 );
    if ( v10 != &v27 && !v12 )
      *(v2 - 1) = v11;
    v14 = &v27;
    v27 = *(v3 - 1);
    v15 = 0;
    v16 = 0;
    v28 = *v3;
    do
    {
      v17 = byte_146127D10[(unsigned __int8)*v14];
      if ( v17 >= 0x10u )
        break;
      if ( v15 < 0x10u )
        v15 = v17 + 16 * v15;
      else
        v16 = 1;
      ++v14;
    }
    while ( v14 != v29 );
    if ( v14 != &v27 && !v16 )
      *v2 = v15;
    v18 = &v27;
    v27 = v3[1];
    v19 = 0;
    v20 = 0;
    v28 = v3[2];
    do
    {
      v21 = byte_146127D10[(unsigned __int8)*v18];
      if ( v21 >= 0x10u )
        break;
      if ( v19 < 0x10u )
        v19 = v21 + 16 * v19;
      else
        v20 = 1;
      ++v18;
    }
    while ( v18 != v29 );
    if ( v18 != &v27 && !v20 )
      v2[1] = v19;
    v22 = &v27;
    v27 = v3[3];
    v23 = 0;
    v24 = 0;
    v28 = v3[4];
    do
    {
      v25 = byte_146127D10[(unsigned __int8)*v22];
      if ( v25 >= 0x10u )
        break;
      if ( v23 < 0x10u )
        v23 = v25 + 16 * v23;
      else
        v24 = 1;
      ++v22;
    }
    while ( v22 != v29 );
    if ( v22 != &v27 && !v24 )
      v2[2] = v23;
    v3 += 10;
    v2 += 5;
    --v5;
  }
  while ( v5 );
  return a1;
}
// 146127D10: using guessed type _BYTE byte_146127D10[256];

//----- (0000000146176F80) ----------------------------------------------------
_QWORD *__fastcall sub_146176F80(__int64 a1, _QWORD *a2)
{
  _QWORD *result; // rax

  result = sub_14615A5E0(++*a2);
  --*a2;
  return result;
}

//----- (0000000146176FA0) ----------------------------------------------------
void __fastcall sub_146176FA0(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4)
{
  char *v7; // rbx
  __int64 v8; // r8
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rsi
  char *j; // rdi
  _QWORD *v13; // rdi
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rbx
  char *v17; // rdi
  unsigned __int64 v18; // r13
  size_t *v19; // rsi
  size_t *v20; // rbp
  void *v21; // rdx
  unsigned __int64 v22; // r14
  __int64 v23; // rbx
  char *v24; // rbp
  size_t *v25; // rdi
  size_t *v26; // rsi
  void *v27; // rdx
  char *v28; // rdi
  char *i; // rbx

  v7 = *(char **)a1;
  v8 = *(_QWORD *)(a1 + 16) - *(_QWORD *)a1;
  v9 = v8 / 80;
  if ( a3 <= v8 / 80 )
  {
    v17 = *(char **)(a1 + 8);
    v18 = (v17 - v7) / 80;
    if ( a3 <= v18 )
    {
      v24 = &v7[80 * a3];
      if ( a3 )
      {
        v25 = (size_t *)(a2 + 40);
        v26 = (size_t *)(v7 + 40);
        do
        {
          *(_OWORD *)v7 = *(_OWORD *)(v25 - 5);
          *((_DWORD *)v7 + 4) = *((_DWORD *)v25 - 6);
          *(_OWORD *)((char *)v26 - 20) = *(_OWORD *)((char *)v25 - 20);
          *((_DWORD *)v26 - 1) = *((_DWORD *)v25 - 1);
          if ( v26 != v25 )
          {
            v27 = v25;
            if ( v25[3] > 0xF )
              v27 = (void *)*v25;
            sub_14617D4E0((void **)v26, v27, v25[2], a4);
          }
          v26[4] = v25[4];
          v7 += 80;
          v26 += 10;
          v25 += 10;
          --a3;
        }
        while ( a3 );
      }
      v28 = *(char **)(a1 + 8);
      for ( i = v24; i != v28; i += 80 )
        sub_1461626B0((__int64)(i + 40));
      *(_QWORD *)(a1 + 8) = v24;
    }
    else
    {
      if ( v7 != v17 )
      {
        v19 = (size_t *)(a2 + 40);
        v20 = (size_t *)(v7 + 40);
        do
        {
          *(_OWORD *)v7 = *(_OWORD *)a2;
          *((_DWORD *)v7 + 4) = *(_DWORD *)(a2 + 16);
          *(_OWORD *)((char *)v20 - 20) = *(_OWORD *)((char *)v19 - 20);
          *((_DWORD *)v20 - 1) = *((_DWORD *)v19 - 1);
          if ( v20 != v19 )
          {
            v21 = v19;
            if ( v19[3] > 0xF )
              v21 = (void *)*v19;
            sub_14617D4E0((void **)v20, v21, v19[2], a4);
          }
          v20[4] = v19[4];
          v7 += 80;
          v20 += 10;
          a2 += 80i64;
          v19 += 10;
          v17 = *(char **)(a1 + 8);
        }
        while ( v7 != v17 );
      }
      v22 = a3 - v18;
      if ( v22 )
      {
        v23 = a2 + 40;
        do
        {
          *(_OWORD *)v17 = *(_OWORD *)(v23 - 40);
          *((_DWORD *)v17 + 4) = *(_DWORD *)(v23 - 24);
          *(_OWORD *)(v17 + 20) = *(_OWORD *)(v23 - 20);
          *((_DWORD *)v17 + 9) = *(_DWORD *)(v23 - 4);
          sub_146170E60((__int64)(v17 + 40), v23, v8, a4);
          *((_QWORD *)v17 + 9) = *(_QWORD *)(v23 + 32);
          v17 += 80;
          v23 += 80i64;
          --v22;
        }
        while ( v22 );
      }
      *(_QWORD *)(a1 + 8) = v17;
    }
  }
  else
  {
    if ( a3 > 0x333333333333333i64 )
      unknown_libname_6(a1, v9, v8);
    v10 = v9 >> 1;
    if ( v9 <= 0x333333333333333i64 - (v9 >> 1) )
    {
      v11 = v9 + v10;
      if ( v9 + v10 < a3 )
        v11 = a3;
    }
    else
    {
      v11 = 0x333333333333333i64;
    }
    if ( v7 )
    {
      for ( j = *(char **)(a1 + 8); v7 != j; v7 += 80 )
        sub_1461626B0((__int64)(v7 + 40));
      sub_14617D7A0(a1, *(void **)a1, (*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) / 80i64);
      *(_QWORD *)a1 = 0i64;
      *(_QWORD *)(a1 + 8) = 0i64;
      *(_QWORD *)(a1 + 16) = 0i64;
    }
    if ( v11 > 0x333333333333333i64 )
      sub_146165390(v10, v9, v8);
    v13 = sub_14615A5E0(80 * v11);
    *(_QWORD *)a1 = v13;
    *(_QWORD *)(a1 + 8) = v13;
    *(_QWORD *)(a1 + 16) = &v13[10 * v11];
    if ( a3 )
    {
      v16 = a2 + 40;
      do
      {
        *(_OWORD *)v13 = *(_OWORD *)(v16 - 40);
        *((_DWORD *)v13 + 4) = *(_DWORD *)(v16 - 24);
        *(_OWORD *)((char *)v13 + 20) = *(_OWORD *)(v16 - 20);
        *((_DWORD *)v13 + 9) = *(_DWORD *)(v16 - 4);
        sub_146170E60((__int64)(v13 + 5), v16, v14, v15);
        v13[9] = *(_QWORD *)(v16 + 32);
        v13 += 10;
        v16 += 80i64;
        --a3;
      }
      while ( a3 );
    }
    *(_QWORD *)(a1 + 8) = v13;
  }
}
// 1461770F4: variable 'v14' is possibly undefined
// 1461770F4: variable 'v15' is possibly undefined
// 146177195: variable 'a4' is possibly undefined
// 146177202: variable 'v8' is possibly undefined
// 1461772E7: variable 'v10' is possibly undefined
// 1461772E7: variable 'v9' is possibly undefined
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (0000000146177300) ----------------------------------------------------
void __fastcall sub_146177300(__int64 *a1, _QWORD *a2, unsigned __int64 a3)
{
  _QWORD *v4; // rbx
  __int64 v6; // rdi
  __int64 v7; // r8
  __int64 v8; // r8
  _QWORD *j; // rdi
  _QWORD *v10; // rbp
  unsigned __int64 v11; // r15
  unsigned __int64 i; // rsi
  const void **v13; // rbx
  __int64 *v14; // r9
  const void **v15; // rdx
  _QWORD *v16; // rdi
  _QWORD *v17; // rbx

  v4 = a2;
  v6 = *a1;
  v7 = 0x8888888888888889ui64;
  if ( a3 <= (a1[2] - *a1) / 120 )
  {
    v10 = (_QWORD *)a1[1];
    v11 = ((__int64)v10 - v6) / 120;
    if ( a3 <= v11 )
    {
      v10 = (_QWORD *)(v6 + 120 * a3);
      if ( a3 )
      {
        v13 = (const void **)(a2 + 14);
        do
        {
          *(_QWORD *)v6 = *(v13 - 14);
          sub_1461793E0((void **)(v6 + 8), v13 - 13);
          *(_QWORD *)(v6 + 32) = *(v13 - 10);
          *(_QWORD *)(v6 + 40) = *(v13 - 9);
          *(_QWORD *)(v6 + 48) = *(v13 - 8);
          *(_QWORD *)(v6 + 56) = *(v13 - 7);
          v14 = (__int64 *)(v13 - 6);
          if ( (const void **)(v6 + 64) != v13 - 6 )
            sub_146176FA0(v6 + 64, *v14, ((__int64)*(v13 - 5) - *v14) / 80, (__int64)v14);
          v15 = v13 - 3;
          if ( (const void **)(v6 + 88) != v13 - 3 )
          {
            if ( (unsigned __int64)*v13 > 7 )
              v15 = (const void **)*v15;
            sub_14617D600((void **)(v6 + 88), v15, (unsigned __int64)*(v13 - 1), (__int64)v14);
          }
          v6 += 120i64;
          v13 += 15;
          --a3;
        }
        while ( a3 );
      }
      v16 = (_QWORD *)a1[1];
      if ( v10 != v16 )
      {
        v17 = v10 + 8;
        do
        {
          sub_146162730((__int64)(v17 + 3));
          sub_14617D330(v17);
          sub_146166C80((__int64)(v17 - 7));
          v17 += 15;
        }
        while ( v17 - 8 != v16 );
      }
    }
    else
    {
      for ( ; (_QWORD *)v6 != v10; v10 = (_QWORD *)a1[1] )
      {
        sub_146179580(v6, (__int64)v4);
        v6 += 120i64;
        v4 += 15;
      }
      for ( i = a3 - v11; i; --i )
      {
        sub_146178F20(v10, v4, v7);
        v10 += 15;
        v4 += 15;
      }
    }
    a1[1] = (__int64)v10;
  }
  else
  {
    sub_14617D1B0(a1, a3);
    for ( j = (_QWORD *)*a1; a3; --a3 )
    {
      sub_146178F20(j, v4, v8);
      j += 15;
      v4 += 15;
    }
    a1[1] = (__int64)j;
  }
}
// 146177386: variable 'v8' is possibly undefined
// 146177409: variable 'v7' is possibly undefined
// 1461774CE: variable 'v14' is possibly undefined

//----- (0000000146177540) ----------------------------------------------------
_QWORD *__fastcall sub_146177540(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rbp
  _QWORD *v7; // rsi
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8

  v6 = *a1;
  if ( *(_BYTE *)(a2 + 25) )
    return (_QWORD *)*a1;
  v7 = operator new(0xB8ui64);
  sub_146170E60((__int64)(v7 + 4), a2 + 32, v8, v9);
  sub_146178F20(v7 + 8, (_QWORD *)(a2 + 64), v10);
  *v7 = v6;
  v7[2] = v6;
  *((_WORD *)v7 + 12) = 0;
  v7[1] = a3;
  *((_BYTE *)v7 + 24) = *(_BYTE *)(a2 + 24);
  *v7 = sub_146177540(a1, *(_QWORD *)a2, v7);
  v7[2] = sub_146177540(a1, *(_QWORD *)(a2 + 16), v7);
  return v7;
}
// 1461775A3: variable 'v8' is possibly undefined
// 1461775A3: variable 'v9' is possibly undefined
// 1461775B1: variable 'v10' is possibly undefined

//----- (0000000146177630) ----------------------------------------------------
__int64 __fastcall sub_146177630(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v5; // r13
  __int64 v6; // rbp
  _QWORD *v7; // r15
  __int64 v8; // r8
  _QWORD *v9; // rsi
  _QWORD *v10; // rdi
  size_t v11; // rbp
  _QWORD *v12; // rcx
  const void *v13; // rdx
  size_t v14; // rbx
  size_t v15; // r8
  unsigned int v16; // eax
  unsigned int v17; // eax
  _QWORD *v18; // rax
  _OWORD *v19; // rdi
  __int64 v20; // r8
  __int64 v21; // r9
  __int128 v23; // [rsp+30h] [rbp-58h] BYREF
  __int128 v24; // [rsp+40h] [rbp-48h]
  __int64 v25; // [rsp+90h] [rbp+8h]

  v5 = (_QWORD *)a1;
  v6 = *(_QWORD *)a1;
  v25 = *(_QWORD *)a1;
  v7 = *(_QWORD **)(*(_QWORD *)a1 + 8i64);
  v8 = 0i64;
  v9 = *(_QWORD **)a1;
  if ( !*((_BYTE *)v7 + 25) )
  {
    v10 = *(_QWORD **)(v6 + 8);
    v11 = *(_QWORD *)(a3 + 16);
    do
    {
      v7 = v10;
      v12 = v10 + 4;
      v13 = (const void *)a3;
      if ( *(_QWORD *)(a3 + 24) > 0xFui64 )
        v13 = *(const void **)a3;
      v14 = v10[6];
      if ( v10[7] > 0xFui64 )
        v12 = (_QWORD *)*v12;
      v15 = v10[6];
      if ( v11 < v14 )
        v15 = v11;
      v16 = memcmp(v12, v13, v15);
      if ( !v16 )
      {
        if ( v14 >= v11 )
          v16 = v14 > v11;
        else
          v16 = -1;
      }
      v17 = v16 >> 31;
      a1 = (unsigned __int8)v17;
      v8 = (unsigned __int8)v17 ^ 1u;
      if ( !(_BYTE)v17 )
        v9 = v10;
      v18 = v10 + 2;
      if ( !(_BYTE)a1 )
        v18 = v10;
      v10 = (_QWORD *)*v18;
    }
    while ( !*(_BYTE *)(*v18 + 25i64) );
    v6 = v25;
  }
  *(_QWORD *)&v24 = v7;
  DWORD2(v24) = v8;
  if ( *((_BYTE *)v9 + 25) || (unsigned __int8)sub_1461797D0((__int64)v5, (size_t *)a3, (const void **)v9 + 4) )
  {
    if ( v5[1] == 0x2AAAAAAAAAAAAAAi64 )
      unknown_libname_3(a1, a2, v8);
    *(_QWORD *)&v23 = v5;
    v19 = operator new(0x60ui64);
    *((_QWORD *)&v23 + 1) = v19;
    sub_146170E60((__int64)(v19 + 2), a3, v20, v21);
    v19[4] = 0i64;
    *((_QWORD *)v19 + 10) = 0i64;
    *((_QWORD *)v19 + 11) = 0i64;
    v19[4] = *(_OWORD *)(a3 + 32);
    v19[5] = *(_OWORD *)(a3 + 48);
    *(_QWORD *)(a3 + 48) = 0i64;
    *(_QWORD *)(a3 + 56) = 15i64;
    *(_BYTE *)(a3 + 32) = 0;
    *(_QWORD *)v19 = v6;
    *((_QWORD *)v19 + 1) = v6;
    *((_QWORD *)v19 + 2) = v6;
    *((_WORD *)v19 + 12) = 0;
    v23 = v24;
    *(_QWORD *)a2 = sub_146165130(v5, (__int64)&v23, (__int64)v19);
    *(_BYTE *)(a2 + 8) = 1;
  }
  else
  {
    *(_QWORD *)a2 = v9;
    *(_BYTE *)(a2 + 8) = 0;
  }
  return a2;
}
// 14617776B: variable 'v20' is possibly undefined
// 14617776B: variable 'v21' is possibly undefined
// 1461777F7: variable 'a1' is possibly undefined
// 1461777F7: variable 'a2' is possibly undefined
// 1461777F7: variable 'v8' is possibly undefined
// 1461653B0: using guessed type void __fastcall __noreturn unknown_libname_3(_QWORD, _QWORD, _QWORD);

//----- (0000000146177800) ----------------------------------------------------
_QWORD *__fastcall sub_146177800(__int64 *a1, __int64 a2, _QWORD *a3)
{
  __int64 v4; // rdi
  __int64 v6; // r10
  __int64 v7; // rbx
  __int64 v8; // rcx
  __int64 v9; // rdx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // r14
  _QWORD *v14; // r15
  _QWORD *v15; // r13
  __int64 v16; // rsi
  __int64 v17; // r8
  __int64 v18; // rbp
  __int64 v19; // rbx
  __int64 i; // rdi
  __int64 j; // rbp
  __int64 k; // rbx
  __int64 *v24; // [rsp+28h] [rbp-50h] BYREF
  _QWORD *v25; // [rsp+30h] [rbp-48h]
  unsigned __int64 v26; // [rsp+38h] [rbp-40h]
  _QWORD *v27; // [rsp+40h] [rbp-38h]
  _QWORD *v28; // [rsp+48h] [rbp-30h]
  __int64 v29; // [rsp+80h] [rbp+8h]

  v4 = a2;
  v6 = *a1;
  v7 = (a2 - *a1) / 120;
  v8 = a1[1] - *a1;
  v9 = v8 / 120;
  v29 = v8 / 120;
  if ( v8 / 120 == 0x222222222222222i64 )
    unknown_libname_6(v8, v9, a3);
  v10 = v9 + 1;
  v11 = (a1[2] - v6) / 120;
  v12 = v11 >> 1;
  if ( v11 <= 0x222222222222222i64 - (v11 >> 1) )
  {
    v13 = v10;
    if ( v12 + v11 >= v10 )
      v13 = v12 + v11;
    if ( v13 > 0x222222222222222i64 )
      sub_146165390(v12, v11, v10);
  }
  else
  {
    v13 = 0x222222222222222i64;
  }
  v14 = sub_14615A5E0(120 * v13);
  v15 = &v14[15 * v7];
  v16 = (__int64)(v15 + 15);
  v24 = a1;
  v25 = v14;
  v26 = v13;
  v28 = v15 + 15;
  sub_146178F20(v15, a3, v17);
  v27 = v15;
  v18 = a1[1];
  v19 = *a1;
  if ( v4 == v18 )
  {
    for ( i = (__int64)v14; v19 != v18; v19 += 120i64 )
    {
      sub_146178E60(i, v19);
      i += 120i64;
    }
  }
  else
  {
    for ( j = (__int64)v14; v19 != v4; v19 += 120i64 )
    {
      sub_146178E60(j, v19);
      j += 120i64;
    }
    v27 = v14;
    for ( k = a1[1]; v4 != k; v4 += 120i64 )
    {
      sub_146178E60(v16, v4);
      v16 += 120i64;
    }
  }
  v25 = 0i64;
  sub_14617D0A0(a1, (__int64)v14, v29 + 1, v13);
  sub_146179330(&v24);
  return v15;
}
// 1461778FE: variable 'v17' is possibly undefined
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (0000000146177A10) ----------------------------------------------------
__int64 __fastcall sub_146177A10(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r10
  __int64 v4; // rdi
  __int64 v5; // r9
  __int64 v7; // rcx
  __int64 v9; // rbx
  __int64 v10; // rdx
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r14
  _QWORD *v15; // rax
  __int64 v16; // r13
  __int64 v17; // r15
  __int64 v18; // rsi
  __int64 v19; // rbp
  __int64 v20; // rbx
  __int64 i; // rdi
  __int64 j; // rbp
  __int64 v23; // rbx
  __int64 v25[3]; // [rsp+20h] [rbp-58h] BYREF
  __int64 k; // [rsp+38h] [rbp-40h]
  __int64 v27; // [rsp+40h] [rbp-38h]
  __int64 v28; // [rsp+80h] [rbp+8h]

  v3 = *a1;
  v4 = a2;
  v5 = a2 - *a1;
  v7 = a1[1] - *a1;
  v9 = v5 / 120;
  v10 = v7 / 120;
  v28 = v7 / 120;
  if ( v7 / 120 == 0x222222222222222i64 )
    unknown_libname_6(v7, v10, a3);
  v11 = v10 + 1;
  v12 = (a1[2] - v3) / 120;
  v13 = v12 >> 1;
  if ( v12 <= 0x222222222222222i64 - (v12 >> 1) )
  {
    v14 = v11;
    if ( v13 + v12 >= v11 )
      v14 = v13 + v12;
    if ( v14 > 0x222222222222222i64 )
      sub_146165390(v13, v12, v11);
  }
  else
  {
    v14 = 0x222222222222222i64;
  }
  v15 = sub_14615A5E0(120 * v14);
  v25[0] = (__int64)a1;
  v16 = (__int64)&v15[15 * v9];
  v25[2] = v14;
  v17 = (__int64)v15;
  v18 = v16 + 120;
  v27 = v16 + 120;
  sub_146178E60(v16, a3);
  v19 = a1[1];
  v20 = *a1;
  k = v16;
  if ( v4 == v19 )
  {
    for ( i = v17; v20 != v19; v20 += 120i64 )
    {
      sub_146178E60(i, v20);
      i += 120i64;
    }
  }
  else
  {
    for ( j = v17; v20 != v4; v20 += 120i64 )
    {
      sub_146178E60(j, v20);
      j += 120i64;
    }
    v23 = a1[1];
    for ( k = v17; v4 != v23; v4 += 120i64 )
    {
      sub_146178E60(v18, v4);
      v18 += 120i64;
    }
  }
  v25[1] = 0i64;
  sub_14617D0A0(a1, v17, v28 + 1, v14);
  sub_146179330(v25);
  return v16;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (0000000146177C20) ----------------------------------------------------
void __fastcall sub_146177C20(__int64 a1, __int64 a2, void **a3)
{
  void **v3; // rbx
  void **v6; // rdi

  v3 = a3;
  while ( !*((_BYTE *)v3 + 25) )
  {
    sub_146177C20(a1, a2, v3[2]);
    v6 = v3;
    v3 = (void **)*v3;
    sub_146177CC0((__int64)(v6 + 5), (__int64)(v6 + 5), *((__int64 **)v6[5] + 1));
    j_j_free(v6[5]);
    j_j_free(v6);
  }
}

//----- (0000000146177CC0) ----------------------------------------------------
void __fastcall sub_146177CC0(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // rbx
  _QWORD *v6; // rsi

  v3 = a3;
  while ( !*((_BYTE *)v3 + 25) )
  {
    sub_146177CC0(a1, a2, v3[2]);
    v6 = v3;
    v3 = (__int64 *)*v3;
    sub_146162730((__int64)(v6 + 19));
    sub_14617D330(v6 + 16);
    sub_146166C80((__int64)(v6 + 9));
    sub_1461626B0((__int64)(v6 + 4));
    j_j_free(v6);
  }
}

//----- (0000000146177D60) ----------------------------------------------------
void __fastcall sub_146177D60(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rbx
  void *v6; // rsi

  v3 = (_QWORD *)a3;
  if ( !*(_BYTE *)(a3 + 25) )
  {
    do
    {
      sub_146177D60(a1, a2, v3[2]);
      v6 = v3;
      v3 = (_QWORD *)*v3;
      sub_1461626B0((__int64)v6 + 64);
      sub_1461626B0((__int64)v6 + 32);
      j_j_free(v6);
    }
    while ( !*((_BYTE *)v3 + 25) );
  }
}

//----- (0000000146177DF0) ----------------------------------------------------
__int64 __fastcall sub_146177DF0(_QWORD **a1, __int64 a2, __int64 *a3, int *a4)
{
  _QWORD *v5; // rbx
  int v7; // r8d
  __int64 result; // rax
  int v9; // eax
  __int64 *i; // rax
  __int64 *v11; // rcx
  __int64 *j; // rcx
  char v13; // dl
  __int64 *v14; // rdx
  __int64 *v15; // rax
  __int64 **v16; // rcx
  __int64 *v17; // rcx
  __int64 *v18; // rax
  _QWORD *v19; // rdx
  char v20; // cl
  __int128 v21; // [rsp+0h] [rbp-28h]

  v5 = *a1;
  if ( *((_BYTE *)a3 + 25) )
  {
    if ( *(_BYTE *)(v5[1] + 25i64) || (v7 = *a4, *(_DWORD *)(v5[2] + 32i64) < *a4) )
    {
      *(_QWORD *)a2 = v5[2];
      result = a2;
      *(_BYTE *)(a2 + 16) = 0;
      *(_DWORD *)(a2 + 8) = 0;
      return result;
    }
    goto LABEL_33;
  }
  v9 = *((_DWORD *)a3 + 8);
  v7 = *a4;
  if ( a3 == (__int64 *)*v5 )
  {
    if ( v7 < v9 )
    {
      *(_QWORD *)a2 = a3;
      result = a2;
      *(_DWORD *)(a2 + 8) = 1;
      *(_BYTE *)(a2 + 16) = 0;
      return result;
    }
    goto LABEL_33;
  }
  if ( v7 < v9 )
  {
    i = (__int64 *)*a3;
    v11 = a3;
    if ( *(_BYTE *)(*a3 + 25) )
    {
      for ( i = (__int64 *)a3[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
      {
        if ( v11 != (__int64 *)*i )
          break;
        v11 = i;
      }
      if ( *((_BYTE *)v11 + 25) )
        i = v11;
    }
    else
    {
      for ( j = (__int64 *)i[2]; !*((_BYTE *)j + 25); j = (__int64 *)j[2] )
        i = j;
    }
    if ( *((_DWORD *)i + 8) < v7 )
    {
      v13 = *(_BYTE *)(i[2] + 25);
      *(_BYTE *)(a2 + 16) = 0;
      if ( v13 )
      {
        *(_QWORD *)a2 = i;
        *(_DWORD *)(a2 + 8) = 0;
        return a2;
      }
      else
      {
        *(_QWORD *)a2 = a3;
        result = a2;
        *(_DWORD *)(a2 + 8) = 1;
      }
      return result;
    }
    goto LABEL_33;
  }
  if ( v7 <= v9 )
  {
    *(_DWORD *)(a2 + 8) = 0;
    result = a2;
    *(_QWORD *)a2 = a3;
    *(_BYTE *)(a2 + 16) = 1;
    return result;
  }
  v14 = (__int64 *)a3[2];
  if ( *((_BYTE *)v14 + 25) )
  {
    v14 = (__int64 *)a3[1];
    if ( *((_BYTE *)v14 + 25) )
    {
LABEL_42:
      v20 = *(_BYTE *)(a3[2] + 25);
      result = a2;
      *(_BYTE *)(a2 + 16) = 0;
      if ( v20 )
      {
        *(_QWORD *)a2 = a3;
        *(_DWORD *)(a2 + 8) = 0;
      }
      else
      {
        *(_QWORD *)a2 = v14;
        *(_DWORD *)(a2 + 8) = 1;
      }
      return result;
    }
    v15 = a3;
    do
    {
      v16 = (__int64 **)v14;
      if ( v15 != (__int64 *)v14[2] )
        break;
      v14 = (__int64 *)v14[1];
      v15 = (__int64 *)v16;
    }
    while ( !*((_BYTE *)v14 + 25) );
  }
  else
  {
    v17 = (__int64 *)*v14;
    if ( !*(_BYTE *)(*v14 + 25) )
    {
      do
      {
        v14 = v17;
        v17 = (__int64 *)*v17;
      }
      while ( !*((_BYTE *)v17 + 25) );
    }
  }
  if ( *((_BYTE *)v14 + 25) || v7 < *((_DWORD *)v14 + 8) )
    goto LABEL_42;
LABEL_33:
  v18 = (__int64 *)v5[1];
  v19 = v5;
  *(_QWORD *)&v21 = v18;
  for ( DWORD2(v21) = 0; !*((_BYTE *)v18 + 25); v18 = (__int64 *)*v18 )
  {
    *(_QWORD *)&v21 = v18;
    if ( *((_DWORD *)v18 + 8) >= v7 )
    {
      DWORD2(v21) = 1;
      v19 = v18;
    }
    else
    {
      DWORD2(v21) = 0;
      v18 += 2;
    }
  }
  if ( *((_BYTE *)v19 + 25) || *a4 < *((_DWORD *)v19 + 8) )
  {
    *(_BYTE *)(a2 + 16) = 0;
    result = a2;
    *(_OWORD *)a2 = v21;
  }
  else
  {
    *(_QWORD *)a2 = v19;
    result = a2;
    *(_DWORD *)(a2 + 8) = 2;
    *(_BYTE *)(a2 + 16) = 1;
  }
  return result;
}
// 146177FFD: variable 'v21' is possibly undefined

//----- (0000000146178070) ----------------------------------------------------
__int64 __fastcall sub_146178070(__int64 *a1, __int64 a2, __int64 a3, const void **a4)
{
  _QWORD *v5; // rax
  _QWORD *v9; // rbx
  const void **v10; // r8
  __int64 i; // rbx
  __int64 v12; // rax
  __int64 j; // rax
  char v14; // cl
  __int64 result; // rax
  __int64 *v16; // rax
  __int64 v17; // rbx
  __int64 v18; // rbx
  __int128 v19; // xmm0
  char v20; // cl
  __int128 v21; // [rsp+20h] [rbp-38h] BYREF
  __int64 v22; // [rsp+30h] [rbp-28h]
  __int64 v23; // [rsp+60h] [rbp+8h] BYREF

  v5 = (_QWORD *)*a1;
  if ( *(_BYTE *)(a3 + 25) )
  {
    v9 = v5 + 2;
    if ( *(_BYTE *)(v5[1] + 25i64) || (unsigned __int8)sub_1461797D0((__int64)a1, (size_t *)(*v9 + 32i64), a4) )
    {
      *(_QWORD *)a2 = *v9;
      *(_BYTE *)(a2 + 16) = 0;
LABEL_33:
      *(_DWORD *)(a2 + 8) = 0;
      return a2;
    }
    goto LABEL_25;
  }
  v10 = (const void **)(a3 + 32);
  if ( a3 == *v5 )
  {
    if ( (unsigned __int8)sub_1461797D0((__int64)a1, (size_t *)a4, v10) )
    {
      *(_QWORD *)a2 = a3;
      *(_DWORD *)(a2 + 8) = 1;
      *(_BYTE *)(a2 + 16) = 0;
      return a2;
    }
    goto LABEL_25;
  }
  if ( (unsigned __int8)sub_1461797D0((__int64)a1, (size_t *)a4, v10) )
  {
    i = *(_QWORD *)a3;
    v12 = a3;
    if ( *(_BYTE *)(*(_QWORD *)a3 + 25i64) )
    {
      for ( i = *(_QWORD *)(a3 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
      {
        if ( v12 != *(_QWORD *)i )
          break;
        v12 = i;
      }
      if ( *(_BYTE *)(v12 + 25) )
        i = v12;
    }
    else
    {
      for ( j = *(_QWORD *)(i + 16); !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 16) )
        i = j;
    }
    if ( !(unsigned __int8)sub_1461797D0((__int64)a1, (size_t *)(i + 32), a4) )
      goto LABEL_25;
    v14 = *(_BYTE *)(*(_QWORD *)(i + 16) + 25i64);
    result = a2;
    *(_BYTE *)(a2 + 16) = 0;
    if ( v14 )
    {
      *(_QWORD *)a2 = i;
      *(_DWORD *)(a2 + 8) = 0;
    }
    else
    {
      *(_QWORD *)a2 = a3;
      *(_DWORD *)(a2 + 8) = 1;
    }
  }
  else
  {
    if ( !(unsigned __int8)sub_1461797D0((__int64)a1, (size_t *)(a3 + 32), a4) )
    {
      *(_QWORD *)a2 = a3;
      *(_BYTE *)(a2 + 16) = 1;
      goto LABEL_33;
    }
    v23 = a3;
    v16 = sub_146179760(&v23);
    v17 = *v16;
    if ( !*(_BYTE *)(*v16 + 25) && !(unsigned __int8)sub_1461797D0((__int64)a1, (size_t *)a4, (const void **)(v17 + 32)) )
    {
LABEL_25:
      sub_146178280(a1, (__int64)&v21, a4);
      v18 = v22;
      if ( *(_BYTE *)(v22 + 25) || (unsigned __int8)sub_1461797D0((__int64)a1, (size_t *)a4, (const void **)(v22 + 32)) )
      {
        v19 = v21;
        *(_BYTE *)(a2 + 16) = 0;
        *(_OWORD *)a2 = v19;
      }
      else
      {
        *(_QWORD *)a2 = v18;
        *(_DWORD *)(a2 + 8) = 2;
        *(_BYTE *)(a2 + 16) = 1;
      }
      return a2;
    }
    v20 = *(_BYTE *)(*(_QWORD *)(a3 + 16) + 25i64);
    result = a2;
    *(_BYTE *)(a2 + 16) = 0;
    if ( v20 )
    {
      *(_QWORD *)a2 = a3;
      *(_DWORD *)(a2 + 8) = 0;
    }
    else
    {
      *(_QWORD *)a2 = v17;
      *(_DWORD *)(a2 + 8) = 1;
    }
  }
  return result;
}

//----- (0000000146178280) ----------------------------------------------------
__int64 __fastcall sub_146178280(__int64 *a1, __int64 a2, const void **a3)
{
  __int64 v3; // rax
  __int64 *v6; // rbx
  bool v7; // cc
  _QWORD *v8; // rcx
  size_t v9; // rbp
  const void *v10; // rdx
  size_t v11; // rsi
  size_t v12; // r8
  int v13; // eax
  int v14; // eax

  v3 = *a1;
  *(_DWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = v3;
  v6 = *(__int64 **)(v3 + 8);
  for ( *(_QWORD *)a2 = v6; !*((_BYTE *)v6 + 25); *(_DWORD *)(a2 + 8) = v14 )
  {
    v7 = (unsigned __int64)a3[3] <= 0xF;
    v8 = v6 + 4;
    v9 = (size_t)a3[2];
    v10 = a3;
    *(_QWORD *)a2 = v6;
    if ( !v7 )
      v10 = *a3;
    v11 = v6[6];
    if ( (unsigned __int64)v6[7] > 0xF )
      v8 = (_QWORD *)*v8;
    v12 = v6[6];
    if ( v9 < v11 )
      v12 = v9;
    v13 = memcmp(v8, v10, v12);
    if ( !v13 )
    {
      if ( v11 >= v9 )
        v13 = v11 > v9;
      else
        v13 = -1;
    }
    if ( v13 >= 0 )
    {
      *(_QWORD *)(a2 + 16) = v6;
      v14 = 1;
    }
    else
    {
      v14 = 0;
      v6 += 2;
    }
    v6 = (__int64 *)*v6;
  }
  return a2;
}

//----- (0000000146178350) ----------------------------------------------------
_QWORD *__fastcall sub_146178350(_QWORD *Src, unsigned __int64 a2, __int64 a3, size_t a4, void *Srca, size_t Size)
{
  __int64 v6; // rsi
  __int64 v7; // rbx
  __int64 v10; // rbp
  unsigned __int64 v11; // r14
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rdx
  _QWORD *v14; // rax
  size_t v15; // rsi
  _QWORD *v16; // r15
  char *v17; // rbp
  char *v18; // rbx
  _QWORD *v19; // rbx

  v6 = Src[2];
  v7 = 0x7FFFFFFFFFFFFFFFi64;
  if ( 0x7FFFFFFFFFFFFFFFi64 - v6 < a2 )
    unknown_libname_4(Src, a2, a3, a4);
  v10 = v6 + a2;
  v11 = Src[3];
  v12 = (v6 + a2) | 0xF;
  if ( v12 <= 0x7FFFFFFFFFFFFFFFi64 )
  {
    v13 = v11 >> 1;
    if ( v11 <= 0x7FFFFFFFFFFFFFFFi64 - (v11 >> 1) )
    {
      v7 = v12;
      if ( v12 < v11 + v13 )
        v7 = v11 + v13;
    }
  }
  v14 = sub_14615A5E0(v7 + 1);
  v15 = v6 - a4;
  Src[3] = v7;
  v16 = v14;
  Src[2] = v10;
  v17 = (char *)v14 + a4;
  v18 = (char *)v14 + a4 + Size;
  if ( v11 <= 0xF )
  {
    memcpy(v14, Src, a4);
    memcpy(v17, Srca, Size);
    memcpy(v18, (char *)Src + a4, v15 + 1);
  }
  else
  {
    v19 = (_QWORD *)*Src;
    memcpy(v14, (const void *)*Src, a4);
    memcpy(v17, Srca, Size);
    memcpy(&v17[Size], (char *)v19 + a4, v15 + 1);
    if ( v11 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)v19 - *(v19 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v19 = (_QWORD *)*(v19 - 1);
    }
    j_j_free(v19);
  }
  *Src = v16;
  return Src;
}
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001461784D0) ----------------------------------------------------
_QWORD *__fastcall sub_1461784D0(_QWORD *a1, __int128 *a2, __int128 *a3)
{
  _BYTE *v4; // rcx
  __int128 v6; // [rsp+40h] [rbp-268h] BYREF
  __int64 v7; // [rsp+50h] [rbp-258h]
  __int128 v8; // [rsp+60h] [rbp-248h] BYREF
  void **v9; // [rsp+70h] [rbp-238h] BYREF
  void *Block; // [rsp+78h] [rbp-230h]
  size_t v11; // [rsp+80h] [rbp-228h]
  unsigned __int64 v12; // [rsp+88h] [rbp-220h]
  char v13[512]; // [rsp+90h] [rbp-218h] BYREF

  v7 = -2i64;
  *(_QWORD *)&v6 = a1;
  v11 = 0i64;
  v9 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  Block = v13;
  v12 = 500i64;
  v6 = *a3;
  v8 = *a2;
  sub_14615CF80((__int64)&v9, (__int64)&v8, &v6);
  *(_OWORD *)a1 = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  sub_14615A650(a1, Block, v11);
  v9 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  v4 = Block;
  if ( Block != v13 )
  {
    if ( v12 >= 0x1000 )
    {
      v4 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v4 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v4);
  }
  return a1;
}
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';

//----- (0000000146178600) ----------------------------------------------------
__int64 __fastcall sub_146178600(__int64 a1)
{
  *(_OWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  return a1;
}

//----- (0000000146178620) ----------------------------------------------------
_QWORD *__fastcall sub_146178620(_QWORD *a1, const char *a2)
{
  size_t v4; // rax

  *(_OWORD *)a1 = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  v4 = strlen(a2);
  sub_14615A650(a1, a2, v4);
  return a1;
}

//----- (0000000146178670) ----------------------------------------------------
const char **__fastcall sub_146178670(const char **a1, const char *a2)
{
  *a1 = a2;
  a1[1] = (const char *)strlen(a2);
  return a1;
}

//----- (00000001461786A0) ----------------------------------------------------
__int64 __fastcall sub_1461786A0(__int64 a1, __int64 *a2)
{
  _QWORD *v4; // r15
  __int64 v5; // rbx
  __int64 v6; // rbp
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  _QWORD *v11; // rdi
  void *v12; // rsi
  __int128 v14; // [rsp+40h] [rbp-68h] BYREF
  __int64 v15; // [rsp+60h] [rbp-48h]
  char v16[24]; // [rsp+68h] [rbp-40h] BYREF

  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  v4 = operator new(0x38ui64);
  *v4 = v4;
  v4[1] = v4;
  v4[2] = v4;
  *((_WORD *)v4 + 12) = 257;
  *(_QWORD *)a1 = v4;
  v5 = *a2;
  v6 = a2[1];
  if ( *a2 != v6 )
  {
    do
    {
      v7 = sub_146177DF0((_QWORD **)a1, (__int64)v16, v4, (int *)v5);
      v14 = *(_OWORD *)v7;
      v15 = *(_QWORD *)(v7 + 16);
      if ( !(_BYTE)v15 )
      {
        if ( *(_QWORD *)(a1 + 8) == 0x492492492492492i64 )
          unknown_libname_3(v9, v8, v10);
        v11 = *(_QWORD **)a1;
        v12 = operator new(0x38ui64);
        *((_DWORD *)v12 + 8) = *(_DWORD *)v5;
        sub_1461787F0((__int64 *)v12 + 5, (_QWORD *)(v5 + 8));
        *(_QWORD *)v12 = v11;
        *((_QWORD *)v12 + 1) = v11;
        *((_QWORD *)v12 + 2) = v11;
        *((_WORD *)v12 + 12) = 0;
        sub_146165130((_QWORD *)a1, (__int64)&v14, (__int64)v12);
      }
      v5 += 24i64;
    }
    while ( v5 != v6 );
  }
  return a1;
}
// 1461787E9: variable 'v9' is possibly undefined
// 1461787E9: variable 'v8' is possibly undefined
// 1461787E9: variable 'v10' is possibly undefined
// 1461653B0: using guessed type void __fastcall __noreturn unknown_libname_3(_QWORD, _QWORD, _QWORD);
// 1461786A0: using guessed type char var_40[24];

//----- (00000001461787F0) ----------------------------------------------------
__int64 *__fastcall sub_1461787F0(__int64 *a1, _QWORD *a2)
{
  _QWORD *v4; // rax
  _QWORD *v5; // r8
  __int64 **v6; // rdx
  __int64 *i; // rcx
  __int64 v8; // rcx
  __int64 j; // rax

  *a1 = 0i64;
  a1[1] = 0i64;
  v4 = operator new(0xB8ui64);
  *v4 = v4;
  v4[1] = v4;
  v4[2] = v4;
  *((_WORD *)v4 + 12) = 257;
  *a1 = (__int64)v4;
  *(_QWORD *)(*a1 + 8) = sub_146177540(a1, *(_QWORD *)(*a2 + 8i64), (__int64)v4);
  a1[1] = a2[1];
  v5 = (_QWORD *)*a1;
  v6 = *(__int64 ***)(*a1 + 8);
  if ( *((_BYTE *)v6 + 25) )
  {
    *v5 = v5;
    *(_QWORD *)(*a1 + 16) = *a1;
  }
  else
  {
    for ( i = *v6; !*((_BYTE *)i + 25); i = (__int64 *)*i )
      v6 = (__int64 **)i;
    *v5 = v6;
    v8 = *(_QWORD *)(*a1 + 8);
    for ( j = *(_QWORD *)(v8 + 16); !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 16) )
      v8 = j;
    *(_QWORD *)(*a1 + 16) = v8;
  }
  return a1;
}

//----- (00000001461788D0) ----------------------------------------------------
__int64 *__fastcall sub_1461788D0(__int64 *a1, __int64 *a2)
{
  _QWORD *v4; // r15
  __int64 v5; // rbx
  __int64 v6; // rbp
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // rdi
  __int64 *v12; // rsi
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int128 v17; // [rsp+40h] [rbp-78h] BYREF
  __int64 v18; // [rsp+60h] [rbp-58h]
  char v19[80]; // [rsp+68h] [rbp-50h] BYREF

  *a1 = 0i64;
  a1[1] = 0i64;
  v4 = operator new(0xB8ui64);
  *v4 = v4;
  v4[1] = v4;
  v4[2] = v4;
  *((_WORD *)v4 + 12) = 257;
  *a1 = (__int64)v4;
  v5 = *a2;
  v6 = a2[1];
  if ( *a2 != v6 )
  {
    do
    {
      v7 = sub_146178070(a1, (__int64)v19, (__int64)v4, (const void **)v5);
      v17 = *(_OWORD *)v7;
      v18 = *(_QWORD *)(v7 + 16);
      if ( !(_BYTE)v18 )
      {
        if ( a1[1] == 0x1642C8590B21642i64 )
          unknown_libname_3(v9, v8, v10);
        v11 = *a1;
        v12 = (__int64 *)operator new(0xB8ui64);
        sub_146170E60((__int64)(v12 + 4), v5, v13, v14);
        sub_146178F20(v12 + 8, (_QWORD *)(v5 + 32), v15);
        *v12 = v11;
        v12[1] = v11;
        v12[2] = v11;
        *((_WORD *)v12 + 12) = 0;
        sub_146165130(a1, (__int64)&v17, (__int64)v12);
      }
      v5 += 152i64;
    }
    while ( v5 != v6 );
  }
  return a1;
}
// 1461789B5: variable 'v13' is possibly undefined
// 1461789B5: variable 'v14' is possibly undefined
// 1461789C3: variable 'v15' is possibly undefined
// 146178A27: variable 'v9' is possibly undefined
// 146178A27: variable 'v8' is possibly undefined
// 146178A27: variable 'v10' is possibly undefined
// 1461653B0: using guessed type void __fastcall __noreturn unknown_libname_3(_QWORD, _QWORD, _QWORD);
// 1461788D0: using guessed type char var_50[80];

//----- (0000000146178A30) ----------------------------------------------------
_QWORD *__fastcall sub_146178A30(_QWORD *a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v5; // rbx
  size_t v6; // rbx
  _QWORD *v7; // rax
  _QWORD *v8; // rdi
  signed __int64 v9; // rbx

  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  v5 = (__int64)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3;
  if ( v5 )
  {
    if ( v5 > 0x1FFFFFFFFFFFFFFFi64 )
      unknown_libname_6(a1, a2, a3);
    v6 = v5;
    v7 = sub_14615A5E0(v6 * 8);
    *a1 = v7;
    v8 = v7;
    a1[1] = v7;
    a1[2] = &v7[v6];
    v9 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
    memmove(v7, *(const void **)a2, v9);
    a1[1] = &v8[v9 >> 3];
  }
  return a1;
}
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (0000000146178AE0) ----------------------------------------------------
_QWORD *__fastcall sub_146178AE0(_QWORD *a1, __int64 a2, __int64 a3)
{
  const void *v3; // r14
  signed __int64 v5; // rbp
  unsigned __int64 v6; // rdi
  size_t v7; // rdi
  _QWORD *v8; // rax
  _QWORD *v9; // rbx

  v3 = *(const void **)a2;
  v5 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  *a1 = 0i64;
  a1[1] = 0i64;
  v6 = v5 >> 3;
  a1[2] = 0i64;
  if ( v5 >> 3 )
  {
    if ( v6 > 0x1FFFFFFFFFFFFFFFi64 )
      unknown_libname_6(a1, a2, a3);
    v7 = v6;
    v8 = sub_14615A5E0(v7 * 8);
    *a1 = v8;
    a1[1] = v8;
    v9 = v8;
    a1[2] = &v8[v7];
    memmove(v8, v3, v5);
    a1[1] = &v9[v7];
  }
  return a1;
}
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (0000000146178B90) ----------------------------------------------------
_QWORD *__fastcall sub_146178B90(_QWORD *a1, _QWORD *a2)
{
  __int64 v4; // r8
  unsigned __int64 v5; // rdx
  __int64 v6; // rbx
  _QWORD *v7; // rdi
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rbp
  __int64 v11; // rbx

  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  v4 = a2[1] - *a2;
  v5 = v4 / 80;
  if ( v4 / 80 )
  {
    if ( v5 > 0x333333333333333i64 )
      unknown_libname_6(a1, v5, v4);
    v6 = 10 * v5;
    v7 = sub_14615A5E0(80 * v5);
    *a1 = v7;
    a1[1] = v7;
    a1[2] = &v7[v6];
    v10 = a2[1];
    if ( *a2 != v10 )
    {
      v11 = *a2 + 40i64;
      do
      {
        *(_OWORD *)v7 = *(_OWORD *)(v11 - 40);
        *((_DWORD *)v7 + 4) = *(_DWORD *)(v11 - 24);
        *(_OWORD *)((char *)v7 + 20) = *(_OWORD *)(v11 - 20);
        *((_DWORD *)v7 + 9) = *(_DWORD *)(v11 - 4);
        sub_146170E60((__int64)(v7 + 5), v11, v8, v9);
        v7[9] = *(_QWORD *)(v11 + 32);
        v7 += 10;
        v11 += 80i64;
      }
      while ( v11 - 40 != v10 );
    }
    a1[1] = v7;
  }
  return a1;
}
// 146178C62: variable 'v8' is possibly undefined
// 146178C62: variable 'v9' is possibly undefined
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (0000000146178CB0) ----------------------------------------------------
_QWORD *__fastcall sub_146178CB0(_QWORD *a1, __int64 *a2, __int64 a3)
{
  __int64 v4; // rbp
  __int64 v5; // rbx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rdx
  __int64 v8; // rdi
  _QWORD *v9; // rsi
  __int64 v10; // r8
  __int64 v11; // r9

  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  v4 = a2[1];
  v5 = *a2;
  v6 = (__int64)((unsigned __int128)((v4 - *a2) * (__int128)0x6666666666666667i64) >> 64) >> 5;
  v7 = (v6 >> 63) + v6;
  if ( v7 )
  {
    if ( v7 > 0x333333333333333i64 )
      unknown_libname_6(a1, v7, a3);
    v8 = 10 * v7;
    v9 = sub_14615A5E0(80 * v7);
    *a1 = v9;
    a1[1] = v9;
    for ( a1[2] = &v9[v8]; v5 != v4; v5 += 80i64 )
    {
      *(_OWORD *)v9 = *(_OWORD *)v5;
      *((_DWORD *)v9 + 4) = *(_DWORD *)(v5 + 16);
      *(_OWORD *)((char *)v9 + 20) = *(_OWORD *)(v5 + 20);
      *((_DWORD *)v9 + 9) = *(_DWORD *)(v5 + 36);
      sub_146170E60((__int64)(v9 + 5), v5 + 40, v10, v11);
      v9[9] = *(_QWORD *)(v5 + 72);
      v9 += 10;
    }
    a1[1] = v9;
  }
  return a1;
}
// 146178D82: variable 'v10' is possibly undefined
// 146178D82: variable 'v11' is possibly undefined
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (0000000146178DD0) ----------------------------------------------------
__int64 __fastcall sub_146178DD0(__int64 a1, __int128 *a2, __int128 *a3, __int64 a4, __int64 a5)
{
  __int64 v8; // rax
  __int128 v9; // xmm0
  __int64 v10; // rax
  __int64 v11; // r8
  __int64 v12; // r9
  __int128 v14; // [rsp+20h] [rbp-38h] BYREF
  char v15[40]; // [rsp+30h] [rbp-28h] BYREF

  v14 = *a2;
  v8 = sub_146176D40((__int64)v15, &v14);
  *(_OWORD *)a1 = *(_OWORD *)v8;
  v9 = *a3;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v8 + 16);
  v14 = v9;
  v10 = sub_146176D40((__int64)v15, &v14);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)v10;
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v10 + 16);
  sub_146170E60(a1 + 40, a4, v11, v12);
  *(_QWORD *)(a1 + 72) = a5;
  return a1;
}
// 146178E36: variable 'v11' is possibly undefined
// 146178E36: variable 'v12' is possibly undefined

//----- (0000000146178E60) ----------------------------------------------------
__int64 __fastcall sub_146178E60(__int64 a1, __int64 a2)
{
  __int64 v3; // rax
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 result; // rax

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 24) = 0i64;
  *(_QWORD *)(a2 + 16) = 0i64;
  *(_QWORD *)(a2 + 8) = 0i64;
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 16) = v6;
  *(_QWORD *)(a1 + 24) = v5;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  v7 = *(_QWORD *)(a2 + 64);
  v8 = *(_QWORD *)(a2 + 80);
  v9 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 80) = 0i64;
  *(_QWORD *)(a2 + 72) = 0i64;
  *(_QWORD *)(a2 + 64) = 0i64;
  *(_QWORD *)(a1 + 64) = v7;
  result = a1;
  *(_QWORD *)(a1 + 72) = v9;
  *(_QWORD *)(a1 + 80) = v8;
  *(_OWORD *)(a1 + 88) = 0i64;
  *(_QWORD *)(a1 + 104) = 0i64;
  *(_QWORD *)(a1 + 112) = 0i64;
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = 0i64;
  *(_WORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 112) = 7i64;
  return result;
}

//----- (0000000146178F20) ----------------------------------------------------
_QWORD *__fastcall sub_146178F20(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  __int64 v5; // r8
  __int64 v6; // r9

  *a1 = *a2;
  sub_146178A30(a1 + 1, (__int64)(a2 + 1), a3);
  a1[4] = a2[4];
  a1[5] = a2[5];
  a1[6] = a2[6];
  a1[7] = a2[7];
  sub_146178B90(a1 + 8, a2 + 8);
  sub_146170F20((__int64)(a1 + 11), (__int64)(a2 + 11), v5, v6);
  return a1;
}
// 146178F88: variable 'v5' is possibly undefined
// 146178F88: variable 'v6' is possibly undefined

//----- (0000000146178FA0) ----------------------------------------------------
__int64 __fastcall sub_146178FA0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int128 *a6)
{
  __int64 v8; // rax
  __int128 v10; // [rsp+30h] [rbp-18h] BYREF
  __int64 v11; // [rsp+58h] [rbp+10h] BYREF
  __int64 v12; // [rsp+60h] [rbp+18h] BYREF
  __int64 v13; // [rsp+68h] [rbp+20h] BYREF

  *(_QWORD *)a1 = a2;
  v12 = a3;
  *(_QWORD *)&v10 = &v12;
  *((_QWORD *)&v10 + 1) = &v13;
  sub_146178AE0((_QWORD *)(a1 + 8), (__int64)&v10, (__int64)&v11);
  *(_QWORD *)(a1 + 32) = a4;
  *(_QWORD *)(a1 + 40) = 0i64;
  v8 = a5;
  *(_QWORD *)(a1 + 48) = a5;
  *(_QWORD *)(a1 + 56) = v8;
  v10 = *a6;
  sub_146178CB0((_QWORD *)(a1 + 64), (__int64 *)&v10, (__int64)&a5);
  *(_OWORD *)(a1 + 88) = 0i64;
  *(_QWORD *)(a1 + 104) = 0i64;
  *(_QWORD *)(a1 + 112) = 7i64;
  *(_WORD *)(a1 + 88) = 0;
  return a1;
}

//----- (00000001461790F0) ----------------------------------------------------
void __fastcall sub_1461790F0(void **a1)
{
  sub_146177C20((__int64)a1, (__int64)a1, *((void ***)*a1 + 1));
  j_j_free(*a1);
}

//----- (0000000146179120) ----------------------------------------------------
void __fastcall sub_146179120(void **a1)
{
  sub_146177CC0((__int64)a1, (__int64)a1, *((__int64 **)*a1 + 1));
  j_j_free(*a1);
}

//----- (0000000146179150) ----------------------------------------------------
void __fastcall sub_146179150(__int64 *a1)
{
  void **v1; // rbx

  v1 = (void **)a1[1];
  if ( v1 )
  {
    sub_146177CC0(a1[1], *a1, *((__int64 **)*v1 + 1));
    j_j_free(*v1);
  }
}

//----- (0000000146179190) ----------------------------------------------------
void __fastcall sub_146179190(__int64 *a1)
{
  __int64 v1; // rdi
  __int64 i; // rbx

  v1 = a1[1];
  for ( i = *a1; i != v1; i += 80i64 )
    sub_1461626B0(i + 40);
}

//----- (00000001461791D0) ----------------------------------------------------
void __fastcall sub_1461791D0(__int64 *a1)
{
  __int64 v1; // rdi
  __int64 i; // rbx

  v1 = a1[1];
  for ( i = *a1; i != v1; i += 120i64 )
  {
    sub_146162730(i + 88);
    sub_14617D330((_QWORD *)(i + 64));
    sub_146166C80(i + 8);
  }
}

//----- (0000000146179220) ----------------------------------------------------
void __fastcall sub_146179220(void **a1)
{
  sub_146177D60((__int64)a1, (__int64)a1, *((_QWORD *)*a1 + 1));
  j_j_free(*a1);
}

//----- (0000000146179250) ----------------------------------------------------
void __fastcall sub_146179250(_QWORD *a1)
{
  void **v1; // rbx

  v1 = (void **)(a1 + 1);
  sub_146177CC0((__int64)(a1 + 1), (__int64)(a1 + 1), *(__int64 **)(a1[1] + 8i64));
  j_j_free(*v1);
}

//----- (0000000146179280) ----------------------------------------------------
void __fastcall sub_146179280(_QWORD *a1)
{
  sub_146162730((__int64)(a1 + 15));
  sub_14617D330(a1 + 12);
  sub_146166C80((__int64)(a1 + 5));
  sub_1461626B0((__int64)a1);
}

//----- (00000001461792F0) ----------------------------------------------------
void __fastcall sub_1461792F0(void *a1)
{
  sub_1461626B0((__int64)a1 + 40);
}

//----- (0000000146179300) ----------------------------------------------------
void __fastcall sub_146179300(_QWORD *a1)
{
  sub_146162730((__int64)(a1 + 11));
  sub_14617D330(a1 + 8);
  sub_146166C80((__int64)(a1 + 1));
}

//----- (0000000146179330) ----------------------------------------------------
void __fastcall sub_146179330(_QWORD *a1)
{
  __int64 v2; // rbx
  __int64 i; // rsi
  _QWORD *v4; // rcx

  if ( a1[1] )
  {
    v2 = a1[3];
    for ( i = a1[4]; v2 != i; v2 += 120i64 )
    {
      sub_146162730(v2 + 88);
      sub_14617D330((_QWORD *)(v2 + 64));
      sub_146166C80(v2 + 8);
    }
    v4 = (_QWORD *)a1[1];
    if ( (unsigned __int64)(120i64 * a1[2]) >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - *(v4 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v4 = (_QWORD *)*(v4 - 1);
    }
    j_j_free(v4);
  }
}

//----- (00000001461793E0) ----------------------------------------------------
void **__fastcall sub_1461793E0(void **a1, const void **a2)
{
  char *v3; // r15
  char *v4; // rdi
  unsigned __int64 v5; // rbp
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rbx
  size_t v9; // rbx
  _QWORD *v10; // rax
  void *v11; // rcx
  char *v12; // rdx
  _BYTE *v14; // rbx
  unsigned __int64 v15; // rbx

  if ( a1 != (void **)a2 )
  {
    v3 = (char *)*a2;
    v4 = (char *)*a1;
    v5 = ((_BYTE *)a2[1] - (_BYTE *)*a2) >> 3;
    v6 = ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3;
    if ( v5 <= v6 )
    {
      v14 = a1[1];
      v11 = *a1;
      v15 = (v14 - v4) >> 3;
      if ( v5 > v15 )
      {
        memmove(v11, *a2, 8 * v15);
        v4 = (char *)a1[1];
        v12 = &v3[8 * v15];
        v11 = v4;
        v5 -= v15;
        goto LABEL_13;
      }
    }
    else
    {
      if ( v5 > 0x1FFFFFFFFFFFFFFFi64 )
        unknown_libname_6(a1, a2, v6);
      v7 = v6 >> 1;
      if ( v6 <= 0x1FFFFFFFFFFFFFFFi64 - (v6 >> 1) )
      {
        v8 = v6 + v7;
        if ( v6 + v7 < v5 )
          v8 = ((_BYTE *)a2[1] - (_BYTE *)*a2) >> 3;
      }
      else
      {
        v8 = 0x1FFFFFFFFFFFFFFFi64;
      }
      if ( v4 )
      {
        sub_14617D740((__int64)a1, v4, v6);
        *a1 = 0i64;
        a1[1] = 0i64;
        a1[2] = 0i64;
      }
      if ( v8 > 0x1FFFFFFFFFFFFFFFi64 )
        sub_146165390(v7, a2, v6);
      v9 = v8;
      v10 = sub_14615A5E0(v9 * 8);
      *a1 = v10;
      v4 = (char *)v10;
      a1[1] = v10;
      a1[2] = &v10[v9];
      v11 = v10;
    }
    v12 = v3;
LABEL_13:
    memmove(v11, v12, 8 * v5);
    a1[1] = &v4[8 * v5];
  }
  return a1;
}
// 146179515: variable 'v7' is possibly undefined
// 146179515: variable 'a2' is possibly undefined
// 146179515: variable 'v6' is possibly undefined
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (0000000146179530) ----------------------------------------------------
__int64 *__fastcall sub_146179530(__int64 *a1, __int64 a2)
{
  sub_146177300(
    a1,
    *(_QWORD **)a2,
    (*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) / 120i64 + *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  return a1;
}

//----- (0000000146179580) ----------------------------------------------------
__int64 __fastcall sub_146179580(__int64 a1, __int64 a2)
{
  __int64 v4; // r9
  _QWORD *v5; // rdx

  *(_QWORD *)a1 = *(_QWORD *)a2;
  sub_1461793E0((void **)(a1 + 8), (const void **)(a2 + 8));
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  if ( a1 + 64 != a2 + 64 )
    sub_146176FA0(
      a1 + 64,
      *(_QWORD *)(a2 + 64),
      (*(_QWORD *)(a2 + 72) - *(_QWORD *)(a2 + 64)) / 80i64,
      *(_QWORD *)(a2 + 64));
  v5 = (_QWORD *)(a2 + 88);
  if ( a1 + 88 != a2 + 88 )
  {
    if ( *(_QWORD *)(a2 + 112) > 7ui64 )
      v5 = (_QWORD *)*v5;
    sub_14617D600((void **)(a1 + 88), v5, *(_QWORD *)(a2 + 104), v4);
  }
  return a1;
}
// 146179618: variable 'v4' is possibly undefined

//----- (0000000146179630) ----------------------------------------------------
__int64 __fastcall sub_146179630(__int64 *a1, int *a2)
{
  __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // r8
  int v7; // r9d
  _DWORD *v8; // rdi
  _QWORD *v9; // rax
  __int128 v11; // [rsp+30h] [rbp-48h] BYREF
  __int128 v12; // [rsp+40h] [rbp-38h]

  v4 = *a1;
  v5 = *(_QWORD *)(*a1 + 8);
  *(_QWORD *)&v12 = v5;
  DWORD2(v12) = 0;
  v6 = v4;
  if ( !*(_BYTE *)(v5 + 25) )
  {
    v7 = *a2;
    do
    {
      *(_QWORD *)&v12 = v5;
      if ( *(_DWORD *)(v5 + 32) >= v7 )
      {
        DWORD2(v12) = 1;
        v6 = v5;
      }
      else
      {
        DWORD2(v12) = 0;
        v5 += 16i64;
      }
      v5 = *(_QWORD *)v5;
    }
    while ( !*(_BYTE *)(v5 + 25) );
  }
  if ( *(_BYTE *)(v6 + 25) || *a2 < *(_DWORD *)(v6 + 32) )
  {
    if ( a1[1] == 0x492492492492492i64 )
      unknown_libname_3(a1, a2, v6);
    *(_QWORD *)&v11 = a1;
    v8 = operator new(0x38ui64);
    *((_QWORD *)&v11 + 1) = v8;
    v8[8] = *a2;
    *((_QWORD *)v8 + 5) = 0i64;
    *((_QWORD *)v8 + 6) = 0i64;
    v9 = operator new(0xB8ui64);
    *v9 = v9;
    v9[1] = v9;
    v9[2] = v9;
    *((_WORD *)v9 + 12) = 257;
    *((_QWORD *)v8 + 5) = v9;
    *(_QWORD *)v8 = v4;
    *((_QWORD *)v8 + 1) = v4;
    *((_QWORD *)v8 + 2) = v4;
    *((_WORD *)v8 + 12) = 0;
    v11 = v12;
    v6 = sub_146165130(a1, (__int64)&v11, (__int64)v8);
  }
  return v6 + 40;
}
// 1461653B0: using guessed type void __fastcall __noreturn unknown_libname_3(_QWORD, _QWORD, _QWORD);

//----- (0000000146179760) ----------------------------------------------------
__int64 *__fastcall sub_146179760(__int64 *a1)
{
  __int64 v1; // rdx
  __int64 **v3; // r9
  __int64 i; // rax
  __int64 *j; // rcx

  v1 = *a1;
  v3 = *(__int64 ***)(*a1 + 16);
  if ( *((_BYTE *)v3 + 25) )
  {
    for ( i = *(_QWORD *)(v1 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
    {
      if ( v1 != *(_QWORD *)(i + 16) )
        break;
      *a1 = i;
      v1 = i;
    }
    *a1 = i;
    return a1;
  }
  else
  {
    for ( j = *v3; !*((_BYTE *)j + 25); j = (__int64 *)*j )
      v3 = (__int64 **)j;
    *a1 = (__int64)v3;
    return a1;
  }
}

//----- (00000001461797D0) ----------------------------------------------------
__int64 __fastcall sub_1461797D0(__int64 a1, size_t *a2, const void **a3)
{
  const void *v3; // r9
  size_t v4; // rdi
  const void *v5; // rax
  size_t v6; // rbx
  size_t v7; // r8
  unsigned int v8; // eax

  v3 = a3;
  v4 = (size_t)a3[2];
  v5 = a2;
  if ( (unsigned __int64)a3[3] > 0xF )
    v3 = *a3;
  v6 = a2[2];
  if ( a2[3] > 0xF )
    v5 = (const void *)*a2;
  v7 = a2[2];
  if ( v4 < v6 )
    v7 = v4;
  v8 = memcmp(v5, v3, v7);
  if ( !v8 )
  {
    if ( v6 < v4 )
      return 1i64;
    v8 = v6 > v4;
  }
  return v8 >> 31;
}

//----- (0000000146179840) ----------------------------------------------------
__int64 __fastcall sub_146179840(__int64 a1, __int64 a2, __int64 a3)
{
  size_t v6; // r8
  const char *v7; // rdi
  size_t v8; // rax
  const char *v9; // rbx
  __int64 v10; // rax
  const char *v11; // rdi
  size_t v12; // rax
  const char *v13; // rbx
  __int64 v14; // rax
  void **v15; // rax
  const char *v16; // rbx
  size_t v17; // rax
  __int64 v18; // rax
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rax
  void *v24; // rcx
  __m128i v25; // xmm0
  void *v26; // rcx
  void *v27; // rcx
  void **v28; // rcx
  void **v29; // rbx
  unsigned __int64 v30; // rdi
  void **v31; // rdx
  void **v32; // rax
  void **v33; // rcx
  void **v34; // rax
  __int128 v35; // xmm0
  const char *v36; // rbx
  size_t v37; // rax
  __int64 v38; // rax
  __int64 v39; // r8
  __int64 v40; // r9
  __int64 v41; // r8
  __int64 v42; // r9
  __int64 v43; // rax
  void *v44; // rcx
  __m128i si128; // xmm0
  void *v46; // rcx
  __int128 v48; // [rsp+38h] [rbp-D0h] BYREF
  __int128 v49; // [rsp+48h] [rbp-C0h] BYREF
  void *v50[5]; // [rsp+60h] [rbp-A8h] BYREF
  void *v51[2]; // [rsp+88h] [rbp-80h] BYREF
  __int128 v52; // [rsp+98h] [rbp-70h]
  void *Block[2]; // [rsp+A8h] [rbp-60h] BYREF
  __m128i v54; // [rsp+B8h] [rbp-50h]
  void *v55[2]; // [rsp+C8h] [rbp-40h] BYREF
  __m128i v56; // [rsp+D8h] [rbp-30h]
  void *v57[2]; // [rsp+E8h] [rbp-20h] BYREF
  __m128i v58; // [rsp+F8h] [rbp-10h]

  v50[4] = (void *)-2i64;
  *(_QWORD *)&v49 = a2;
  *(_OWORD *)v51 = 0i64;
  v52 = 0i64;
  v6 = strlen(*(const char **)a1);
  sub_14615A650(v51, *(const void **)a1, v6);
  v7 = *(const char **)a1;
  v8 = strlen(*(const char **)a1);
  if ( (v8 < 4
     || (v9 = &v7[v8], v10 = sub_1461A7840(v7, &v7[v8], "ros_", 4i64), (const char *)v10 == v9)
     || v10 != (_QWORD)v7)
    && ((v11 = *(const char **)a1, v12 = strlen(*(const char **)a1), v12 < 9)
     || (v13 = &v11[v12], v14 = sub_1461A7840(v11, &v11[v12], "launcher/", 9i64), (const char *)v14 == v13)
     || v14 != (_QWORD)v11) )
  {
    v28 = v51;
    v29 = (void **)v51[0];
    v30 = *((_QWORD *)&v52 + 1);
    if ( *((_QWORD *)&v52 + 1) > 0xFui64 )
      v28 = (void **)v51[0];
    v31 = (void **)((char *)v28 + v52);
    v32 = v51;
    if ( *((_QWORD *)&v52 + 1) > 0xFui64 )
      v32 = (void **)v51[0];
    if ( v32 != v31 )
    {
      do
      {
        if ( *(_BYTE *)v32 == 47 )
          *(_BYTE *)v32 = 43;
        v32 = (void **)((char *)v32 + 1);
      }
      while ( v32 != v31 );
      v30 = *((_QWORD *)&v52 + 1);
      v29 = (void **)v51[0];
    }
    if ( *(_QWORD *)(a3 + 8) )
    {
      *(_OWORD *)v57 = *(_OWORD *)a3;
      v33 = v57;
    }
    else
    {
      *(_QWORD *)&v48 = **(_QWORD **)(a1 + 8);
      *((_QWORD *)&v48 + 1) = strlen((const char *)v48);
      v33 = (void **)&v48;
    }
    v34 = v51;
    if ( v30 > 0xF )
      v34 = v29;
    v35 = *(_OWORD *)v33;
    v55[0] = v34;
    v55[1] = (void *)v49;
    v56.m128i_i64[0] = v35;
    v56.m128i_i64[1] = (__int64)v33[1];
    *(_QWORD *)&v48 = 220i64;
    *((_QWORD *)&v48 + 1) = v55;
    *(_QWORD *)&v49 = "data\\game-storage\\%s_%s";
    *((_QWORD *)&v49 + 1) = 23i64;
    v36 = (const char *)sub_1461A30D0(&v49, &v48);
    v37 = strlen(v36);
    *(_QWORD *)&v48 = v36;
    *((_QWORD *)&v48 + 1) = v37;
    v38 = sub_1461A2C60((__int64)v57, (__int64)&v48);
    sub_146170F20((__int64)v50, v38, v39, v40);
    v43 = sub_1461645B0((__int64)Block, v50, v41, v42);
    *(_OWORD *)a2 = 0i64;
    *(_QWORD *)(a2 + 16) = 0i64;
    *(_QWORD *)(a2 + 24) = 0i64;
    *(_OWORD *)a2 = *(_OWORD *)v43;
    *(_OWORD *)(a2 + 16) = *(_OWORD *)(v43 + 16);
    *(_QWORD *)(v43 + 16) = 0i64;
    *(_QWORD *)(v43 + 24) = 7i64;
    *(_WORD *)v43 = 0;
    if ( v54.m128i_i64[1] > 7ui64 )
    {
      v44 = Block[0];
      if ( (unsigned __int64)(2 * v54.m128i_i64[1] + 2) >= 0x1000 )
      {
        v44 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)(Block[0] - v44 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v44);
    }
    si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
    v54 = si128;
    LOWORD(Block[0]) = 0;
    if ( v58.m128i_i64[1] > 7ui64 )
    {
      v46 = v57[0];
      if ( (unsigned __int64)(2 * v58.m128i_i64[1] + 2) >= 0x1000 )
      {
        v46 = (void *)*((_QWORD *)v57[0] - 1);
        if ( (unsigned __int64)(v57[0] - v46 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v46);
      si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
    }
    v58 = si128;
    LOWORD(v57[0]) = 0;
    if ( *((_QWORD *)&v52 + 1) > 0xFui64 )
    {
      v27 = v51[0];
      if ( (unsigned __int64)(*((_QWORD *)&v52 + 1) + 1i64) >= 0x1000 )
      {
        v27 = (void *)*((_QWORD *)v51[0] - 1);
        if ( (unsigned __int64)(v51[0] - v27 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      goto LABEL_51;
    }
  }
  else
  {
    v15 = v51;
    if ( *((_QWORD *)&v52 + 1) > 0xFui64 )
      v15 = (void **)v51[0];
    *(_QWORD *)&v48 = v15;
    *(_OWORD *)v57 = v48;
    *(_QWORD *)&v49 = 12i64;
    *((_QWORD *)&v49 + 1) = v57;
    *(_QWORD *)&v48 = "data\\game-storage\\%s";
    *((_QWORD *)&v48 + 1) = 20i64;
    v16 = (const char *)sub_1461A30D0(&v48, &v49);
    v17 = strlen(v16);
    *(_QWORD *)&v48 = v16;
    *((_QWORD *)&v48 + 1) = v17;
    v18 = sub_1461A2C60((__int64)v55, (__int64)&v48);
    sub_146170F20((__int64)v50, v18, v19, v20);
    v23 = sub_1461645B0((__int64)Block, v50, v21, v22);
    *(_OWORD *)a2 = 0i64;
    *(_QWORD *)(a2 + 16) = 0i64;
    *(_QWORD *)(a2 + 24) = 0i64;
    *(_OWORD *)a2 = *(_OWORD *)v23;
    *(_OWORD *)(a2 + 16) = *(_OWORD *)(v23 + 16);
    *(_QWORD *)(v23 + 16) = 0i64;
    *(_QWORD *)(v23 + 24) = 7i64;
    *(_WORD *)v23 = 0;
    if ( v54.m128i_i64[1] > 7ui64 )
    {
      v24 = Block[0];
      if ( (unsigned __int64)(2 * v54.m128i_i64[1] + 2) >= 0x1000 )
      {
        v24 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)(Block[0] - v24 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v24);
    }
    v25 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
    v54 = v25;
    LOWORD(Block[0]) = 0;
    if ( v56.m128i_i64[1] > 7ui64 )
    {
      v26 = v55[0];
      if ( (unsigned __int64)(2 * v56.m128i_i64[1] + 2) >= 0x1000 )
      {
        v26 = (void *)*((_QWORD *)v55[0] - 1);
        if ( (unsigned __int64)(v55[0] - v26 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v26);
      v25 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
    }
    v56 = v25;
    LOWORD(v55[0]) = 0;
    if ( *((_QWORD *)&v52 + 1) > 0xFui64 )
    {
      v27 = v51[0];
      if ( (unsigned __int64)(*((_QWORD *)&v52 + 1) + 1i64) >= 0x1000 )
      {
        v27 = (void *)*((_QWORD *)v51[0] - 1);
        if ( (unsigned __int64)(v51[0] - v27 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
LABEL_51:
      j_j_free(v27);
    }
  }
  return a2;
}
// 1461799A6: variable 'v19' is possibly undefined
// 1461799A6: variable 'v20' is possibly undefined
// 1461799B4: variable 'v21' is possibly undefined
// 1461799B4: variable 'v22' is possibly undefined
// 146179C05: variable 'v39' is possibly undefined
// 146179C05: variable 'v40' is possibly undefined
// 146179C13: variable 'v41' is possibly undefined
// 146179C13: variable 'v42' is possibly undefined
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 1461A7840: using guessed type __int64 __fastcall sub_1461A7840(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146179D90) ----------------------------------------------------
__int64 sub_146179D90()
{
  __int64 v1; // rdx
  __int64 v2; // rcx
  __int64 v3; // r8
  __int64 v4; // r9
  __int64 v5; // rcx
  int v6; // eax
  char v7; // al

  if ( dword_14610AABC <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 380i64) )
    return (unsigned __int8)byte_14610AAB8;
  sub_1461A7CF4(&dword_14610AABC);
  if ( dword_14610AABC != -1 )
    return (unsigned __int8)byte_14610AAB8;
  if ( !sub_1461A4660(v2, v1, v3, v4) )
    goto LABEL_10;
  v6 = dword_1461090C0;
  if ( dword_1461090C0 == -1 )
  {
    v6 = sub_1461A48B0(v5);
    dword_1461090C0 = v6;
  }
  if ( v6 == 1 )
LABEL_10:
    v7 = 0;
  else
    v7 = 1;
  byte_14610AAB8 = v7;
  Init_thread_footer(&dword_14610AABC);
  return (unsigned __int8)byte_14610AAB8;
}
// 146179DFF: variable 'v2' is possibly undefined
// 146179DFF: variable 'v1' is possibly undefined
// 146179DFF: variable 'v3' is possibly undefined
// 146179DFF: variable 'v4' is possibly undefined
// 146179E13: variable 'v5' is possibly undefined
// 1461090C0: using guessed type int dword_1461090C0;
// 14610AAB8: using guessed type char byte_14610AAB8;
// 14610AABC: using guessed type int dword_14610AABC;
// 14611AE78: using guessed type int TlsIndex;
// 146179D90: using guessed type __int64 sub_146179D90();
// 1461A48B0: using guessed type __int64 __fastcall sub_1461A48B0(_QWORD);
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);

//----- (0000000146179E30) ----------------------------------------------------
_QWORD *__fastcall sub_146179E30(__int64 a1)
{
  _QWORD *v1; // r14
  __m128i si128; // xmm6
  __int64 v3; // r8
  _QWORD *v4; // rbx
  _QWORD *v5; // rdi
  _QWORD *v6; // rax
  bool v7; // zf
  __int64 v8; // rcx
  unsigned int v9; // eax
  const char *v10; // rax
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  const char *v14; // rbx
  __int64 v15; // r8
  __int64 v16; // r8
  int v17; // eax
  __int64 *v18; // rdi
  __int64 v19; // rbx
  __int64 v20; // r8
  __int64 v21; // r8
  __int64 v22; // r9
  const char *v23; // rax
  __int64 v24; // r8
  const char *v25; // rbx
  __int64 v26; // r8
  __int64 v27; // r8
  __int64 v28; // r8
  __int64 v29; // r9
  __int64 v30; // r9
  __int64 v31; // r8
  __int64 v32; // r9
  const wchar_t *v33; // rcx
  const wchar_t *v34; // rcx
  const wchar_t *v35; // rcx
  wchar_t *v36; // rcx
  _QWORD *v37; // rax
  int v38; // esi
  const char **v39; // r15
  __m128i v40; // xmm8
  size_t v41; // rax
  void **v42; // rdi
  unsigned __int64 v43; // rax
  char *v44; // rbx
  __int64 v45; // rax
  __int64 v46; // rdx
  __int64 v47; // r8
  __int64 v48; // r9
  unsigned __int64 v49; // rbx
  void **v50; // rdi
  void **v51; // r12
  unsigned __int64 v52; // r13
  void **v53; // r14
  __int64 v54; // rax
  char *v55; // rcx
  void **v56; // rax
  __int64 v57; // rcx
  size_t v58; // rbx
  size_t v59; // rdi
  void **v60; // rax
  char *v61; // r12
  unsigned __int64 v62; // r14
  _QWORD *v63; // rbx
  int v64; // esi
  __int128 v65; // kr20_16
  void **v66; // rbx
  size_t v67; // rdi
  _OWORD *v68; // rax
  __int128 v69; // xmm6
  __int128 v70; // xmm7
  void *v71; // rcx
  void *v72; // rcx
  void **v73; // rdi
  char *v74; // rbx
  __int64 v75; // rax
  __int64 v76; // rdx
  __int64 v77; // rcx
  __int64 v78; // r8
  __int64 v79; // r9
  size_t v80; // rax
  size_t v81; // rdi
  void **v82; // r12
  unsigned __int64 v83; // r14
  _QWORD *v84; // rbx
  int v85; // esi
  __int128 v86; // kr30_16
  void **v87; // rbx
  size_t v88; // rdi
  _OWORD *v89; // rax
  __int128 v90; // xmm6
  __int128 v91; // xmm7
  void *v92; // rcx
  void *v93; // rcx
  __int64 v94; // rax
  DWORD FileAttributesW; // ebx
  wchar_t *v96; // rcx
  _QWORD *v97; // rax
  __int64 v98; // r8
  __int64 v99; // r9
  _QWORD *v100; // rcx
  __int64 v101; // rdx
  __int64 v102; // rcx
  __int64 v103; // r8
  __int64 v104; // r9
  __int64 v105; // r14
  __int64 v106; // rdi
  void **v107; // r12
  unsigned __int64 v108; // rbx
  void *v109; // rcx
  void *v110; // rcx
  wchar_t *v111; // rcx
  void *v112; // rcx
  void *v113; // rcx
  char v115[8]; // [rsp+30h] [rbp-D0h] BYREF
  const char *i; // [rsp+38h] [rbp-C8h] BYREF
  __int128 v117; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v118; // [rsp+50h] [rbp-B0h]
  __int64 v119; // [rsp+58h] [rbp-A8h]
  int v120; // [rsp+60h] [rbp-A0h]
  _QWORD *v121; // [rsp+68h] [rbp-98h]
  __int128 v122; // [rsp+70h] [rbp-90h] BYREF
  __int64 v123; // [rsp+80h] [rbp-80h]
  __int64 v124; // [rsp+88h] [rbp-78h]
  __int64 v125; // [rsp+90h] [rbp-70h]
  __int128 v126; // [rsp+A0h] [rbp-60h] BYREF
  __m128i v127; // [rsp+B0h] [rbp-50h]
  void *v128[2]; // [rsp+C0h] [rbp-40h] BYREF
  __int128 v129; // [rsp+D0h] [rbp-30h]
  void *Src[2]; // [rsp+E0h] [rbp-20h] BYREF
  __int128 v131; // [rsp+F0h] [rbp-10h]
  void *v132[2]; // [rsp+100h] [rbp+0h] BYREF
  __int128 v133; // [rsp+110h] [rbp+10h]
  wchar_t *v134[2]; // [rsp+120h] [rbp+20h] BYREF
  __m128i v135; // [rsp+130h] [rbp+30h]
  wchar_t *FileName[2]; // [rsp+140h] [rbp+40h] BYREF
  __int64 v137; // [rsp+150h] [rbp+50h]
  unsigned __int64 v138; // [rsp+158h] [rbp+58h]
  struct _stat64i32 Stat; // [rsp+160h] [rbp+60h] BYREF
  __int128 v140[16]; // [rsp+190h] [rbp+90h] BYREF
  char v141[120]; // [rsp+2F8h] [rbp+1F8h] BYREF
  char v142[120]; // [rsp+370h] [rbp+270h] BYREF
  char v143[120]; // [rsp+3E8h] [rbp+2E8h] BYREF
  char v144[120]; // [rsp+460h] [rbp+360h] BYREF
  char v145[120]; // [rsp+4D8h] [rbp+3D8h] BYREF
  char v146[120]; // [rsp+550h] [rbp+450h] BYREF
  char v147[120]; // [rsp+5C8h] [rbp+4C8h] BYREF
  char v148[120]; // [rsp+640h] [rbp+540h] BYREF
  char v149[120]; // [rsp+6B8h] [rbp+5B8h] BYREF
  char v150[120]; // [rsp+730h] [rbp+630h] BYREF
  char v151[120]; // [rsp+7A8h] [rbp+6A8h] BYREF
  char v152[120]; // [rsp+820h] [rbp+720h] BYREF
  char v153[120]; // [rsp+898h] [rbp+798h] BYREF
  char v154[120]; // [rsp+910h] [rbp+810h] BYREF
  char v155[120]; // [rsp+988h] [rbp+888h] BYREF
  char v156[120]; // [rsp+A00h] [rbp+900h] BYREF
  char v157[120]; // [rsp+A78h] [rbp+978h] BYREF
  char v158[120]; // [rsp+AF0h] [rbp+9F0h] BYREF
  char v159[120]; // [rsp+B68h] [rbp+A68h] BYREF
  char v160[120]; // [rsp+BE0h] [rbp+AE0h] BYREF
  char v161[120]; // [rsp+C58h] [rbp+B58h] BYREF
  char v162[120]; // [rsp+CD0h] [rbp+BD0h] BYREF
  char v163[120]; // [rsp+D48h] [rbp+C48h] BYREF
  char v164[120]; // [rsp+DC0h] [rbp+CC0h] BYREF
  char v165[120]; // [rsp+E38h] [rbp+D38h] BYREF
  char v166[120]; // [rsp+EB0h] [rbp+DB0h] BYREF
  const char *v167; // [rsp+F28h] [rbp+E28h]
  _QWORD v168[7]; // [rsp+F30h] [rbp+E30h] BYREF
  __int64 v169[3]; // [rsp+F68h] [rbp+E68h] BYREF
  __int16 v170[8]; // [rsp+F80h] [rbp+E80h] BYREF
  __m128i v171; // [rsp+F90h] [rbp+E90h]
  const char *v172; // [rsp+FA0h] [rbp+EA0h]
  _QWORD v173[7]; // [rsp+FA8h] [rbp+EA8h] BYREF
  __int64 v174[3]; // [rsp+FE0h] [rbp+EE0h] BYREF
  __int128 v175; // [rsp+FF8h] [rbp+EF8h]
  __int64 v176; // [rsp+1008h] [rbp+F08h]
  __int64 v177; // [rsp+1010h] [rbp+F10h]
  const char *v178; // [rsp+1018h] [rbp+F18h]
  _QWORD v179[7]; // [rsp+1020h] [rbp+F20h] BYREF
  __int64 v180[3]; // [rsp+1058h] [rbp+F58h] BYREF
  __int128 v181; // [rsp+1070h] [rbp+F70h]
  __m128i v182; // [rsp+1080h] [rbp+F80h]
  const char *v183; // [rsp+1090h] [rbp+F90h]
  _QWORD v184[7]; // [rsp+1098h] [rbp+F98h] BYREF
  __int64 v185[3]; // [rsp+10D0h] [rbp+FD0h] BYREF
  __int128 v186; // [rsp+10E8h] [rbp+FE8h]
  __int64 v187; // [rsp+10F8h] [rbp+FF8h]
  __int64 v188; // [rsp+1100h] [rbp+1000h]
  const char *v189; // [rsp+1108h] [rbp+1008h]
  _QWORD v190[7]; // [rsp+1110h] [rbp+1010h] BYREF
  __int64 v191[3]; // [rsp+1148h] [rbp+1048h] BYREF
  __int128 v192; // [rsp+1160h] [rbp+1060h]
  __m128i v193; // [rsp+1170h] [rbp+1070h]
  const char *v194; // [rsp+1180h] [rbp+1080h]
  _QWORD v195[7]; // [rsp+1188h] [rbp+1088h] BYREF
  __int64 v196[3]; // [rsp+11C0h] [rbp+10C0h] BYREF
  __int128 v197; // [rsp+11D8h] [rbp+10D8h]
  __int64 v198; // [rsp+11E8h] [rbp+10E8h]
  __int64 v199; // [rsp+11F0h] [rbp+10F0h]
  const char *v200; // [rsp+11F8h] [rbp+10F8h]
  _QWORD v201[7]; // [rsp+1200h] [rbp+1100h] BYREF
  __int64 v202[3]; // [rsp+1238h] [rbp+1138h] BYREF
  __int128 v203; // [rsp+1250h] [rbp+1150h]
  __m128i v204; // [rsp+1260h] [rbp+1160h]
  const char *v205; // [rsp+1270h] [rbp+1170h]
  _QWORD v206[7]; // [rsp+1278h] [rbp+1178h] BYREF
  __int64 v207[3]; // [rsp+12B0h] [rbp+11B0h] BYREF
  __int128 v208; // [rsp+12C8h] [rbp+11C8h]
  __int64 v209; // [rsp+12D8h] [rbp+11D8h]
  __int64 v210; // [rsp+12E0h] [rbp+11E0h]
  const char *v211; // [rsp+12E8h] [rbp+11E8h]
  _QWORD v212[7]; // [rsp+12F0h] [rbp+11F0h] BYREF
  __int64 v213[3]; // [rsp+1328h] [rbp+1228h] BYREF
  __int128 v214; // [rsp+1340h] [rbp+1240h]
  __m128i v215; // [rsp+1350h] [rbp+1250h]
  const char *v216; // [rsp+1360h] [rbp+1260h]
  _QWORD v217[7]; // [rsp+1368h] [rbp+1268h] BYREF
  __int64 v218[3]; // [rsp+13A0h] [rbp+12A0h] BYREF
  __int128 v219; // [rsp+13B8h] [rbp+12B8h]
  __int64 v220; // [rsp+13C8h] [rbp+12C8h]
  __int64 v221; // [rsp+13D0h] [rbp+12D0h]
  const char *v222; // [rsp+13D8h] [rbp+12D8h]
  _QWORD v223[7]; // [rsp+13E0h] [rbp+12E0h] BYREF
  __int64 v224[3]; // [rsp+1418h] [rbp+1318h] BYREF
  __int128 v225; // [rsp+1430h] [rbp+1330h]
  __m128i v226; // [rsp+1440h] [rbp+1340h]
  const char *v227; // [rsp+1450h] [rbp+1350h]
  _QWORD v228[7]; // [rsp+1458h] [rbp+1358h] BYREF
  __int64 v229[3]; // [rsp+1490h] [rbp+1390h] BYREF
  __int128 v230; // [rsp+14A8h] [rbp+13A8h]
  __int64 v231; // [rsp+14B8h] [rbp+13B8h]
  __int64 v232; // [rsp+14C0h] [rbp+13C0h]
  const char *v233; // [rsp+14C8h] [rbp+13C8h]
  _QWORD v234[7]; // [rsp+14D0h] [rbp+13D0h] BYREF
  __int64 v235[3]; // [rsp+1508h] [rbp+1408h] BYREF
  __int128 v236; // [rsp+1520h] [rbp+1420h]
  __m128i v237; // [rsp+1530h] [rbp+1430h]
  const char *v238; // [rsp+1540h] [rbp+1440h]
  _QWORD v239[7]; // [rsp+1548h] [rbp+1448h] BYREF
  __int64 v240[3]; // [rsp+1580h] [rbp+1480h] BYREF
  __int128 v241; // [rsp+1598h] [rbp+1498h]
  __int64 v242; // [rsp+15A8h] [rbp+14A8h]
  __int64 v243; // [rsp+15B0h] [rbp+14B0h]
  const char *v244; // [rsp+15B8h] [rbp+14B8h]
  _QWORD v245[7]; // [rsp+15C0h] [rbp+14C0h] BYREF
  __int64 v246[3]; // [rsp+15F8h] [rbp+14F8h] BYREF
  __int128 v247; // [rsp+1610h] [rbp+1510h]
  __m128i v248; // [rsp+1620h] [rbp+1520h]
  char v249[120]; // [rsp+1630h] [rbp+1530h] BYREF
  char v250[120]; // [rsp+16A8h] [rbp+15A8h] BYREF
  char v251[120]; // [rsp+1720h] [rbp+1620h] BYREF
  char v252[120]; // [rsp+1798h] [rbp+1698h] BYREF
  char v253[120]; // [rsp+1810h] [rbp+1710h] BYREF
  char v254[120]; // [rsp+1888h] [rbp+1788h] BYREF
  char v255[120]; // [rsp+1900h] [rbp+1800h] BYREF
  char v256; // [rsp+1978h] [rbp+1878h] BYREF

  v124 = -2i64;
  v1 = (_QWORD *)a1;
  v121 = (_QWORD *)a1;
  v125 = a1;
  v120 = 0;
  v122 = 0i64;
  v123 = 0i64;
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v140,
    (__int64)"launcher/api-ms-win-core-console-l1-1-0.dll",
    (__int64)"724F4F91041AD595E365B724A0348C83ACF12BBB",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-console-l1-1-0.dll",
    19208i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)&v140[7] + 8,
    (__int64)"launcher/api-ms-win-core-datetime-l1-1-0.dll",
    (__int64)"4940D5B92B6B80A40371F8DF073BF3EB406F5658",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-datetime-l1-1-0.dll",
    18696i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)&v140[15],
    (__int64)"launcher/api-ms-win-core-debug-l1-1-0.dll",
    (__int64)"E7C8A6C29C3158F8B332EEA5C33C3B1E044B5F73",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-debug-l1-1-0.dll",
    18696i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v141,
    (__int64)"launcher/api-ms-win-core-errorhandling-l1-1-0.dll",
    (__int64)"51CBB7BA47802DC630C2507750432C55F5979C27",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-errorhandling-l1-1-0.dll",
    18696i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v142,
    (__int64)"launcher/api-ms-win-core-file-l1-1-0.dll",
    (__int64)"9ACBEEF0AC510C179B319CA69CD5378D0E70504D",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-file-l1-1-0.dll",
    22280i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v143,
    (__int64)"launcher/api-ms-win-core-file-l1-2-0.dll",
    (__int64)"04669214375B25E2DC8A3635484E6EEB206BC4EB",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-file-l1-2-0.dll",
    18696i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v144,
    (__int64)"launcher/api-ms-win-core-file-l2-1-0.dll",
    (__int64)"402B7B8F8DCFD321B1D12FC85A1EE5137A5569B2",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-file-l2-1-0.dll",
    18696i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v145,
    (__int64)"launcher/api-ms-win-core-handle-l1-1-0.dll",
    (__int64)"A2E2A40CEA25EA4FD64B8DEAF4FBE4A2DB94107A",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-handle-l1-1-0.dll",
    18696i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v146,
    (__int64)"launcher/api-ms-win-core-heap-l1-1-0.dll",
    (__int64)"B4310929CCB82DD3C3A779CAB68F1F9F368076F2",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-heap-l1-1-0.dll",
    19208i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v147,
    (__int64)"launcher/api-ms-win-core-interlocked-l1-1-0.dll",
    (__int64)"F779CDEF9DED19402AA72958085213D6671CA572",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-interlocked-l1-1-0.dll",
    18696i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v148,
    (__int64)"launcher/api-ms-win-core-libraryloader-l1-1-0.dll",
    (__int64)"47143A66B4A2E2BA019BF1FD07BCCA9CFB8BB117",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-libraryloader-l1-1-0.dll",
    19720i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v149,
    (__int64)"launcher/api-ms-win-core-localization-l1-2-0.dll",
    (__int64)"9874398548891F6A08FC06437996F84EB7495783",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-localization-l1-2-0.dll",
    21256i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v150,
    (__int64)"launcher/api-ms-win-core-memory-l1-1-0.dll",
    (__int64)"9C03356CF48112563BB845479F40BF27B293E95E",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-memory-l1-1-0.dll",
    19208i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v151,
    (__int64)"launcher/api-ms-win-core-namedpipe-l1-1-0.dll",
    (__int64)"CB59F1FE73C17446EB196FC0DD7D944A0CD9D81F",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-namedpipe-l1-1-0.dll",
    18696i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v152,
    (__int64)"launcher/api-ms-win-core-processenvironment-l1-1-0.dll",
    (__int64)"2745259F4DBBEFBF6B570EE36D224ABDB18719BC",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-processenvironment-l1-1-0.dll",
    19720i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v153,
    (__int64)"launcher/api-ms-win-core-processthreads-l1-1-0.dll",
    (__int64)"50699041060D14576ED7BACBD44BE9AF80EB902A",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-processthreads-l1-1-0.dll",
    20744i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v154,
    (__int64)"launcher/api-ms-win-core-processthreads-l1-1-1.dll",
    (__int64)"0BFFB9ED366853E7019452644D26E8E8F236241B",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-processthreads-l1-1-1.dll",
    19208i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v155,
    (__int64)"launcher/api-ms-win-core-profile-l1-1-0.dll",
    (__int64)"E7E0B18A40A35BD8B0766AC72253DE827432E148",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-profile-l1-1-0.dll",
    18184i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v156,
    (__int64)"launcher/api-ms-win-core-rtlsupport-l1-1-0.dll",
    (__int64)"24F37D46DFC0EF303EF04ABF9956241AF55D25C9",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-rtlsupport-l1-1-0.dll",
    19208i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v157,
    (__int64)"launcher/api-ms-win-core-string-l1-1-0.dll",
    (__int64)"637E4A9946691F76E6DEB69BDC21C210921D6F07",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-string-l1-1-0.dll",
    18696i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v158,
    (__int64)"launcher/api-ms-win-core-synch-l1-1-0.dll",
    (__int64)"5584C189216A17228CCA6CD07037AAA9A8603241",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-synch-l1-1-0.dll",
    20744i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v159,
    (__int64)"launcher/api-ms-win-core-synch-l1-2-0.dll",
    (__int64)"A9AEBBBB73B7B846B051325D7572F2398F5986EE",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-synch-l1-2-0.dll",
    19208i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v160,
    (__int64)"launcher/api-ms-win-core-sysinfo-l1-1-0.dll",
    (__int64)"F20AE25484A1C1B43748A1F0C422F48F092AD2C1",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-sysinfo-l1-1-0.dll",
    19720i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v161,
    (__int64)"launcher/api-ms-win-core-timezone-l1-1-0.dll",
    (__int64)"4BF13DB65943E708690D6256D7DDD421CC1CC72B",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-timezone-l1-1-0.dll",
    19208i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v162,
    (__int64)"launcher/api-ms-win-core-util-l1-1-0.dll",
    (__int64)"1E1A5AB47E4C2B3C32C81690B94954B7612BB493",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-core-util-l1-1-0.dll",
    18696i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v163,
    (__int64)"launcher/api-ms-win-crt-conio-l1-1-0.dll",
    (__int64)"49002B58CB0DF2EE8D868DEC335133CF225657DF",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-crt-conio-l1-1-0.dll",
    19720i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v164,
    (__int64)"launcher/api-ms-win-crt-convert-l1-1-0.dll",
    (__int64)"C84E41FDCC4CA89A76AE683CB390A9B86500D3CA",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-crt-convert-l1-1-0.dll",
    22792i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v165,
    (__int64)"launcher/api-ms-win-crt-environment-l1-1-0.dll",
    (__int64)"9A4818897251CACB7FE1C6FE1BE3E854985186AD",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-crt-environment-l1-1-0.dll",
    19208i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v166,
    (__int64)"launcher/api-ms-win-crt-filesystem-l1-1-0.dll",
    (__int64)"78FA03C89EA12FF93FA499C38673039CC2D55D40",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-crt-filesystem-l1-1-0.dll",
    20744i64,
    &v126);
  v167 = "launcher/api-ms-win-crt-heap-l1-1-0.dll";
  i = "60B4CF246C5F414FC1CD12F506C41A1043D473EE";
  *(_QWORD *)&v117 = &i;
  *((_QWORD *)&v117 + 1) = &v117;
  sub_146178AE0(v168, (__int64)&v117, (__int64)v115);
  v168[3] = "https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-crt-heap-l1-1-0.dll";
  v168[4] = 0i64;
  v168[5] = 19720i64;
  v168[6] = 19720i64;
  v126 = 0i64;
  sub_146178CB0(v169, (__int64 *)&v126, (__int64)v115);
  sub_146178600((__int64)v170);
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  v171 = si128;
  v170[0] = 0;
  v172 = "launcher/api-ms-win-crt-locale-l1-1-0.dll";
  i = "9C1DF49A8DBDC8496AC6057F886F5C17B2C39E3E";
  *(_QWORD *)&v117 = &i;
  *((_QWORD *)&v117 + 1) = &v117;
  sub_146178AE0(v173, (__int64)&v117, (__int64)v115);
  v173[3] = "https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-crt-locale-l1-1-0.dll";
  v173[4] = 0i64;
  v173[5] = 19208i64;
  v173[6] = 19208i64;
  v126 = 0i64;
  sub_146178CB0(v174, (__int64 *)&v126, (__int64)v115);
  v175 = 0i64;
  v176 = 0i64;
  v177 = 7i64;
  LOWORD(v175) = 0;
  v178 = "launcher/api-ms-win-crt-math-l1-1-0.dll";
  i = "8B35EC4676BD96C2C4508DC5F98CA471B22DEED7";
  *(_QWORD *)&v117 = &i;
  *((_QWORD *)&v117 + 1) = &v117;
  sub_146178AE0(v179, (__int64)&v117, (__int64)v115);
  v179[3] = "https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-crt-math-l1-1-0.dll";
  v179[4] = 0i64;
  v179[5] = 27912i64;
  v179[6] = 27912i64;
  v126 = 0i64;
  sub_146178CB0(v180, (__int64 *)&v126, (__int64)v115);
  v181 = 0i64;
  v182 = si128;
  LOWORD(v181) = 0;
  v183 = "launcher/api-ms-win-crt-multibyte-l1-1-0.dll";
  i = "91EEF52C557AEFD0FDE27E8DF4E3C3B7F99862F2";
  *(_QWORD *)&v117 = &i;
  *((_QWORD *)&v117 + 1) = &v117;
  sub_146178AE0(v184, (__int64)&v117, (__int64)v115);
  v184[3] = "https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-crt-multibyte-l1-1-0.dll";
  v184[4] = 0i64;
  v184[5] = 26888i64;
  v184[6] = 26888i64;
  v126 = 0i64;
  sub_146178CB0(v185, (__int64 *)&v126, (__int64)v115);
  v186 = 0i64;
  v187 = 0i64;
  v188 = 7i64;
  LOWORD(v186) = 0;
  v189 = "launcher/api-ms-win-crt-private-l1-1-0.dll";
  i = "0C33CFE40EDD278A692C2E73E941184FD24286D9";
  *(_QWORD *)&v117 = &i;
  *((_QWORD *)&v117 + 1) = &v117;
  sub_146178AE0(v190, (__int64)&v117, (__int64)v115);
  v190[3] = "https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-crt-private-l1-1-0.dll";
  v190[4] = 0i64;
  v190[5] = 71432i64;
  v190[6] = 71432i64;
  v126 = 0i64;
  sub_146178CB0(v191, (__int64 *)&v126, (__int64)v115);
  v192 = 0i64;
  v193 = si128;
  LOWORD(v192) = 0;
  v194 = "launcher/api-ms-win-crt-process-l1-1-0.dll";
  i = "EC96F7BEEAEC14D3B6C437B97B4A18A365534B9B";
  *(_QWORD *)&v117 = &i;
  *((_QWORD *)&v117 + 1) = &v117;
  sub_146178AE0(v195, (__int64)&v117, (__int64)v115);
  v195[3] = "https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-crt-process-l1-1-0.dll";
  v195[4] = 0i64;
  v195[5] = 19720i64;
  v195[6] = 19720i64;
  v126 = 0i64;
  sub_146178CB0(v196, (__int64 *)&v126, (__int64)v115);
  v197 = 0i64;
  v198 = 0i64;
  v199 = 7i64;
  LOWORD(v197) = 0;
  v200 = "launcher/api-ms-win-crt-runtime-l1-1-0.dll";
  i = "A19ACEFA3F95D1B565650FDBC40EF98C793358E9";
  *(_QWORD *)&v117 = &i;
  *((_QWORD *)&v117 + 1) = &v117;
  sub_146178AE0(v201, (__int64)&v117, (__int64)v115);
  v201[3] = "https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-crt-runtime-l1-1-0.dll";
  v201[4] = 0i64;
  v201[5] = 23304i64;
  v201[6] = 23304i64;
  v126 = 0i64;
  sub_146178CB0(v202, (__int64 *)&v126, (__int64)v115);
  v203 = 0i64;
  v204 = si128;
  LOWORD(v203) = 0;
  v205 = "launcher/api-ms-win-crt-stdio-l1-1-0.dll";
  i = "982B5DA1C1F5B9D74AF6243885BCBA605D54DF8C";
  *(_QWORD *)&v117 = &i;
  *((_QWORD *)&v117 + 1) = &v117;
  sub_146178AE0(v206, (__int64)&v117, (__int64)v115);
  v206[3] = "https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-crt-stdio-l1-1-0.dll";
  v206[4] = 0i64;
  v206[5] = 24840i64;
  v206[6] = 24840i64;
  v126 = 0i64;
  sub_146178CB0(v207, (__int64 *)&v126, (__int64)v115);
  v208 = 0i64;
  v209 = 0i64;
  v210 = 7i64;
  LOWORD(v208) = 0;
  v211 = "launcher/api-ms-win-crt-string-l1-1-0.dll";
  i = "7F389E6F2D6E5BEB2A3BAF622A0C0EA24BC4DE60";
  *(_QWORD *)&v117 = &i;
  *((_QWORD *)&v117 + 1) = &v117;
  sub_146178AE0(v212, (__int64)&v117, (__int64)v115);
  v212[3] = "https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-crt-string-l1-1-0.dll";
  v212[4] = 0i64;
  v212[5] = 24840i64;
  v212[6] = 24840i64;
  v126 = 0i64;
  sub_146178CB0(v213, (__int64 *)&v126, (__int64)v115);
  v214 = 0i64;
  v215 = si128;
  LOWORD(v214) = 0;
  v216 = "launcher/api-ms-win-crt-time-l1-1-0.dll";
  i = "EE815A158BAACB357D9E074C0755B6F6C286B625";
  *(_QWORD *)&v117 = &i;
  *((_QWORD *)&v117 + 1) = &v117;
  sub_146178AE0(v217, (__int64)&v117, (__int64)v115);
  v217[3] = "https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-crt-time-l1-1-0.dll";
  v217[4] = 0i64;
  v217[5] = 21256i64;
  v217[6] = 21256i64;
  v126 = 0i64;
  sub_146178CB0(v218, (__int64 *)&v126, (__int64)v115);
  v219 = 0i64;
  v220 = 0i64;
  v221 = 7i64;
  LOWORD(v219) = 0;
  v222 = "launcher/api-ms-win-crt-utility-l1-1-0.dll";
  i = "EAA07829D012206AC55FB1AF5CC6A35F341D22BE";
  *(_QWORD *)&v117 = &i;
  *((_QWORD *)&v117 + 1) = &v117;
  sub_146178AE0(v223, (__int64)&v117, (__int64)v115);
  v223[3] = "https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/api-ms-win-crt-utility-l1-1-0.dll";
  v223[4] = 0i64;
  v223[5] = 19208i64;
  v223[6] = 19208i64;
  v126 = 0i64;
  sub_146178CB0(v224, (__int64 *)&v126, (__int64)v115);
  v225 = 0i64;
  v226 = si128;
  LOWORD(v225) = 0;
  v227 = "launcher/Launcher.exe";
  i = "F259DE45C50F399D3E278FD39401EF51A3CC031A";
  *(_QWORD *)&v117 = &i;
  *((_QWORD *)&v117 + 1) = &v117;
  sub_146178AE0(v228, (__int64)&v117, (__int64)v115);
  v228[3] = "https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/Launcher.exe";
  v228[4] = 0i64;
  v228[5] = 48490288i64;
  v228[6] = 48490288i64;
  v126 = 0i64;
  sub_146178CB0(v229, (__int64 *)&v126, (__int64)v115);
  v230 = 0i64;
  v231 = 0i64;
  v232 = 7i64;
  LOWORD(v230) = 0;
  v233 = "launcher/Launcher.rpf";
  i = "237682874D921209CDBDB16E257C65A9480BAD94";
  *(_QWORD *)&v117 = &i;
  *((_QWORD *)&v117 + 1) = &v117;
  sub_146178AE0(v234, (__int64)&v117, (__int64)v115);
  v234[3] = "https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/Launcher.rpf";
  v234[4] = 0i64;
  v234[5] = 858112i64;
  v234[6] = 858112i64;
  v126 = 0i64;
  sub_146178CB0(v235, (__int64 *)&v126, (__int64)v115);
  v236 = 0i64;
  v237 = si128;
  LOWORD(v236) = 0;
  v238 = "launcher/LauncherPatcher.exe";
  i = "BFD3A153979C2CED11F6F8BFDBE767AD502F4655";
  *(_QWORD *)&v117 = &i;
  *((_QWORD *)&v117 + 1) = &v117;
  sub_146178AE0(v239, (__int64)&v117, (__int64)v115);
  v239[3] = "https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/LauncherPatcher.exe";
  v239[4] = 0i64;
  v239[5] = 508208i64;
  v239[6] = 508208i64;
  v126 = 0i64;
  sub_146178CB0(v240, (__int64 *)&v126, (__int64)v115);
  v241 = 0i64;
  v242 = 0i64;
  v243 = 7i64;
  LOWORD(v241) = 0;
  v244 = "launcher/mtl_libovr.dll";
  i = "0FF4CEDA9DE3B63C4DE6E1626009D5ED5A475C96";
  *(_QWORD *)&v117 = &i;
  *((_QWORD *)&v117 + 1) = &v117;
  sub_146178AE0(v245, (__int64)&v117, (__int64)v115);
  v245[3] = "https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/mtl_libovr.dll";
  v245[4] = 0i64;
  v245[5] = 178584i64;
  v245[6] = 178584i64;
  v126 = 0i64;
  sub_146178CB0(v246, (__int64 *)&v126, (__int64)v115);
  v247 = 0i64;
  v248 = si128;
  LOWORD(v247) = 0;
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v249,
    (__int64)"launcher/offline.pak",
    (__int64)"53F93E488AA5482C187641CE85164F7C5A1ED8B2",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/offline.pak",
    1597382i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v250,
    (__int64)"launcher/RockstarService.exe",
    (__int64)"FCA2A3393CEDB7DE49C6ABAD69F2ACC7354DFD66",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/RockstarService.exe",
    2017072i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v251,
    (__int64)"launcher/RockstarSteamHelper.exe",
    (__int64)"8E10781C248612A0F00A2BBFA828FC110978E751",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/RockstarSteamHelper.exe",
    1063216i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v252,
    (__int64)"launcher/ucrtbase.dll",
    (__int64)"4189F4459C54E69C6D3155A82524BDA7549A75A6",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/ucrtbase.dll",
    1016584i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v253,
    (__int64)"launcher/ThirdParty/Epic/EOSSDK-Win64-Shipping-1.13.1.dll",
    (__int64)"9176F6D58E46153342D7B065D279636DF8298603",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/ThirdParty/Epic/EOSSDK-Win64-Shipping-1.13.1.dll",
    23390688i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v254,
    (__int64)"launcher/ThirdParty/Epic/EOSSDK-Win64-Shipping.dll",
    (__int64)"AF01787DDB7DE00239EDC62D33E0B20C0BE80037",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/ThirdParty/Epic/EOSSDK-Win64-Shipping.dll",
    9971968i64,
    &v126);
  v126 = 0i64;
  sub_146178FA0(
    (__int64)v255,
    (__int64)"launcher/ThirdParty/Steam/steam_api64.dll",
    (__int64)"BD014660F7978A07BA2F99B6CF0621D678602663",
    (__int64)"https://content.cfx.re/mirrors/mtl/1.0.53.576/launcher/ThirdParty/Steam/steam_api64.dll",
    121256i64,
    &v126);
  *(_QWORD *)&v117 = v140;
  *((_QWORD *)&v117 + 1) = &v256;
  sub_146179530((__int64 *)&v122, (__int64)&v117);
  `eh vector destructor iterator'(v140, 0x78ui64, 0x33ui64, (void (__fastcall *)(void *))sub_146179300);
  v5 = (_QWORD *)*((_QWORD *)&v122 + 1);
  v4 = (_QWORD *)v122;
  if ( (_QWORD)v122 != *((_QWORD *)&v122 + 1) )
  {
    v6 = (_QWORD *)*((_QWORD *)&xmmword_14610AAC0 + 1);
    do
    {
      if ( v6 == (_QWORD *)qword_14610AAD0 )
      {
        sub_146177800((__int64 *)&xmmword_14610AAC0, (__int64)v6, v4);
        v6 = (_QWORD *)*((_QWORD *)&xmmword_14610AAC0 + 1);
      }
      else
      {
        sub_146178F20(v6, v4, v3);
        v6 = (_QWORD *)(*((_QWORD *)&xmmword_14610AAC0 + 1) + 120i64);
        *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
      }
      v4 += 15;
    }
    while ( v4 != v5 );
  }
  v7 = (unsigned __int8)sub_146179D90() == 0;
  v9 = dword_1461090C0;
  if ( !v7 )
    goto LABEL_27;
  if ( dword_1461090C0 == -1 )
  {
    v9 = sub_1461A48B0(v8);
    dword_1461090C0 = v9;
  }
  if ( v9 >= 0xB80 )
  {
LABEL_27:
    if ( v9 == -1 )
    {
      v9 = sub_1461A48B0(v8);
      dword_1461090C0 = v9;
    }
    LODWORD(i) = v9;
    v23 = **(const char ***)sub_146179630((__int64 *)&qword_14610AAE8, (int *)&i);
    for ( i = v23; !i[25]; v23 = i )
    {
      v25 = v23 + 32;
      sub_146170E60((__int64)v140, (__int64)(v23 + 32), v24, v13);
      sub_146178F20(&v140[2], (_QWORD *)v25 + 4, v26);
      if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
      {
        sub_146177800((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), &v140[2]);
      }
      else
      {
        sub_146178F20(*((_QWORD **)&xmmword_14610AAC0 + 1), &v140[2], v27);
        *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
      }
      sub_146162730((__int64)&v140[7] + 8);
      sub_14617D330(&v140[6]);
      sub_146166C80((__int64)&v140[2] + 8);
      sub_1461626B0((__int64)v140);
      sub_146179760((__int64 *)&i);
    }
LABEL_34:
    v17 = dword_1461090C0;
    goto LABEL_35;
  }
  LODWORD(i) = 2944;
  v10 = **(const char ***)sub_146179630((__int64 *)&qword_14610AAE8, (int *)&i);
  for ( i = v10; !i[25]; v10 = i )
  {
    v14 = v10 + 32;
    sub_146170E60((__int64)v140, (__int64)(v10 + 32), v12, v13);
    sub_146178F20(&v140[2], (_QWORD *)v14 + 4, v15);
    if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
    {
      sub_146177800((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), &v140[2]);
    }
    else
    {
      sub_146178F20(*((_QWORD **)&xmmword_14610AAC0 + 1), &v140[2], v16);
      *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
    }
    sub_146162730((__int64)&v140[7] + 8);
    sub_14617D330(&v140[6]);
    sub_146166C80((__int64)&v140[2] + 8);
    sub_1461626B0((__int64)v140);
    sub_146179760((__int64 *)&i);
  }
  v17 = dword_1461090C0;
  if ( dword_1461090C0 == -1 )
  {
    v17 = sub_1461A48B0(v11);
    dword_1461090C0 = v17;
  }
  if ( v17 != 1 )
  {
    if ( v17 == -1 )
    {
      v17 = sub_1461A48B0(v11);
      dword_1461090C0 = v17;
    }
    LODWORD(i) = v17;
    v18 = (__int64 *)sub_146179630((__int64 *)&qword_14610AAE8, (int *)&i);
    *((_QWORD *)&v126 + 1) = 26224i64;
    v127 = _mm_load_si128((const __m128i *)&xmmword_14612A930);
    *(_QWORD *)&v126 = 0x722E657461647075i64;
    sub_146178280(v18, (__int64)FileName, (const void **)&v126);
    v19 = v137;
    if ( *(_BYTE *)(v137 + 25)
      || (unsigned __int8)sub_1461797D0((__int64)v18, (size_t *)&v126, (const void **)(v137 + 32)) )
    {
      std::_Xout_of_range("invalid map<K, T> key");
LABEL_276:
      unknown_libname_4(v57, v46, v47, v48);
    }
    *(_QWORD *)&v140[0] = "override/update/update.rpf";
    sub_146178A30((_QWORD *)v140 + 1, v19 + 72, v20);
    v140[2] = *(_OWORD *)(v19 + 96);
    v140[3] = *(_OWORD *)(v19 + 112);
    sub_146178B90(&v140[4], (_QWORD *)(v19 + 128));
    sub_146170F20((__int64)&v140[5] + 8, v19 + 152, v21, v22);
    if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
    {
      sub_146177A10((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
    }
    else
    {
      sub_146178E60(*((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
      *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
    }
    sub_146162730((__int64)&v140[5] + 8);
    sub_14617D330(&v140[4]);
    sub_146166C80((__int64)v140 + 8);
    sub_1461626B0((__int64)&v126);
    goto LABEL_34;
  }
LABEL_35:
  if ( v17 == -1 )
  {
    v17 = sub_1461A48B0(v11);
    dword_1461090C0 = v17;
  }
  if ( v17 >= 2060 )
  {
    *(_QWORD *)&v140[0] = "update/x64/dlcpacks/mpsum/dlc.rpf";
    i = "ffd81a2ce5741b38eae69e47132ddbfc5cfdf9f4";
    *(_QWORD *)&v117 = &i;
    *((_QWORD *)&v117 + 1) = &v117;
    sub_146178AE0((_QWORD *)v140 + 1, (__int64)&v117, (__int64)v115);
    *(_QWORD *)&v140[2] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
    *((_QWORD *)&v140[2] + 1) = 0i64;
    *(_QWORD *)&v140[3] = 980621312i64;
    *((_QWORD *)&v140[3] + 1) = 980621312i64;
    v126 = 0i64;
    sub_146178CB0(&v140[4], (__int64 *)&v126, (__int64)v115);
    *(__int128 *)((char *)&v140[5] + 8) = 0i64;
    *((_QWORD *)&v140[6] + 1) = 0i64;
    *(_QWORD *)&v140[7] = 7i64;
    WORD4(v140[5]) = 0;
    if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
    {
      sub_146177A10((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
    }
    else
    {
      sub_146178E60(*((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
      *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
    }
    sub_146162730((__int64)&v140[5] + 8);
    sub_14617D330(&v140[4]);
    sub_146166C80((__int64)v140 + 8);
    v17 = dword_1461090C0;
  }
  if ( v17 == -1 )
  {
    v17 = sub_1461A48B0(v11);
    dword_1461090C0 = v17;
  }
  if ( v17 >= 2189 )
  {
    *(_QWORD *)&v140[0] = "update/x64/dlcpacks/mpheist4/dlc.rpf";
    i = "1ddd73a584126793478c835efef9899a1c9d6fe7";
    *(_QWORD *)&v117 = &i;
    *((_QWORD *)&v117 + 1) = &v117;
    sub_146178AE0((_QWORD *)v140 + 1, (__int64)&v117, (__int64)v115);
    *(_QWORD *)&v140[2] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
    *((_QWORD *)&v140[2] + 1) = 0i64;
    *(_QWORD *)&v140[3] = 3452489728i64;
    *((_QWORD *)&v140[3] + 1) = 3452489728i64;
    v126 = 0i64;
    sub_146178CB0(&v140[4], (__int64 *)&v126, (__int64)v115);
    *(__int128 *)((char *)&v140[5] + 8) = 0i64;
    *((_QWORD *)&v140[6] + 1) = 0i64;
    *(_QWORD *)&v140[7] = 7i64;
    WORD4(v140[5]) = 0;
    if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
    {
      sub_146177A10((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
    }
    else
    {
      sub_146178E60(*((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
      *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
    }
    if ( *(_QWORD *)&v140[7] > 7ui64 )
      sub_1461650D0((__int64)&v140[5] + 8, *((void **)&v140[5] + 1), *(__int64 *)&v140[7]);
    *((_QWORD *)&v140[6] + 1) = 0i64;
    *(_QWORD *)&v140[7] = 7i64;
    WORD4(v140[5]) = 0;
    sub_14617D330(&v140[4]);
    sub_146166C80((__int64)v140 + 8);
    *(_QWORD *)&v140[0] = "update/x64/dlcpacks/patchday24ng/dlc.rpf";
    i = "f1d3a69dc31f50dd7741dfe5495568af40da4191";
    *(_QWORD *)&v117 = &i;
    *((_QWORD *)&v117 + 1) = &v117;
    sub_146178AE0((_QWORD *)v140 + 1, (__int64)&v117, (__int64)v115);
    *(_QWORD *)&v140[2] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
    *((_QWORD *)&v140[2] + 1) = 0i64;
    *(_QWORD *)&v140[3] = 384018432i64;
    *((_QWORD *)&v140[3] + 1) = 384018432i64;
    v126 = 0i64;
    sub_146178CB0(&v140[4], (__int64 *)&v126, (__int64)v115);
    *(__int128 *)((char *)&v140[5] + 8) = 0i64;
    *((_QWORD *)&v140[6] + 1) = 0i64;
    *(_QWORD *)&v140[7] = 7i64;
    WORD4(v140[5]) = 0;
    if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
    {
      sub_146177A10((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
    }
    else
    {
      sub_146178E60(*((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
      *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
    }
    sub_146162730((__int64)&v140[5] + 8);
    sub_14617D330(&v140[4]);
    sub_146166C80((__int64)v140 + 8);
    v17 = dword_1461090C0;
  }
  if ( v17 == -1 )
  {
    v17 = sub_1461A48B0(v11);
    dword_1461090C0 = v17;
  }
  if ( v17 >= 2372 )
  {
    *(_QWORD *)&v140[0] = "update/x64/dlcpacks/mptuner/dlc.rpf";
    i = "7a7521b3396701f4fe8ae51347c6206c46306648";
    *(_QWORD *)&v117 = &i;
    *((_QWORD *)&v117 + 1) = &v117;
    sub_146178AE0((_QWORD *)v140 + 1, (__int64)&v117, (__int64)v115);
    *(_QWORD *)&v140[2] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
    *((_QWORD *)&v140[2] + 1) = 0i64;
    *(_QWORD *)&v140[3] = 3482869760i64;
    *((_QWORD *)&v140[3] + 1) = 3482869760i64;
    v126 = 0i64;
    sub_146178CB0(&v140[4], (__int64 *)&v126, (__int64)v115);
    *(__int128 *)((char *)&v140[5] + 8) = 0i64;
    *((_QWORD *)&v140[6] + 1) = 0i64;
    *(_QWORD *)&v140[7] = 7i64;
    WORD4(v140[5]) = 0;
    if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
    {
      sub_146177A10((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
    }
    else
    {
      sub_146178E60(*((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
      *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
    }
    sub_146162730((__int64)&v140[5] + 8);
    sub_14617D330(&v140[4]);
    sub_146166C80((__int64)v140 + 8);
    v17 = dword_1461090C0;
  }
  if ( v17 == -1 )
  {
    v17 = sub_1461A48B0(v11);
    dword_1461090C0 = v17;
  }
  if ( v17 >= 2545 )
  {
    *(_QWORD *)&v140[0] = "update/x64/dlcpacks/mpsecurity/dlc.rpf";
    i = "27c8100da2537472ad012df036a95da08188d54a";
    *(_QWORD *)&v117 = &i;
    *((_QWORD *)&v117 + 1) = &v117;
    sub_146178AE0((_QWORD *)v140 + 1, (__int64)&v117, (__int64)v115);
    *(_QWORD *)&v140[2] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
    *((_QWORD *)&v140[2] + 1) = 0i64;
    *(_QWORD *)&v140[3] = 1978963968i64;
    *((_QWORD *)&v140[3] + 1) = 1978963968i64;
    v126 = 0i64;
    sub_146178CB0(&v140[4], (__int64 *)&v126, (__int64)v115);
    *(__int128 *)((char *)&v140[5] + 8) = 0i64;
    *((_QWORD *)&v140[6] + 1) = 0i64;
    *(_QWORD *)&v140[7] = 7i64;
    WORD4(v140[5]) = 0;
    if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
    {
      sub_146177A10((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
    }
    else
    {
      sub_146178E60(*((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
      *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
    }
    sub_146162730((__int64)&v140[5] + 8);
    sub_14617D330(&v140[4]);
    sub_146166C80((__int64)v140 + 8);
    *(_QWORD *)&v140[0] = "update/x64/dlcpacks/mpsecurity/dlc1.rpf";
    i = "82f34009966d790a2987c70a2872a5658a71f198";
    *(_QWORD *)&v117 = &i;
    *((_QWORD *)&v117 + 1) = &v117;
    sub_146178AE0((_QWORD *)v140 + 1, (__int64)&v117, (__int64)v115);
    *(_QWORD *)&v140[2] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
    *((_QWORD *)&v140[2] + 1) = 0i64;
    *(_QWORD *)&v140[3] = 1308874752i64;
    *((_QWORD *)&v140[3] + 1) = 1308874752i64;
    v126 = 0i64;
    sub_146178CB0(&v140[4], (__int64 *)&v126, (__int64)v115);
    *(__int128 *)((char *)&v140[5] + 8) = 0i64;
    *((_QWORD *)&v140[6] + 1) = 0i64;
    *(_QWORD *)&v140[7] = 7i64;
    WORD4(v140[5]) = 0;
    if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
    {
      sub_146177A10((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
    }
    else
    {
      sub_146178E60(*((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
      *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
    }
    sub_146162730((__int64)&v140[5] + 8);
    sub_14617D330(&v140[4]);
    sub_146166C80((__int64)v140 + 8);
    v17 = dword_1461090C0;
  }
  if ( v17 == -1 )
  {
    v17 = sub_1461A48B0(v11);
    dword_1461090C0 = v17;
  }
  if ( v17 >= 2612 )
  {
    *(_QWORD *)&v140[0] = "update/x64/dlcpacks/mpg9ec/dlc.rpf";
    i = "011114b746a4d5a830241a174b3e16eb2f63f224";
    *(_QWORD *)&v117 = &i;
    *((_QWORD *)&v117 + 1) = &v117;
    sub_146178AE0((_QWORD *)v140 + 1, (__int64)&v117, (__int64)v115);
    *(_QWORD *)&v140[2] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
    *((_QWORD *)&v140[2] + 1) = 0i64;
    *(_QWORD *)&v140[3] = 1847296i64;
    *((_QWORD *)&v140[3] + 1) = 1847296i64;
    v126 = 0i64;
    sub_146178CB0(&v140[4], (__int64 *)&v126, (__int64)v115);
    *(__int128 *)((char *)&v140[5] + 8) = 0i64;
    *((_QWORD *)&v140[6] + 1) = 0i64;
    *(_QWORD *)&v140[7] = 7i64;
    WORD4(v140[5]) = 0;
    if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
    {
      sub_146177A10((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
    }
    else
    {
      sub_146178E60(*((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
      *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
    }
    sub_146162730((__int64)&v140[5] + 8);
    sub_14617D330(&v140[4]);
    sub_146166C80((__int64)v140 + 8);
    v17 = dword_1461090C0;
  }
  if ( v17 == -1 )
  {
    v17 = sub_1461A48B0(v11);
    dword_1461090C0 = v17;
  }
  if ( v17 >= 2699 )
  {
    *(_QWORD *)&v140[0] = "update/x64/dlcpacks/mpsum2/dlc.rpf";
    i = "5cb63b0939a716e899fa1f514b73a14ca4b58129";
    *(_QWORD *)&v117 = &i;
    *((_QWORD *)&v117 + 1) = &v117;
    sub_146178AE0((_QWORD *)v140 + 1, (__int64)&v117, (__int64)v115);
    *(_QWORD *)&v140[2] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
    *((_QWORD *)&v140[2] + 1) = 0i64;
    *(_QWORD *)&v140[3] = 1245167616i64;
    *((_QWORD *)&v140[3] + 1) = 1245167616i64;
    v126 = 0i64;
    sub_146178CB0(&v140[4], (__int64 *)&v126, (__int64)v115);
    *(__int128 *)((char *)&v140[5] + 8) = 0i64;
    *((_QWORD *)&v140[6] + 1) = 0i64;
    *(_QWORD *)&v140[7] = 7i64;
    WORD4(v140[5]) = 0;
    if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
    {
      sub_146177A10((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
    }
    else
    {
      sub_146178E60(*((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
      *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
    }
    sub_146162730((__int64)&v140[5] + 8);
    sub_14617D330(&v140[4]);
    sub_146166C80((__int64)v140 + 8);
    v17 = dword_1461090C0;
  }
  if ( v17 == -1 )
  {
    v17 = sub_1461A48B0(v11);
    dword_1461090C0 = v17;
  }
  if ( v17 >= 2802 )
  {
    *(_QWORD *)&v140[0] = "update/x64/dlcpacks/mpchristmas3/dlc.rpf";
    i = "500440406ee1aa825ce2371699b127fce460d9a2";
    *(_QWORD *)&v117 = &i;
    *((_QWORD *)&v117 + 1) = &v117;
    sub_146178AE0((_QWORD *)v140 + 1, (__int64)&v117, (__int64)v115);
    *(_QWORD *)&v140[2] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
    *((_QWORD *)&v140[2] + 1) = 0i64;
    *(_QWORD *)&v140[3] = 1822871552i64;
    *((_QWORD *)&v140[3] + 1) = 1822871552i64;
    v126 = 0i64;
    sub_146178CB0(&v140[4], (__int64 *)&v126, (__int64)v115);
    *(__int128 *)((char *)&v140[5] + 8) = 0i64;
    *((_QWORD *)&v140[6] + 1) = 0i64;
    *(_QWORD *)&v140[7] = 7i64;
    WORD4(v140[5]) = 0;
    if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
    {
      sub_146177A10((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
    }
    else
    {
      sub_146178E60(*((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
      *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
    }
    sub_146162730((__int64)&v140[5] + 8);
    sub_14617D330(&v140[4]);
    sub_146166C80((__int64)v140 + 8);
    v17 = dword_1461090C0;
  }
  if ( v17 == -1 )
  {
    v17 = sub_1461A48B0(v11);
    dword_1461090C0 = v17;
  }
  if ( v17 >= 2944 )
  {
    *(_QWORD *)&v140[0] = "update/x64/dlcpacks/mp2023_01/dlc.rpf";
    i = "11519d20c34a5f34d06252078b41e28275dbc67b";
    *(_QWORD *)&v117 = &i;
    *((_QWORD *)&v117 + 1) = &v117;
    sub_146178AE0((_QWORD *)v140 + 1, (__int64)&v117, (__int64)v115);
    *(_QWORD *)&v140[2] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
    *((_QWORD *)&v140[2] + 1) = 0i64;
    *(_QWORD *)&v140[3] = 809424896i64;
    *((_QWORD *)&v140[3] + 1) = 809424896i64;
    v126 = 0i64;
    sub_146178CB0(&v140[4], (__int64 *)&v126, (__int64)v115);
    *(__int128 *)((char *)&v140[5] + 8) = 0i64;
    *((_QWORD *)&v140[6] + 1) = 0i64;
    *(_QWORD *)&v140[7] = 7i64;
    WORD4(v140[5]) = 0;
    if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
    {
      sub_146177A10((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
    }
    else
    {
      sub_146178E60(*((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
      *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
    }
    sub_146162730((__int64)&v140[5] + 8);
    sub_14617D330(&v140[4]);
    sub_146166C80((__int64)v140 + 8);
    v17 = dword_1461090C0;
  }
  if ( v17 == -1 )
  {
    v17 = sub_1461A48B0(v11);
    dword_1461090C0 = v17;
  }
  if ( v17 >= 3095 )
  {
    *(_QWORD *)&v140[0] = "update/x64/dlcpacks/mp2023_02/dlc.rpf";
    i = "22afecbf20f46f1a871f442b2822b120bb41fbbf";
    *(_QWORD *)&v117 = &i;
    *((_QWORD *)&v117 + 1) = &v117;
    sub_146178AE0((_QWORD *)v140 + 1, (__int64)&v117, (__int64)v115);
    *(_QWORD *)&v140[2] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
    *((_QWORD *)&v140[2] + 1) = 0i64;
    *(_QWORD *)&v140[3] = 1604741120i64;
    *((_QWORD *)&v140[3] + 1) = 1604741120i64;
    v126 = 0i64;
    sub_146178CB0(&v140[4], (__int64 *)&v126, (__int64)v115);
    *(__int128 *)((char *)&v140[5] + 8) = 0i64;
    *((_QWORD *)&v140[6] + 1) = 0i64;
    *(_QWORD *)&v140[7] = 7i64;
    WORD4(v140[5]) = 0;
    if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
    {
      sub_146177A10((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
    }
    else
    {
      sub_146178E60(*((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
      *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
    }
    sub_146162730((__int64)&v140[5] + 8);
    sub_14617D330(&v140[4]);
    sub_146166C80((__int64)v140 + 8);
    v17 = dword_1461090C0;
  }
  if ( v17 == -1 )
  {
    v17 = sub_1461A48B0(v11);
    dword_1461090C0 = v17;
  }
  if ( v17 >= 3258 )
  {
    *(_QWORD *)&v140[0] = "update/x64/dlcpacks/mp2024_01/dlc.rpf";
    i = "bf9efb4348cc95ecd2ab0bfd956768148c7b48bf";
    *(_QWORD *)&v117 = &i;
    *((_QWORD *)&v117 + 1) = &v117;
    sub_146178AE0((_QWORD *)v140 + 1, (__int64)&v117, (__int64)v115);
    *(_QWORD *)&v140[2] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
    *((_QWORD *)&v140[2] + 1) = 0i64;
    *(_QWORD *)&v140[3] = 1178773504i64;
    *((_QWORD *)&v140[3] + 1) = 1178773504i64;
    v126 = 0i64;
    sub_146178CB0(&v140[4], (__int64 *)&v126, (__int64)v115);
    *(__int128 *)((char *)&v140[5] + 8) = 0i64;
    *((_QWORD *)&v140[6] + 1) = 0i64;
    *(_QWORD *)&v140[7] = 7i64;
    WORD4(v140[5]) = 0;
    if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
    {
      sub_146177A10((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
    }
    else
    {
      sub_146178E60(*((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
      *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
    }
    sub_146162730((__int64)&v140[5] + 8);
    sub_14617D330(&v140[4]);
    sub_146166C80((__int64)v140 + 8);
    v17 = dword_1461090C0;
  }
  if ( v17 == -1 )
  {
    v17 = sub_1461A48B0(v11);
    dword_1461090C0 = v17;
  }
  if ( v17 >= 3407 )
  {
    *(_QWORD *)&v140[0] = "update/x64/dlcpacks/mp2024_02/dlc.rpf";
    i = "c15b71266137bddb93ad1197afeb35d54b6a21fe";
    *(_QWORD *)&v117 = &i;
    *((_QWORD *)&v117 + 1) = &v117;
    sub_146178AE0((_QWORD *)v140 + 1, (__int64)&v117, (__int64)v115);
    *(_QWORD *)&v140[2] = "nope:https://runtime.fivem.net/patches/dlcpacks/patchday4ng/dlc.rpfmpbiker/dlc.rpf";
    *((_QWORD *)&v140[2] + 1) = 0i64;
    *(_QWORD *)&v140[3] = 1183961088i64;
    *((_QWORD *)&v140[3] + 1) = 1183961088i64;
    v126 = 0i64;
    sub_146178CB0(&v140[4], (__int64 *)&v126, (__int64)v115);
    *(__int128 *)((char *)&v140[5] + 8) = 0i64;
    *((_QWORD *)&v140[6] + 1) = 0i64;
    *(_QWORD *)&v140[7] = 7i64;
    WORD4(v140[5]) = 0;
    if ( *((_QWORD *)&xmmword_14610AAC0 + 1) == qword_14610AAD0 )
    {
      sub_146177A10((__int64 *)&xmmword_14610AAC0, *((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
    }
    else
    {
      sub_146178E60(*((__int64 *)&xmmword_14610AAC0 + 1), (__int64)v140);
      *((_QWORD *)&xmmword_14610AAC0 + 1) += 120i64;
    }
    sub_146162730((__int64)&v140[5] + 8);
    sub_14617D330(&v140[4]);
    sub_146166C80((__int64)v140 + 8);
  }
  v126 = 0i64;
  v127 = 0ui64;
  sub_146168F30(&v126, L"data\\game-storage\\game_files.dat", 0x20ui64, v13);
  sub_1461645B0((__int64)v134, (void **)&v126, v28, v29);
  v117 = 0i64;
  v118 = 0i64;
  v119 = 0i64;
  sub_146168F30(&v117, L"data\\game-storage\\update+update.rpf_fc941d698834e30e40a06a40f6a35b1b18e1c50c", 0x4Cui64, v30);
  sub_1461645B0((__int64)FileName, (void **)&v117, v31, v32);
  v33 = (const wchar_t *)FileName;
  if ( v138 > 7 )
    v33 = FileName[0];
  if ( !wstat64i32(v33, &Stat) && Stat.st_size == 928075776 )
  {
    v34 = (const wchar_t *)FileName;
    if ( v138 > 7 )
      v34 = FileName[0];
    wunlink(v34);
    v35 = (const wchar_t *)v134;
    if ( v135.m128i_i64[1] > 7ui64 )
      v35 = v134[0];
    wunlink(v35);
  }
  sub_146162730((__int64)FileName);
  if ( v135.m128i_i64[1] > 7ui64 )
  {
    v36 = v134[0];
    if ( (unsigned __int64)(2 * v135.m128i_i64[1] + 2) >= 0x1000 )
    {
      v36 = (wchar_t *)*((_QWORD *)v134[0] - 1);
      if ( (unsigned __int64)((char *)v134[0] - (char *)v36 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v36);
  }
  *v1 = 0i64;
  v1[1] = 0i64;
  v37 = operator new(0x60ui64);
  *v37 = v37;
  v37[1] = v37;
  v37[2] = v37;
  *((_WORD *)v37 + 12) = 257;
  *v1 = v37;
  v38 = 1;
  v120 = 1;
  i = (const char *)*((_QWORD *)&xmmword_14610AAC0 + 1);
  v39 = (const char **)xmmword_14610AAC0;
  if ( (_QWORD)xmmword_14610AAC0 != *((_QWORD *)&xmmword_14610AAC0 + 1) )
  {
    v40 = _mm_load_si128((const __m128i *)&Size);
    while ( 1 )
    {
      *(_OWORD *)v128 = 0i64;
      v129 = 0ui64;
      v41 = strlen(*v39);
      sub_14615A650(v128, *v39, v41);
      v42 = v128;
      if ( *((_QWORD *)&v129 + 1) > 0xFui64 )
        v42 = (void **)v128[0];
      v43 = v129;
      if ( (unsigned __int64)v129 < 4 )
        goto LABEL_186;
      v44 = (char *)v42 + v129;
      v45 = sub_1461A7840(v42, (char *)v42 + v129, "ros_", 4i64);
      if ( (char *)v45 != v44 && (void **)v45 == v42 )
        break;
LABEL_185:
      v43 = v129;
LABEL_186:
      v73 = v128;
      if ( *((_QWORD *)&v129 + 1) > 0xFui64 )
        v73 = (void **)v128[0];
      if ( v43 >= 9 )
      {
        v74 = (char *)v73 + v43;
        v75 = sub_1461A7840(v73, (char *)v73 + v43, "launcher/", 9i64);
        if ( (char *)v75 != v74 && (void **)v75 == v73 )
        {
          *(_OWORD *)v132 = 0i64;
          v133 = 0i64;
          if ( (unsigned __int64)v129 < 9 )
            unknown_libname_5(v77, v76, v78, v79);
          v80 = v129 - 9;
          v81 = v129 - 9;
          v82 = v128;
          if ( *((_QWORD *)&v129 + 1) > 0xFui64 )
            v82 = (void **)v128[0];
          if ( v80 > 0x7FFFFFFFFFFFFFFFi64 )
            unknown_libname_4(v77, v76, v78, v79);
          if ( v80 > 0xF )
          {
            v83 = v80 | 0xF;
            if ( (v80 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
            {
              if ( v83 < 0x16 )
                v83 = 22i64;
            }
            else
            {
              v83 = 0x7FFFFFFFFFFFFFFFi64;
            }
            v84 = sub_14615A5E0(v83 + 1);
            v132[0] = v84;
            *(_QWORD *)&v133 = v81;
            *((_QWORD *)&v133 + 1) = v83;
            memcpy(v84, (char *)v82 + 9, v81);
            *((_BYTE *)v84 + v81) = 0;
          }
          else
          {
            *(_QWORD *)&v133 = v129 - 9;
            *((_QWORD *)&v133 + 1) = 15i64;
            memcpy(v132, (char *)v82 + 9, v80);
            *((_BYTE *)v132 + v81) = 0;
          }
          v85 = v38 | 4;
          v120 = v85;
          v86 = v133;
          if ( *((_QWORD *)&v133 + 1) - (_QWORD)v133 < 9ui64 )
          {
            v89 = sub_146178350(v132, 9ui64, 0i64, 0i64, "Launcher/", 9ui64);
          }
          else
          {
            *(_QWORD *)&v133 = v133 + 9;
            v87 = v132;
            if ( *((_QWORD *)&v86 + 1) > 0xFui64 )
              v87 = (void **)v132[0];
            if ( "" <= (char *)v87 || "Launcher/" > (char *)v87 + v86 )
            {
              v88 = 9i64;
            }
            else if ( v87 > (void **)"Launcher/" )
            {
              v88 = (char *)v87 - "Launcher/";
            }
            else
            {
              v88 = 0i64;
            }
            memmove((char *)v87 + 9, v87, v86 + 1);
            memcpy(v87, "Launcher/", v88);
            memcpy((char *)v87 + v88, &aLauncher_1[v88 + 9], 9 - v88);
            v89 = v132;
          }
          v90 = *v89;
          v91 = v89[1];
          *((_QWORD *)v89 + 2) = 0i64;
          *((_QWORD *)v89 + 3) = 15i64;
          *(_BYTE *)v89 = 0;
          v38 = v85 | 2;
          v120 = v38;
          if ( *((_QWORD *)&v129 + 1) > 0xFui64 )
          {
            v92 = v128[0];
            if ( (unsigned __int64)(*((_QWORD *)&v129 + 1) + 1i64) >= 0x1000 )
            {
              v92 = (void *)*((_QWORD *)v128[0] - 1);
              if ( (unsigned __int64)(v128[0] - v92 - 8) > 0x1F )
                invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
            }
            j_j_free(v92);
          }
          *(_OWORD *)v128 = v90;
          v129 = v91;
          if ( *((_QWORD *)&v133 + 1) > 0xFui64 )
          {
            v93 = v132[0];
            if ( (unsigned __int64)(*((_QWORD *)&v133 + 1) + 1i64) >= 0x1000 )
            {
              v93 = (void *)*((_QWORD *)v132[0] - 1);
              if ( (unsigned __int64)(v132[0] - v93 - 8) > 0x1F )
                invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
            }
            j_j_free(v93);
          }
        }
      }
      v117 = 0i64;
      v94 = sub_146179840((__int64)v39, (__int64)v134, (__int64)&v117);
      if ( *(_QWORD *)(v94 + 24) > 7ui64 )
        v94 = *(_QWORD *)v94;
      FileAttributesW = GetFileAttributesW((LPCWSTR)v94);
      if ( v135.m128i_i64[1] > 7ui64 )
      {
        v96 = v134[0];
        if ( (unsigned __int64)(2 * v135.m128i_i64[1] + 2) >= 0x1000 )
        {
          v96 = (wchar_t *)*((_QWORD *)v134[0] - 1);
          if ( (unsigned __int64)((char *)v134[0] - (char *)v96 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v96);
      }
      if ( FileAttributesW == -1 )
      {
        v1 = v121;
      }
      else
      {
        v117 = 0i64;
        v97 = (_QWORD *)sub_146179840((__int64)v39, (__int64)&Stat, (__int64)&v117);
        v100 = v97;
        if ( v97[3] > 7ui64 )
          v100 = (_QWORD *)*v97;
        *(_QWORD *)&v126 = v100;
        *((_QWORD *)&v126 + 1) = v97[2];
        v105 = sub_1461A2B60((__int64)v134, (unsigned __int16 **)&v126, v98, v99);
        memset(v140, 0, 32);
        v106 = v129;
        v107 = v128;
        if ( *((_QWORD *)&v129 + 1) > 0xFui64 )
          v107 = (void **)v128[0];
        if ( (unsigned __int64)v129 > 0x7FFFFFFFFFFFFFFFi64 )
          unknown_libname_4(v102, v101, v103, v104);
        if ( (unsigned __int64)v129 > 0xF )
        {
          v108 = v129 | 0xF;
          if ( ((unsigned __int64)v129 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
          {
            if ( v108 < 0x16 )
              v108 = 22i64;
          }
          else
          {
            v108 = 0x7FFFFFFFFFFFFFFFi64;
          }
          *(_QWORD *)&v140[0] = sub_14615A5E0(v108 + 1);
          *(_QWORD *)&v140[1] = v106;
          *((_QWORD *)&v140[1] + 1) = v108;
          memcpy(*(void **)&v140[0], v107, v106 + 1);
        }
        else
        {
          *(_QWORD *)&v140[1] = v129;
          *((_QWORD *)&v140[1] + 1) = 15i64;
          v140[0] = *(_OWORD *)v107;
        }
        v140[2] = *(_OWORD *)v105;
        v140[3] = *(_OWORD *)(v105 + 16);
        *(_QWORD *)(v105 + 16) = 0i64;
        *(_QWORD *)(v105 + 24) = 15i64;
        *(_BYTE *)v105 = 0;
        v1 = v121;
        sub_146177630((unsigned __int64)v121, (__int64)FileName, (__int64)v140);
        if ( *((_QWORD *)&v140[3] + 1) > 0xFui64 )
        {
          v109 = *(void **)&v140[2];
          if ( (unsigned __int64)(*((_QWORD *)&v140[3] + 1) + 1i64) >= 0x1000 )
          {
            v109 = *(void **)(*(_QWORD *)&v140[2] - 8i64);
            if ( (unsigned __int64)(*(_QWORD *)&v140[2] - (_QWORD)v109 - 8i64) > 0x1F )
LABEL_270:
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v109);
        }
        if ( *((_QWORD *)&v140[1] + 1) > 0xFui64 )
        {
          v110 = *(void **)&v140[0];
          if ( (unsigned __int64)(*((_QWORD *)&v140[1] + 1) + 1i64) >= 0x1000 )
          {
            v110 = *(void **)(*(_QWORD *)&v140[0] - 8i64);
            if ( (unsigned __int64)(*(_QWORD *)&v140[0] - (_QWORD)v110 - 8i64) > 0x1F )
              goto LABEL_270;
          }
          j_j_free(v110);
        }
        if ( v135.m128i_i64[1] > 0xFui64 )
        {
          v111 = v134[0];
          if ( (unsigned __int64)(v135.m128i_i64[1] + 1) >= 0x1000 )
          {
            v111 = (wchar_t *)*((_QWORD *)v134[0] - 1);
            if ( (unsigned __int64)((char *)v134[0] - (char *)v111 - 8) > 0x1F )
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v111);
        }
        v135 = v40;
        LOBYTE(v134[0]) = 0;
        if ( Stat.st_atime > 7ui64 )
        {
          v112 = *(void **)&Stat.st_dev;
          if ( (unsigned __int64)(2 * Stat.st_atime + 2) >= 0x1000 )
          {
            v112 = *(void **)(*(_QWORD *)&Stat.st_dev - 8i64);
            if ( (unsigned __int64)(*(_QWORD *)&Stat.st_dev - (_QWORD)v112 - 8i64) > 0x1F )
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v112);
        }
      }
      if ( *((_QWORD *)&v129 + 1) > 0xFui64 )
      {
        v113 = v128[0];
        if ( (unsigned __int64)(*((_QWORD *)&v129 + 1) + 1i64) >= 0x1000 )
        {
          v113 = (void *)*((_QWORD *)v128[0] - 1);
          if ( (unsigned __int64)(v128[0] - v113 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v113);
      }
      v39 += 15;
      if ( v39 == (const char **)i )
        goto LABEL_264;
    }
    v49 = v129;
    v50 = v128;
    v51 = (void **)v128[0];
    v52 = *((_QWORD *)&v129 + 1);
    if ( *((_QWORD *)&v129 + 1) > 0xFui64 )
      v50 = (void **)v128[0];
    if ( (_QWORD)v129 )
    {
      v53 = (void **)((char *)v50 + v129);
      if ( (unsigned __int64)(v129 + 2) >= 0x10 )
      {
        v54 = sub_1461A7770((const __m128i *)v50, v129, (__m128i *)"/\\", 2ui64);
        v52 = *((_QWORD *)&v129 + 1);
        v49 = v129;
        v51 = (void **)v128[0];
LABEL_152:
        v57 = v54 + 1;
        *(_OWORD *)Src = 0i64;
        v131 = 0i64;
        if ( v49 < v54 + 1 )
          unknown_libname_5(v57, v46, v47, v48);
        v58 = v49 - v57;
        v59 = -1i64;
        if ( v58 != -1i64 )
          v59 = v58;
        v60 = v128;
        if ( v52 > 0xF )
          v60 = v51;
        v61 = (char *)v60 + v57;
        if ( v59 > 0x7FFFFFFFFFFFFFFFi64 )
          goto LABEL_276;
        if ( v59 > 0xF )
        {
          v62 = v59 | 0xF;
          if ( (v59 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
          {
            if ( v62 < 0x16 )
              v62 = 22i64;
          }
          else
          {
            v62 = 0x7FFFFFFFFFFFFFFFi64;
          }
          v63 = sub_14615A5E0(v62 + 1);
          Src[0] = v63;
          *(_QWORD *)&v131 = v59;
          *((_QWORD *)&v131 + 1) = v62;
          memcpy(v63, v61, v59);
          *((_BYTE *)v63 + v59) = 0;
        }
        else
        {
          *(_QWORD *)&v131 = v59;
          *((_QWORD *)&v131 + 1) = 15i64;
          memcpy(Src, (char *)v60 + v57, v59);
          *((_BYTE *)Src + v59) = 0;
        }
        v64 = v38 | 0x10;
        v120 = v64;
        v65 = v131;
        if ( *((_QWORD *)&v131 + 1) - (_QWORD)v131 < 0xCui64 )
        {
          v68 = sub_146178350(Src, 0xCui64, 0i64, 0i64, "Social Club/", 0xCui64);
        }
        else
        {
          *(_QWORD *)&v131 = v131 + 12;
          v66 = Src;
          if ( *((_QWORD *)&v65 + 1) > 0xFui64 )
            v66 = (void **)Src[0];
          if ( "" <= (char *)v66 || "Social Club/" > (char *)v66 + v65 )
          {
            v67 = 12i64;
          }
          else if ( v66 > (void **)"Social Club/" )
          {
            v67 = (char *)v66 - "Social Club/";
          }
          else
          {
            v67 = 0i64;
          }
          memmove((char *)v66 + 12, v66, v65 + 1);
          memcpy(v66, "Social Club/", v67);
          memcpy((char *)v66 + v67, &aSocialClub[v67 + 12], 12 - v67);
          v68 = Src;
        }
        v69 = *v68;
        v70 = v68[1];
        *((_QWORD *)v68 + 2) = 0i64;
        *((_QWORD *)v68 + 3) = 15i64;
        *(_BYTE *)v68 = 0;
        v38 = v64 | 8;
        v120 = v38;
        if ( *((_QWORD *)&v129 + 1) > 0xFui64 )
        {
          v71 = v128[0];
          if ( (unsigned __int64)(*((_QWORD *)&v129 + 1) + 1i64) >= 0x1000 )
          {
            v71 = (void *)*((_QWORD *)v128[0] - 1);
            if ( (unsigned __int64)(v128[0] - v71 - 8) > 0x1F )
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v71);
        }
        *(_OWORD *)v128 = v69;
        v129 = v70;
        if ( *((_QWORD *)&v131 + 1) > 0xFui64 )
        {
          v72 = Src[0];
          if ( (unsigned __int64)(*((_QWORD *)&v131 + 1) + 1i64) >= 0x1000 )
          {
            v72 = (void *)*((_QWORD *)Src[0] - 1);
            if ( (unsigned __int64)(Src[0] - v72 - 8) > 0x1F )
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v72);
        }
        goto LABEL_185;
      }
      memset(v140, 0, sizeof(v140));
      v55 = "/\\";
      do
        *((_BYTE *)v140 + (unsigned __int8)*v55++) = 1;
      while ( v55 != "" );
      v52 = *((_QWORD *)&v129 + 1);
      v56 = v50;
      if ( v50 < v53 )
      {
        while ( !*((_BYTE *)v140 + *(unsigned __int8 *)v56) )
        {
          v56 = (void **)((char *)v56 + 1);
          if ( v56 >= v53 )
            goto LABEL_151;
        }
        v54 = (char *)v56 - (char *)v50;
        goto LABEL_152;
      }
    }
LABEL_151:
    v54 = -1i64;
    goto LABEL_152;
  }
LABEL_264:
  sub_14617D400(&v122);
  return v1;
}
// 14617CA32: conditional instruction was optimized away because %var_1910.8>=9u
// 14617B1AF: variable 'v3' is possibly undefined
// 14617B202: variable 'v8' is possibly undefined
// 14617B25E: variable 'v12' is possibly undefined
// 14617B25E: variable 'v13' is possibly undefined
// 14617B26F: variable 'v15' is possibly undefined
// 14617B28F: variable 'v16' is possibly undefined
// 14617B309: variable 'v11' is possibly undefined
// 14617B3C4: variable 'v20' is possibly undefined
// 14617B418: variable 'v21' is possibly undefined
// 14617B418: variable 'v22' is possibly undefined
// 14617B4DE: variable 'v24' is possibly undefined
// 14617B4EF: variable 'v26' is possibly undefined
// 14617B50F: variable 'v27' is possibly undefined
// 14617C4FB: variable 'v28' is possibly undefined
// 14617C4FB: variable 'v29' is possibly undefined
// 14617C525: variable 'v30' is possibly undefined
// 14617C533: variable 'v31' is possibly undefined
// 14617C533: variable 'v32' is possibly undefined
// 14617CCE6: variable 'v98' is possibly undefined
// 14617CCE6: variable 'v99' is possibly undefined
// 14617D044: variable 'v102' is possibly undefined
// 14617D044: variable 'v101' is possibly undefined
// 14617D044: variable 'v103' is possibly undefined
// 14617D044: variable 'v104' is possibly undefined
// 14617D057: variable 'v57' is possibly undefined
// 14617D057: variable 'v46' is possibly undefined
// 14617D057: variable 'v47' is possibly undefined
// 14617D057: variable 'v48' is possibly undefined
// 14617D063: variable 'v77' is possibly undefined
// 14617D063: variable 'v76' is possibly undefined
// 14617D063: variable 'v78' is possibly undefined
// 14617D063: variable 'v79' is possibly undefined
// 1461090C0: using guessed type int dword_1461090C0;
// 14610AAC0: using guessed type __int128 xmmword_14610AAC0;
// 14610AAD0: using guessed type __int64 qword_14610AAD0;
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 1461212B8: using guessed type __int64 qword_1461212B8;
// 146127E10: using guessed type wchar_t aDataGameStorag_1[33];
// 14612A840: using guessed type wchar_t aDataGameStorag_2[77];
// 14612A930: using guessed type __int128 xmmword_14612A930;
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);
// 1461689E0: using guessed type void __fastcall __noreturn unknown_libname_5(_QWORD, _QWORD, _QWORD, _QWORD);
// 146179D90: using guessed type __int64 sub_146179D90(void);
// 1461A48B0: using guessed type __int64 __fastcall sub_1461A48B0(_QWORD);
// 1461A7840: using guessed type __int64 __fastcall sub_1461A7840(_QWORD, _QWORD, _QWORD, _QWORD);
// 146179E30: using guessed type char var_16E8[120];
// 146179E30: using guessed type char var_1670[120];
// 146179E30: using guessed type char var_15F8[120];
// 146179E30: using guessed type char var_1580[120];
// 146179E30: using guessed type char var_1508[120];
// 146179E30: using guessed type char var_1490[120];
// 146179E30: using guessed type char var_1418[120];
// 146179E30: using guessed type char var_13A0[120];
// 146179E30: using guessed type char var_1328[120];
// 146179E30: using guessed type char var_12B0[120];
// 146179E30: using guessed type char var_1238[120];
// 146179E30: using guessed type char var_11C0[120];
// 146179E30: using guessed type char var_1148[120];
// 146179E30: using guessed type char var_10D0[120];
// 146179E30: using guessed type char var_1058[120];
// 146179E30: using guessed type char var_FE0[120];
// 146179E30: using guessed type char var_F68[120];
// 146179E30: using guessed type char var_EF0[120];
// 146179E30: using guessed type char var_E78[120];
// 146179E30: using guessed type char var_E00[120];
// 146179E30: using guessed type char var_D88[120];
// 146179E30: using guessed type char var_D10[120];
// 146179E30: using guessed type char var_C98[120];
// 146179E30: using guessed type char var_C20[120];
// 146179E30: using guessed type char var_BA8[120];
// 146179E30: using guessed type char var_B30[120];
// 146179E30: using guessed type char var_19B0[8];
// 146179E30: using guessed type __int64 var_A78[3];
// 146179E30: using guessed type __int16 var_A60[8];
// 146179E30: using guessed type __int64 var_A00[3];
// 146179E30: using guessed type __int64 var_988[3];
// 146179E30: using guessed type __int64 var_910[3];
// 146179E30: using guessed type __int64 var_898[3];
// 146179E30: using guessed type __int64 var_820[3];
// 146179E30: using guessed type __int64 var_7A8[3];
// 146179E30: using guessed type __int64 var_730[3];
// 146179E30: using guessed type __int64 var_6B8[3];
// 146179E30: using guessed type __int64 var_640[3];
// 146179E30: using guessed type __int64 var_5C8[3];
// 146179E30: using guessed type __int64 var_550[3];
// 146179E30: using guessed type __int64 var_4D8[3];
// 146179E30: using guessed type __int64 var_460[3];
// 146179E30: using guessed type __int64 var_3E8[3];
// 146179E30: using guessed type char var_3B0[120];
// 146179E30: using guessed type char var_338[120];
// 146179E30: using guessed type char var_2C0[120];
// 146179E30: using guessed type char var_248[120];
// 146179E30: using guessed type char var_1D0[120];
// 146179E30: using guessed type char var_158[120];
// 146179E30: using guessed type char var_E0[120];

//----- (000000014617D0A0) ----------------------------------------------------
__int64 __fastcall sub_14617D0A0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  _QWORD *i; // rsi
  _QWORD *v10; // r8
  __int64 result; // rax

  v4 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v4 != i; v4 += 15 )
    {
      sub_146162730((__int64)(v4 + 11));
      sub_14617D330(v4 + 8);
      sub_146166C80((__int64)(v4 + 1));
    }
    v10 = (_QWORD *)*a1;
    if ( (unsigned __int64)(120 * ((a1[2] - *a1) / 120i64)) >= 0x1000 )
    {
      if ( (unsigned __int64)v10 - *(v10 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v10 = (_QWORD *)*(v10 - 1);
    }
    j_j_free(v10);
  }
  *a1 = a2;
  a1[1] = a2 + 120 * a3;
  result = a2 + 120 * a4;
  a1[2] = result;
  return result;
}

//----- (000000014617D1B0) ----------------------------------------------------
_QWORD *__fastcall sub_14617D1B0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  _QWORD *v4; // rbx
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rbp
  _QWORD *i; // rsi
  _QWORD *v9; // r8
  _QWORD *v10; // rax
  _QWORD *result; // rax

  v2 = a2;
  if ( a2 > 0x222222222222222i64 )
    unknown_libname_6(a1, a2, a2);
  v4 = (_QWORD *)*a1;
  v5 = (a1[2] - *a1) / 120i64;
  v6 = v5 >> 1;
  if ( v5 <= 0x222222222222222i64 - (v5 >> 1) )
  {
    v7 = v6 + v5;
    if ( v6 + v5 < v2 )
      v7 = v2;
  }
  else
  {
    v7 = 0x222222222222222i64;
  }
  if ( v4 )
  {
    for ( i = (_QWORD *)a1[1]; v4 != i; v4 += 15 )
    {
      sub_146162730((__int64)(v4 + 11));
      sub_14617D330(v4 + 8);
      sub_146166C80((__int64)(v4 + 1));
    }
    v9 = (_QWORD *)*a1;
    if ( (unsigned __int64)(120 * ((a1[2] - *a1) / 120i64)) >= 0x1000 )
    {
      if ( (unsigned __int64)v9 - *(v9 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v9 = (_QWORD *)*(v9 - 1);
    }
    j_j_free(v9);
    *a1 = 0i64;
    a1[1] = 0i64;
    a1[2] = 0i64;
  }
  if ( v7 > 0x222222222222222i64 )
    sub_146165390(v6, v5, v2);
  v10 = sub_14615A5E0(120 * v7);
  *a1 = v10;
  a1[1] = v10;
  result = &v10[15 * v7];
  a1[2] = result;
  return result;
}
// 14617D315: variable 'v6' is possibly undefined
// 14617D315: variable 'v5' is possibly undefined
// 14617D315: variable 'v2' is possibly undefined
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (000000014617D330) ----------------------------------------------------
void __fastcall sub_14617D330(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *i; // rdi
  _QWORD *v4; // r8

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v1 != i; v1 += 10 )
      sub_1461626B0((__int64)(v1 + 5));
    v4 = (_QWORD *)*a1;
    if ( (unsigned __int64)(80 * ((a1[2] - *a1) / 80i64)) >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - *(v4 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v4 = (_QWORD *)*(v4 - 1);
    }
    j_j_free(v4);
    *a1 = 0i64;
    a1[1] = 0i64;
    a1[2] = 0i64;
  }
}

//----- (000000014617D400) ----------------------------------------------------
void __fastcall sub_14617D400(_QWORD *a1)
{
  _QWORD *v1; // rbx
  _QWORD *i; // rsi
  _QWORD *v4; // r8

  v1 = (_QWORD *)*a1;
  if ( *a1 )
  {
    for ( i = (_QWORD *)a1[1]; v1 != i; v1 += 15 )
    {
      sub_146162730((__int64)(v1 + 11));
      sub_14617D330(v1 + 8);
      sub_146166C80((__int64)(v1 + 1));
    }
    v4 = (_QWORD *)*a1;
    if ( (unsigned __int64)(120 * ((a1[2] - *a1) / 120i64)) >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - *(v4 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v4 = (_QWORD *)*(v4 - 1);
    }
    j_j_free(v4);
    *a1 = 0i64;
    a1[1] = 0i64;
    a1[2] = 0i64;
  }
}

//----- (000000014617D4E0) ----------------------------------------------------
void **__fastcall sub_14617D4E0(void **a1, void *Src, size_t Size, __int64 a4)
{
  unsigned __int64 v4; // r14
  void *v8; // rdi
  size_t v9; // rdi
  unsigned __int64 v10; // rdx
  _QWORD *v11; // rax
  _QWORD *v12; // r15
  _QWORD *v13; // rcx

  v4 = (unsigned __int64)a1[3];
  if ( Size > v4 )
  {
    v9 = 0x7FFFFFFFFFFFFFFFi64;
    if ( Size > 0x7FFFFFFFFFFFFFFFi64 )
      unknown_libname_4(a1, Src, Size, a4);
    if ( (Size | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      v10 = v4 >> 1;
      if ( v4 <= 0x7FFFFFFFFFFFFFFFi64 - (v4 >> 1) )
      {
        v9 = Size | 0xF;
        if ( (Size | 0xF) < v4 + v10 )
          v9 = v4 + v10;
      }
    }
    v11 = sub_14615A5E0(v9 + 1);
    a1[2] = (void *)Size;
    a1[3] = (void *)v9;
    v12 = v11;
    memcpy(v11, Src, Size);
    *((_BYTE *)v12 + Size) = 0;
    if ( v4 > 0xF )
    {
      v13 = *a1;
      if ( v4 + 1 >= 0x1000 )
      {
        if ( (unsigned __int64)v13 - *(v13 - 1) - 8 > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        v13 = (_QWORD *)*(v13 - 1);
      }
      j_j_free(v13);
    }
    *a1 = v12;
  }
  else
  {
    v8 = a1;
    if ( v4 > 0xF )
      v8 = *a1;
    a1[2] = (void *)Size;
    memmove(v8, Src, Size);
    *((_BYTE *)v8 + Size) = 0;
  }
  return a1;
}
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014617D600) ----------------------------------------------------
void **__fastcall sub_14617D600(void **a1, void *Src, unsigned __int64 a3, __int64 a4)
{
  unsigned __int64 v4; // rsi
  char *v8; // rbp
  __int64 v9; // rbx
  __int64 v10; // rbx
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  _QWORD *v13; // rax
  _QWORD *v14; // rbp

  v4 = (unsigned __int64)a1[3];
  if ( a3 > v4 )
  {
    v10 = 0x7FFFFFFFFFFFFFFEi64;
    if ( a3 > 0x7FFFFFFFFFFFFFFEi64 )
      unknown_libname_4(a1, Src, a3, a4);
    if ( (a3 | 7) > 0x7FFFFFFFFFFFFFFEi64 || (v11 = v4 >> 1, v4 > 0x7FFFFFFFFFFFFFFEi64 - (v4 >> 1)) )
    {
      v12 = 0x7FFFFFFFFFFFFFFFi64;
    }
    else
    {
      v10 = a3 | 7;
      if ( (a3 | 7) < v4 + v11 )
        v10 = v4 + v11;
      v12 = v10 + 1;
      if ( (unsigned __int64)(v10 + 1) > 0x7FFFFFFFFFFFFFFFi64 )
        sub_146165390(v12, v11, a3);
    }
    v13 = sub_14615A5E0(2 * v12);
    a1[3] = (void *)v10;
    a1[2] = (void *)a3;
    v14 = v13;
    memcpy(v13, Src, 2 * a3);
    *((_WORD *)v14 + a3) = 0;
    if ( v4 > 7 )
      sub_1461650D0((__int64)a1, *a1, v4);
    *a1 = v14;
  }
  else
  {
    v8 = (char *)a1;
    if ( v4 > 7 )
      v8 = (char *)*a1;
    v9 = 2 * a3;
    a1[2] = (void *)a3;
    memmove(v8, Src, 2 * a3);
    *(_WORD *)&v8[v9] = 0;
  }
  return a1;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014617D740) ----------------------------------------------------
void __fastcall sub_14617D740(__int64 a1, void *a2, __int64 a3)
{
  void *v3; // rax

  v3 = a2;
  if ( (unsigned __int64)(8 * a3) >= 0x1000 )
  {
    if ( (unsigned __int64)a2 - *((_QWORD *)a2 - 1) - 8 > 0x1F )
      invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    v3 = (void *)*((_QWORD *)a2 - 1);
  }
  j_j_free(v3);
}

//----- (000000014617D7A0) ----------------------------------------------------
void __fastcall sub_14617D7A0(__int64 a1, void *a2, __int64 a3)
{
  void *v3; // rax

  v3 = a2;
  if ( (unsigned __int64)(80 * a3) >= 0x1000 )
  {
    if ( (unsigned __int64)a2 - *((_QWORD *)a2 - 1) - 8 > 0x1F )
      invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    v3 = (void *)*((_QWORD *)a2 - 1);
  }
  j_j_free(v3);
}

//----- (000000014617D800) ----------------------------------------------------
void __fastcall sub_14617D800(const wchar_t *a1, __int64 a2, __int64 a3, __int64 a4)
{
  sub_1461871B0(0i64, a1, a3, a4);
}

//----- (000000014617D810) ----------------------------------------------------
_QWORD *__fastcall sub_14617D810(_QWORD *a1, _BYTE *a2, _BYTE *a3, __int64 a4)
{
  size_t v6; // rsi
  __int64 v7; // rbp
  _QWORD *v8; // rax
  _QWORD *v9; // rbx

  *(_OWORD *)a1 = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  if ( a2 == a3 )
  {
    a1[3] = 15i64;
    *(_BYTE *)a1 = 0;
  }
  else
  {
    v6 = a3 - a2;
    v7 = 0x7FFFFFFFFFFFFFFFi64;
    if ( (unsigned __int64)(a3 - a2) > 0x7FFFFFFFFFFFFFFFi64 )
      unknown_libname_4(a1, a2, a3, a4);
    if ( v6 > 0xF )
    {
      if ( (v6 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
      {
        v7 = v6 | 0xF;
        if ( (v6 | 0xF) < 0x16 )
          v7 = 22i64;
      }
      v8 = sub_14615A5E0(v7 + 1);
      *a1 = v8;
      a1[2] = v6;
      a1[3] = v7;
      v9 = v8;
      memcpy(v8, a2, v6);
      *((_BYTE *)v9 + v6) = 0;
    }
    else
    {
      a1[2] = v6;
      a1[3] = 15i64;
      memcpy(a1, a2, v6);
      *((_BYTE *)a1 + v6) = 0;
    }
  }
  return a1;
}
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014617D900) ----------------------------------------------------
__int64 __fastcall sub_14617D900(__int64 a1, _QWORD *a2)
{
  _QWORD *v4; // rax
  void *v5; // r9
  uintptr_t v6; // rax

  v4 = operator new(0x10ui64);
  v5 = v4;
  if ( v4 )
  {
    *v4 = 0i64;
    v4[1] = 0i64;
    *v4 = *a2;
    v4[1] = a2[1];
    *a2 = 0i64;
    a2[1] = 0i64;
  }
  else
  {
    v5 = 0i64;
  }
  v6 = beginthreadex(0i64, 0, (_beginthreadex_proc_type)sub_14617F440, v5, 0, (unsigned int *)(a1 + 8));
  *(_QWORD *)a1 = v6;
  if ( !v6 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    std::_Throw_Cpp_error(6);
    JUMPOUT(0x14617D99Di64);
  }
  return a1;
}
// 14617D998: control flows out of bounds to 14617D99D

//----- (000000014617D9A0) ----------------------------------------------------
__int64 __fastcall sub_14617D9A0(__int64 a1, _QWORD *a2, wchar_t *a3)
{
  unsigned __int64 v6; // rax
  __int64 v7; // r9
  _QWORD *v8; // rax

  v6 = wcslen(a3);
  v8 = sub_1461653F0(a2, a3, v6, v7);
  *(_OWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_OWORD *)a1 = *(_OWORD *)v8;
  *(_OWORD *)(a1 + 16) = *((_OWORD *)v8 + 1);
  v8[2] = 0i64;
  *(_WORD *)v8 = 0;
  v8[3] = 7i64;
  return a1;
}
// 14617D9D0: variable 'v7' is possibly undefined

//----- (000000014617DA20) ----------------------------------------------------
HMODULE __fastcall sub_14617DA20(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  WCHAR *v4; // rax
  __int64 v5; // rax
  WCHAR *v6; // rcx
  __int64 v7; // r8
  __int64 v8; // rax
  char *v9; // r9
  WCHAR v10; // dx
  WCHAR *v11; // rax
  WCHAR Buffer[512]; // [rsp+20h] [rbp-418h] BYREF

  GetSystemDirectoryW(Buffer, 0x200u);
  v3 = 512i64;
  v4 = Buffer;
  do
  {
    if ( !*v4 )
      break;
    ++v4;
    --v3;
  }
  while ( v3 );
  v5 = 512 - v3;
  if ( v3 )
  {
    v6 = &Buffer[v5];
    v7 = 512 - v5;
    if ( v5 != 512 )
    {
      v8 = 2147483646i64;
      v9 = (char *)((char *)asc_14612C3A4 - (char *)v6);
      do
      {
        if ( !v8 )
          break;
        v10 = *(WCHAR *)((char *)v6 + (_QWORD)v9);
        if ( !v10 )
          break;
        *v6 = v10;
        --v8;
        ++v6;
        --v7;
      }
      while ( v7 );
    }
    v11 = v6 - 1;
    if ( v7 )
      v11 = v6;
    *v11 = 0;
  }
  sub_14618AC00(Buffer, 512i64, a2);
  return LoadLibraryW(Buffer);
}
// 14617DA20: using guessed type WCHAR Buffer[512];

//----- (000000014617DB10) ----------------------------------------------------
_QWORD *__fastcall sub_14617DB10(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rbp
  _QWORD *v7; // rsi
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9

  v6 = *a1;
  if ( *(_BYTE *)(a2 + 25) )
    return (_QWORD *)*a1;
  v7 = operator new(0x60ui64);
  sub_146170E60((__int64)(v7 + 4), a2 + 32, v8, v9);
  sub_146170E60((__int64)(v7 + 8), a2 + 64, v10, v11);
  *v7 = v6;
  v7[2] = v6;
  *((_WORD *)v7 + 12) = 0;
  v7[1] = a3;
  *((_BYTE *)v7 + 24) = *(_BYTE *)(a2 + 24);
  *v7 = sub_14617DB10(a1, *(_QWORD *)a2, v7);
  v7[2] = sub_14617DB10(a1, *(_QWORD *)(a2 + 16), v7);
  return v7;
}
// 14617DB73: variable 'v8' is possibly undefined
// 14617DB73: variable 'v9' is possibly undefined
// 14617DB81: variable 'v10' is possibly undefined
// 14617DB81: variable 'v11' is possibly undefined

//----- (000000014617DC00) ----------------------------------------------------
_QWORD *__fastcall sub_14617DC00(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rbp
  _QWORD *v7; // rsi
  __int64 v8; // r8
  __int64 v9; // r9

  v6 = *a1;
  if ( *(_BYTE *)(a2 + 25) )
    return (_QWORD *)*a1;
  v7 = operator new(0x50ui64);
  sub_146170E60((__int64)(v7 + 4), a2 + 32, v8, v9);
  sub_146185420(v7 + 8, a2 + 64);
  *v7 = v6;
  v7[2] = v6;
  *((_WORD *)v7 + 12) = 0;
  v7[1] = a3;
  *((_BYTE *)v7 + 24) = *(_BYTE *)(a2 + 24);
  *v7 = sub_14617DC00(a1, *(_QWORD *)a2, v7);
  v7[2] = sub_14617DC00(a1, *(_QWORD *)(a2 + 16), v7);
  return v7;
}
// 14617DC63: variable 'v8' is possibly undefined
// 14617DC63: variable 'v9' is possibly undefined
// 146185420: using guessed type __int64 __fastcall sub_146185420(_QWORD, _QWORD);

//----- (000000014617DCF0) ----------------------------------------------------
_OWORD *__fastcall sub_14617DCF0(_OWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int *v4; // r14
  unsigned int *v6; // r12
  _QWORD *v7; // r13
  _OWORD *result; // rax
  __int64 v9; // r15
  unsigned __int64 v10; // rsi
  unsigned int *v11; // rbx
  unsigned __int64 v12; // rdi
  int v13; // r9d
  __int64 v14; // rax
  unsigned int v15; // edx
  unsigned int v16; // r8d
  __int64 v17; // rcx
  int v18; // r10d
  int v19; // r8d
  char v20; // cl
  unsigned int v21; // eax
  unsigned int v22; // r9d
  unsigned int v23; // eax
  unsigned int v24; // eax
  char v25; // cl
  unsigned int v26; // eax
  unsigned int v27; // r9d
  unsigned int v28; // eax
  __int64 v29; // rcx
  int v30; // r10d
  int v31; // eax
  __int64 v32; // rax
  __int64 v33; // rcx
  __int64 v34; // r13
  _BYTE *v35; // rsi
  _BYTE *v36; // rdi
  _BYTE *v37; // r15
  int v38; // edx
  char v39; // al
  unsigned int *v40; // r8
  unsigned int v41; // r9d
  int v42; // edx
  unsigned __int64 v43; // rsi
  char v44; // bp
  unsigned int v45; // r11d
  unsigned int v46; // r9d
  unsigned int v47; // eax
  unsigned __int64 v48; // rdi
  unsigned int v49; // eax
  int v50; // edx
  unsigned __int64 v51; // rdi
  unsigned __int64 v52; // rbp
  int *v53; // rbx
  unsigned int i; // edx
  unsigned int v55; // edx
  unsigned __int64 v56; // r9
  int v57; // r10d
  unsigned int *v58; // [rsp+28h] [rbp-40h]
  unsigned int v60; // [rsp+78h] [rbp+10h]

  v4 = *(unsigned int **)a3;
  v6 = *(unsigned int **)a2;
  v7 = a1;
  if ( *(_QWORD *)a2 == *(_QWORD *)a3 && *(_QWORD *)(a2 + 8) == *(_QWORD *)(a3 + 8) )
  {
    result = a1;
    *a1 = *(_OWORD *)a4;
  }
  else
  {
    v9 = *(_QWORD *)(a3 + 8);
    v10 = *(_QWORD *)(a2 + 8);
    v11 = *(unsigned int **)a4;
    sub_146186F80((_OWORD *)a4, (__int64)a1, v9 + 32 * (v4 - v6) - v10);
    v12 = *(_QWORD *)(a4 + 8);
    v13 = -1 << v10;
    v14 = 0i64;
    if ( v12 )
      v15 = 0xFFFFFFFF >> (32 - v12);
    else
      v15 = 0;
    v16 = 0xFFFFFFFF >> (32 - v9);
    v17 = v7[1];
    v18 = -1 << v17;
    v60 = v16;
    if ( !v17 )
      v14 = 4i64;
    v58 = (unsigned int *)(*v7 - v14);
    if ( v6 == v4 )
    {
      v19 = v13 & v16;
      v20 = v12 - v10;
      if ( v12 < v10 )
        v20 = v10 - v12;
      v21 = *v6 & v19;
      v22 = v21 >> v20;
      v23 = v21 << v20;
      if ( v12 >= v10 )
        v22 = v23;
      v24 = *v11;
      if ( v11 == v58 )
      {
        if ( !v7[1] )
          v18 = 0;
        *v11 = v22 | v24 & (v15 | v18);
      }
      else
      {
        *v11 = v22 | v15 & v24;
        v11[1] = v18 & v11[1] | ((v19 & *v6) >> (v9 - *((_BYTE *)v7 + 8)));
      }
    }
    else if ( v11 == (unsigned int *)(*v7 - v14) )
    {
      v25 = v12 - v10;
      if ( v12 < v10 )
        v25 = v10 - v12;
      v26 = *v6 & v13;
      v27 = v26 >> v25;
      v28 = v26 << v25;
      v29 = v7[1];
      if ( v12 >= v10 )
        v27 = v28;
      if ( !v29 )
        v18 = 0;
      v30 = *v11 & (v15 | v18);
      if ( v9 )
        v31 = v27 | v30 | ((v16 & *v4) << (v29 - v9));
      else
        v31 = v27 | v30;
      *v11 = v31;
    }
    else
    {
      v32 = v10 & 7;
      v33 = v12 & 7;
      if ( v32 == v33 )
      {
        v34 = v9 & 7;
        v35 = (char *)v6 + ((v10 - v32) >> 3);
        v36 = (char *)v11 + ((v12 - v33) >> 3);
        v37 = (char *)v4 + ((unsigned __int64)(v9 - v34) >> 3);
        if ( v32 )
        {
          v38 = 255 >> (8 - v32);
          v39 = *v35++ & (-1 << v32);
          *v36 = v39 | *v36 & v38;
          ++v36;
        }
        memmove(v36, v35, v37 - v35);
        if ( v34 )
          v36[v37 - v35] = v36[v37 - v35] & (-1 << v34) | *v37 & (255 >> (8 - v34));
        return a1;
      }
      else
      {
        v40 = v6 + 1;
        v41 = (-1 << v10) & *v6;
        v42 = *v11 & v15;
        if ( v12 >= v10 )
        {
          v51 = v12 - v10;
          v52 = 32 - v51;
          *v11 = v42 | (v41 << v51);
          v53 = (int *)(v11 + 1);
          for ( i = *v6 >> (32 - v51); v40 != v4; i = v55 >> v52 )
          {
            *v53++ = i | (*v40 << v51);
            v55 = *v40++;
          }
          v56 = *(_QWORD *)(a3 + 8);
          if ( v56 < v52 )
          {
            v57 = *v53 & v18;
            if ( v56 )
              *v53 = i | v57 | ((v60 & *v40) << v51);
            else
              *v53 = i | v57;
          }
          else
          {
            *v53 = i | (*v40 << v51);
            if ( v56 != v52 )
              v53[1] = v18 & v53[1] | ~v18 & (*v40 >> v52);
          }
        }
        else
        {
          v43 = v10 - v12;
          v44 = 32 - v43;
          v45 = 0xFFFFFFFF >> v43;
          v46 = v42 | (v41 >> v43);
          for ( *v11 = v46; v40 != v4; *v11 = v46 )
          {
            *v11++ = (*v40 << v44) | v46 & v45;
            v47 = *v40++;
            v46 = (v47 >> v43) | ~(0xFFFFFFFF >> v43) & *v11;
          }
          v48 = *(_QWORD *)(a3 + 8);
          if ( v48 )
          {
            v49 = *v11;
            v50 = (v60 & *v40) << v44;
            if ( v48 < v43 )
            {
              *v11 = v50 | v49 & (v18 | v45);
            }
            else
            {
              *v11 = v50 | v45 & v49;
              if ( v48 != v43 )
                v11[1] = v18 & v11[1] | ((v60 & *v40) >> v43);
            }
          }
        }
      }
    }
    return v7;
  }
  return result;
}

//----- (000000014617E120) ----------------------------------------------------
_BYTE *__fastcall sub_14617E120(_QWORD *a1, _BYTE *a2, __int64 a3)
{
  _BYTE *v5; // rcx
  _BYTE *v6; // r14
  _BYTE *result; // rax
  size_t v8; // rsi
  _BYTE *v9; // r15
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  _BYTE *v12; // r12
  _QWORD *v13; // rax
  _BYTE *v14; // r15
  _QWORD *v15; // rdi
  void *v16; // rcx
  _BYTE *v17; // r8
  _QWORD *v18; // rdx
  size_t v19; // r8
  _QWORD *v20; // rcx

  v5 = (_BYTE *)a1[2];
  v6 = (_BYTE *)a1[1];
  if ( v6 == v5 )
  {
    v8 = 0x7FFFFFFFFFFFFFFFi64;
    v9 = &v6[-*a1];
    if ( v9 == (_BYTE *)0x7FFFFFFFFFFFFFFFi64 )
      unknown_libname_6(v5, a2, a3);
    v10 = (unsigned __int64)&v5[-*a1];
    v11 = v10 >> 1;
    v12 = v9 + 1;
    if ( v10 <= 0x7FFFFFFFFFFFFFFFi64 - (v10 >> 1) )
    {
      v8 = v11 + v10;
      if ( v11 + v10 < (unsigned __int64)v12 )
        v8 = (size_t)(v9 + 1);
    }
    v13 = sub_14615A5E0(v8);
    v14 = &v9[(_QWORD)v13];
    v15 = v13;
    *v14 = *a2;
    v16 = v13;
    v17 = (_BYTE *)a1[1];
    v18 = (_QWORD *)*a1;
    if ( v6 == v17 )
    {
      v19 = v17 - (_BYTE *)v18;
    }
    else
    {
      memmove(v13, v18, v6 - (_BYTE *)v18);
      v16 = v14 + 1;
      v19 = a1[1] - (_QWORD)v6;
      v18 = v6;
    }
    memmove(v16, v18, v19);
    v20 = (_QWORD *)*a1;
    if ( *a1 )
    {
      if ( a1[2] - (_QWORD)v20 >= 0x1000ui64 )
      {
        if ( (unsigned __int64)v20 - *(v20 - 1) - 8 > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        v20 = (_QWORD *)*(v20 - 1);
      }
      j_j_free(v20);
    }
    *a1 = v15;
    result = v14;
    a1[1] = &v12[(_QWORD)v15];
    a1[2] = (char *)v15 + v8;
  }
  else
  {
    *v6 = *a2;
    result = (_BYTE *)a1[1];
    a1[1] = result + 1;
  }
  return result;
}
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (000000014617E280) ----------------------------------------------------
__int64 __fastcall sub_14617E280(__int64 a1, __int64 a2)
{
  unsigned __int8 *v4; // rdx
  __int64 v5; // rdi
  __int64 v6; // rax
  unsigned __int64 v7; // r12
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rsi
  unsigned __int8 *v11; // rbp
  __int64 v12; // r15
  __int64 v13; // rdi
  unsigned __int8 *v14; // r8
  unsigned __int8 *v15; // rax
  unsigned __int8 *v16; // rdx
  __int64 i; // rcx
  __int64 v19[3]; // [rsp+28h] [rbp-40h] BYREF
  __int64 v20; // [rsp+40h] [rbp-28h]
  __int64 v21; // [rsp+48h] [rbp-20h]

  v4 = *(unsigned __int8 **)a1;
  v5 = a2 - *(_QWORD *)a1;
  v6 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if ( v6 == 0xFFFFFFFFFFFFFFFi64 )
    unknown_libname_6(a1, v4, 0xFFFFFFFFFFFFFFFi64);
  v7 = v6 + 1;
  v8 = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v4) >> 4;
  v9 = v8 >> 1;
  if ( v8 <= 0xFFFFFFFFFFFFFFFi64 - (v8 >> 1) )
  {
    v10 = v6 + 1;
    if ( v9 + v8 >= v7 )
      v10 = v9 + v8;
    if ( v10 > 0xFFFFFFFFFFFFFFFi64 )
      sub_146165390(v8, v9, 0xFFFFFFFFFFFFFFFi64);
  }
  else
  {
    v10 = 0xFFFFFFFFFFFFFFFi64;
  }
  v11 = (unsigned __int8 *)sub_14615A5E0(16 * v10);
  v12 = (__int64)&v11[v5 & 0xFFFFFFFFFFFFFFF0ui64];
  v13 = v12 + 16;
  v19[0] = a1;
  v19[2] = v10;
  v21 = v12 + 16;
  *(_BYTE *)v12 = 0;
  sub_1461862B0((_QWORD *)(v12 + 8), 0);
  v20 = v12;
  v14 = *(unsigned __int8 **)(a1 + 8);
  v15 = *(unsigned __int8 **)a1;
  v16 = v11;
  if ( (unsigned __int8 *)a2 == v14 )
  {
    for ( ; v15 != v14; v15 += 16 )
    {
      *v16 = *v15;
      *((_QWORD *)v16 + 1) = *((_QWORD *)v15 + 1);
      *v15 = 0;
      *((_QWORD *)v15 + 1) = 0i64;
      v16 += 16;
    }
  }
  else
  {
    for ( ; v15 != (unsigned __int8 *)a2; v15 += 16 )
    {
      *v16 = *v15;
      *((_QWORD *)v16 + 1) = *((_QWORD *)v15 + 1);
      *v15 = 0;
      *((_QWORD *)v15 + 1) = 0i64;
      v16 += 16;
    }
    v20 = (__int64)v11;
    for ( i = *(_QWORD *)(a1 + 8); a2 != i; a2 += 16i64 )
    {
      *(_BYTE *)v13 = *(_BYTE *)a2;
      *(_QWORD *)(v13 + 8) = *(_QWORD *)(a2 + 8);
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0i64;
      v13 += 16i64;
    }
  }
  v19[1] = 0i64;
  sub_14618AD60((unsigned __int8 **)a1, v11, v7, v10);
  sub_146186CB0(v19);
  return v12;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (000000014617E450) ----------------------------------------------------
unsigned __int8 *__fastcall sub_14617E450(__int64 a1, __int64 a2, __int64 *a3)
{
  unsigned __int8 *v5; // rdx
  __int64 v6; // rbx
  __int64 v7; // rax
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rbp
  unsigned __int8 *v12; // r15
  unsigned __int8 *v13; // r13
  unsigned __int8 *v14; // rsi
  __int64 v15; // xmm6_8
  unsigned __int8 *v16; // r8
  unsigned __int8 *v17; // rcx
  unsigned __int8 *v18; // rdx
  __int64 i; // rcx
  __int64 v21[3]; // [rsp+28h] [rbp-70h] BYREF
  unsigned __int8 *v22; // [rsp+40h] [rbp-58h]
  unsigned __int8 *v23; // [rsp+48h] [rbp-50h]

  v5 = *(unsigned __int8 **)a1;
  v6 = a2 - *(_QWORD *)a1;
  v7 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if ( v7 == 0xFFFFFFFFFFFFFFFi64 )
    unknown_libname_6(a1, v5, 0xFFFFFFFFFFFFFFFi64);
  v8 = v7 + 1;
  v9 = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v5) >> 4;
  v10 = v9 >> 1;
  if ( v9 <= 0xFFFFFFFFFFFFFFFi64 - (v9 >> 1) )
  {
    v11 = v7 + 1;
    if ( v10 + v9 >= v8 )
      v11 = v10 + v9;
    if ( v11 > 0xFFFFFFFFFFFFFFFi64 )
      sub_146165390(v9, v10, 0xFFFFFFFFFFFFFFFi64);
  }
  else
  {
    v11 = 0xFFFFFFFFFFFFFFFi64;
  }
  v12 = (unsigned __int8 *)sub_14615A5E0(16 * v11);
  v13 = &v12[v6 & 0xFFFFFFFFFFFFFFF0ui64];
  v14 = v13 + 16;
  v21[0] = a1;
  v21[2] = v11;
  v23 = v13 + 16;
  *v13 = 0;
  *((_QWORD *)v13 + 1) = 0i64;
  v15 = *a3;
  sub_14618BD60((unsigned __int8 ***)v13 + 1, *v13);
  *v13 = 7;
  *((_QWORD *)v13 + 1) = v15;
  v22 = v13;
  v16 = *(unsigned __int8 **)(a1 + 8);
  v17 = *(unsigned __int8 **)a1;
  v18 = v12;
  if ( (unsigned __int8 *)a2 == v16 )
  {
    for ( ; v17 != v16; v17 += 16 )
    {
      *v18 = *v17;
      *((_QWORD *)v18 + 1) = *((_QWORD *)v17 + 1);
      *v17 = 0;
      *((_QWORD *)v17 + 1) = 0i64;
      v18 += 16;
    }
  }
  else
  {
    for ( ; v17 != (unsigned __int8 *)a2; v17 += 16 )
    {
      *v18 = *v17;
      *((_QWORD *)v18 + 1) = *((_QWORD *)v17 + 1);
      *v17 = 0;
      *((_QWORD *)v17 + 1) = 0i64;
      v18 += 16;
    }
    v22 = v12;
    for ( i = *(_QWORD *)(a1 + 8); a2 != i; a2 += 16i64 )
    {
      *v14 = *(_BYTE *)a2;
      *((_QWORD *)v14 + 1) = *(_QWORD *)(a2 + 8);
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0i64;
      v14 += 16;
    }
  }
  v21[1] = 0i64;
  sub_14618AD60((unsigned __int8 **)a1, v12, v8, v11);
  sub_146186CB0(v21);
  return &v12[v6 & 0xFFFFFFFFFFFFFFF0ui64];
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (000000014617E650) ----------------------------------------------------
unsigned __int8 *__fastcall sub_14617E650(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int8 *v5; // rdx
  __int64 v6; // rbx
  __int64 v7; // rax
  unsigned __int64 v8; // r13
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rbp
  unsigned __int8 *v12; // r12
  unsigned __int8 *v13; // r14
  __int64 v14; // r8
  __int64 v15; // r9
  unsigned __int8 *v16; // r8
  unsigned __int8 *v17; // rax
  unsigned __int8 *v18; // rdx
  __int64 i; // rcx
  void *v21; // [rsp+30h] [rbp-68h]
  __int64 v22; // [rsp+38h] [rbp-60h] BYREF
  unsigned __int8 *v23; // [rsp+40h] [rbp-58h]
  unsigned __int64 v24; // [rsp+48h] [rbp-50h]
  unsigned __int8 *v25; // [rsp+50h] [rbp-48h]
  unsigned __int8 *v26; // [rsp+58h] [rbp-40h]
  unsigned __int8 *v27; // [rsp+A8h] [rbp+10h]

  v5 = *(unsigned __int8 **)a1;
  v6 = a2 - *(_QWORD *)a1;
  v7 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if ( v7 == 0xFFFFFFFFFFFFFFFi64 )
    unknown_libname_6(a1, v5, 0xFFFFFFFFFFFFFFFi64);
  v8 = v7 + 1;
  v9 = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v5) >> 4;
  v10 = v9 >> 1;
  if ( v9 <= 0xFFFFFFFFFFFFFFFi64 - (v9 >> 1) )
  {
    v11 = v7 + 1;
    if ( v10 + v9 >= v8 )
      v11 = v10 + v9;
    if ( v11 > 0xFFFFFFFFFFFFFFFi64 )
      sub_146165390(v9, v10, 0xFFFFFFFFFFFFFFFi64);
  }
  else
  {
    v11 = 0xFFFFFFFFFFFFFFFi64;
  }
  v12 = (unsigned __int8 *)sub_14615A5E0(16 * v11);
  v27 = &v12[v6 & 0xFFFFFFFFFFFFFFF0ui64];
  v13 = v27 + 16;
  v22 = a1;
  v23 = v12;
  v24 = v11;
  v25 = v27 + 16;
  v26 = v27 + 16;
  *v27 = 0;
  *((_QWORD *)v27 + 1) = 0i64;
  sub_14618BD60((unsigned __int8 ***)v27 + 1, *v27);
  *v27 = 3;
  v21 = operator new(0x20ui64);
  sub_146170E60((__int64)v21, a3, v14, v15);
  *((_QWORD *)v27 + 1) = v21;
  v25 = v27;
  v16 = *(unsigned __int8 **)(a1 + 8);
  v17 = *(unsigned __int8 **)a1;
  v18 = v12;
  if ( (unsigned __int8 *)a2 == v16 )
  {
    for ( ; v17 != v16; v17 += 16 )
    {
      *v18 = *v17;
      *((_QWORD *)v18 + 1) = *((_QWORD *)v17 + 1);
      *v17 = 0;
      *((_QWORD *)v17 + 1) = 0i64;
      v18 += 16;
    }
  }
  else
  {
    for ( ; v17 != (unsigned __int8 *)a2; v17 += 16 )
    {
      *v18 = *v17;
      *((_QWORD *)v18 + 1) = *((_QWORD *)v17 + 1);
      *v17 = 0;
      *((_QWORD *)v17 + 1) = 0i64;
      v18 += 16;
    }
    v25 = v12;
    for ( i = *(_QWORD *)(a1 + 8); a2 != i; a2 += 16i64 )
    {
      *v13 = *(_BYTE *)a2;
      *((_QWORD *)v13 + 1) = *(_QWORD *)(a2 + 8);
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0i64;
      v13 += 16;
    }
  }
  v23 = 0i64;
  sub_14618AD60((unsigned __int8 **)a1, v12, v8, v11);
  sub_146186CB0(&v22);
  return v27;
}
// 14617E748: variable 'v14' is possibly undefined
// 14617E748: variable 'v15' is possibly undefined
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (000000014617E870) ----------------------------------------------------
unsigned __int8 *__fastcall sub_14617E870(__int64 a1, __int64 a2, __int64 *a3)
{
  unsigned __int8 *v5; // rdx
  __int64 v6; // rbx
  __int64 v7; // rax
  unsigned __int64 v8; // r13
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rbp
  unsigned __int8 *v12; // r12
  unsigned __int8 *v13; // r14
  __int64 v14; // rbx
  unsigned __int8 *v15; // r8
  unsigned __int8 *v16; // rax
  unsigned __int8 *v17; // rdx
  __int64 i; // rcx
  __int64 v20[3]; // [rsp+28h] [rbp-60h] BYREF
  unsigned __int8 *v21; // [rsp+40h] [rbp-48h]
  unsigned __int8 *v22; // [rsp+48h] [rbp-40h]
  unsigned __int8 *v23; // [rsp+90h] [rbp+8h]

  v5 = *(unsigned __int8 **)a1;
  v6 = a2 - *(_QWORD *)a1;
  v7 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if ( v7 == 0xFFFFFFFFFFFFFFFi64 )
    unknown_libname_6(a1, v5, 0xFFFFFFFFFFFFFFFi64);
  v8 = v7 + 1;
  v9 = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v5) >> 4;
  v10 = v9 >> 1;
  if ( v9 <= 0xFFFFFFFFFFFFFFFi64 - (v9 >> 1) )
  {
    v11 = v7 + 1;
    if ( v10 + v9 >= v8 )
      v11 = v10 + v9;
    if ( v11 > 0xFFFFFFFFFFFFFFFi64 )
      sub_146165390(v9, v10, 0xFFFFFFFFFFFFFFFi64);
  }
  else
  {
    v11 = 0xFFFFFFFFFFFFFFFi64;
  }
  v12 = (unsigned __int8 *)sub_14615A5E0(16 * v11);
  v23 = &v12[v6 & 0xFFFFFFFFFFFFFFF0ui64];
  v13 = v23 + 16;
  v20[0] = a1;
  v20[2] = v11;
  v22 = v23 + 16;
  *v23 = 0;
  *((_QWORD *)v23 + 1) = 0i64;
  v14 = *a3;
  sub_14618BD60((unsigned __int8 ***)v23 + 1, *v23);
  *v23 = 5;
  *((_QWORD *)v23 + 1) = v14;
  v21 = v23;
  v15 = *(unsigned __int8 **)(a1 + 8);
  v16 = *(unsigned __int8 **)a1;
  v17 = v12;
  if ( (unsigned __int8 *)a2 == v15 )
  {
    for ( ; v16 != v15; v16 += 16 )
    {
      *v17 = *v16;
      *((_QWORD *)v17 + 1) = *((_QWORD *)v16 + 1);
      *v16 = 0;
      *((_QWORD *)v16 + 1) = 0i64;
      v17 += 16;
    }
  }
  else
  {
    for ( ; v16 != (unsigned __int8 *)a2; v16 += 16 )
    {
      *v17 = *v16;
      *((_QWORD *)v17 + 1) = *((_QWORD *)v16 + 1);
      *v16 = 0;
      *((_QWORD *)v16 + 1) = 0i64;
      v17 += 16;
    }
    v21 = v12;
    for ( i = *(_QWORD *)(a1 + 8); a2 != i; a2 += 16i64 )
    {
      *v13 = *(_BYTE *)a2;
      *((_QWORD *)v13 + 1) = *(_QWORD *)(a2 + 8);
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0i64;
      v13 += 16;
    }
  }
  v20[1] = 0i64;
  sub_14618AD60((unsigned __int8 **)a1, v12, v8, v11);
  sub_146186CB0(v20);
  return v23;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (000000014617EA60) ----------------------------------------------------
unsigned __int8 *__fastcall sub_14617EA60(__int64 a1, __int64 a2, __int64 *a3)
{
  unsigned __int8 *v5; // rdx
  __int64 v6; // rbx
  __int64 v7; // rax
  unsigned __int64 v8; // r13
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rbp
  unsigned __int8 *v12; // r12
  unsigned __int8 *v13; // r14
  __int64 v14; // rbx
  unsigned __int8 *v15; // r8
  unsigned __int8 *v16; // rax
  unsigned __int8 *v17; // rdx
  __int64 i; // rcx
  __int64 v20[3]; // [rsp+28h] [rbp-60h] BYREF
  unsigned __int8 *v21; // [rsp+40h] [rbp-48h]
  unsigned __int8 *v22; // [rsp+48h] [rbp-40h]
  unsigned __int8 *v23; // [rsp+90h] [rbp+8h]

  v5 = *(unsigned __int8 **)a1;
  v6 = a2 - *(_QWORD *)a1;
  v7 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if ( v7 == 0xFFFFFFFFFFFFFFFi64 )
    unknown_libname_6(a1, v5, 0xFFFFFFFFFFFFFFFi64);
  v8 = v7 + 1;
  v9 = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v5) >> 4;
  v10 = v9 >> 1;
  if ( v9 <= 0xFFFFFFFFFFFFFFFi64 - (v9 >> 1) )
  {
    v11 = v7 + 1;
    if ( v10 + v9 >= v8 )
      v11 = v10 + v9;
    if ( v11 > 0xFFFFFFFFFFFFFFFi64 )
      sub_146165390(v9, v10, 0xFFFFFFFFFFFFFFFi64);
  }
  else
  {
    v11 = 0xFFFFFFFFFFFFFFFi64;
  }
  v12 = (unsigned __int8 *)sub_14615A5E0(16 * v11);
  v23 = &v12[v6 & 0xFFFFFFFFFFFFFFF0ui64];
  v13 = v23 + 16;
  v20[0] = a1;
  v20[2] = v11;
  v22 = v23 + 16;
  *v23 = 0;
  *((_QWORD *)v23 + 1) = 0i64;
  v14 = *a3;
  sub_14618BD60((unsigned __int8 ***)v23 + 1, *v23);
  *v23 = 6;
  *((_QWORD *)v23 + 1) = v14;
  v21 = v23;
  v15 = *(unsigned __int8 **)(a1 + 8);
  v16 = *(unsigned __int8 **)a1;
  v17 = v12;
  if ( (unsigned __int8 *)a2 == v15 )
  {
    for ( ; v16 != v15; v16 += 16 )
    {
      *v17 = *v16;
      *((_QWORD *)v17 + 1) = *((_QWORD *)v16 + 1);
      *v16 = 0;
      *((_QWORD *)v16 + 1) = 0i64;
      v17 += 16;
    }
  }
  else
  {
    for ( ; v16 != (unsigned __int8 *)a2; v16 += 16 )
    {
      *v17 = *v16;
      *((_QWORD *)v17 + 1) = *((_QWORD *)v16 + 1);
      *v16 = 0;
      *((_QWORD *)v16 + 1) = 0i64;
      v17 += 16;
    }
    v21 = v12;
    for ( i = *(_QWORD *)(a1 + 8); a2 != i; a2 += 16i64 )
    {
      *v13 = *(_BYTE *)a2;
      *((_QWORD *)v13 + 1) = *(_QWORD *)(a2 + 8);
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0i64;
      v13 += 16;
    }
  }
  v20[1] = 0i64;
  sub_14618AD60((unsigned __int8 **)a1, v12, v8, v11);
  sub_146186CB0(v20);
  return v23;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (000000014617EC50) ----------------------------------------------------
unsigned __int8 *__fastcall sub_14617EC50(__int64 a1, __int64 a2, char *a3)
{
  unsigned __int8 *v5; // rdx
  __int64 v6; // rbx
  __int64 v7; // rax
  unsigned __int64 v8; // r13
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rbp
  unsigned __int8 *v12; // r12
  unsigned __int8 *v13; // r14
  char v14; // bl
  unsigned __int8 *v15; // r8
  unsigned __int8 *v16; // rax
  unsigned __int8 *v17; // rdx
  __int64 i; // rcx
  __int64 v20[3]; // [rsp+28h] [rbp-60h] BYREF
  unsigned __int8 *v21; // [rsp+40h] [rbp-48h]
  unsigned __int8 *v22; // [rsp+48h] [rbp-40h]
  unsigned __int8 *v23; // [rsp+90h] [rbp+8h]
  __int64 v24; // [rsp+98h] [rbp+10h]

  v5 = *(unsigned __int8 **)a1;
  v6 = a2 - *(_QWORD *)a1;
  v7 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if ( v7 == 0xFFFFFFFFFFFFFFFi64 )
    unknown_libname_6(a1, v5, 0xFFFFFFFFFFFFFFFi64);
  v8 = v7 + 1;
  v9 = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v5) >> 4;
  v10 = v9 >> 1;
  if ( v9 <= 0xFFFFFFFFFFFFFFFi64 - (v9 >> 1) )
  {
    v11 = v7 + 1;
    if ( v10 + v9 >= v8 )
      v11 = v10 + v9;
    if ( v11 > 0xFFFFFFFFFFFFFFFi64 )
      sub_146165390(v9, v10, 0xFFFFFFFFFFFFFFFi64);
  }
  else
  {
    v11 = 0xFFFFFFFFFFFFFFFi64;
  }
  v12 = (unsigned __int8 *)sub_14615A5E0(16 * v11);
  v23 = &v12[v6 & 0xFFFFFFFFFFFFFFF0ui64];
  v13 = v23 + 16;
  v20[0] = a1;
  v20[2] = v11;
  v22 = v23 + 16;
  *v23 = 0;
  *((_QWORD *)v23 + 1) = 0i64;
  v14 = *a3;
  sub_14618BD60((unsigned __int8 ***)v23 + 1, *v23);
  *v23 = 4;
  LOBYTE(v24) = v14;
  *((_QWORD *)v23 + 1) = v24;
  v21 = v23;
  v15 = *(unsigned __int8 **)(a1 + 8);
  v16 = *(unsigned __int8 **)a1;
  v17 = v12;
  if ( (unsigned __int8 *)a2 == v15 )
  {
    for ( ; v16 != v15; v16 += 16 )
    {
      *v17 = *v16;
      *((_QWORD *)v17 + 1) = *((_QWORD *)v16 + 1);
      *v16 = 0;
      *((_QWORD *)v16 + 1) = 0i64;
      v17 += 16;
    }
  }
  else
  {
    for ( ; v16 != (unsigned __int8 *)a2; v16 += 16 )
    {
      *v17 = *v16;
      *((_QWORD *)v17 + 1) = *((_QWORD *)v16 + 1);
      *v16 = 0;
      *((_QWORD *)v16 + 1) = 0i64;
      v17 += 16;
    }
    v21 = v12;
    for ( i = *(_QWORD *)(a1 + 8); a2 != i; a2 += 16i64 )
    {
      *v13 = *(_BYTE *)a2;
      *((_QWORD *)v13 + 1) = *(_QWORD *)(a2 + 8);
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0i64;
      v13 += 16;
    }
  }
  v20[1] = 0i64;
  sub_14618AD60((unsigned __int8 **)a1, v12, v8, v11);
  sub_146186CB0(v20);
  return v23;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (000000014617EE50) ----------------------------------------------------
__int64 __fastcall sub_14617EE50(__int64 a1, __int64 a2, char *a3)
{
  unsigned __int8 *v4; // rdx
  __int64 v6; // rax
  __int64 v7; // rsi
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rbp
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rdi
  unsigned __int8 *v13; // rax
  char v14; // cl
  __int64 v15; // rsi
  unsigned __int8 *v16; // r10
  _BYTE *v17; // rdx
  unsigned __int8 *v18; // r8
  unsigned __int8 *v19; // rax
  unsigned __int8 *i; // rdx
  unsigned __int8 *j; // r8
  __int64 v22; // rcx
  __int64 v24[3]; // [rsp+20h] [rbp-48h] BYREF
  __int64 k; // [rsp+38h] [rbp-30h]
  __int64 v26; // [rsp+40h] [rbp-28h]

  v4 = *(unsigned __int8 **)a1;
  v6 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  v7 = a2 - *(_QWORD *)a1;
  if ( v6 == 0xFFFFFFFFFFFFFFFi64 )
    unknown_libname_6(a1, v4, 0xFFFFFFFFFFFFFFFi64);
  v9 = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v4) >> 4;
  v10 = v6 + 1;
  v11 = v9 >> 1;
  if ( v9 <= 0xFFFFFFFFFFFFFFFi64 - (v9 >> 1) )
  {
    v12 = v6 + 1;
    if ( v11 + v9 >= v10 )
      v12 = v11 + v9;
    if ( v12 > 0xFFFFFFFFFFFFFFFi64 )
      sub_146165390(v9, v11, 0xFFFFFFFFFFFFFFFi64);
  }
  else
  {
    v12 = 0xFFFFFFFFFFFFFFFi64;
  }
  v13 = (unsigned __int8 *)sub_14615A5E0(16 * v12);
  v14 = *a3;
  v15 = (__int64)&v13[v7 & 0xFFFFFFFFFFFFFFF0ui64];
  v24[0] = a1;
  v24[2] = v12;
  v16 = v13;
  k = v15;
  *(_BYTE *)v15 = v14;
  v17 = (_BYTE *)(v15 + 16);
  *(_QWORD *)(v15 + 8) = *((_QWORD *)a3 + 1);
  *a3 = 0;
  *((_QWORD *)a3 + 1) = 0i64;
  v18 = *(unsigned __int8 **)(a1 + 8);
  v19 = *(unsigned __int8 **)a1;
  v26 = v15 + 16;
  if ( (unsigned __int8 *)a2 == v18 )
  {
    for ( i = v16; v19 != v18; v19 += 16 )
    {
      *i = *v19;
      i += 16;
      *((_QWORD *)i - 1) = *((_QWORD *)v19 + 1);
      *v19 = 0;
      *((_QWORD *)v19 + 1) = 0i64;
    }
  }
  else
  {
    for ( j = v16; v19 != (unsigned __int8 *)a2; v19 += 16 )
    {
      *j = *v19;
      j += 16;
      *((_QWORD *)j - 1) = *((_QWORD *)v19 + 1);
      *v19 = 0;
      *((_QWORD *)v19 + 1) = 0i64;
    }
    v22 = *(_QWORD *)(a1 + 8);
    for ( k = (__int64)v16; a2 != v22; a2 += 16i64 )
    {
      *v17 = *(_BYTE *)a2;
      v17 += 16;
      *((_QWORD *)v17 - 1) = *(_QWORD *)(a2 + 8);
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0i64;
    }
  }
  v24[1] = 0i64;
  sub_14618AD60((unsigned __int8 **)a1, v16, v10, v12);
  sub_146186CB0(v24);
  return v15;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (000000014617F010) ----------------------------------------------------
char *__fastcall sub_14617F010(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rbx
  __int64 v5; // rbp
  unsigned __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r14
  size_t v12; // r14
  _QWORD *v13; // rax
  unsigned __int64 v14; // rbx
  _QWORD *v15; // r15
  char *v16; // r13
  _OWORD *v17; // rbx
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rbx
  __int64 i; // rsi
  _QWORD *v22; // rcx
  char *result; // rax

  v4 = a2 - *a1;
  v5 = (a1[1] - *a1) >> 5;
  if ( v5 == 0x7FFFFFFFFFFFFFFi64 )
    unknown_libname_6(a1, a2, 0x7FFFFFFFFFFFFFFi64);
  v8 = v5 + 1;
  v9 = (a1[2] - *a1) >> 5;
  v10 = v9 >> 1;
  if ( v9 <= 0x7FFFFFFFFFFFFFFi64 - (v9 >> 1) )
  {
    v11 = v8;
    if ( v10 + v9 >= v8 )
      v11 = v10 + v9;
    if ( v11 > 0x7FFFFFFFFFFFFFFi64 )
      sub_146165390(v9, v10, 0x7FFFFFFFFFFFFFFi64);
  }
  else
  {
    v11 = 0x7FFFFFFFFFFFFFFi64;
  }
  v12 = 4 * v11;
  v13 = sub_14615A5E0(v12 * 8);
  v14 = v4 & 0xFFFFFFFFFFFFFFE0ui64;
  *(_OWORD *)((char *)v13 + v14) = 0i64;
  v15 = v13;
  v16 = (char *)v13 + v14;
  *((_QWORD *)v16 + 2) = 0i64;
  v17 = (_OWORD *)((char *)v13 + v14 + 32);
  *((_QWORD *)v16 + 3) = 0i64;
  *(_OWORD *)v16 = *(_OWORD *)a3;
  *((_OWORD *)v16 + 1) = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(a3 + 16) = 0i64;
  *(_QWORD *)(a3 + 24) = 7i64;
  *(_WORD *)a3 = 0;
  v18 = a1[1];
  v19 = *a1;
  if ( a2 == v18 )
  {
    v17 = v13;
  }
  else
  {
    sub_14617F620(v19, a2, v13);
    v18 = a1[1];
    v19 = a2;
  }
  sub_14617F620(v19, v18, v17);
  v20 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v20 != i; v20 += 32i64 )
      sub_146162730(v20);
    v22 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFE0ui64) >= 0x1000 )
    {
      if ( (unsigned __int64)v22 - *(v22 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v22 = (_QWORD *)*(v22 - 1);
    }
    j_j_free(v22);
  }
  *a1 = (__int64)v15;
  result = v16;
  a1[1] = (__int64)&v15[4 * v8];
  a1[2] = (__int64)&v15[v12];
  return result;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (000000014617F1D0) ----------------------------------------------------
__int64 __fastcall sub_14617F1D0(__int64 a1, __int64 a2, char *a3)
{
  unsigned __int8 *v6; // rdx
  __int64 v7; // rdi
  __int64 v8; // rax
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rsi
  unsigned __int8 *v13; // rbp
  __int64 v14; // r13
  __int64 v15; // rdi
  char v16; // dl
  unsigned __int8 *v17; // r8
  unsigned __int8 *v18; // rax
  unsigned __int8 *v19; // rdx
  __int64 i; // rcx
  __int64 v22; // [rsp+28h] [rbp-50h] BYREF
  unsigned __int8 *v23; // [rsp+30h] [rbp-48h]
  unsigned __int64 v24; // [rsp+38h] [rbp-40h]
  __int64 v25; // [rsp+40h] [rbp-38h]
  __int64 v26; // [rsp+48h] [rbp-30h]

  v6 = *(unsigned __int8 **)a1;
  v7 = a2 - *(_QWORD *)a1;
  v8 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if ( v8 == 0xFFFFFFFFFFFFFFFi64 )
    unknown_libname_6(a1, v6, 0xFFFFFFFFFFFFFFFi64);
  v9 = v8 + 1;
  v10 = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v6) >> 4;
  v11 = v10 >> 1;
  if ( v10 <= 0xFFFFFFFFFFFFFFFi64 - (v10 >> 1) )
  {
    v12 = v8 + 1;
    if ( v11 + v10 >= v9 )
      v12 = v11 + v10;
    if ( v12 > 0xFFFFFFFFFFFFFFFi64 )
      sub_146165390(v10, v11, 0xFFFFFFFFFFFFFFFi64);
  }
  else
  {
    v12 = 0xFFFFFFFFFFFFFFFi64;
  }
  v13 = (unsigned __int8 *)sub_14615A5E0(16 * v12);
  v14 = (__int64)&v13[v7 & 0xFFFFFFFFFFFFFFF0ui64];
  v15 = v14 + 16;
  v22 = a1;
  v23 = v13;
  v24 = v12;
  v25 = v14 + 16;
  v26 = v14 + 16;
  v16 = *a3;
  *(_BYTE *)v14 = *a3;
  sub_1461862B0((_QWORD *)(v14 + 8), v16);
  v25 = v14;
  v17 = *(unsigned __int8 **)(a1 + 8);
  v18 = *(unsigned __int8 **)a1;
  v19 = v13;
  if ( (unsigned __int8 *)a2 == v17 )
  {
    for ( ; v18 != v17; v18 += 16 )
    {
      *v19 = *v18;
      *((_QWORD *)v19 + 1) = *((_QWORD *)v18 + 1);
      *v18 = 0;
      *((_QWORD *)v18 + 1) = 0i64;
      v19 += 16;
    }
  }
  else
  {
    for ( ; v18 != (unsigned __int8 *)a2; v18 += 16 )
    {
      *v19 = *v18;
      *((_QWORD *)v19 + 1) = *((_QWORD *)v18 + 1);
      *v18 = 0;
      *((_QWORD *)v18 + 1) = 0i64;
      v19 += 16;
    }
    v25 = (__int64)v13;
    for ( i = *(_QWORD *)(a1 + 8); a2 != i; a2 += 16i64 )
    {
      *(_BYTE *)v15 = *(_BYTE *)a2;
      *(_QWORD *)(v15 + 8) = *(_QWORD *)(a2 + 8);
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0i64;
      v15 += 16i64;
    }
  }
  v23 = 0i64;
  sub_14618AD60((unsigned __int8 **)a1, v13, v9, v12);
  sub_146186CB0(&v22);
  return v14;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (000000014617F3A0) ----------------------------------------------------
void __fastcall sub_14617F3A0(__int64 a1, __int64 a2, unsigned __int8 **a3)
{
  unsigned __int8 **v3; // rbx
  unsigned __int8 ***v6; // rsi

  v3 = a3;
  while ( !*((_BYTE *)v3 + 25) )
  {
    sub_14617F3A0(a1, a2, v3[2]);
    v6 = (unsigned __int8 ***)v3;
    v3 = (unsigned __int8 **)*v3;
    sub_14618BD60(v6 + 9, *((unsigned __int8 *)v6 + 64));
    sub_1461626B0((__int64)(v6 + 4));
    j_j_free(v6);
  }
}

//----- (000000014617F440) ----------------------------------------------------
__int64 __fastcall sub_14617F440(_QWORD *a1)
{
  volatile signed __int32 *v2; // rbx

  sub_1461873D0();
  Cnd_do_broadcast_at_thread_exit();
  if ( a1 )
  {
    v2 = (volatile signed __int32 *)a1[1];
    if ( v2 )
    {
      if ( _InterlockedExchangeAdd(v2 + 2, 0xFFFFFFFF) == 1 )
      {
        (**(void (__fastcall ***)(volatile signed __int32 *))v2)(v2);
        if ( _InterlockedExchangeAdd(v2 + 3, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
      }
    }
    j_j_free(a1);
  }
  return 0i64;
}

//----- (000000014617F4C0) ----------------------------------------------------
char *__fastcall sub_14617F4C0(__int64 a1, unsigned __int64 a2, _DWORD *a3)
{
  __int64 v6; // rbp
  unsigned __int64 v7; // rcx
  __int64 v8; // rbp
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rax
  __int64 v11; // r15
  _QWORD *v12; // r14
  unsigned __int64 v13; // rdx
  _DWORD *v14; // rcx
  _QWORD *v15; // rcx
  char *result; // rax

  if ( a2 > 0x3FFFFFFFFFFFFFFFi64 )
    unknown_libname_6(a1, a2, 0x3FFFFFFFFFFFFFFFi64);
  v6 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  v7 = (__int64)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 2;
  v8 = v6 >> 2;
  v9 = v7 >> 1;
  if ( v7 <= 0x3FFFFFFFFFFFFFFFi64 - (v7 >> 1) )
  {
    v10 = v9 + v7;
    if ( v9 + v7 >= a2 )
    {
      if ( v10 > 0x3FFFFFFFFFFFFFFFi64 )
        sub_146165390(v7, v9, 0x3FFFFFFFFFFFFFFFi64);
    }
    else
    {
      v10 = a2;
    }
  }
  else
  {
    v10 = 0x3FFFFFFFFFFFFFFFi64;
  }
  v11 = 4 * v10;
  v12 = sub_14615A5E0(4 * v10);
  v13 = a2 - v8;
  v14 = (_DWORD *)v12 + v8;
  if ( *a3 )
  {
    for ( ; v13; --v13 )
      *v14++ = *a3;
  }
  else
  {
    memset(v14, 0, 4 * v13);
  }
  memmove(v12, *(const void **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
  v15 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    if ( ((*(_QWORD *)(a1 + 16) - (_QWORD)v15) & 0xFFFFFFFFFFFFFFFCui64) >= 0x1000 )
    {
      if ( (unsigned __int64)v15 - *(v15 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v15 = (_QWORD *)*(v15 - 1);
    }
    j_j_free(v15);
  }
  *(_QWORD *)a1 = v12;
  *(_QWORD *)(a1 + 8) = (char *)v12 + 4 * a2;
  result = (char *)v12 + v11;
  *(_QWORD *)(a1 + 16) = (char *)v12 + v11;
  return result;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (000000014617F620) ----------------------------------------------------
_OWORD *__fastcall sub_14617F620(__int64 a1, __int64 a2, _OWORD *a3)
{
  _OWORD *result; // rax
  __int64 v4; // r8
  char *v5; // r9

  result = a3;
  if ( a1 != a2 )
  {
    v4 = a1 + 24;
    v5 = (char *)result - a1;
    do
    {
      v4 += 32i64;
      *result = 0i64;
      *(_QWORD *)&v5[v4 - 40] = 0i64;
      *(_QWORD *)&v5[v4 - 32] = 0i64;
      *result = *(_OWORD *)(v4 - 56);
      result[1] = *(_OWORD *)(v4 - 40);
      *(_QWORD *)(v4 - 40) = 0i64;
      result += 2;
      *(_QWORD *)(v4 - 32) = 7i64;
      *(_WORD *)(v4 - 56) = 0;
    }
    while ( v4 - 24 != a2 );
  }
  return result;
}

//----- (000000014617F690) ----------------------------------------------------
void **__fastcall sub_14617F690(void **Src, char *a2, _QWORD *a3)
{
  _QWORD *v3; // rdi
  unsigned __int64 v6; // rdx
  __int64 v7; // r8
  __int64 v8; // r9
  size_t v9; // rax
  __int64 v10; // r9
  __int64 v11; // r9
  size_t v12; // r8

  v3 = a3;
  *(_OWORD *)Src = 0i64;
  Src[2] = 0i64;
  Src[3] = (void *)15;
  *(_BYTE *)Src = 0;
  v6 = strlen(a2) + a3[2];
  sub_146190960(Src, v6, v7, v8);
  v9 = strlen(a2);
  sub_14618B8D0(Src, a2, v9, v10);
  v12 = v3[2];
  if ( v3[3] > 0xFui64 )
    v3 = (_QWORD *)*v3;
  sub_14618B8D0(Src, v3, v12, v11);
  return Src;
}
// 14617F6EA: variable 'v7' is possibly undefined
// 14617F6EA: variable 'v8' is possibly undefined
// 14617F700: variable 'v10' is possibly undefined
// 14617F719: variable 'v11' is possibly undefined

//----- (000000014617F740) ----------------------------------------------------
void **__fastcall sub_14617F740(void **Src, char *a2, const char **a3)
{
  size_t v6; // rbx
  unsigned __int64 v7; // rdx
  __int64 v8; // r8
  __int64 v9; // r9
  size_t v10; // rax
  __int64 v11; // r9
  size_t v12; // rax
  __int64 v13; // r9

  *(_OWORD *)Src = 0i64;
  Src[2] = 0i64;
  Src[3] = (void *)15;
  *(_BYTE *)Src = 0;
  v6 = strlen(*a3);
  v7 = strlen(a2) + v6;
  sub_146190960(Src, v7, v8, v9);
  v10 = strlen(a2);
  sub_14618B8D0(Src, a2, v10, v11);
  v12 = strlen(*a3);
  sub_14618B8D0(Src, (void *)*a3, v12, v13);
  return Src;
}
// 14617F7A8: variable 'v8' is possibly undefined
// 14617F7A8: variable 'v9' is possibly undefined
// 14617F7BE: variable 'v11' is possibly undefined
// 14617F7D4: variable 'v13' is possibly undefined

//----- (000000014617F800) ----------------------------------------------------
void **__fastcall sub_14617F800(void **Src, char *a2, _QWORD *a3, char *a4)
{
  _QWORD *v5; // rsi
  unsigned __int64 v8; // rdx
  __int64 v9; // r8
  __int64 v10; // r9
  size_t v11; // rax
  __int64 v12; // r9
  __int64 v13; // r9
  size_t v14; // r8
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  char v19; // r15
  size_t v20; // rsi
  unsigned __int64 v21; // r14
  _QWORD *v22; // rax
  __int64 v23; // rbx
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // rdx
  _QWORD *v26; // rbp
  _QWORD *v27; // rbx

  v5 = a3;
  *(_OWORD *)Src = 0i64;
  Src[2] = 0i64;
  Src[3] = (void *)15;
  *(_BYTE *)Src = 0;
  v8 = strlen(a2) + a3[2] + 1i64;
  sub_146190960(Src, v8, v9, v10);
  v11 = strlen(a2);
  sub_14618B8D0(Src, a2, v11, v12);
  v14 = v5[2];
  if ( v5[3] > 0xFui64 )
    v5 = (_QWORD *)*v5;
  sub_14618B8D0(Src, v5, v14, v13);
  v19 = *a4;
  v20 = (size_t)Src[2];
  v21 = (unsigned __int64)Src[3];
  if ( v20 >= v21 )
  {
    v23 = 0x7FFFFFFFFFFFFFFFi64;
    if ( v20 == 0x7FFFFFFFFFFFFFFFi64 )
      unknown_libname_4(v16, v15, v17, v18);
    v24 = (v20 + 1) | 0xF;
    if ( v24 <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      v25 = v21 >> 1;
      if ( v21 <= 0x7FFFFFFFFFFFFFFFi64 - (v21 >> 1) )
      {
        v23 = (v20 + 1) | 0xF;
        if ( v24 < v21 + v25 )
          v23 = v21 + v25;
      }
    }
    v26 = sub_14615A5E0(v23 + 1);
    Src[2] = (void *)(v20 + 1);
    Src[3] = (void *)v23;
    if ( v21 <= 0xF )
    {
      memcpy(v26, Src, v20);
      *((_BYTE *)v26 + v20) = v19;
      *((_BYTE *)v26 + v20 + 1) = 0;
    }
    else
    {
      v27 = *Src;
      memcpy(v26, *Src, v20);
      *((_BYTE *)v26 + v20) = v19;
      *((_BYTE *)v26 + v20 + 1) = 0;
      if ( v21 + 1 >= 0x1000 )
      {
        if ( (unsigned __int64)v27 - *(v27 - 1) - 8 > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        v27 = (_QWORD *)*(v27 - 1);
      }
      j_j_free(v27);
    }
    *Src = v26;
  }
  else
  {
    Src[2] = (void *)(v20 + 1);
    v22 = Src;
    if ( v21 > 0xF )
      v22 = *Src;
    *((_BYTE *)v22 + v20) = v19;
    *((_BYTE *)v22 + v20 + 1) = 0;
  }
  return Src;
}
// 14617F86B: variable 'v9' is possibly undefined
// 14617F86B: variable 'v10' is possibly undefined
// 14617F881: variable 'v12' is possibly undefined
// 14617F89A: variable 'v13' is possibly undefined
// 14617F9C9: variable 'v16' is possibly undefined
// 14617F9C9: variable 'v15' is possibly undefined
// 14617F9C9: variable 'v17' is possibly undefined
// 14617F9C9: variable 'v18' is possibly undefined
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014617F9D0) ----------------------------------------------------
void **__fastcall sub_14617F9D0(void **Src, char *a2, _QWORD *a3, char *a4, void **a5)
{
  size_t v9; // rbx
  void *v10; // rsi
  unsigned __int64 v11; // rdx
  __int64 v12; // r8
  __int64 v13; // r9
  size_t v14; // rax
  __int64 v15; // r9
  __int64 v16; // r9
  size_t v17; // r8
  size_t v18; // rax
  __int64 v19; // r9
  __int64 v20; // r9

  *(_OWORD *)Src = 0i64;
  Src[2] = 0i64;
  Src[3] = (void *)15;
  *(_BYTE *)Src = 0;
  v9 = strlen(a4);
  v10 = a5;
  v11 = (unsigned __int64)a5[2] + v9 + strlen(a2) + a3[2];
  sub_146190960(Src, v11, v12, v13);
  v14 = strlen(a2);
  sub_14618B8D0(Src, a2, v14, v15);
  v17 = a3[2];
  if ( a3[3] > 0xFui64 )
    a3 = (_QWORD *)*a3;
  sub_14618B8D0(Src, a3, v17, v16);
  v18 = strlen(a4);
  sub_14618B8D0(Src, a4, v18, v19);
  if ( (unsigned __int64)a5[3] > 0xF )
    v10 = *a5;
  sub_14618B8D0(Src, v10, (size_t)a5[2], v20);
  return Src;
}
// 14617FA4D: variable 'v12' is possibly undefined
// 14617FA4D: variable 'v13' is possibly undefined
// 14617FA63: variable 'v15' is possibly undefined
// 14617FA7C: variable 'v16' is possibly undefined
// 14617FA92: variable 'v19' is possibly undefined
// 14617FAAB: variable 'v20' is possibly undefined

//----- (000000014617FAD0) ----------------------------------------------------
void **__fastcall sub_14617FAD0(void **Src, _QWORD *a2, char *a3, _QWORD *a4, char *Str, void **a6, void **a7)
{
  size_t v11; // rbx
  void *v12; // r14
  void *v13; // rsi
  unsigned __int64 v14; // rdx
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r9
  size_t v18; // r8
  size_t v19; // rax
  __int64 v20; // r9
  __int64 v21; // r9
  size_t v22; // r8
  size_t v23; // rax
  __int64 v24; // r9
  __int64 v25; // r9
  __int64 v26; // r9

  *(_OWORD *)Src = 0i64;
  Src[2] = 0i64;
  Src[3] = (void *)15;
  *(_BYTE *)Src = 0;
  v11 = strlen(Str);
  v12 = a6;
  v13 = a7;
  v14 = (unsigned __int64)a6[2] + strlen(a3) + a2[2] + (_QWORD)a7[2] + v11 + a4[2];
  sub_146190960(Src, v14, v15, v16);
  v18 = a2[2];
  if ( a2[3] > 0xFui64 )
    a2 = (_QWORD *)*a2;
  sub_14618B8D0(Src, a2, v18, v17);
  v19 = strlen(a3);
  sub_14618B8D0(Src, a3, v19, v20);
  v22 = a4[2];
  if ( a4[3] > 0xFui64 )
    a4 = (_QWORD *)*a4;
  sub_14618B8D0(Src, a4, v22, v21);
  v23 = strlen(Str);
  sub_14618B8D0(Src, Str, v23, v24);
  if ( (unsigned __int64)a6[3] > 0xF )
    v12 = *a6;
  sub_14618B8D0(Src, v12, (size_t)a6[2], v25);
  if ( (unsigned __int64)a7[3] > 0xF )
    v13 = *a7;
  sub_14618B8D0(Src, v13, (size_t)a7[2], v26);
  return Src;
}
// 14617FB63: variable 'v15' is possibly undefined
// 14617FB63: variable 'v16' is possibly undefined
// 14617FB7D: variable 'v17' is possibly undefined
// 14617FB93: variable 'v20' is possibly undefined
// 14617FBAC: variable 'v21' is possibly undefined
// 14617FBCC: variable 'v24' is possibly undefined
// 14617FBE5: variable 'v25' is possibly undefined
// 14617FBFE: variable 'v26' is possibly undefined

//----- (000000014617FC20) ----------------------------------------------------
void **__fastcall sub_14617FC20(void **Src, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *v4; // rbx
  _QWORD *v5; // rsi
  _QWORD *v6; // r14
  __int64 v8; // r9
  size_t v9; // r8
  __int64 v10; // r9
  size_t v11; // r8
  __int64 v12; // r9
  size_t v13; // r8

  v4 = a4;
  v5 = a3;
  v6 = a2;
  *(_OWORD *)Src = 0i64;
  Src[2] = 0i64;
  Src[3] = (void *)15;
  *(_BYTE *)Src = 0;
  sub_146190960(Src, a3[2] + a4[2] + a2[2], (__int64)a3, (__int64)a4);
  v9 = v6[2];
  if ( v6[3] > 0xFui64 )
    v6 = (_QWORD *)*v6;
  sub_14618B8D0(Src, v6, v9, v8);
  v11 = v5[2];
  if ( v5[3] > 0xFui64 )
    v5 = (_QWORD *)*v5;
  sub_14618B8D0(Src, v5, v11, v10);
  v13 = v4[2];
  if ( v4[3] > 0xFui64 )
    v4 = (_QWORD *)*v4;
  sub_14618B8D0(Src, v4, v13, v12);
  return Src;
}
// 14617FC96: variable 'v8' is possibly undefined
// 14617FCAF: variable 'v10' is possibly undefined
// 14617FCC8: variable 'v12' is possibly undefined

//----- (000000014617FCF0) ----------------------------------------------------
__int64 __fastcall sub_14617FCF0(__int64 a1, unsigned int a2, _QWORD *a3, __int64 a4)
{
  __m128i si128; // xmm6
  void **v8; // rax
  _BYTE *v9; // rcx
  void *v10; // rcx
  void *v11; // rcx
  void **v12; // rax
  void *v13; // rcx
  void *v15[2]; // [rsp+40h] [rbp-69h] BYREF
  __m128i v16; // [rsp+50h] [rbp-59h]
  void *v17[2]; // [rsp+60h] [rbp-49h] BYREF
  __m128i v18; // [rsp+70h] [rbp-39h]
  void *Src[3]; // [rsp+80h] [rbp-29h] BYREF
  unsigned __int64 v20; // [rsp+98h] [rbp-11h]
  void *Block; // [rsp+A0h] [rbp-9h] BYREF
  __m128i v22; // [rsp+B0h] [rbp+7h]

  *(_OWORD *)v17 = 0i64;
  si128 = _mm_load_si128((const __m128i *)&Size);
  v18 = si128;
  LOBYTE(v17[0]) = 0;
  v16 = _mm_load_si128((const __m128i *)&xmmword_14612A940);
  v15[0] = (void *)0x72655F726568746Fi64;
  v15[1] = (void *)7499634;
  v8 = sub_14618F180(&Block, v15, a2, a4);
  sub_14617FC20(Src, v8, v17, a3);
  if ( v22.m128i_i64[1] > 0xFui64 )
  {
    v9 = Block;
    if ( (unsigned __int64)(v22.m128i_i64[1] + 1) >= 0x1000 )
    {
      v9 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v9 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v9);
    si128 = _mm_load_si128((const __m128i *)&Size);
  }
  v22 = si128;
  LOBYTE(Block) = 0;
  if ( v16.m128i_i64[1] > 0xFui64 )
  {
    v10 = v15[0];
    if ( (unsigned __int64)(v16.m128i_i64[1] + 1) >= 0x1000 )
    {
      v10 = (void *)*((_QWORD *)v15[0] - 1);
      if ( (unsigned __int64)(v15[0] - v10 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v10);
  }
  if ( v18.m128i_i64[1] > 0xFui64 )
  {
    v11 = v17[0];
    if ( (unsigned __int64)(v18.m128i_i64[1] + 1) >= 0x1000 )
    {
      v11 = (void *)*((_QWORD *)v17[0] - 1);
      if ( (unsigned __int64)(v17[0] - v11 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v11);
  }
  v12 = Src;
  if ( v20 > 0xF )
    v12 = (void **)Src[0];
  *(_OWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)a1 = &nlohmann::json_abi_v3_11_2::detail::exception::`vftable';
  *(_DWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = &std::exception::`vftable';
  *(_OWORD *)(a1 + 40) = 0i64;
  v15[0] = v12;
  LOBYTE(v15[1]) = 1;
  _std_exception_copy(v15);
  *(_QWORD *)(a1 + 32) = &std::runtime_error::`vftable';
  *(_QWORD *)a1 = &nlohmann::json_abi_v3_11_2::detail::other_error::`vftable';
  if ( v20 > 0xF )
  {
    v13 = Src[0];
    if ( v20 + 1 >= 0x1000 )
    {
      v13 = (void *)*((_QWORD *)Src[0] - 1);
      if ( (unsigned __int64)(Src[0] - v13 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v13);
  }
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CE48: using guessed type void *std::runtime_error::`vftable';
// 14612A940: using guessed type __int128 xmmword_14612A940;
// 14612BC10: using guessed type void *nlohmann::json_abi_v3_11_2::detail::exception::`vftable';
// 14612BCC8: using guessed type void *nlohmann::json_abi_v3_11_2::detail::other_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014617FF70) ----------------------------------------------------
__int64 __fastcall sub_14617FF70(__int64 a1, unsigned int a2, _QWORD *a3, __int64 a4)
{
  __m128i si128; // xmm6
  void **v8; // rax
  _BYTE *v9; // rcx
  void *v10; // rcx
  void *v11; // rcx
  void **v12; // rax
  void *v13; // rcx
  void *v15[2]; // [rsp+40h] [rbp-69h] BYREF
  __m128i v16; // [rsp+50h] [rbp-59h]
  void *v17[2]; // [rsp+60h] [rbp-49h] BYREF
  __m128i v18; // [rsp+70h] [rbp-39h]
  void *Src[3]; // [rsp+80h] [rbp-29h] BYREF
  unsigned __int64 v20; // [rsp+98h] [rbp-11h]
  void *Block; // [rsp+A0h] [rbp-9h] BYREF
  __m128i v22; // [rsp+B0h] [rbp+7h]

  *(_OWORD *)v17 = 0i64;
  si128 = _mm_load_si128((const __m128i *)&Size);
  v18 = si128;
  LOBYTE(v17[0]) = 0;
  v16 = _mm_load_si128((const __m128i *)&xmmword_14611E150);
  strcpy((char *)v15, "out_of_range");
  BYTE5(v15[1]) = 0;
  HIWORD(v15[1]) = 0;
  v8 = sub_14618F180(&Block, v15, a2, a4);
  sub_14617FC20(Src, v8, v17, a3);
  if ( v22.m128i_i64[1] > 0xFui64 )
  {
    v9 = Block;
    if ( (unsigned __int64)(v22.m128i_i64[1] + 1) >= 0x1000 )
    {
      v9 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v9 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v9);
    si128 = _mm_load_si128((const __m128i *)&Size);
  }
  v22 = si128;
  LOBYTE(Block) = 0;
  if ( v16.m128i_i64[1] > 0xFui64 )
  {
    v10 = v15[0];
    if ( (unsigned __int64)(v16.m128i_i64[1] + 1) >= 0x1000 )
    {
      v10 = (void *)*((_QWORD *)v15[0] - 1);
      if ( (unsigned __int64)(v15[0] - v10 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v10);
  }
  if ( v18.m128i_i64[1] > 0xFui64 )
  {
    v11 = v17[0];
    if ( (unsigned __int64)(v18.m128i_i64[1] + 1) >= 0x1000 )
    {
      v11 = (void *)*((_QWORD *)v17[0] - 1);
      if ( (unsigned __int64)(v17[0] - v11 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v11);
  }
  v12 = Src;
  if ( v20 > 0xF )
    v12 = (void **)Src[0];
  *(_OWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)a1 = &nlohmann::json_abi_v3_11_2::detail::exception::`vftable';
  *(_DWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = &std::exception::`vftable';
  *(_OWORD *)(a1 + 40) = 0i64;
  v15[0] = v12;
  LOBYTE(v15[1]) = 1;
  _std_exception_copy(v15);
  *(_QWORD *)(a1 + 32) = &std::runtime_error::`vftable';
  *(_QWORD *)a1 = &nlohmann::json_abi_v3_11_2::detail::out_of_range::`vftable';
  if ( v20 > 0xF )
  {
    v13 = Src[0];
    if ( v20 + 1 >= 0x1000 )
    {
      v13 = (void *)*((_QWORD *)Src[0] - 1);
      if ( (unsigned __int64)(Src[0] - v13 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v13);
  }
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CE48: using guessed type void *std::runtime_error::`vftable';
// 14611E150: using guessed type __int128 xmmword_14611E150;
// 14612BC10: using guessed type void *nlohmann::json_abi_v3_11_2::detail::exception::`vftable';
// 14612BCB0: using guessed type void *nlohmann::json_abi_v3_11_2::detail::out_of_range::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (00000001461801E0) ----------------------------------------------------
__int64 __fastcall sub_1461801E0(__int64 a1, unsigned int a2, __int64 *a3, void **a4)
{
  __m128i si128; // xmm6
  void **v9; // rbx
  __int64 v10; // r9
  void **v11; // rax
  _BYTE *v12; // rcx
  void *v13; // rcx
  _BYTE *v14; // rcx
  void *v15; // rcx
  void **v16; // r9
  void *v17; // rcx
  void *v19[2]; // [rsp+58h] [rbp-A8h] BYREF
  __m128i v20; // [rsp+68h] [rbp-98h]
  void *v21[2]; // [rsp+78h] [rbp-88h] BYREF
  __m128i v22; // [rsp+88h] [rbp-78h]
  void *Src[3]; // [rsp+98h] [rbp-68h] BYREF
  unsigned __int64 v24; // [rsp+B0h] [rbp-50h]
  void *Block; // [rsp+B8h] [rbp-48h] BYREF
  __m128i v26; // [rsp+C8h] [rbp-38h]
  void *v27; // [rsp+D8h] [rbp-28h] BYREF
  __m128i v28; // [rsp+E8h] [rbp-18h]

  *(_OWORD *)v21 = 0i64;
  si128 = _mm_load_si128((const __m128i *)&Size);
  v22 = si128;
  LOBYTE(v21[0]) = 0;
  v9 = sub_146190190(&v27, (__int64)a3);
  v20 = _mm_load_si128((const __m128i *)&xmmword_14612A940);
  v19[0] = (void *)0x72655F6573726170i64;
  v19[1] = (void *)7499634;
  v11 = sub_14618F180(&Block, v19, a2, v10);
  sub_14617FAD0(Src, v11, "parse error", v9, ": ", v21, a4);
  if ( v26.m128i_i64[1] > 0xFui64 )
  {
    v12 = Block;
    if ( (unsigned __int64)(v26.m128i_i64[1] + 1) >= 0x1000 )
    {
      v12 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v12 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v12);
    si128 = _mm_load_si128((const __m128i *)&Size);
  }
  v26 = si128;
  LOBYTE(Block) = 0;
  if ( v20.m128i_i64[1] > 0xFui64 )
  {
    v13 = v19[0];
    if ( (unsigned __int64)(v20.m128i_i64[1] + 1) >= 0x1000 )
    {
      v13 = (void *)*((_QWORD *)v19[0] - 1);
      if ( (unsigned __int64)(v19[0] - v13 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v13);
    si128 = _mm_load_si128((const __m128i *)&Size);
  }
  if ( v28.m128i_i64[1] > 0xFui64 )
  {
    v14 = v27;
    if ( (unsigned __int64)(v28.m128i_i64[1] + 1) >= 0x1000 )
    {
      v14 = (_BYTE *)*((_QWORD *)v27 - 1);
      if ( (unsigned __int64)((_BYTE *)v27 - v14 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v14);
    si128 = _mm_load_si128((const __m128i *)&Size);
  }
  v28 = si128;
  LOBYTE(v27) = 0;
  if ( v22.m128i_i64[1] > 0xFui64 )
  {
    v15 = v21[0];
    if ( (unsigned __int64)(v22.m128i_i64[1] + 1) >= 0x1000 )
    {
      v15 = (void *)*((_QWORD *)v21[0] - 1);
      if ( (unsigned __int64)(v21[0] - v15 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v15);
  }
  v16 = Src;
  if ( v24 > 0xF )
    v16 = (void **)Src[0];
  sub_1461864A0(a1, a2, *a3, (__int64)v16);
  if ( v24 > 0xF )
  {
    v17 = Src[0];
    if ( v24 + 1 >= 0x1000 )
    {
      v17 = (void *)*((_QWORD *)Src[0] - 1);
      if ( (unsigned __int64)(Src[0] - v17 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v17);
  }
  return a1;
}
// 14618029F: variable 'v10' is possibly undefined
// 14612A940: using guessed type __int128 xmmword_14612A940;

//----- (00000001461804D0) ----------------------------------------------------
__int64 __fastcall sub_1461804D0(__int64 a1, unsigned int a2, _QWORD *a3, __int64 a4)
{
  __m128i si128; // xmm6
  void **v8; // rax
  _BYTE *v9; // rcx
  void *v10; // rcx
  void *v11; // rcx
  void **v12; // rax
  void *v13; // rcx
  void *v15[2]; // [rsp+40h] [rbp-69h] BYREF
  __m128i v16; // [rsp+50h] [rbp-59h]
  void *v17[2]; // [rsp+60h] [rbp-49h] BYREF
  __m128i v18; // [rsp+70h] [rbp-39h]
  void *Src[3]; // [rsp+80h] [rbp-29h] BYREF
  unsigned __int64 v20; // [rsp+98h] [rbp-11h]
  void *Block; // [rsp+A0h] [rbp-9h] BYREF
  __m128i v22; // [rsp+B0h] [rbp+7h]

  *(_OWORD *)v17 = 0i64;
  si128 = _mm_load_si128((const __m128i *)&Size);
  v18 = si128;
  LOBYTE(v17[0]) = 0;
  v15[1] = (void *)29295;
  v16 = _mm_load_si128((const __m128i *)&xmmword_14612A930);
  v15[0] = (void *)0x7272655F65707974i64;
  v8 = sub_14618F180(&Block, v15, a2, a4);
  sub_14617FC20(Src, v8, v17, a3);
  if ( v22.m128i_i64[1] > 0xFui64 )
  {
    v9 = Block;
    if ( (unsigned __int64)(v22.m128i_i64[1] + 1) >= 0x1000 )
    {
      v9 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v9 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v9);
    si128 = _mm_load_si128((const __m128i *)&Size);
  }
  v22 = si128;
  LOBYTE(Block) = 0;
  if ( v16.m128i_i64[1] > 0xFui64 )
  {
    v10 = v15[0];
    if ( (unsigned __int64)(v16.m128i_i64[1] + 1) >= 0x1000 )
    {
      v10 = (void *)*((_QWORD *)v15[0] - 1);
      if ( (unsigned __int64)(v15[0] - v10 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v10);
  }
  if ( v18.m128i_i64[1] > 0xFui64 )
  {
    v11 = v17[0];
    if ( (unsigned __int64)(v18.m128i_i64[1] + 1) >= 0x1000 )
    {
      v11 = (void *)*((_QWORD *)v17[0] - 1);
      if ( (unsigned __int64)(v17[0] - v11 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v11);
  }
  v12 = Src;
  if ( v20 > 0xF )
    v12 = (void **)Src[0];
  *(_OWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)a1 = &nlohmann::json_abi_v3_11_2::detail::exception::`vftable';
  *(_DWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = &std::exception::`vftable';
  *(_OWORD *)(a1 + 40) = 0i64;
  v15[0] = v12;
  LOBYTE(v15[1]) = 1;
  _std_exception_copy(v15);
  *(_QWORD *)(a1 + 32) = &std::runtime_error::`vftable';
  *(_QWORD *)a1 = &nlohmann::json_abi_v3_11_2::detail::type_error::`vftable';
  if ( v20 > 0xF )
  {
    v13 = Src[0];
    if ( v20 + 1 >= 0x1000 )
    {
      v13 = (void *)*((_QWORD *)Src[0] - 1);
      if ( (unsigned __int64)(Src[0] - v13 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v13);
  }
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CE48: using guessed type void *std::runtime_error::`vftable';
// 14612A930: using guessed type __int128 xmmword_14612A930;
// 14612BC10: using guessed type void *nlohmann::json_abi_v3_11_2::detail::exception::`vftable';
// 14612BC98: using guessed type void *nlohmann::json_abi_v3_11_2::detail::type_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146180740) ----------------------------------------------------
__int64 __fastcall sub_146180740(__int64 a1, unsigned int a2, _QWORD *a3)
{
  __m128i si128; // xmm6
  __int64 v7; // r9
  void **v8; // rax
  _BYTE *v9; // rcx
  void *v10; // rcx
  void *v11; // rcx
  void **v12; // rax
  void *v13; // rcx
  void *v15[2]; // [rsp+40h] [rbp-69h] BYREF
  __m128i v16; // [rsp+50h] [rbp-59h]
  void *v17[2]; // [rsp+60h] [rbp-49h] BYREF
  __m128i v18; // [rsp+70h] [rbp-39h]
  void *Src[3]; // [rsp+80h] [rbp-29h] BYREF
  unsigned __int64 v20; // [rsp+98h] [rbp-11h]
  void *Block; // [rsp+A0h] [rbp-9h] BYREF
  __m128i v22; // [rsp+B0h] [rbp+7h]

  *(_OWORD *)v17 = 0i64;
  si128 = _mm_load_si128((const __m128i *)&Size);
  v18 = si128;
  LOBYTE(v17[0]) = 0;
  *(_OWORD *)v15 = 0i64;
  v15[0] = sub_14615A5E0(0x20ui64);
  v16 = _mm_load_si128((const __m128i *)&xmmword_14612E110);
  strcpy((char *)v15[0], "invalid_iterator");
  v8 = sub_14618F180(&Block, v15, a2, v7);
  sub_14617FC20(Src, v8, v17, a3);
  if ( v22.m128i_i64[1] > 0xFui64 )
  {
    v9 = Block;
    if ( (unsigned __int64)(v22.m128i_i64[1] + 1) >= 0x1000 )
    {
      v9 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v9 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v9);
    si128 = _mm_load_si128((const __m128i *)&Size);
  }
  v22 = si128;
  LOBYTE(Block) = 0;
  if ( v16.m128i_i64[1] > 0xFui64 )
  {
    v10 = v15[0];
    if ( (unsigned __int64)(v16.m128i_i64[1] + 1) >= 0x1000 )
    {
      v10 = (void *)*((_QWORD *)v15[0] - 1);
      if ( (unsigned __int64)(v15[0] - v10 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v10);
  }
  if ( v18.m128i_i64[1] > 0xFui64 )
  {
    v11 = v17[0];
    if ( (unsigned __int64)(v18.m128i_i64[1] + 1) >= 0x1000 )
    {
      v11 = (void *)*((_QWORD *)v17[0] - 1);
      if ( (unsigned __int64)(v17[0] - v11 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v11);
  }
  v12 = Src;
  if ( v20 > 0xF )
    v12 = (void **)Src[0];
  *(_OWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)a1 = &nlohmann::json_abi_v3_11_2::detail::exception::`vftable';
  *(_DWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = &std::exception::`vftable';
  *(_OWORD *)(a1 + 40) = 0i64;
  v15[0] = v12;
  LOBYTE(v15[1]) = 1;
  _std_exception_copy(v15);
  *(_QWORD *)(a1 + 32) = &std::runtime_error::`vftable';
  *(_QWORD *)a1 = &nlohmann::json_abi_v3_11_2::detail::invalid_iterator::`vftable';
  if ( v20 > 0xF )
  {
    v13 = Src[0];
    if ( v20 + 1 >= 0x1000 )
    {
      v13 = (void *)*((_QWORD *)Src[0] - 1);
      if ( (unsigned __int64)(Src[0] - v13 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v13);
  }
  return a1;
}
// 1461807D0: variable 'v7' is possibly undefined
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CE48: using guessed type void *std::runtime_error::`vftable';
// 14612BC10: using guessed type void *nlohmann::json_abi_v3_11_2::detail::exception::`vftable';
// 14612BC80: using guessed type void *nlohmann::json_abi_v3_11_2::detail::invalid_iterator::`vftable';
// 14612E110: using guessed type __int128 xmmword_14612E110;
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (00000001461809B0) ----------------------------------------------------
__int64 __fastcall sub_1461809B0(_QWORD *a1, __int64 a2)
{
  unsigned __int64 v4; // r9
  _QWORD *v5; // rcx
  unsigned int v6; // r8d
  __int64 v7; // r11
  _BYTE *v8; // rcx
  int v9; // r8d
  __int64 v10; // rdx
  __int64 v11; // rdx

  if ( (_BYTE)a2 )
  {
    v4 = (unsigned __int8)a2;
    v5 = a1 + 2;
    v6 = 1;
    if ( (unsigned __int8)a2 >= 0xAui64 )
    {
      if ( (unsigned __int8)a2 < 0x64ui64 )
        v6 = 2;
      else
        v6 = 3;
    }
    v7 = v6;
    v8 = (char *)v5 + v6;
    if ( (unsigned __int8)a2 >= 0x64ui64 )
    {
      do
      {
        v9 = v4;
        v4 /= 0x64ui64;
        v10 = 2i64 * (unsigned int)(v9 - 100 * v4);
        *(v8 - 1) = a00010203040506_0[v10 + 1];
        v8 -= 2;
        *v8 = a00010203040506_0[v10];
      }
      while ( v4 >= 0x64 );
    }
    if ( v4 < 0xA )
    {
      *(v8 - 1) = v4 + 48;
    }
    else
    {
      v11 = 2i64 * (unsigned int)v4;
      *(v8 - 1) = a00010203040506_0[v11 + 1];
      *(v8 - 2) = a00010203040506_0[v11];
    }
    return (*(__int64 (__fastcall **)(_QWORD, _QWORD *, __int64))(*(_QWORD *)*a1 + 8i64))(*a1, a1 + 2, v7);
  }
  else
  {
    LOBYTE(a2) = 48;
    return (**(__int64 (__fastcall ***)(_QWORD, __int64))*a1)(*a1, a2);
  }
}
// 146180A02: conditional instruction was optimized away because rdx.8 is in (64..FF)

//----- (0000000146180AF0) ----------------------------------------------------
__int64 __fastcall sub_146180AF0(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v4; // rcx
  unsigned int v5; // r8d
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r9
  __int64 v8; // r10
  _BYTE *i; // rcx
  int v10; // r8d
  __int64 v11; // rdx
  __int64 v12; // rdx

  if ( !a2 )
    return (**(__int64 (__fastcall ***)(_QWORD, __int64))*a1)(*a1, 48i64);
  v4 = a1 + 2;
  v5 = 1;
  if ( (a2 & 0x8000000000000000ui64) == 0i64 )
  {
    v7 = a2;
    if ( a2 < 0xA )
      goto LABEL_10;
    while ( a2 >= 0x64 )
    {
      if ( a2 < 0x3E8 )
      {
        v5 += 2;
        goto LABEL_10;
      }
      if ( a2 < 0x2710 )
      {
        v5 += 3;
        goto LABEL_10;
      }
      v5 += 4;
      a2 /= 0x2710ui64;
      if ( a2 < 0xA )
        goto LABEL_10;
    }
  }
  else
  {
    v6 = -(__int64)a2;
    *((_BYTE *)a1 + 16) = 45;
    v7 = v6;
    if ( v6 >= 0xA )
    {
      while ( v6 >= 0x64 )
      {
        if ( v6 < 0x3E8 )
        {
          v5 += 2;
          goto LABEL_9;
        }
        if ( v6 < 0x2710 )
        {
          v5 += 3;
          goto LABEL_9;
        }
        v5 += 4;
        v6 /= 0x2710ui64;
        if ( v6 < 0xA )
          goto LABEL_9;
      }
      ++v5;
    }
  }
LABEL_9:
  ++v5;
LABEL_10:
  v8 = v5;
  for ( i = (char *)v4 + v5; v7 >= 0x64; *i = byte_14612CE20[v11] )
  {
    v10 = v7;
    v7 /= 0x64ui64;
    v11 = 2i64 * (unsigned int)(v10 - 100 * v7);
    *(i - 1) = byte_14612CE20[v11 + 1];
    i -= 2;
  }
  if ( v7 < 0xA )
  {
    *(i - 1) = v7 + 48;
  }
  else
  {
    v12 = 2i64 * (unsigned int)v7;
    *(i - 1) = byte_14612CE20[v12 + 1];
    *(i - 2) = byte_14612CE20[v12];
  }
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD *, __int64))(*(_QWORD *)*a1 + 8i64))(*a1, a1 + 2, v8);
}
// 14612CE20: using guessed type _BYTE byte_14612CE20[200];

//----- (0000000146180CC0) ----------------------------------------------------
__int64 __fastcall sub_146180CC0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  _QWORD *v5; // rcx
  unsigned int v6; // r8d
  __int64 v7; // r11
  _BYTE *i; // rcx
  int v9; // r8d
  __int64 v10; // rdx
  __int64 v11; // rdx

  v2 = a2;
  if ( !a2 )
    return (**(__int64 (__fastcall ***)(_QWORD, __int64))*a1)(*a1, 48i64);
  v5 = a1 + 2;
  v6 = 1;
  if ( a2 >= 0xA )
  {
    while ( a2 >= 0x64 )
    {
      if ( a2 < 0x3E8 )
      {
        v6 += 2;
        goto LABEL_12;
      }
      if ( a2 < 0x2710 )
      {
        v6 += 3;
        goto LABEL_12;
      }
      v6 += 4;
      a2 /= 0x2710ui64;
      if ( a2 < 0xA )
        goto LABEL_12;
    }
    ++v6;
  }
LABEL_12:
  v7 = v6;
  for ( i = (char *)v5 + v6; v2 >= 0x64; *i = a00010203040506_1[v10] )
  {
    v9 = v2;
    v2 /= 0x64ui64;
    v10 = 2i64 * (unsigned int)(v9 - 100 * v2);
    *(i - 1) = a00010203040506_1[v10 + 1];
    i -= 2;
  }
  if ( v2 < 0xA )
  {
    *(i - 1) = v2 + 48;
  }
  else
  {
    v11 = 2i64 * (unsigned int)v2;
    *(i - 1) = a00010203040506_1[v11 + 1];
    *(i - 2) = a00010203040506_1[v11];
  }
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD *, __int64))(*(_QWORD *)*a1 + 8i64))(*a1, a1 + 2, v7);
}

//----- (0000000146180DF0) ----------------------------------------------------
__int64 __fastcall sub_146180DF0(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 result; // rax

  v3 = *(_QWORD *)(a1 + 8);
  if ( v3 == *(_QWORD *)(a1 + 16) )
    return sub_14617EE50(a1, v3, (char *)a2);
  *(_BYTE *)v3 = *(_BYTE *)a2;
  *(_QWORD *)(v3 + 8) = *(_QWORD *)(a2 + 8);
  *(_BYTE *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0i64;
  result = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = result + 16;
  return result;
}

//----- (0000000146180E30) ----------------------------------------------------
_QWORD *__fastcall sub_146180E30(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  char v6; // dl
  _QWORD *v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // rax
  __int64 i; // rbx
  __int64 *v11; // r8
  __int64 v12; // rsi
  unsigned __int8 *v13; // r15
  __int64 v14; // rbp
  unsigned __int8 *v15; // rdi
  unsigned __int8 *v16; // r14
  unsigned __int8 *j; // rbx
  unsigned __int8 v18; // al
  __int64 v19; // rcx
  __int64 v20; // rdx
  unsigned __int8 **v21; // rax
  void **v23; // rax
  const char *v24[2]; // [rsp+20h] [rbp-A8h] BYREF
  char pExceptionObject[56]; // [rsp+30h] [rbp-98h] BYREF
  void *Src; // [rsp+68h] [rbp-60h] BYREF
  unsigned __int8 **v27; // [rsp+70h] [rbp-58h] BYREF

  v24[1] = (const char *)-2i64;
  if ( a1 != *a3 )
  {
    sub_146178620(&Src, "iterator does not fit current value");
    sub_146180740((__int64)pExceptionObject, 0xCAu, &Src);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_iterator_detail_json_abi_v3_11_2_nlohmann__);
  }
  sub_14618D4F0(a1, a2);
  v6 = *(_BYTE *)a1;
  switch ( *(_BYTE *)a1 )
  {
    case 1:
      v7 = *(_QWORD **)(a1 + 8);
      v8 = a3[1];
      v9 = v8;
      i = *(_QWORD *)(v8 + 16);
      if ( *(_BYTE *)(i + 25) )
      {
        for ( i = *(_QWORD *)(v8 + 8); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
        {
          if ( v9 != *(_QWORD *)(i + 16) )
            break;
          v9 = i;
        }
      }
      else
      {
        v11 = *(__int64 **)i;
        if ( !*(_BYTE *)(*(_QWORD *)i + 25i64) )
        {
          do
          {
            i = (__int64)v11;
            v11 = (__int64 *)*v11;
          }
          while ( !*((_BYTE *)v11 + 25) );
        }
      }
      v12 = sub_14618B000(v7, v8);
      sub_14618BD60((unsigned __int8 ***)(v12 + 72), *(unsigned __int8 *)(v12 + 64));
      sub_1461626B0(v12 + 32);
      j_j_free((void *)v12);
      a2[1] = i;
      return a2;
    case 2:
      v13 = (unsigned __int8 *)a3[2];
      v14 = *(_QWORD *)(a1 + 8);
      v15 = v13;
      v16 = *(unsigned __int8 **)(v14 + 8);
      for ( j = v13 + 16; j != v16; j += 16 )
      {
        v18 = *j;
        v19 = *((_QWORD *)j + 1);
        *j = 0;
        *((_QWORD *)j + 1) = 0i64;
        v20 = *v15;
        *v15 = v18;
        LOBYTE(Src) = v20;
        v21 = (unsigned __int8 **)*((_QWORD *)v15 + 1);
        *((_QWORD *)v15 + 1) = v19;
        v27 = v21;
        sub_14618BD60(&v27, v20);
        v15 += 16;
      }
      sub_14618BD60(
        (unsigned __int8 ***)(*(_QWORD *)(v14 + 8) - 8i64),
        *(unsigned __int8 *)(*(_QWORD *)(v14 + 8) - 16i64));
      *(_QWORD *)(v14 + 8) -= 16i64;
      a2[2] = v13;
      return a2;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      if ( a3[3] )
      {
        sub_146178620(&Src, "iterator out of range");
        sub_146180740((__int64)pExceptionObject, 0xCDu, &Src);
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_iterator_detail_json_abi_v3_11_2_nlohmann__);
      }
      if ( v6 == 3 )
      {
        sub_1461626B0(*(_QWORD *)(a1 + 8));
      }
      else
      {
        if ( v6 != 8 )
          goto LABEL_9;
        sub_146176C60(*(_QWORD *)(a1 + 8));
      }
      j_j_free(*(void **)(a1 + 8));
      *(_QWORD *)(a1 + 8) = 0i64;
LABEL_9:
      *(_BYTE *)a1 = 0;
      return a2;
    default:
      v24[0] = sub_146192A40((_BYTE *)a1);
      v23 = sub_14617F740(&Src, "cannot use erase() with ", v24);
      sub_1461804D0((__int64)pExceptionObject, 0x133u, v23, a1);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVtype_error_detail_json_abi_v3_11_2_nlohmann__);
  }
}

//----- (00000001461810F0) ----------------------------------------------------
void __fastcall sub_1461810F0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  _QWORD *v6; // r14
  size_t v7; // rsi
  unsigned __int64 v8; // rbp
  _QWORD *v9; // rdi
  __int64 v10; // rdi
  unsigned __int64 v11; // rdx
  _QWORD *v12; // r15
  _QWORD *v13; // rcx
  void **v14; // rax
  const char *v15[2]; // [rsp+30h] [rbp-98h] BYREF
  char pExceptionObject[56]; // [rsp+40h] [rbp-88h] BYREF
  void *Src; // [rsp+78h] [rbp-50h] BYREF

  v15[1] = (const char *)-2i64;
  if ( *(_BYTE *)a1 != 3 )
  {
    v15[0] = sub_146192A40((_BYTE *)a1);
    v14 = sub_14617F740(&Src, "type must be string, but is ", v15);
    sub_1461804D0((__int64)pExceptionObject, 0x12Eu, v14, a1);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVtype_error_detail_json_abi_v3_11_2_nlohmann__);
  }
  v6 = *(_QWORD **)(a1 + 8);
  if ( a2 != v6 )
  {
    v7 = v6[2];
    if ( v6[3] > 0xFui64 )
      v6 = (_QWORD *)*v6;
    v8 = a2[3];
    if ( v7 > v8 )
    {
      v10 = 0x7FFFFFFFFFFFFFFFi64;
      if ( v7 > 0x7FFFFFFFFFFFFFFFi64 )
        unknown_libname_4(a1, a2, a3, a4);
      if ( (v7 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
      {
        v11 = v8 >> 1;
        if ( v8 <= 0x7FFFFFFFFFFFFFFFi64 - (v8 >> 1) )
        {
          v10 = v7 | 0xF;
          if ( (v7 | 0xF) < v11 + v8 )
            v10 = v11 + v8;
        }
      }
      v12 = sub_14615A5E0(v10 + 1);
      a2[2] = v7;
      a2[3] = v10;
      memcpy(v12, v6, v7);
      *((_BYTE *)v12 + v7) = 0;
      if ( v8 > 0xF )
      {
        v13 = (_QWORD *)*a2;
        if ( v8 + 1 >= 0x1000 )
        {
          if ( (unsigned __int64)v13 - *(v13 - 1) - 8 > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          v13 = (_QWORD *)*(v13 - 1);
        }
        j_j_free(v13);
      }
      *a2 = v12;
    }
    else
    {
      v9 = a2;
      if ( v8 > 0xF )
        v9 = (_QWORD *)*a2;
      a2[2] = v7;
      memmove(v9, v6, v7);
      *((_BYTE *)v9 + v7) = 0;
    }
  }
}
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001461812B0) ----------------------------------------------------
__int64 __fastcall sub_1461812B0(__int64 *a1, __int64 a2, __int64 a3, char a4)
{
  unsigned __int8 *v7; // rdx
  __int64 v8; // rcx
  unsigned __int8 *v9; // rdx
  __int64 v10; // rax
  unsigned __int64 v11; // rcx
  unsigned __int8 *v12; // rdx
  int v13; // eax
  unsigned __int8 *v14; // rcx
  unsigned __int8 *v15; // rax
  unsigned __int8 v16; // al
  unsigned __int8 **v17; // r8
  __int64 v18; // rcx
  __int64 v19; // rdx
  unsigned __int8 **v20; // rax
  __int64 v21; // rcx
  _QWORD *v22; // rax
  int v23; // ebx
  unsigned __int8 v24; // al
  unsigned __int8 **v25; // r8
  unsigned __int8 *v26; // rcx
  __int64 v27; // rdx
  unsigned __int8 **v28; // rax
  int v30; // [rsp+20h] [rbp-30h] BYREF
  __int64 v31; // [rsp+28h] [rbp-28h]
  char v32[8]; // [rsp+30h] [rbp-20h] BYREF
  unsigned __int8 **v33; // [rsp+38h] [rbp-18h] BYREF
  __int64 v34; // [rsp+40h] [rbp-10h] BYREF
  unsigned __int8 **v35; // [rsp+48h] [rbp-8h] BYREF
  char v36; // [rsp+70h] [rbp+20h] BYREF

  v31 = -2i64;
  v7 = (unsigned __int8 *)a1[4];
  v8 = a1[7];
  if ( v8 >= 0 )
    v9 = &v7[4 * ((unsigned __int64)v8 >> 5)];
  else
    v9 = &v7[-4 * ((unsigned __int64)~v8 >> 5) - 4];
  v10 = v8 & 0x1F;
  v11 = v10 - 1;
  if ( v10 )
    v12 = &v9[4 * (v11 >> 5)];
  else
    v12 = &v9[-4 * (~v11 >> 5) - 4];
  v13 = *(_DWORD *)v12;
  if ( _bittest(&v13, v11 & 0x1F) )
  {
    v32[0] = 0;
    sub_1461862B0(&v33, 0);
    if ( !a4 )
    {
      v36 = 5;
      v30 = (a1[2] - a1[1]) >> 3;
      v14 = (unsigned __int8 *)a1[21];
      if ( !v14 )
      {
        std::_Xbad_function_call();
        JUMPOUT(0x14618153Ci64);
      }
      if ( !(*(unsigned __int8 (__fastcall **)(unsigned __int8 *, int *, char *, char *, int, __int64))(*(_QWORD *)v14 + 16i64))(
              v14,
              &v30,
              &v36,
              v32,
              v30,
              v31) )
        goto LABEL_12;
    }
    v15 = (unsigned __int8 *)a1[2];
    if ( (unsigned __int8 *)a1[1] == v15 )
    {
      v16 = v32[0];
      v17 = v33;
      v32[0] = 0;
      v33 = 0i64;
      v18 = *a1;
      v19 = *(unsigned __int8 *)*a1;
      *(_BYTE *)v18 = v16;
      LOBYTE(v34) = v19;
      v20 = *(unsigned __int8 ***)(v18 + 8);
      *(_QWORD *)(v18 + 8) = v17;
      v35 = v20;
      sub_14618BD60(&v35, v19);
      *(_BYTE *)a2 = 1;
      *(_QWORD *)(a2 + 8) = *a1;
      sub_14618BD60(&v33, (unsigned __int8)v32[0]);
      return a2;
    }
    v21 = *((_QWORD *)v15 - 1);
    if ( v21 )
    {
      if ( *(_BYTE *)v21 == 2 )
      {
        sub_146180DF0(*(_QWORD *)(v21 + 8), (__int64)v32);
        *(_BYTE *)a2 = 1;
        *(_QWORD *)(a2 + 8) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[2] - 8) + 8i64) + 8i64) - 16i64;
        sub_14618BD60(&v33, (unsigned __int8)v32[0]);
      }
      else
      {
        v22 = sub_14618BC00(a1 + 8, &v34);
        v23 = *(_DWORD *)*v22 & (1 << v22[1]);
        sub_1461900F0((unsigned __int64 *)a1 + 8);
        if ( v23 )
        {
          v24 = v32[0];
          v25 = v33;
          v32[0] = 0;
          v33 = 0i64;
          v26 = (unsigned __int8 *)a1[12];
          v27 = *v26;
          *v26 = v24;
          LOBYTE(v34) = v27;
          v28 = (unsigned __int8 **)*((_QWORD *)v26 + 1);
          *((_QWORD *)v26 + 1) = v25;
          v35 = v28;
          sub_14618BD60(&v35, v27);
          *(_BYTE *)a2 = 1;
          *(_QWORD *)(a2 + 8) = a1[12];
        }
        else
        {
          *(_BYTE *)a2 = 0;
          *(_QWORD *)(a2 + 8) = 0i64;
        }
        sub_14618BD60(&v33, (unsigned __int8)v32[0]);
      }
    }
    else
    {
LABEL_12:
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0i64;
      sub_14618BD60(&v33, (unsigned __int8)v32[0]);
    }
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0i64;
  }
  return a2;
}
// 14618153B: control flows out of bounds to 14618153C
// 1461812EE: conditional instruction was optimized away because rcx.8<0
// 1461812B0: using guessed type char var_20[8];

//----- (0000000146181540) ----------------------------------------------------
__int64 __fastcall sub_146181540(__int64 *a1, __int64 a2, unsigned __int8 ***a3, char a4)
{
  unsigned __int8 *v7; // rdx
  __int64 v8; // rcx
  unsigned __int8 *v9; // rdx
  __int64 v10; // rcx
  unsigned __int64 v11; // rax
  unsigned __int8 *v12; // rdx
  int v13; // eax
  unsigned __int8 **v14; // xmm6_8
  unsigned __int8 v15; // r9
  unsigned __int8 *v16; // rcx
  unsigned __int8 *v17; // rax
  unsigned __int8 **v18; // r8
  __int64 v19; // rcx
  __int64 v20; // rdx
  unsigned __int8 **v21; // rax
  __int64 v22; // rcx
  _QWORD *v23; // rax
  int v24; // ebx
  unsigned __int8 v25; // al
  unsigned __int8 **v26; // r8
  unsigned __int8 *v27; // rcx
  __int64 v28; // rdx
  unsigned __int8 **v29; // rax
  int v31; // [rsp+20h] [rbp-40h] BYREF
  __int64 v32; // [rsp+28h] [rbp-38h]
  char v33[8]; // [rsp+30h] [rbp-30h] BYREF
  unsigned __int8 **v34; // [rsp+38h] [rbp-28h] BYREF
  __int64 v35; // [rsp+40h] [rbp-20h] BYREF
  unsigned __int8 **v36; // [rsp+48h] [rbp-18h] BYREF
  char v37; // [rsp+80h] [rbp+20h] BYREF

  v32 = -2i64;
  v7 = (unsigned __int8 *)a1[4];
  v8 = a1[7];
  if ( v8 >= 0 )
    v9 = &v7[4 * ((unsigned __int64)v8 >> 5)];
  else
    v9 = &v7[-4 * ((unsigned __int64)~v8 >> 5) - 4];
  v10 = v8 & 0x1F;
  v11 = v10 - 1;
  if ( v10 )
    v12 = &v9[4 * (v11 >> 5)];
  else
    v12 = &v9[-4 * (~v11 >> 5) - 4];
  v13 = *(_DWORD *)v12;
  if ( _bittest(&v13, ((_BYTE)v10 - 1) & 0x1F) )
  {
    v33[0] = 0;
    v34 = 0i64;
    v14 = *a3;
    sub_14618BD60(&v34, 0i64);
    v15 = 7;
    v33[0] = 7;
    v34 = v14;
    if ( !a4 )
    {
      v37 = 5;
      v31 = (a1[2] - a1[1]) >> 3;
      v16 = (unsigned __int8 *)a1[21];
      if ( !v16 )
      {
        std::_Xbad_function_call();
        JUMPOUT(0x1461817EDi64);
      }
      if ( !(*(unsigned __int8 (__fastcall **)(unsigned __int8 *, int *, char *, char *, int, __int64))(*(_QWORD *)v16 + 16i64))(
              v16,
              &v31,
              &v37,
              v33,
              v31,
              v32) )
      {
        *(_BYTE *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0i64;
        sub_14618BD60(&v34, (unsigned __int8)v33[0]);
        return a2;
      }
      v15 = v33[0];
    }
    v17 = (unsigned __int8 *)a1[2];
    if ( (unsigned __int8 *)a1[1] == v17 )
    {
      v18 = v34;
      v33[0] = 0;
      v34 = 0i64;
      v19 = *a1;
      v20 = *(unsigned __int8 *)*a1;
      *(_BYTE *)v19 = v15;
      LOBYTE(v35) = v20;
      v21 = *(unsigned __int8 ***)(v19 + 8);
      *(_QWORD *)(v19 + 8) = v18;
      v36 = v21;
      sub_14618BD60(&v36, v20);
      *(_BYTE *)a2 = 1;
      *(_QWORD *)(a2 + 8) = *a1;
      sub_14618BD60(&v34, (unsigned __int8)v33[0]);
    }
    else
    {
      v22 = *((_QWORD *)v17 - 1);
      if ( v22 )
      {
        if ( *(_BYTE *)v22 == 2 )
        {
          sub_146180DF0(*(_QWORD *)(v22 + 8), (__int64)v33);
          *(_BYTE *)a2 = 1;
          *(_QWORD *)(a2 + 8) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[2] - 8) + 8i64) + 8i64) - 16i64;
          sub_14618BD60(&v34, (unsigned __int8)v33[0]);
        }
        else
        {
          v23 = sub_14618BC00(a1 + 8, &v35);
          v24 = *(_DWORD *)*v23 & (1 << v23[1]);
          sub_1461900F0((unsigned __int64 *)a1 + 8);
          if ( v24 )
          {
            v25 = v33[0];
            v26 = v34;
            v33[0] = 0;
            v34 = 0i64;
            v27 = (unsigned __int8 *)a1[12];
            v28 = *v27;
            *v27 = v25;
            LOBYTE(v35) = v28;
            v29 = (unsigned __int8 **)*((_QWORD *)v27 + 1);
            *((_QWORD *)v27 + 1) = v26;
            v36 = v29;
            sub_14618BD60(&v36, v28);
            *(_BYTE *)a2 = 1;
            *(_QWORD *)(a2 + 8) = a1[12];
          }
          else
          {
            *(_BYTE *)a2 = 0;
            *(_QWORD *)(a2 + 8) = 0i64;
          }
          sub_14618BD60(&v34, (unsigned __int8)v33[0]);
        }
      }
      else
      {
        *(_BYTE *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0i64;
        sub_14618BD60(&v34, v15);
      }
    }
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0i64;
  }
  return a2;
}
// 1461817EC: control flows out of bounds to 1461817ED
// 146181582: conditional instruction was optimized away because rcx.8<0
// 146181540: using guessed type char var_30[8];

//----- (00000001461817F0) ----------------------------------------------------
__int64 __fastcall sub_1461817F0(unsigned __int8 **a1, __int64 *a2)
{
  unsigned __int8 *v3; // rax
  __int64 v4; // xmm6_8
  __int64 v5; // r8
  __int64 v6; // rdx
  unsigned __int8 **v7; // rcx
  __int64 v9; // rbp
  __int64 v10; // rbp
  unsigned __int8 *v11; // rsi
  __int64 v12; // xmm6_8
  __int64 v13; // xmm6_8
  unsigned __int8 *v14; // r8
  __int64 v15; // rdx
  unsigned __int8 **v16; // rcx
  unsigned __int8 **v17[2]; // [rsp+30h] [rbp-28h] BYREF

  v3 = a1[2];
  if ( a1[1] == v3 )
  {
    v17[0] = 0i64;
    v4 = *a2;
    sub_14618BD60(v17, 0i64);
    v5 = (__int64)*a1;
    v6 = **a1;
    *(_BYTE *)v5 = 7;
    v7 = *(unsigned __int8 ***)(v5 + 8);
    *(_QWORD *)(v5 + 8) = v4;
    v17[0] = v7;
    sub_14618BD60(v17, v6);
    return (__int64)*a1;
  }
  else
  {
    v9 = *((_QWORD *)v3 - 1);
    if ( *(_BYTE *)v9 == 2 )
    {
      v10 = *(_QWORD *)(v9 + 8);
      v11 = *(unsigned __int8 **)(v10 + 8);
      if ( v11 == *(unsigned __int8 **)(v10 + 16) )
      {
        sub_14617E450(v10, *(_QWORD *)(v10 + 8), a2);
      }
      else
      {
        *v11 = 0;
        *((_QWORD *)v11 + 1) = 0i64;
        v12 = *a2;
        sub_14618BD60((unsigned __int8 ***)v11 + 1, *v11);
        *v11 = 7;
        *((_QWORD *)v11 + 1) = v12;
        *(_QWORD *)(v10 + 8) += 16i64;
      }
      return *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1[2] - 1) + 8i64) + 8i64) - 16i64;
    }
    else
    {
      v17[0] = 0i64;
      v13 = *a2;
      sub_14618BD60(v17, 0i64);
      v14 = a1[4];
      v15 = *v14;
      *v14 = 7;
      v16 = (unsigned __int8 **)*((_QWORD *)v14 + 1);
      *((_QWORD *)v14 + 1) = v13;
      v17[0] = v16;
      sub_14618BD60(v17, v15);
      return (__int64)a1[4];
    }
  }
}

//----- (0000000146181950) ----------------------------------------------------
__int64 __fastcall sub_146181950(__int64 *a1, __int64 a2, __int64 a3, char a4)
{
  unsigned __int8 *v8; // rdx
  __int64 v9; // rcx
  unsigned __int8 *v10; // rdx
  __int64 v11; // rax
  unsigned __int64 v12; // rcx
  unsigned __int8 *v13; // rdx
  int v14; // eax
  unsigned __int8 **v15; // rbx
  __int64 v16; // r8
  __int64 v17; // r9
  unsigned __int8 *v18; // rcx
  unsigned __int8 *v19; // rax
  unsigned __int8 v20; // al
  __int64 v21; // rcx
  __int64 v22; // rdx
  unsigned __int8 **v23; // rax
  __int64 v24; // rcx
  _QWORD *v25; // rax
  int v26; // ebx
  unsigned __int8 v27; // al
  unsigned __int8 **v28; // r8
  unsigned __int8 *v29; // rcx
  __int64 v30; // rdx
  unsigned __int8 **v31; // rax
  int v33; // [rsp+20h] [rbp-30h] BYREF
  __int64 v34; // [rsp+28h] [rbp-28h]
  char v35[8]; // [rsp+30h] [rbp-20h] BYREF
  unsigned __int8 **v36; // [rsp+38h] [rbp-18h] BYREF
  char *v37; // [rsp+40h] [rbp-10h] BYREF
  unsigned __int8 **v38; // [rsp+48h] [rbp-8h] BYREF
  char v39; // [rsp+70h] [rbp+20h] BYREF

  v34 = -2i64;
  v8 = (unsigned __int8 *)a1[4];
  v9 = a1[7];
  if ( v9 >= 0 )
    v10 = &v8[4 * ((unsigned __int64)v9 >> 5)];
  else
    v10 = &v8[-4 * ((unsigned __int64)~v9 >> 5) - 4];
  v11 = v9 & 0x1F;
  v12 = v11 - 1;
  if ( v11 )
    v13 = &v10[4 * (v12 >> 5)];
  else
    v13 = &v10[-4 * (~v12 >> 5) - 4];
  v14 = *(_DWORD *)v13;
  if ( !_bittest(&v14, v12 & 0x1F) )
  {
    *(_BYTE *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0i64;
    return a2;
  }
  v36 = 0i64;
  sub_14618BD60(&v36, 0i64);
  v35[0] = 3;
  v15 = (unsigned __int8 **)operator new(0x20ui64);
  v37 = &v39;
  v38 = v15;
  sub_146170E60((__int64)v15, a3, v16, v17);
  v36 = v15;
  if ( !a4 )
  {
    v39 = 5;
    v33 = (a1[2] - a1[1]) >> 3;
    v18 = (unsigned __int8 *)a1[21];
    if ( !v18 )
    {
      std::_Xbad_function_call();
      JUMPOUT(0x146181C18i64);
    }
    if ( !(*(unsigned __int8 (__fastcall **)(unsigned __int8 *, int *, char *, char *, int, __int64))(*(_QWORD *)v18 + 16i64))(
            v18,
            &v33,
            &v39,
            v35,
            v33,
            v34) )
    {
LABEL_12:
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0i64;
      sub_14618BD60(&v36, (unsigned __int8)v35[0]);
      return a2;
    }
    v15 = v36;
  }
  v19 = (unsigned __int8 *)a1[2];
  if ( (unsigned __int8 *)a1[1] == v19 )
  {
    v20 = v35[0];
    v35[0] = 0;
    v36 = 0i64;
    v21 = *a1;
    v22 = *(unsigned __int8 *)*a1;
    *(_BYTE *)v21 = v20;
    LOBYTE(v37) = v22;
    v23 = *(unsigned __int8 ***)(v21 + 8);
    *(_QWORD *)(v21 + 8) = v15;
    v38 = v23;
    sub_14618BD60(&v38, v22);
    *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 8) = *a1;
    sub_14618BD60(&v36, (unsigned __int8)v35[0]);
    return a2;
  }
  v24 = *((_QWORD *)v19 - 1);
  if ( !v24 )
    goto LABEL_12;
  if ( *(_BYTE *)v24 == 2 )
  {
    sub_146180DF0(*(_QWORD *)(v24 + 8), (__int64)v35);
    *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 8) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[2] - 8) + 8i64) + 8i64) - 16i64;
    sub_14618BD60(&v36, (unsigned __int8)v35[0]);
  }
  else
  {
    v25 = sub_14618BC00(a1 + 8, &v37);
    v26 = *(_DWORD *)*v25 & (1 << v25[1]);
    sub_1461900F0((unsigned __int64 *)a1 + 8);
    if ( v26 )
    {
      v27 = v35[0];
      v28 = v36;
      v35[0] = 0;
      v36 = 0i64;
      v29 = (unsigned __int8 *)a1[12];
      v30 = *v29;
      *v29 = v27;
      LOBYTE(v37) = v30;
      v31 = (unsigned __int8 **)*((_QWORD *)v29 + 1);
      *((_QWORD *)v29 + 1) = v28;
      v38 = v31;
      sub_14618BD60(&v38, v30);
      *(_BYTE *)a2 = 1;
      *(_QWORD *)(a2 + 8) = a1[12];
    }
    else
    {
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0i64;
    }
    sub_14618BD60(&v36, (unsigned __int8)v35[0]);
  }
  return a2;
}
// 146181C17: control flows out of bounds to 146181C18
// 146181993: conditional instruction was optimized away because rcx.8<0
// 146181A3F: variable 'v16' is possibly undefined
// 146181A3F: variable 'v17' is possibly undefined
// 146181950: using guessed type char var_20[8];

//----- (0000000146181C20) ----------------------------------------------------
__int64 __fastcall sub_146181C20(unsigned __int8 **a1, __int64 a2)
{
  unsigned __int8 *v4; // rax
  void *v5; // rbx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // rdx
  unsigned __int8 **v10; // rax
  __int64 v12; // rbp
  __int64 v13; // rbp
  unsigned __int8 *v14; // rbx
  __int64 v15; // r8
  __int64 v16; // r9
  void *v17; // rbx
  __int64 v18; // r8
  __int64 v19; // r9
  unsigned __int8 *v20; // rcx
  __int64 v21; // rdx
  unsigned __int8 **v22; // rax
  unsigned __int8 **v23; // [rsp+30h] [rbp-38h] BYREF
  char *v24; // [rsp+38h] [rbp-30h]
  void *v25; // [rsp+40h] [rbp-28h]
  char v26; // [rsp+70h] [rbp+8h] BYREF

  v4 = a1[2];
  if ( a1[1] == v4 )
  {
    v23 = 0i64;
    sub_14618BD60(&v23, 0i64);
    v5 = operator new(0x20ui64);
    v24 = &v26;
    v25 = v5;
    sub_146170E60((__int64)v5, a2, v6, v7);
    v8 = (__int64)*a1;
    v9 = **a1;
    *(_BYTE *)v8 = 3;
    v10 = *(unsigned __int8 ***)(v8 + 8);
    *(_QWORD *)(v8 + 8) = v5;
    v23 = v10;
    sub_14618BD60(&v23, v9);
    return (__int64)*a1;
  }
  else
  {
    v12 = *((_QWORD *)v4 - 1);
    if ( *(_BYTE *)v12 == 2 )
    {
      v13 = *(_QWORD *)(v12 + 8);
      v14 = *(unsigned __int8 **)(v13 + 8);
      if ( v14 == *(unsigned __int8 **)(v13 + 16) )
      {
        sub_14617E650(v13, *(_QWORD *)(v13 + 8), a2);
      }
      else
      {
        *v14 = 0;
        *((_QWORD *)v14 + 1) = 0i64;
        sub_14618BD60((unsigned __int8 ***)v14 + 1, *v14);
        *v14 = 3;
        v24 = &v26;
        v25 = operator new(0x20ui64);
        sub_146170E60((__int64)v25, a2, v15, v16);
        *((_QWORD *)v14 + 1) = v25;
        *(_QWORD *)(v13 + 8) += 16i64;
      }
      return *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1[2] - 1) + 8i64) + 8i64) - 16i64;
    }
    else
    {
      v23 = 0i64;
      sub_14618BD60(&v23, 0i64);
      v17 = operator new(0x20ui64);
      v24 = &v26;
      v25 = v17;
      sub_146170E60((__int64)v17, a2, v18, v19);
      v20 = a1[4];
      v21 = *v20;
      *v20 = 3;
      v22 = (unsigned __int8 **)*((_QWORD *)v20 + 1);
      *((_QWORD *)v20 + 1) = v17;
      v23 = v22;
      sub_14618BD60(&v23, v21);
      return (__int64)a1[4];
    }
  }
}
// 146181C83: variable 'v6' is possibly undefined
// 146181C83: variable 'v7' is possibly undefined
// 146181D0A: variable 'v15' is possibly undefined
// 146181D0A: variable 'v16' is possibly undefined
// 146181D78: variable 'v18' is possibly undefined
// 146181D78: variable 'v19' is possibly undefined

//----- (0000000146181DC0) ----------------------------------------------------
__int64 __fastcall sub_146181DC0(__int64 *a1, __int64 a2, unsigned __int8 ***a3, char a4)
{
  unsigned __int8 *v7; // rdx
  __int64 v8; // rcx
  unsigned __int8 *v9; // rdx
  __int64 v10; // rax
  unsigned __int64 v11; // rcx
  unsigned __int8 *v12; // rdx
  int v13; // eax
  unsigned __int8 **v14; // rbx
  unsigned __int8 v15; // r8
  unsigned __int8 *v16; // rcx
  unsigned __int8 *v17; // rax
  __int64 v18; // rcx
  __int64 v19; // rdx
  unsigned __int8 **v20; // rax
  __int64 v21; // rcx
  _QWORD *v22; // rax
  int v23; // ebx
  unsigned __int8 v24; // al
  unsigned __int8 **v25; // r8
  unsigned __int8 *v26; // rcx
  __int64 v27; // rdx
  unsigned __int8 **v28; // rax
  int v30; // [rsp+20h] [rbp-30h] BYREF
  __int64 v31; // [rsp+28h] [rbp-28h]
  char v32[8]; // [rsp+30h] [rbp-20h] BYREF
  unsigned __int8 **v33; // [rsp+38h] [rbp-18h] BYREF
  __int64 v34; // [rsp+40h] [rbp-10h] BYREF
  unsigned __int8 **v35; // [rsp+48h] [rbp-8h] BYREF
  char v36; // [rsp+70h] [rbp+20h] BYREF

  v31 = -2i64;
  v7 = (unsigned __int8 *)a1[4];
  v8 = a1[7];
  if ( v8 >= 0 )
    v9 = &v7[4 * ((unsigned __int64)v8 >> 5)];
  else
    v9 = &v7[-4 * ((unsigned __int64)~v8 >> 5) - 4];
  v10 = v8 & 0x1F;
  v11 = v10 - 1;
  if ( v10 )
    v12 = &v9[4 * (v11 >> 5)];
  else
    v12 = &v9[-4 * (~v11 >> 5) - 4];
  v13 = *(_DWORD *)v12;
  if ( _bittest(&v13, v11 & 0x1F) )
  {
    v32[0] = 0;
    v33 = 0i64;
    v14 = *a3;
    sub_14618BD60(&v33, 0i64);
    v15 = 5;
    v32[0] = 5;
    v33 = v14;
    if ( !a4 )
    {
      v36 = 5;
      v30 = (a1[2] - a1[1]) >> 3;
      v16 = (unsigned __int8 *)a1[21];
      if ( !v16 )
      {
        std::_Xbad_function_call();
        JUMPOUT(0x146182062i64);
      }
      if ( !(*(unsigned __int8 (__fastcall **)(unsigned __int8 *, int *, char *, char *, int, __int64))(*(_QWORD *)v16 + 16i64))(
              v16,
              &v30,
              &v36,
              v32,
              v30,
              v31) )
      {
        *(_BYTE *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0i64;
        sub_14618BD60(&v33, (unsigned __int8)v32[0]);
        return a2;
      }
      v14 = v33;
      v15 = v32[0];
    }
    v17 = (unsigned __int8 *)a1[2];
    if ( (unsigned __int8 *)a1[1] == v17 )
    {
      v32[0] = 0;
      v33 = 0i64;
      v18 = *a1;
      v19 = *(unsigned __int8 *)*a1;
      *(_BYTE *)v18 = v15;
      LOBYTE(v34) = v19;
      v20 = *(unsigned __int8 ***)(v18 + 8);
      *(_QWORD *)(v18 + 8) = v14;
      v35 = v20;
      sub_14618BD60(&v35, v19);
      *(_BYTE *)a2 = 1;
      *(_QWORD *)(a2 + 8) = *a1;
      sub_14618BD60(&v33, (unsigned __int8)v32[0]);
    }
    else
    {
      v21 = *((_QWORD *)v17 - 1);
      if ( v21 )
      {
        if ( *(_BYTE *)v21 == 2 )
        {
          sub_146180DF0(*(_QWORD *)(v21 + 8), (__int64)v32);
          *(_BYTE *)a2 = 1;
          *(_QWORD *)(a2 + 8) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[2] - 8) + 8i64) + 8i64) - 16i64;
          sub_14618BD60(&v33, (unsigned __int8)v32[0]);
        }
        else
        {
          v22 = sub_14618BC00(a1 + 8, &v34);
          v23 = *(_DWORD *)*v22 & (1 << v22[1]);
          sub_1461900F0((unsigned __int64 *)a1 + 8);
          if ( v23 )
          {
            v24 = v32[0];
            v25 = v33;
            v32[0] = 0;
            v33 = 0i64;
            v26 = (unsigned __int8 *)a1[12];
            v27 = *v26;
            *v26 = v24;
            LOBYTE(v34) = v27;
            v28 = (unsigned __int8 **)*((_QWORD *)v26 + 1);
            *((_QWORD *)v26 + 1) = v25;
            v35 = v28;
            sub_14618BD60(&v35, v27);
            *(_BYTE *)a2 = 1;
            *(_QWORD *)(a2 + 8) = a1[12];
          }
          else
          {
            *(_BYTE *)a2 = 0;
            *(_QWORD *)(a2 + 8) = 0i64;
          }
          sub_14618BD60(&v33, (unsigned __int8)v32[0]);
        }
      }
      else
      {
        *(_BYTE *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0i64;
        sub_14618BD60(&v33, v15);
      }
    }
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0i64;
  }
  return a2;
}
// 146182061: control flows out of bounds to 146182062
// 146181DFE: conditional instruction was optimized away because rcx.8<0
// 146181DC0: using guessed type char var_20[8];

//----- (0000000146182070) ----------------------------------------------------
__int64 __fastcall sub_146182070(unsigned __int8 **a1, __int64 *a2)
{
  unsigned __int8 *v3; // rax
  __int64 v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // rdx
  unsigned __int8 **v7; // rax
  __int64 v9; // rbp
  __int64 v10; // rbp
  unsigned __int8 *v11; // r14
  __int64 v12; // rbx
  __int64 v13; // rbx
  unsigned __int8 *v14; // rcx
  __int64 v15; // rdx
  unsigned __int8 **v16; // rax
  unsigned __int8 **v17[5]; // [rsp+30h] [rbp-28h] BYREF

  v3 = a1[2];
  if ( a1[1] == v3 )
  {
    v17[0] = 0i64;
    v4 = *a2;
    sub_14618BD60(v17, 0i64);
    v5 = (__int64)*a1;
    v6 = **a1;
    *(_BYTE *)v5 = 5;
    v7 = *(unsigned __int8 ***)(v5 + 8);
    *(_QWORD *)(v5 + 8) = v4;
    v17[0] = v7;
    sub_14618BD60(v17, v6);
    return (__int64)*a1;
  }
  else
  {
    v9 = *((_QWORD *)v3 - 1);
    if ( *(_BYTE *)v9 == 2 )
    {
      v10 = *(_QWORD *)(v9 + 8);
      v11 = *(unsigned __int8 **)(v10 + 8);
      if ( v11 == *(unsigned __int8 **)(v10 + 16) )
      {
        sub_14617E870(v10, *(_QWORD *)(v10 + 8), a2);
      }
      else
      {
        *v11 = 0;
        *((_QWORD *)v11 + 1) = 0i64;
        v12 = *a2;
        sub_14618BD60((unsigned __int8 ***)v11 + 1, *v11);
        *v11 = 5;
        *((_QWORD *)v11 + 1) = v12;
        *(_QWORD *)(v10 + 8) += 16i64;
      }
      return *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1[2] - 1) + 8i64) + 8i64) - 16i64;
    }
    else
    {
      v17[0] = 0i64;
      v13 = *a2;
      sub_14618BD60(v17, 0i64);
      v14 = a1[4];
      v15 = *v14;
      *v14 = 5;
      v16 = (unsigned __int8 **)*((_QWORD *)v14 + 1);
      *((_QWORD *)v14 + 1) = v13;
      v17[0] = v16;
      sub_14618BD60(v17, v15);
      return (__int64)a1[4];
    }
  }
}

//----- (00000001461821A0) ----------------------------------------------------
__int64 __fastcall sub_1461821A0(__int64 *a1, __int64 a2, unsigned __int8 ***a3, char a4)
{
  unsigned __int8 *v7; // rdx
  __int64 v8; // rcx
  unsigned __int8 *v9; // rdx
  __int64 v10; // rax
  unsigned __int64 v11; // rcx
  unsigned __int8 *v12; // rdx
  int v13; // eax
  unsigned __int8 **v14; // rbx
  unsigned __int8 v15; // r8
  unsigned __int8 *v16; // rcx
  unsigned __int8 *v17; // rax
  __int64 v18; // rcx
  __int64 v19; // rdx
  unsigned __int8 **v20; // rax
  __int64 v21; // rcx
  _QWORD *v22; // rax
  int v23; // ebx
  unsigned __int8 v24; // al
  unsigned __int8 **v25; // r8
  unsigned __int8 *v26; // rcx
  __int64 v27; // rdx
  unsigned __int8 **v28; // rax
  int v30; // [rsp+20h] [rbp-30h] BYREF
  __int64 v31; // [rsp+28h] [rbp-28h]
  char v32[8]; // [rsp+30h] [rbp-20h] BYREF
  unsigned __int8 **v33; // [rsp+38h] [rbp-18h] BYREF
  __int64 v34; // [rsp+40h] [rbp-10h] BYREF
  unsigned __int8 **v35; // [rsp+48h] [rbp-8h] BYREF
  char v36; // [rsp+70h] [rbp+20h] BYREF

  v31 = -2i64;
  v7 = (unsigned __int8 *)a1[4];
  v8 = a1[7];
  if ( v8 >= 0 )
    v9 = &v7[4 * ((unsigned __int64)v8 >> 5)];
  else
    v9 = &v7[-4 * ((unsigned __int64)~v8 >> 5) - 4];
  v10 = v8 & 0x1F;
  v11 = v10 - 1;
  if ( v10 )
    v12 = &v9[4 * (v11 >> 5)];
  else
    v12 = &v9[-4 * (~v11 >> 5) - 4];
  v13 = *(_DWORD *)v12;
  if ( _bittest(&v13, v11 & 0x1F) )
  {
    v32[0] = 0;
    v33 = 0i64;
    v14 = *a3;
    sub_14618BD60(&v33, 0i64);
    v15 = 6;
    v32[0] = 6;
    v33 = v14;
    if ( !a4 )
    {
      v36 = 5;
      v30 = (a1[2] - a1[1]) >> 3;
      v16 = (unsigned __int8 *)a1[21];
      if ( !v16 )
      {
        std::_Xbad_function_call();
        JUMPOUT(0x146182442i64);
      }
      if ( !(*(unsigned __int8 (__fastcall **)(unsigned __int8 *, int *, char *, char *, int, __int64))(*(_QWORD *)v16 + 16i64))(
              v16,
              &v30,
              &v36,
              v32,
              v30,
              v31) )
      {
        *(_BYTE *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0i64;
        sub_14618BD60(&v33, (unsigned __int8)v32[0]);
        return a2;
      }
      v14 = v33;
      v15 = v32[0];
    }
    v17 = (unsigned __int8 *)a1[2];
    if ( (unsigned __int8 *)a1[1] == v17 )
    {
      v32[0] = 0;
      v33 = 0i64;
      v18 = *a1;
      v19 = *(unsigned __int8 *)*a1;
      *(_BYTE *)v18 = v15;
      LOBYTE(v34) = v19;
      v20 = *(unsigned __int8 ***)(v18 + 8);
      *(_QWORD *)(v18 + 8) = v14;
      v35 = v20;
      sub_14618BD60(&v35, v19);
      *(_BYTE *)a2 = 1;
      *(_QWORD *)(a2 + 8) = *a1;
      sub_14618BD60(&v33, (unsigned __int8)v32[0]);
    }
    else
    {
      v21 = *((_QWORD *)v17 - 1);
      if ( v21 )
      {
        if ( *(_BYTE *)v21 == 2 )
        {
          sub_146180DF0(*(_QWORD *)(v21 + 8), (__int64)v32);
          *(_BYTE *)a2 = 1;
          *(_QWORD *)(a2 + 8) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[2] - 8) + 8i64) + 8i64) - 16i64;
          sub_14618BD60(&v33, (unsigned __int8)v32[0]);
        }
        else
        {
          v22 = sub_14618BC00(a1 + 8, &v34);
          v23 = *(_DWORD *)*v22 & (1 << v22[1]);
          sub_1461900F0((unsigned __int64 *)a1 + 8);
          if ( v23 )
          {
            v24 = v32[0];
            v25 = v33;
            v32[0] = 0;
            v33 = 0i64;
            v26 = (unsigned __int8 *)a1[12];
            v27 = *v26;
            *v26 = v24;
            LOBYTE(v34) = v27;
            v28 = (unsigned __int8 **)*((_QWORD *)v26 + 1);
            *((_QWORD *)v26 + 1) = v25;
            v35 = v28;
            sub_14618BD60(&v35, v27);
            *(_BYTE *)a2 = 1;
            *(_QWORD *)(a2 + 8) = a1[12];
          }
          else
          {
            *(_BYTE *)a2 = 0;
            *(_QWORD *)(a2 + 8) = 0i64;
          }
          sub_14618BD60(&v33, (unsigned __int8)v32[0]);
        }
      }
      else
      {
        *(_BYTE *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0i64;
        sub_14618BD60(&v33, v15);
      }
    }
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0i64;
  }
  return a2;
}
// 146182441: control flows out of bounds to 146182442
// 1461821DE: conditional instruction was optimized away because rcx.8<0
// 1461821A0: using guessed type char var_20[8];

//----- (0000000146182450) ----------------------------------------------------
__int64 __fastcall sub_146182450(unsigned __int8 **a1, __int64 *a2)
{
  unsigned __int8 *v3; // rax
  __int64 v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // rdx
  unsigned __int8 **v7; // rax
  __int64 v9; // rbp
  __int64 v10; // rbp
  unsigned __int8 *v11; // r14
  __int64 v12; // rbx
  __int64 v13; // rbx
  unsigned __int8 *v14; // rcx
  __int64 v15; // rdx
  unsigned __int8 **v16; // rax
  unsigned __int8 **v17[5]; // [rsp+30h] [rbp-28h] BYREF

  v3 = a1[2];
  if ( a1[1] == v3 )
  {
    v17[0] = 0i64;
    v4 = *a2;
    sub_14618BD60(v17, 0i64);
    v5 = (__int64)*a1;
    v6 = **a1;
    *(_BYTE *)v5 = 6;
    v7 = *(unsigned __int8 ***)(v5 + 8);
    *(_QWORD *)(v5 + 8) = v4;
    v17[0] = v7;
    sub_14618BD60(v17, v6);
    return (__int64)*a1;
  }
  else
  {
    v9 = *((_QWORD *)v3 - 1);
    if ( *(_BYTE *)v9 == 2 )
    {
      v10 = *(_QWORD *)(v9 + 8);
      v11 = *(unsigned __int8 **)(v10 + 8);
      if ( v11 == *(unsigned __int8 **)(v10 + 16) )
      {
        sub_14617EA60(v10, *(_QWORD *)(v10 + 8), a2);
      }
      else
      {
        *v11 = 0;
        *((_QWORD *)v11 + 1) = 0i64;
        v12 = *a2;
        sub_14618BD60((unsigned __int8 ***)v11 + 1, *v11);
        *v11 = 6;
        *((_QWORD *)v11 + 1) = v12;
        *(_QWORD *)(v10 + 8) += 16i64;
      }
      return *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1[2] - 1) + 8i64) + 8i64) - 16i64;
    }
    else
    {
      v17[0] = 0i64;
      v13 = *a2;
      sub_14618BD60(v17, 0i64);
      v14 = a1[4];
      v15 = *v14;
      *v14 = 6;
      v16 = (unsigned __int8 **)*((_QWORD *)v14 + 1);
      *((_QWORD *)v14 + 1) = v13;
      v17[0] = v16;
      sub_14618BD60(v17, v15);
      return (__int64)a1[4];
    }
  }
}

//----- (0000000146182580) ----------------------------------------------------
__int64 __fastcall sub_146182580(__int64 *a1, __int64 a2, char *a3, char a4)
{
  unsigned __int8 *v7; // rdx
  __int64 v8; // rcx
  unsigned __int8 *v9; // rdx
  __int64 v10; // rcx
  unsigned __int64 v11; // rax
  unsigned __int8 *v12; // rdx
  int v13; // eax
  char v14; // bl
  unsigned __int8 v15; // r9
  unsigned __int8 **v16; // rax
  unsigned __int8 *v17; // rcx
  unsigned __int8 *v18; // rcx
  __int64 v19; // r8
  __int64 v20; // rdx
  unsigned __int8 **v21; // rcx
  __int64 v22; // rcx
  _QWORD *v23; // rax
  int v24; // ebx
  unsigned __int8 v25; // al
  unsigned __int8 **v26; // r8
  unsigned __int8 *v27; // rcx
  __int64 v28; // rdx
  unsigned __int8 **v29; // rax
  int v31; // [rsp+20h] [rbp-30h] BYREF
  __int64 v32; // [rsp+28h] [rbp-28h]
  char v33[8]; // [rsp+30h] [rbp-20h] BYREF
  unsigned __int8 **v34; // [rsp+38h] [rbp-18h] BYREF
  __int64 v35; // [rsp+40h] [rbp-10h] BYREF
  unsigned __int8 **v36; // [rsp+48h] [rbp-8h] BYREF
  unsigned __int8 **v37; // [rsp+70h] [rbp+20h] BYREF

  v32 = -2i64;
  v7 = (unsigned __int8 *)a1[4];
  v8 = a1[7];
  if ( v8 >= 0 )
    v9 = &v7[4 * ((unsigned __int64)v8 >> 5)];
  else
    v9 = &v7[-4 * ((unsigned __int64)~v8 >> 5) - 4];
  v10 = v8 & 0x1F;
  v11 = v10 - 1;
  if ( v10 )
    v12 = &v9[4 * (v11 >> 5)];
  else
    v12 = &v9[-4 * (~v11 >> 5) - 4];
  v13 = *(_DWORD *)v12;
  if ( _bittest(&v13, ((_BYTE)v10 - 1) & 0x1F) )
  {
    v33[0] = 0;
    v34 = 0i64;
    v14 = *a3;
    sub_14618BD60(&v34, 0i64);
    v15 = 4;
    v33[0] = 4;
    LOBYTE(v37) = v14;
    v16 = v37;
    v34 = v37;
    if ( !a4 )
    {
      LOBYTE(v37) = 5;
      v31 = (a1[2] - a1[1]) >> 3;
      v17 = (unsigned __int8 *)a1[21];
      if ( !v17 )
      {
        std::_Xbad_function_call();
        JUMPOUT(0x14618282Ei64);
      }
      if ( !(*(unsigned __int8 (__fastcall **)(unsigned __int8 *, int *, unsigned __int8 ***, char *, int, __int64))(*(_QWORD *)v17 + 16i64))(
              v17,
              &v31,
              &v37,
              v33,
              v31,
              v32) )
      {
        *(_BYTE *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0i64;
        sub_14618BD60(&v34, (unsigned __int8)v33[0]);
        return a2;
      }
      v16 = v34;
      v15 = v33[0];
    }
    v18 = (unsigned __int8 *)a1[2];
    if ( (unsigned __int8 *)a1[1] == v18 )
    {
      v33[0] = 0;
      v34 = 0i64;
      v19 = *a1;
      v20 = *(unsigned __int8 *)*a1;
      *(_BYTE *)v19 = v15;
      LOBYTE(v35) = v20;
      v21 = *(unsigned __int8 ***)(v19 + 8);
      *(_QWORD *)(v19 + 8) = v16;
      v36 = v21;
      sub_14618BD60(&v36, v20);
      *(_BYTE *)a2 = 1;
      *(_QWORD *)(a2 + 8) = *a1;
      sub_14618BD60(&v34, (unsigned __int8)v33[0]);
    }
    else
    {
      v22 = *((_QWORD *)v18 - 1);
      if ( v22 )
      {
        if ( *(_BYTE *)v22 == 2 )
        {
          sub_146180DF0(*(_QWORD *)(v22 + 8), (__int64)v33);
          *(_BYTE *)a2 = 1;
          *(_QWORD *)(a2 + 8) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[2] - 8) + 8i64) + 8i64) - 16i64;
          sub_14618BD60(&v34, (unsigned __int8)v33[0]);
        }
        else
        {
          v23 = sub_14618BC00(a1 + 8, &v35);
          v24 = *(_DWORD *)*v23 & (1 << v23[1]);
          sub_1461900F0((unsigned __int64 *)a1 + 8);
          if ( v24 )
          {
            v25 = v33[0];
            v26 = v34;
            v33[0] = 0;
            v34 = 0i64;
            v27 = (unsigned __int8 *)a1[12];
            v28 = *v27;
            *v27 = v25;
            LOBYTE(v35) = v28;
            v29 = (unsigned __int8 **)*((_QWORD *)v27 + 1);
            *((_QWORD *)v27 + 1) = v26;
            v36 = v29;
            sub_14618BD60(&v36, v28);
            *(_BYTE *)a2 = 1;
            *(_QWORD *)(a2 + 8) = a1[12];
          }
          else
          {
            *(_BYTE *)a2 = 0;
            *(_QWORD *)(a2 + 8) = 0i64;
          }
          sub_14618BD60(&v34, (unsigned __int8)v33[0]);
        }
      }
      else
      {
        *(_BYTE *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0i64;
        sub_14618BD60(&v34, v15);
      }
    }
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0i64;
  }
  return a2;
}
// 14618282D: control flows out of bounds to 14618282E
// 1461825C1: conditional instruction was optimized away because rcx.8<0
// 146182580: using guessed type char var_20[8];

//----- (0000000146182830) ----------------------------------------------------
__int64 __fastcall sub_146182830(unsigned __int8 **a1, char *a2)
{
  unsigned __int8 *v3; // rax
  char v4; // bl
  __int64 v5; // r8
  __int64 v6; // rdx
  unsigned __int8 **v7; // rcx
  __int64 v9; // rbp
  __int64 v10; // rbp
  unsigned __int8 *v11; // r14
  char v12; // bl
  char v13; // bl
  unsigned __int8 *v14; // r8
  __int64 v15; // rdx
  unsigned __int8 **v16; // rcx
  unsigned __int8 **v17[5]; // [rsp+30h] [rbp-28h] BYREF
  __int64 v18; // [rsp+60h] [rbp+8h]

  v3 = a1[2];
  if ( a1[1] == v3 )
  {
    v17[0] = 0i64;
    v4 = *a2;
    sub_14618BD60(v17, 0i64);
    LOBYTE(v18) = v4;
    v5 = (__int64)*a1;
    v6 = **a1;
    *(_BYTE *)v5 = 4;
    v7 = *(unsigned __int8 ***)(v5 + 8);
    *(_QWORD *)(v5 + 8) = v18;
    v17[0] = v7;
    sub_14618BD60(v17, v6);
    return (__int64)*a1;
  }
  else
  {
    v9 = *((_QWORD *)v3 - 1);
    if ( *(_BYTE *)v9 == 2 )
    {
      v10 = *(_QWORD *)(v9 + 8);
      v11 = *(unsigned __int8 **)(v10 + 8);
      if ( v11 == *(unsigned __int8 **)(v10 + 16) )
      {
        sub_14617EC50(v10, *(_QWORD *)(v10 + 8), a2);
      }
      else
      {
        *v11 = 0;
        *((_QWORD *)v11 + 1) = 0i64;
        v12 = *a2;
        sub_14618BD60((unsigned __int8 ***)v11 + 1, *v11);
        *v11 = 4;
        LOBYTE(v18) = v12;
        *((_QWORD *)v11 + 1) = v18;
        *(_QWORD *)(v10 + 8) += 16i64;
      }
      return *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1[2] - 1) + 8i64) + 8i64) - 16i64;
    }
    else
    {
      v17[0] = 0i64;
      v13 = *a2;
      sub_14618BD60(v17, 0i64);
      LOBYTE(v18) = v13;
      v14 = a1[4];
      v15 = *v14;
      *v14 = 4;
      v16 = (unsigned __int8 **)*((_QWORD *)v14 + 1);
      *((_QWORD *)v14 + 1) = v18;
      v17[0] = v16;
      sub_14618BD60(v17, v15);
      return (__int64)a1[4];
    }
  }
}

//----- (0000000146182980) ----------------------------------------------------
__int64 __fastcall sub_146182980(__int64 *a1, __int64 a2, unsigned __int8 *a3, char a4)
{
  unsigned __int8 *v7; // rdx
  __int64 v8; // rcx
  unsigned __int8 *v9; // rdx
  __int64 v10; // rax
  unsigned __int64 v11; // rcx
  unsigned __int8 *v12; // rdx
  int v13; // eax
  unsigned __int8 *v14; // rcx
  unsigned __int8 *v15; // rax
  unsigned __int8 v16; // al
  unsigned __int8 **v17; // r8
  __int64 v18; // rcx
  __int64 v19; // rdx
  unsigned __int8 **v20; // rax
  __int64 v21; // rcx
  _QWORD *v22; // rax
  int v23; // ebx
  unsigned __int8 v24; // al
  unsigned __int8 **v25; // r8
  unsigned __int8 *v26; // rcx
  __int64 v27; // rdx
  unsigned __int8 **v28; // rax
  int v30; // [rsp+20h] [rbp-30h] BYREF
  __int64 v31; // [rsp+28h] [rbp-28h]
  char v32[8]; // [rsp+30h] [rbp-20h] BYREF
  unsigned __int8 **v33; // [rsp+38h] [rbp-18h] BYREF
  __int64 v34; // [rsp+40h] [rbp-10h] BYREF
  unsigned __int8 **v35; // [rsp+48h] [rbp-8h] BYREF
  char v36; // [rsp+70h] [rbp+20h] BYREF

  v31 = -2i64;
  v7 = (unsigned __int8 *)a1[4];
  v8 = a1[7];
  if ( v8 >= 0 )
    v9 = &v7[4 * ((unsigned __int64)v8 >> 5)];
  else
    v9 = &v7[-4 * ((unsigned __int64)~v8 >> 5) - 4];
  v10 = v8 & 0x1F;
  v11 = v10 - 1;
  if ( v10 )
    v12 = &v9[4 * (v11 >> 5)];
  else
    v12 = &v9[-4 * (~v11 >> 5) - 4];
  v13 = *(_DWORD *)v12;
  if ( _bittest(&v13, v11 & 0x1F) )
  {
    v32[0] = *a3;
    sub_1461862B0(&v33, v32[0]);
    if ( !a4 )
    {
      v36 = 5;
      v30 = (a1[2] - a1[1]) >> 3;
      v14 = (unsigned __int8 *)a1[21];
      if ( !v14 )
      {
        std::_Xbad_function_call();
        JUMPOUT(0x146182C0Di64);
      }
      if ( !(*(unsigned __int8 (__fastcall **)(unsigned __int8 *, int *, char *, char *, int, __int64))(*(_QWORD *)v14 + 16i64))(
              v14,
              &v30,
              &v36,
              v32,
              v30,
              v31) )
        goto LABEL_12;
    }
    v15 = (unsigned __int8 *)a1[2];
    if ( (unsigned __int8 *)a1[1] == v15 )
    {
      v16 = v32[0];
      v17 = v33;
      v32[0] = 0;
      v33 = 0i64;
      v18 = *a1;
      v19 = *(unsigned __int8 *)*a1;
      *(_BYTE *)v18 = v16;
      LOBYTE(v34) = v19;
      v20 = *(unsigned __int8 ***)(v18 + 8);
      *(_QWORD *)(v18 + 8) = v17;
      v35 = v20;
      sub_14618BD60(&v35, v19);
      *(_BYTE *)a2 = 1;
      *(_QWORD *)(a2 + 8) = *a1;
      sub_14618BD60(&v33, (unsigned __int8)v32[0]);
      return a2;
    }
    v21 = *((_QWORD *)v15 - 1);
    if ( v21 )
    {
      if ( *(_BYTE *)v21 == 2 )
      {
        sub_146180DF0(*(_QWORD *)(v21 + 8), (__int64)v32);
        *(_BYTE *)a2 = 1;
        *(_QWORD *)(a2 + 8) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[2] - 8) + 8i64) + 8i64) - 16i64;
        sub_14618BD60(&v33, (unsigned __int8)v32[0]);
      }
      else
      {
        v22 = sub_14618BC00(a1 + 8, &v34);
        v23 = *(_DWORD *)*v22 & (1 << v22[1]);
        sub_1461900F0((unsigned __int64 *)a1 + 8);
        if ( v23 )
        {
          v24 = v32[0];
          v25 = v33;
          v32[0] = 0;
          v33 = 0i64;
          v26 = (unsigned __int8 *)a1[12];
          v27 = *v26;
          *v26 = v24;
          LOBYTE(v34) = v27;
          v28 = (unsigned __int8 **)*((_QWORD *)v26 + 1);
          *((_QWORD *)v26 + 1) = v25;
          v35 = v28;
          sub_14618BD60(&v35, v27);
          *(_BYTE *)a2 = 1;
          *(_QWORD *)(a2 + 8) = a1[12];
        }
        else
        {
          *(_BYTE *)a2 = 0;
          *(_QWORD *)(a2 + 8) = 0i64;
        }
        sub_14618BD60(&v33, (unsigned __int8)v32[0]);
      }
    }
    else
    {
LABEL_12:
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0i64;
      sub_14618BD60(&v33, (unsigned __int8)v32[0]);
    }
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0i64;
  }
  return a2;
}
// 146182C0C: control flows out of bounds to 146182C0D
// 1461829BE: conditional instruction was optimized away because rcx.8<0
// 146182980: using guessed type char var_20[8];

//----- (0000000146182C10) ----------------------------------------------------
__int64 __fastcall sub_146182C10(unsigned __int8 **a1, char *a2)
{
  unsigned __int8 *v3; // rax
  __int64 v4; // r8
  __int64 v5; // rdx
  unsigned __int8 **v6; // rcx
  __int64 v8; // rdi
  __int64 v9; // rdi
  __int64 v10; // rax
  char v11; // dl
  char *v12; // r8
  __int64 v13; // rdx
  unsigned __int8 **v14; // rcx
  char v15; // [rsp+28h] [rbp-20h]
  char v16; // [rsp+28h] [rbp-20h]
  unsigned __int8 **v17[3]; // [rsp+30h] [rbp-18h] BYREF

  v3 = a1[2];
  if ( a1[1] == v3 )
  {
    v15 = *a2;
    sub_1461862B0(v17, *a2);
    v4 = (__int64)*a1;
    v5 = **a1;
    *(_BYTE *)v4 = v15;
    v6 = *(unsigned __int8 ***)(v4 + 8);
    *(unsigned __int8 ***)(v4 + 8) = v17[0];
    v17[0] = v6;
    sub_14618BD60(v17, v5);
    return (__int64)*a1;
  }
  else
  {
    v8 = *((_QWORD *)v3 - 1);
    if ( *(_BYTE *)v8 == 2 )
    {
      v9 = *(_QWORD *)(v8 + 8);
      v10 = *(_QWORD *)(v9 + 8);
      if ( v10 == *(_QWORD *)(v9 + 16) )
      {
        sub_14617F1D0(v9, *(_QWORD *)(v9 + 8), a2);
      }
      else
      {
        v11 = *a2;
        *(_BYTE *)v10 = v11;
        sub_1461862B0((_QWORD *)(v10 + 8), v11);
        *(_QWORD *)(v9 + 8) += 16i64;
      }
      return *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1[2] - 1) + 8i64) + 8i64) - 16i64;
    }
    else
    {
      v16 = *a2;
      sub_1461862B0(v17, *a2);
      v12 = (char *)a1[4];
      v13 = (unsigned __int8)*v12;
      *v12 = v16;
      v14 = (unsigned __int8 **)*((_QWORD *)v12 + 1);
      *((unsigned __int8 ***)v12 + 1) = v17[0];
      v17[0] = v14;
      sub_14618BD60(v17, v13);
      return (__int64)a1[4];
    }
  }
}

//----- (0000000146182D30) ----------------------------------------------------
char __fastcall sub_146182D30(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  bool v4; // zf
  _QWORD pExceptionObject[9]; // [rsp+20h] [rbp-48h] BYREF

  v4 = *(_BYTE *)(a1 + 176) == 0;
  *(_BYTE *)(a1 + 104) = 1;
  if ( !v4 )
  {
    sub_146186520(pExceptionObject, a4);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVparse_error_detail_json_abi_v3_11_2_nlohmann__);
  }
  return 0;
}
// 146182D30: using guessed type _QWORD pExceptionObject[9];

//----- (0000000146182D70) ----------------------------------------------------
char __fastcall sub_146182D70(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  bool v4; // zf
  _QWORD pExceptionObject[9]; // [rsp+20h] [rbp-48h] BYREF

  v4 = *(_BYTE *)(a1 + 41) == 0;
  *(_BYTE *)(a1 + 40) = 1;
  if ( !v4 )
  {
    sub_146186520(pExceptionObject, a4);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVparse_error_detail_json_abi_v3_11_2_nlohmann__);
  }
  return 0;
}
// 146182D70: using guessed type _QWORD pExceptionObject[9];

//----- (0000000146182DB0) ----------------------------------------------------
char __fastcall sub_146182DB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  bool v4; // zf
  _QWORD pExceptionObject[9]; // [rsp+20h] [rbp-48h] BYREF

  v4 = *(_BYTE *)(a1 + 176) == 0;
  *(_BYTE *)(a1 + 104) = 1;
  if ( !v4 )
  {
    sub_146186470(pExceptionObject, a4);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVout_of_range_detail_json_abi_v3_11_2_nlohmann__);
  }
  return 0;
}
// 146182DB0: using guessed type _QWORD pExceptionObject[9];

//----- (0000000146182DF0) ----------------------------------------------------
__int64 __fastcall sub_146182DF0(__int64 a1, _QWORD *a2, __int64 a3, char a4, char a5)
{
  char *v9; // rcx
  __int64 v10; // r8
  __int64 v11; // rdx
  __int64 v12; // r8
  char *decimal_point; // rax
  __int64 v14; // rdx
  __int64 v15; // r8
  char v16; // al
  __int64 v17; // rdx
  __int64 v18; // rdx
  std::ios_base *v19; // rbx
  char v20; // al
  __int64 v21; // rcx
  char v23[56]; // [rsp+30h] [rbp-98h] BYREF
  char *v24; // [rsp+68h] [rbp-60h]
  __int64 v25; // [rsp+70h] [rbp-58h]
  __int64 v26; // [rsp+78h] [rbp-50h]
  _QWORD *v27; // [rsp+80h] [rbp-48h]
  __int64 v28; // [rsp+88h] [rbp-40h]
  __int64 v29; // [rsp+90h] [rbp-38h]

  v25 = -2i64;
  v26 = a1;
  v27 = a2;
  v29 = a3;
  v9 = 0i64;
  v24 = 0i64;
  v10 = *(_QWORD *)(a3 + 56);
  if ( v10 )
  {
    v9 = (char *)v10;
    if ( v10 == a3 )
    {
      v9 = (char *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v10 + 8i64))(v10, v23);
      v24 = v9;
      v12 = *(_QWORD *)(a3 + 56);
      if ( !v12 )
        goto LABEL_7;
      LOBYTE(v11) = v12 != a3;
      (*(void (__fastcall **)(_QWORD, __int64))(*(_QWORD *)v12 + 32i64))(*(_QWORD *)(a3 + 56), v11);
      v9 = v24;
    }
    else
    {
      v24 = (char *)v10;
    }
    *(_QWORD *)(a3 + 56) = 0i64;
  }
LABEL_7:
  v28 = a1;
  *(_QWORD *)(a1 + 56) = 0i64;
  if ( v9 )
    *(_QWORD *)(a1 + 56) = (**(__int64 (__fastcall ***)(char *, __int64))v9)(v9, a1);
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = *a2;
  *(_QWORD *)(a1 + 80) = a2[1];
  *a2 = 0i64;
  a2[1] = 0i64;
  *(_BYTE *)(a1 + 88) = a5;
  *(_DWORD *)(a1 + 92) = -1;
  *(_BYTE *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0i64;
  *(_QWORD *)(a1 + 112) = 0i64;
  *(_QWORD *)(a1 + 120) = 0i64;
  *(_QWORD *)(a1 + 128) = 0i64;
  *(_QWORD *)(a1 + 136) = 0i64;
  *(_QWORD *)(a1 + 144) = 0i64;
  *(_OWORD *)(a1 + 152) = 0i64;
  *(_QWORD *)(a1 + 168) = 0i64;
  *(_QWORD *)(a1 + 176) = 15i64;
  *(_BYTE *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 184) = Src;
  *(_QWORD *)(a1 + 192) = 0i64;
  *(_QWORD *)(a1 + 200) = 0i64;
  *(_QWORD *)(a1 + 208) = 0i64;
  decimal_point = localeconv()->decimal_point;
  if ( decimal_point )
    v16 = *decimal_point;
  else
    v16 = 46;
  *(_DWORD *)(a1 + 216) = v16;
  *(_BYTE *)(a1 + 224) = a4;
  *(_DWORD *)(a1 + 64) = sub_146190AF0(a1 + 72, v14, v15);
  if ( v24 )
  {
    LOBYTE(v17) = v24 != v23;
    (*(void (__fastcall **)(char *, __int64))(*(_QWORD *)v24 + 32i64))(v24, v17);
    v24 = 0i64;
  }
  v18 = *a2;
  if ( *a2 )
  {
    v19 = (std::ios_base *)(v18 + *(int *)(*(_QWORD *)v18 + 4i64));
    v20 = std::ios_base::rdstate(v19);
    std::ios::clear(v19, v20 & 1, 0i64);
  }
  v21 = *(_QWORD *)(a3 + 56);
  if ( v21 )
  {
    LOBYTE(v18) = v21 != a3;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v21 + 32i64))(v21, v18);
    *(_QWORD *)(a3 + 56) = 0i64;
  }
  return a1;
}
// 146182E7B: variable 'v11' is possibly undefined
// 146182F74: variable 'v14' is possibly undefined
// 146182F74: variable 'v15' is possibly undefined
// 146182F94: variable 'v17' is possibly undefined
// 146182FDB: variable 'v18' is possibly undefined
// 14611C358: using guessed type __int64 __fastcall std::ios::clear(_QWORD, _QWORD, _QWORD);
// 14611C4B0: using guessed type _DWORD std::ios_base::rdstate(std::ios_base *__hidden this);

//----- (0000000146183010) ----------------------------------------------------
__int64 __fastcall sub_146183010(__int64 a1, __int64 *a2)
{
  __int64 v4; // rdx
  __int64 v5; // r8
  int v6; // eax
  unsigned __int8 v7; // bl
  __int64 v8; // rdx
  __int64 v9; // r8
  int v10; // eax
  __int64 v11; // rdx
  __int64 v12; // r8
  __int64 v13; // rdx
  __int64 v14; // r8
  int v15; // eax
  unsigned __int8 **v16; // xmm6_8
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // r8
  __int64 v20; // rdx
  unsigned __int64 v21; // rax
  int *v22; // rdx
  int v23; // eax
  __int64 v24; // rcx
  int v25; // eax
  __int64 v26; // rdx
  __int64 v27; // rcx
  unsigned __int64 v28; // rax
  __int64 v29; // rcx
  int v30; // eax
  __int64 v31; // rdx
  __int64 v32; // r8
  __int64 v33; // rdx
  __int64 v34; // rcx
  unsigned __int64 v35; // rax
  __int64 v36; // rcx
  int v37; // eax
  __int64 v38; // rdx
  __int64 v39; // r8
  int v40; // eax
  void **v41; // rax
  __int64 v42; // rbx
  __int64 v43; // r8
  __int64 v44; // r9
  _QWORD *v45; // rax
  void **v46; // rax
  __int64 v47; // rbx
  __int64 v48; // r8
  __int64 v49; // r9
  _QWORD *v50; // rax
  _QWORD *v51; // rax
  void **v52; // rax
  __int64 v53; // rbx
  __int64 v54; // r8
  __int64 v55; // r9
  _QWORD *v56; // rax
  void **v57; // rax
  __int64 v58; // rbx
  __int64 v59; // r8
  __int64 v60; // r9
  _QWORD *v61; // rax
  void **v62; // rax
  __int64 v63; // rbx
  __int64 v64; // r8
  __int64 v65; // r9
  _QWORD *v66; // rax
  void **v67; // rax
  __int64 v68; // rbx
  __int64 v69; // r8
  __int64 v70; // r9
  _QWORD *v71; // rax
  void **v72; // rax
  __int64 v73; // rbx
  __int64 v74; // r8
  __int64 v75; // r9
  _QWORD *v76; // rax
  char v78; // [rsp+38h] [rbp-D0h] BYREF
  __int128 v79; // [rsp+40h] [rbp-C8h] BYREF
  __int64 v80; // [rsp+50h] [rbp-B8h]
  unsigned __int8 **v81; // [rsp+58h] [rbp-B0h] BYREF
  void **v82; // [rsp+60h] [rbp-A8h] BYREF
  _BYTE v83[16]; // [rsp+68h] [rbp-A0h] BYREF
  void **v84; // [rsp+80h] [rbp-88h]
  char v85[24]; // [rsp+88h] [rbp-80h] BYREF
  __int128 v86; // [rsp+A0h] [rbp-68h] BYREF
  __int64 v87; // [rsp+B0h] [rbp-58h]
  unsigned __int64 v88; // [rsp+B8h] [rbp-50h]
  __m128i v89; // [rsp+C8h] [rbp-40h] BYREF
  __m128i v90; // [rsp+D8h] [rbp-30h] BYREF
  __int64 v91; // [rsp+E8h] [rbp-20h]
  char v92[16]; // [rsp+F0h] [rbp-18h] BYREF
  char v93[16]; // [rsp+100h] [rbp-8h] BYREF
  char v94[16]; // [rsp+110h] [rbp+8h] BYREF
  char v95[16]; // [rsp+120h] [rbp+18h] BYREF
  __int128 v96; // [rsp+130h] [rbp+28h] BYREF
  __m128i si128; // [rsp+140h] [rbp+38h]
  _QWORD v98[4]; // [rsp+150h] [rbp+48h] BYREF
  void *Src[4]; // [rsp+170h] [rbp+68h] BYREF

  v91 = -2i64;
  v86 = 0i64;
  v87 = 0i64;
  v88 = 0i64;
  while ( 2 )
  {
    switch ( *(_DWORD *)(a1 + 64) )
    {
      case 1:
        v78 = 1;
        sub_146182580(a2, (__int64)v94, &v78, 0);
        goto LABEL_26;
      case 2:
        v78 = 0;
        sub_146182580(a2, (__int64)v93, &v78, 0);
        goto LABEL_26;
      case 3:
        if ( sub_14618F630(a2) )
          goto LABEL_26;
        goto LABEL_6;
      case 4:
        sub_146181950(a2, (__int64)v98, a1 + 152, 0);
        goto LABEL_26;
      case 5:
        v81 = *(unsigned __int8 ***)(a1 + 200);
        sub_1461821A0(a2, (__int64)Src, &v81, 0);
        goto LABEL_26;
      case 6:
        v81 = *(unsigned __int8 ***)(a1 + 192);
        sub_146181DC0(a2, (__int64)v95, &v81, 0);
        goto LABEL_26;
      case 7:
        v16 = *(unsigned __int8 ***)(a1 + 208);
        if ( dclass(*(double *)&v16) <= 0 )
        {
          v81 = v16;
          sub_146181540(a2, (__int64)v92, &v81, 0);
          goto LABEL_26;
        }
        v78 = 39;
        v51 = sub_14618E820(a1 + 72, v98, v17, v18);
        v52 = sub_14617F800(Src, "number overflow parsing '", v51, &v78);
        v53 = sub_14617FF70((__int64)&v82, 0x196u, v52, 0i64);
        v56 = sub_14618E820(a1 + 72, &v96, v54, v55);
        v7 = sub_146182DB0((__int64)a2, *(_QWORD *)(a1 + 104), (__int64)v56, v53);
        sub_1461626B0((__int64)&v96);
        v84 = &std::exception::`vftable';
        _std_exception_destroy(v85);
        v82 = &std::exception::`vftable';
        _std_exception_destroy(v83);
        sub_1461626B0((__int64)Src);
        sub_1461626B0((__int64)v98);
        goto LABEL_70;
      case 8:
        if ( !sub_1461923F0((__int64)a2, 0xFFFFFFFFFFFFFFFFui64) )
          goto LABEL_6;
        v15 = sub_146190AF0(a1 + 72, v13, v14);
        *(_DWORD *)(a1 + 64) = v15;
        if ( v15 != 10 )
        {
          v78 = 1;
          sub_1461907F0((__int64 *)&v86, &v78);
          continue;
        }
        if ( !sub_14618D580(a2) )
          goto LABEL_6;
        while ( 1 )
        {
          while ( 1 )
          {
LABEL_26:
            if ( !v88 )
            {
              v7 = 1;
              goto LABEL_70;
            }
            v19 = v88 & 0x1F;
            v20 = (v88 & 0x8000000000000000ui64) == 0i64
                ? v86 + 4 * (v88 >> 5)
                : (unsigned __int64)v86 - (4 * (~v88 >> 5) + 4);
            v21 = v19 - 1;
            v22 = (int *)((v88 & 0x1F) != 0 ? v20 + 4 * (v21 >> 5) : v20 - (4 * (~v21 >> 5) + 4));
            v23 = *v22;
            v24 = a1 + 72;
            if ( !_bittest(&v23, ((_BYTE)v19 - 1) & 0x1F) )
              break;
            v25 = sub_146190AF0(v24, (__int64)v22, v19);
            *(_DWORD *)(a1 + 64) = v25;
            if ( v25 == 13 )
              goto LABEL_57;
            if ( v25 != 10 )
            {
              v96 = 0i64;
              si128 = _mm_load_si128((const __m128i *)&xmmword_14612E0F0);
              strcpy((char *)&v96, "array");
              v57 = (void **)sub_14618DCE0(a1, (__int64)v98, 10i64, (__int64)&v96);
              v79 = *(_OWORD *)(a1 + 104);
              v80 = *(_QWORD *)(a1 + 120);
              v58 = sub_1461801E0((__int64)&v82, 0x65u, (__int64 *)&v79, v57);
              v61 = sub_14618E820(a1 + 72, Src, v59, v60);
              v7 = sub_146182D30((__int64)a2, *(_QWORD *)(a1 + 104), (__int64)v61, v58);
              sub_1461626B0((__int64)Src);
              v84 = &std::exception::`vftable';
              _std_exception_destroy(v85);
              v82 = &std::exception::`vftable';
              _std_exception_destroy(v83);
              sub_1461626B0((__int64)v98);
              goto LABEL_68;
            }
            if ( !sub_14618D580(a2) )
              goto LABEL_6;
            v26 = v88 & 0x1F;
            if ( (v88 & 0x8000000000000000ui64) == 0i64 )
              v27 = v86 + 4 * (v88 >> 5);
            else
              v27 = v86 - (4 * (~v88 >> 5) + 4);
            v28 = v26 - 1;
            if ( (v88 & 0x1F) != 0 )
              v29 = v27 + 4 * (v28 >> 5);
            else
              v29 = v27 - (4 * (~v28 >> 5) + 4);
            v89.m128i_i64[0] = v29;
            v89.m128i_i64[1] = ((_BYTE)v26 - 1) & 0x1F;
            sub_14618DB00((unsigned __int64 *)&v86, (__int64)&v96, &v89);
          }
          v30 = sub_146190AF0(v24, (__int64)v22, v19);
          *(_DWORD *)(a1 + 64) = v30;
          if ( v30 == 13 )
            break;
          if ( v30 != 11 )
          {
            v96 = 0i64;
            si128 = _mm_load_si128((const __m128i *)&xmmword_14612E100);
            strcpy((char *)&v96, "object");
            v62 = (void **)sub_14618DCE0(a1, (__int64)v98, 11i64, (__int64)&v96);
            v79 = *(_OWORD *)(a1 + 104);
            v80 = *(_QWORD *)(a1 + 120);
            v63 = sub_1461801E0((__int64)&v82, 0x65u, (__int64 *)&v79, v62);
            v66 = sub_14618E820(a1 + 72, Src, v64, v65);
            v7 = sub_146182D30((__int64)a2, *(_QWORD *)(a1 + 104), (__int64)v66, v63);
            sub_1461626B0((__int64)Src);
            v84 = &std::exception::`vftable';
            _std_exception_destroy(v85);
            v82 = &std::exception::`vftable';
            _std_exception_destroy(v83);
            sub_1461626B0((__int64)v98);
            goto LABEL_68;
          }
          if ( !sub_14618D680(a2) )
            goto LABEL_6;
          v33 = v88 & 0x1F;
          if ( (v88 & 0x8000000000000000ui64) == 0i64 )
            v34 = v86 + 4 * (v88 >> 5);
          else
            v34 = v86 - (4 * (~v88 >> 5) + 4);
          v35 = v33 - 1;
          if ( (v88 & 0x1F) != 0 )
            v36 = v34 + 4 * (v35 >> 5);
          else
            v36 = v34 - (4 * (~v35 >> 5) + 4);
          v90.m128i_i64[0] = v36;
          v90.m128i_i64[1] = ((_BYTE)v33 - 1) & 0x1F;
          sub_14618DB00((unsigned __int64 *)&v86, (__int64)&v79, &v90);
        }
        v37 = sub_146190AF0(a1 + 72, v31, v32);
        *(_DWORD *)(a1 + 64) = v37;
        if ( v37 != 4 )
          goto LABEL_59;
        if ( sub_14618EFD0(a2, (const void **)(a1 + 152)) )
        {
          v40 = sub_146190AF0(a1 + 72, v38, v39);
          *(_DWORD *)(a1 + 64) = v40;
          if ( v40 == 12 )
            goto LABEL_57;
LABEL_58:
          v96 = 0i64;
          *(_QWORD *)&v96 = sub_14615A5E0(0x20ui64);
          si128 = _mm_load_si128((const __m128i *)&xmmword_14612E110);
          strcpy((char *)v96, "object separator");
          v41 = (void **)sub_14618DCE0(a1, (__int64)v98, 12i64, (__int64)&v96);
          v79 = *(_OWORD *)(a1 + 104);
          v80 = *(_QWORD *)(a1 + 120);
          v42 = sub_1461801E0((__int64)&v82, 0x65u, (__int64 *)&v79, v41);
          v45 = sub_14618E820(a1 + 72, Src, v43, v44);
          v7 = sub_146182D30((__int64)a2, *(_QWORD *)(a1 + 104), (__int64)v45, v42);
          sub_1461626B0((__int64)Src);
          v84 = &std::exception::`vftable';
          _std_exception_destroy(v85);
          v82 = &std::exception::`vftable';
          _std_exception_destroy(v83);
          sub_1461626B0((__int64)v98);
LABEL_68:
          if ( si128.m128i_i64[1] > 0xFui64 )
            sub_146173950((__int64)&v96, (void *)v96, si128.m128i_i64[1]);
        }
        else
        {
LABEL_6:
          v7 = 0;
        }
LABEL_70:
        if ( (_QWORD)v86 )
          sub_14618BCA0((__int64)&v86, (void *)v86, (v87 - (__int64)v86) >> 2);
        return v7;
      case 9:
        if ( !sub_146192630((__int64)a2, 0xFFFFFFFFFFFFFFFFui64) )
          goto LABEL_6;
        v6 = sub_146190AF0(a1 + 72, v4, v5);
        *(_DWORD *)(a1 + 64) = v6;
        if ( v6 == 11 )
        {
          if ( sub_14618D680(a2) )
            goto LABEL_26;
          goto LABEL_6;
        }
        if ( v6 != 4 )
        {
LABEL_59:
          *((_QWORD *)&v96 + 1) = 31077i64;
          si128 = _mm_load_si128((const __m128i *)&xmmword_14612A930);
          *(_QWORD *)&v96 = 0x6B207463656A626Fi64;
          v46 = (void **)sub_14618DCE0(a1, (__int64)v98, 4i64, (__int64)&v96);
          v79 = *(_OWORD *)(a1 + 104);
          v80 = *(_QWORD *)(a1 + 120);
          v47 = sub_1461801E0((__int64)&v82, 0x65u, (__int64 *)&v79, v46);
          v50 = sub_14618E820(a1 + 72, Src, v48, v49);
          v7 = sub_146182D30((__int64)a2, *(_QWORD *)(a1 + 104), (__int64)v50, v47);
          sub_1461626B0((__int64)Src);
          v84 = &std::exception::`vftable';
          _std_exception_destroy(v85);
          v82 = &std::exception::`vftable';
          _std_exception_destroy(v83);
          sub_1461626B0((__int64)v98);
          goto LABEL_68;
        }
        if ( !sub_14618EFD0(a2, (const void **)(a1 + 152)) )
          goto LABEL_6;
        v10 = sub_146190AF0(a1 + 72, v8, v9);
        *(_DWORD *)(a1 + 64) = v10;
        if ( v10 != 12 )
          goto LABEL_58;
        v78 = 0;
        sub_1461907F0((__int64 *)&v86, &v78);
LABEL_57:
        *(_DWORD *)(a1 + 64) = sub_146190AF0(a1 + 72, v11, v12);
        continue;
      case 0xE:
        v96 = 0i64;
        si128 = _mm_load_si128((const __m128i *)&xmmword_14612E0F0);
        strcpy((char *)&v96, "value");
        v67 = (void **)sub_14618DCE0(a1, (__int64)v98, 0i64, (__int64)&v96);
        v79 = *(_OWORD *)(a1 + 104);
        v80 = *(_QWORD *)(a1 + 120);
        v68 = sub_1461801E0((__int64)&v82, 0x65u, (__int64 *)&v79, v67);
        v71 = sub_14618E820(a1 + 72, Src, v69, v70);
        v7 = sub_146182D30((__int64)a2, *(_QWORD *)(a1 + 104), (__int64)v71, v68);
        sub_1461626B0((__int64)Src);
        v84 = &std::exception::`vftable';
        _std_exception_destroy(v85);
        v82 = &std::exception::`vftable';
        _std_exception_destroy(v83);
        sub_1461626B0((__int64)v98);
        goto LABEL_68;
      default:
        v96 = 0i64;
        si128 = _mm_load_si128((const __m128i *)&xmmword_14612E0F0);
        strcpy((char *)&v96, "value");
        v72 = (void **)sub_14618DCE0(a1, (__int64)v98, 16i64, (__int64)&v96);
        v79 = *(_OWORD *)(a1 + 104);
        v80 = *(_QWORD *)(a1 + 120);
        v73 = sub_1461801E0((__int64)&v82, 0x65u, (__int64 *)&v79, v72);
        v76 = sub_14618E820(a1 + 72, Src, v74, v75);
        v7 = sub_146182D30((__int64)a2, *(_QWORD *)(a1 + 104), (__int64)v76, v73);
        sub_1461626B0((__int64)Src);
        v84 = &std::exception::`vftable';
        _std_exception_destroy(v85);
        v82 = &std::exception::`vftable';
        _std_exception_destroy(v83);
        sub_1461626B0((__int64)v98);
        goto LABEL_68;
    }
  }
}
// 146183265: conditional instruction was optimized away because %var_110.8<0
// 146183312: conditional instruction was optimized away because %var_110.8<0
// 1461833C8: conditional instruction was optimized away because %var_110.8<0
// 1461830A0: variable 'v4' is possibly undefined
// 1461830A0: variable 'v5' is possibly undefined
// 1461830E4: variable 'v8' is possibly undefined
// 1461830E4: variable 'v9' is possibly undefined
// 146183130: variable 'v13' is possibly undefined
// 146183130: variable 'v14' is possibly undefined
// 14618344A: variable 'v31' is possibly undefined
// 14618344A: variable 'v32' is possibly undefined
// 146183476: variable 'v38' is possibly undefined
// 146183476: variable 'v39' is possibly undefined
// 14618348B: variable 'v11' is possibly undefined
// 14618348B: variable 'v12' is possibly undefined
// 14618351A: variable 'v43' is possibly undefined
// 14618351A: variable 'v44' is possibly undefined
// 1461835F5: variable 'v48' is possibly undefined
// 1461835F5: variable 'v49' is possibly undefined
// 14618365B: variable 'v17' is possibly undefined
// 14618365B: variable 'v18' is possibly undefined
// 14618369A: variable 'v54' is possibly undefined
// 14618369A: variable 'v55' is possibly undefined
// 146183779: variable 'v59' is possibly undefined
// 146183779: variable 'v60' is possibly undefined
// 146183850: variable 'v64' is possibly undefined
// 146183850: variable 'v65' is possibly undefined
// 146183AE0: variable 'v69' is possibly undefined
// 146183AE0: variable 'v70' is possibly undefined
// 146183BB6: variable 'v74' is possibly undefined
// 146183BB6: variable 'v75' is possibly undefined
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14612A930: using guessed type __int128 xmmword_14612A930;
// 14612CC44: using guessed type int dword_14612CC44;
// 14612CC4C: using guessed type int dword_14612CC4C;
// 14612E0F0: using guessed type __int128 xmmword_14612E0F0;
// 14612E100: using guessed type __int128 xmmword_14612E100;
// 14612E110: using guessed type __int128 xmmword_14612E110;
// 1461A8F1C: using guessed type __int64 __fastcall _std_exception_destroy(_QWORD);
// 146183010: using guessed type char var_D8[16];
// 146183010: using guessed type char var_C8[16];
// 146183010: using guessed type char var_B8[16];
// 146183010: using guessed type char var_A8[16];
// 146183010: using guessed type _QWORD var_78[4];

//----- (0000000146183CC0) ----------------------------------------------------
__int64 __fastcall sub_146183CC0(__int64 a1, __int64 a2)
{
  __int64 v4; // rdx
  __int64 v5; // r8
  int v6; // eax
  __int64 v7; // rdx
  __int64 v8; // r8
  int v9; // eax
  __int64 v10; // rdx
  __int64 v11; // r8
  __int64 v12; // rdx
  __int64 v13; // r8
  int v14; // eax
  double v15; // xmm6_8
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // rdx
  unsigned __int64 v20; // rax
  int *v21; // rdx
  int v22; // eax
  __int64 v23; // rcx
  int v24; // eax
  __int64 v25; // rdx
  __int64 v26; // rcx
  unsigned __int64 v27; // rax
  __int64 v28; // rcx
  int v29; // eax
  __int64 v30; // rdx
  __int64 v31; // r8
  __int64 v32; // rdx
  __int64 v33; // rcx
  unsigned __int64 v34; // rax
  __int64 v35; // rcx
  int v36; // eax
  __int64 v37; // rdx
  __int64 v38; // r8
  int v39; // eax
  void **v40; // rax
  __int64 v41; // rbx
  __int64 v42; // r8
  __int64 v43; // r9
  void **v44; // rax
  __int64 v45; // rbx
  __int64 v46; // r8
  __int64 v47; // r9
  _QWORD *v48; // rax
  void **v49; // rax
  __int64 v50; // rbx
  __int64 v51; // r8
  __int64 v52; // r9
  void **v53; // rax
  __int64 v54; // rbx
  __int64 v55; // r8
  __int64 v56; // r9
  void **v57; // rax
  __int64 v58; // rbx
  __int64 v59; // r8
  __int64 v60; // r9
  _QWORD *v61; // rax
  unsigned __int8 v62; // di
  void **v63; // rax
  __int64 v64; // rbx
  __int64 v65; // r8
  __int64 v66; // r9
  void **v67; // rax
  __int64 v68; // rbx
  __int64 v69; // r8
  __int64 v70; // r9
  void **v71; // rax
  __int64 v72; // rbx
  __int64 v73; // r8
  __int64 v74; // r9
  void **v75; // rax
  __int64 v76; // rbx
  __int64 v77; // r8
  __int64 v78; // r9
  __int64 v80; // [rsp+38h] [rbp-D0h] BYREF
  double v81; // [rsp+40h] [rbp-C8h] BYREF
  void **v82; // [rsp+48h] [rbp-C0h] BYREF
  char v83[24]; // [rsp+50h] [rbp-B8h] BYREF
  void **v84; // [rsp+68h] [rbp-A0h]
  char v85[24]; // [rsp+70h] [rbp-98h] BYREF
  __int128 v86; // [rsp+88h] [rbp-80h] BYREF
  __int64 v87; // [rsp+98h] [rbp-70h]
  unsigned __int64 v88; // [rsp+A0h] [rbp-68h]
  __int64 v89; // [rsp+A8h] [rbp-60h]
  __int128 Src; // [rsp+B0h] [rbp-58h] BYREF
  __m128i si128; // [rsp+C0h] [rbp-48h]
  __m128i v92[2]; // [rsp+D8h] [rbp-30h] BYREF
  __int128 pExceptionObject; // [rsp+F8h] [rbp-10h] BYREF
  __int64 v94; // [rsp+108h] [rbp+0h]
  __m128i v95[2]; // [rsp+138h] [rbp+30h] BYREF
  void **v96; // [rsp+158h] [rbp+50h]
  char v97[24]; // [rsp+160h] [rbp+58h] BYREF

  v89 = -2i64;
  v86 = 0i64;
  v87 = 0i64;
  v88 = 0i64;
LABEL_2:
  while ( 2 )
  {
    switch ( *(_DWORD *)(a1 + 64) )
    {
      case 1:
        LOBYTE(v80) = 1;
        sub_146182830((unsigned __int8 **)a2, (char *)&v80);
        goto LABEL_23;
      case 2:
        LOBYTE(v80) = 0;
        sub_146182830((unsigned __int8 **)a2, (char *)&v80);
        goto LABEL_23;
      case 3:
        if ( sub_14618F660((unsigned __int8 **)a2) )
          goto LABEL_23;
        goto LABEL_73;
      case 4:
        sub_146181C20((unsigned __int8 **)a2, a1 + 152);
        goto LABEL_23;
      case 5:
        v81 = *(double *)(a1 + 200);
        sub_146182450((unsigned __int8 **)a2, (__int64 *)&v81);
        goto LABEL_23;
      case 6:
        v81 = *(double *)(a1 + 192);
        sub_146182070((unsigned __int8 **)a2, (__int64 *)&v81);
        goto LABEL_23;
      case 7:
        v15 = *(double *)(a1 + 208);
        if ( dclass(v15) > 0 )
        {
          LOBYTE(v80) = 39;
          v48 = sub_14618E820(a1 + 72, v92, v16, v17);
          v49 = sub_14617F800((void **)&Src, "number overflow parsing '", v48, (char *)&v80);
          v50 = sub_14617FF70((__int64)v95, 0x196u, v49, 0i64);
          sub_14618E820(a1 + 72, &pExceptionObject, v51, v52);
          *(_BYTE *)(a2 + 40) = 1;
          if ( *(_BYTE *)(a2 + 41) )
          {
            sub_146186470(&v82, v50);
            CxxThrowException(&v82, (_ThrowInfo *)&_TI3_AVout_of_range_detail_json_abi_v3_11_2_nlohmann__);
          }
          sub_1461626B0((__int64)&pExceptionObject);
          v96 = &std::exception::`vftable';
          _std_exception_destroy(v97);
          v95[0].m128i_i64[0] = (__int64)&std::exception::`vftable';
          _std_exception_destroy(&v95[0].m128i_u64[1]);
          sub_1461626B0((__int64)&Src);
          sub_1461626B0((__int64)v92);
          goto LABEL_73;
        }
        v81 = v15;
        sub_1461817F0((unsigned __int8 **)a2, (__int64 *)&v81);
        break;
      case 8:
        if ( !sub_146192540(a2, 0xFFFFFFFFFFFFFFFFui64) )
          goto LABEL_73;
        v14 = sub_146190AF0(a1 + 72, v12, v13);
        *(_DWORD *)(a1 + 64) = v14;
        if ( v14 == 10 )
        {
          *(_QWORD *)(a2 + 16) -= 8i64;
          goto LABEL_23;
        }
        LOBYTE(v80) = 1;
        sub_1461907F0((__int64 *)&v86, (char *)&v80);
        continue;
      case 9:
        if ( !sub_146192780(a2, 0xFFFFFFFFFFFFFFFFui64) )
          goto LABEL_73;
        v6 = sub_146190AF0(a1 + 72, v4, v5);
        *(_DWORD *)(a1 + 64) = v6;
        if ( v6 == 11 )
        {
          *(_QWORD *)(a2 + 16) -= 8i64;
          goto LABEL_23;
        }
        if ( v6 != 4 )
        {
          *((_QWORD *)&Src + 1) = 31077i64;
          si128 = _mm_load_si128((const __m128i *)&xmmword_14612A930);
          *(_QWORD *)&Src = 0x6B207463656A626Fi64;
          v44 = (void **)sub_14618DCE0(a1, (__int64)v95, 4i64, (__int64)&Src);
          pExceptionObject = *(_OWORD *)(a1 + 104);
          v94 = *(_QWORD *)(a1 + 120);
          v45 = sub_1461801E0((__int64)&v82, 0x65u, (__int64 *)&pExceptionObject, v44);
          sub_14618E820(a1 + 72, v92, v46, v47);
          *(_BYTE *)(a2 + 40) = 1;
          if ( *(_BYTE *)(a2 + 41) )
          {
            sub_146186520(&pExceptionObject, v45);
            CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVparse_error_detail_json_abi_v3_11_2_nlohmann__);
          }
LABEL_71:
          sub_1461626B0((__int64)v92);
          v84 = &std::exception::`vftable';
          _std_exception_destroy(v85);
          v82 = &std::exception::`vftable';
          _std_exception_destroy(v83);
          sub_1461626B0((__int64)v95);
          if ( si128.m128i_i64[1] > 0xFui64 )
            sub_146173950((__int64)&Src, (void *)Src, si128.m128i_i64[1]);
LABEL_73:
          v62 = 0;
          goto LABEL_74;
        }
        *(_QWORD *)(a2 + 32) = sub_146186E80(
                                 *(__int64 **)(*(_QWORD *)(*(_QWORD *)(a2 + 16) - 8i64) + 8i64),
                                 (const void **)(a1 + 152));
        v9 = sub_146190AF0(a1 + 72, v7, v8);
        *(_DWORD *)(a1 + 64) = v9;
        if ( v9 != 12 )
        {
          Src = 0i64;
          *(_QWORD *)&Src = sub_14615A5E0(0x20ui64);
          si128 = _mm_load_si128((const __m128i *)&xmmword_14612E110);
          strcpy((char *)Src, "object separator");
          v40 = (void **)sub_14618DCE0(a1, (__int64)v95, 12i64, (__int64)&Src);
          pExceptionObject = *(_OWORD *)(a1 + 104);
          v94 = *(_QWORD *)(a1 + 120);
          v41 = sub_1461801E0((__int64)&v82, 0x65u, (__int64 *)&pExceptionObject, v40);
          sub_14618E820(a1 + 72, v92, v42, v43);
          *(_BYTE *)(a2 + 40) = 1;
          if ( *(_BYTE *)(a2 + 41) )
          {
            sub_146186520(&pExceptionObject, v41);
            CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVparse_error_detail_json_abi_v3_11_2_nlohmann__);
          }
          goto LABEL_71;
        }
        LOBYTE(v80) = 0;
        sub_1461907F0((__int64 *)&v86, (char *)&v80);
        goto LABEL_51;
      case 0xE:
        Src = 0i64;
        si128 = _mm_load_si128((const __m128i *)&xmmword_14612E0F0);
        strcpy((char *)&Src, "value");
        v71 = (void **)sub_14618DCE0(a1, (__int64)v95, 0i64, (__int64)&Src);
        pExceptionObject = *(_OWORD *)(a1 + 104);
        v94 = *(_QWORD *)(a1 + 120);
        v72 = sub_1461801E0((__int64)&v82, 0x65u, (__int64 *)&pExceptionObject, v71);
        sub_14618E820(a1 + 72, v92, v73, v74);
        *(_BYTE *)(a2 + 40) = 1;
        if ( *(_BYTE *)(a2 + 41) )
        {
          sub_146186520(&pExceptionObject, v72);
          CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVparse_error_detail_json_abi_v3_11_2_nlohmann__);
        }
        goto LABEL_71;
      default:
        Src = 0i64;
        si128 = _mm_load_si128((const __m128i *)&xmmword_14612E0F0);
        strcpy((char *)&Src, "value");
        v75 = (void **)sub_14618DCE0(a1, (__int64)v95, 16i64, (__int64)&Src);
        pExceptionObject = *(_OWORD *)(a1 + 104);
        v94 = *(_QWORD *)(a1 + 120);
        v76 = sub_1461801E0((__int64)&v82, 0x65u, (__int64 *)&pExceptionObject, v75);
        sub_14618E820(a1 + 72, v92, v77, v78);
        *(_BYTE *)(a2 + 40) = 1;
        if ( *(_BYTE *)(a2 + 41) )
        {
          sub_146186520(&pExceptionObject, v76);
          CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVparse_error_detail_json_abi_v3_11_2_nlohmann__);
        }
        goto LABEL_71;
    }
    break;
  }
  while ( 1 )
  {
    while ( 1 )
    {
LABEL_23:
      if ( !v88 )
      {
        v62 = 1;
        goto LABEL_74;
      }
      v18 = v88 & 0x1F;
      v19 = (v88 & 0x8000000000000000ui64) == 0i64
          ? v86 + 4 * (v88 >> 5)
          : (unsigned __int64)v86 - (4 * (~v88 >> 5) + 4);
      v20 = v18 - 1;
      v21 = (int *)((v88 & 0x1F) != 0 ? v19 + 4 * (v20 >> 5) : v19 - (4 * (~v20 >> 5) + 4));
      v22 = *v21;
      v23 = a1 + 72;
      if ( !_bittest(&v22, ((_BYTE)v18 - 1) & 0x1F) )
        break;
      v24 = sub_146190AF0(v23, (__int64)v21, v18);
      *(_DWORD *)(a1 + 64) = v24;
      if ( v24 == 13 )
        goto LABEL_51;
      if ( v24 != 10 )
      {
        Src = 0i64;
        si128 = _mm_load_si128((const __m128i *)&xmmword_14612E0F0);
        strcpy((char *)&Src, "array");
        v53 = (void **)sub_14618DCE0(a1, (__int64)v95, 10i64, (__int64)&Src);
        pExceptionObject = *(_OWORD *)(a1 + 104);
        v94 = *(_QWORD *)(a1 + 120);
        v54 = sub_1461801E0((__int64)&v82, 0x65u, (__int64 *)&pExceptionObject, v53);
        sub_14618E820(a1 + 72, v92, v55, v56);
        *(_BYTE *)(a2 + 40) = 1;
        if ( *(_BYTE *)(a2 + 41) )
        {
          sub_146186520(&pExceptionObject, v54);
          CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVparse_error_detail_json_abi_v3_11_2_nlohmann__);
        }
        goto LABEL_66;
      }
      *(_QWORD *)(a2 + 16) -= 8i64;
      v25 = v88 & 0x1F;
      if ( (v88 & 0x8000000000000000ui64) == 0i64 )
        v26 = v86 + 4 * (v88 >> 5);
      else
        v26 = v86 - (4 * (~v88 >> 5) + 4);
      v27 = v25 - 1;
      if ( (v88 & 0x1F) != 0 )
        v28 = v26 + 4 * (v27 >> 5);
      else
        v28 = v26 - (4 * (~v27 >> 5) + 4);
      v95[0].m128i_i64[0] = v28;
      v95[0].m128i_i64[1] = ((_BYTE)v25 - 1) & 0x1F;
      sub_14618DB00((unsigned __int64 *)&v86, (__int64)&Src, v95);
    }
    v29 = sub_146190AF0(v23, (__int64)v21, v18);
    *(_DWORD *)(a1 + 64) = v29;
    if ( v29 == 13 )
    {
      v36 = sub_146190AF0(a1 + 72, v30, v31);
      *(_DWORD *)(a1 + 64) = v36;
      if ( v36 != 4 )
      {
        *((_QWORD *)&Src + 1) = 31077i64;
        si128 = _mm_load_si128((const __m128i *)&xmmword_14612A930);
        *(_QWORD *)&Src = 0x6B207463656A626Fi64;
        v67 = (void **)sub_14618DCE0(a1, (__int64)v95, 4i64, (__int64)&Src);
        pExceptionObject = *(_OWORD *)(a1 + 104);
        v94 = *(_QWORD *)(a1 + 120);
        v68 = sub_1461801E0((__int64)&v82, 0x65u, (__int64 *)&pExceptionObject, v67);
        sub_14618E820(a1 + 72, v92, v69, v70);
        *(_BYTE *)(a2 + 40) = 1;
        if ( *(_BYTE *)(a2 + 41) )
        {
          sub_146186520(&pExceptionObject, v68);
          CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVparse_error_detail_json_abi_v3_11_2_nlohmann__);
        }
        goto LABEL_66;
      }
      *(_QWORD *)(a2 + 32) = sub_146186E80(
                               *(__int64 **)(*(_QWORD *)(*(_QWORD *)(a2 + 16) - 8i64) + 8i64),
                               (const void **)(a1 + 152));
      v39 = sub_146190AF0(a1 + 72, v37, v38);
      *(_DWORD *)(a1 + 64) = v39;
      if ( v39 != 12 )
      {
        Src = 0i64;
        *(_QWORD *)&Src = sub_14615A5E0(0x20ui64);
        si128 = _mm_load_si128((const __m128i *)&xmmword_14612E110);
        strcpy((char *)Src, "object separator");
        v63 = (void **)sub_14618DCE0(a1, (__int64)v95, 12i64, (__int64)&Src);
        pExceptionObject = *(_OWORD *)(a1 + 104);
        v94 = *(_QWORD *)(a1 + 120);
        v64 = sub_1461801E0((__int64)&v82, 0x65u, (__int64 *)&pExceptionObject, v63);
        sub_14618E820(a1 + 72, v92, v65, v66);
        *(_BYTE *)(a2 + 40) = 1;
        if ( *(_BYTE *)(a2 + 41) )
        {
          sub_146186520(&pExceptionObject, v64);
          CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVparse_error_detail_json_abi_v3_11_2_nlohmann__);
        }
LABEL_66:
        v62 = 0;
        sub_1461626B0((__int64)v92);
        v84 = &std::exception::`vftable';
        _std_exception_destroy(v85);
        v82 = &std::exception::`vftable';
        _std_exception_destroy(v83);
        sub_1461626B0((__int64)v95);
        goto LABEL_61;
      }
LABEL_51:
      *(_DWORD *)(a1 + 64) = sub_146190AF0(a1 + 72, v10, v11);
      goto LABEL_2;
    }
    if ( v29 != 11 )
      break;
    *(_QWORD *)(a2 + 16) -= 8i64;
    v32 = v88 & 0x1F;
    if ( (v88 & 0x8000000000000000ui64) == 0i64 )
      v33 = v86 + 4 * (v88 >> 5);
    else
      v33 = v86 - (4 * (~v88 >> 5) + 4);
    v34 = v32 - 1;
    if ( (v88 & 0x1F) != 0 )
      v35 = v33 + 4 * (v34 >> 5);
    else
      v35 = v33 - (4 * (~v34 >> 5) + 4);
    v92[0].m128i_i64[0] = v35;
    v92[0].m128i_i64[1] = ((_BYTE)v32 - 1) & 0x1F;
    sub_14618DB00((unsigned __int64 *)&v86, (__int64)&pExceptionObject, v92);
  }
  Src = 0i64;
  si128 = _mm_load_si128((const __m128i *)&xmmword_14612E100);
  strcpy((char *)&Src, "object");
  v57 = (void **)sub_14618DCE0(a1, (__int64)v95, 11i64, (__int64)&Src);
  pExceptionObject = *(_OWORD *)(a1 + 104);
  v94 = *(_QWORD *)(a1 + 120);
  v58 = sub_1461801E0((__int64)&v82, 0x65u, (__int64 *)&pExceptionObject, v57);
  v61 = sub_14618E820(a1 + 72, v92, v59, v60);
  v62 = sub_146182D70(a2, *(_QWORD *)(a1 + 104), (__int64)v61, v58);
  sub_1461626B0((__int64)v92);
  v84 = &std::exception::`vftable';
  _std_exception_destroy(v85);
  v82 = &std::exception::`vftable';
  _std_exception_destroy(v83);
  sub_1461626B0((__int64)v95);
LABEL_61:
  if ( si128.m128i_i64[1] > 0xFui64 )
    sub_146173950((__int64)&Src, (void *)Src, si128.m128i_i64[1]);
LABEL_74:
  if ( (_QWORD)v86 )
    sub_14618BCA0((__int64)&v86, (void *)v86, (v87 - (__int64)v86) >> 2);
  return v62;
}
// 146183ED5: conditional instruction was optimized away because %var_118.8<0
// 146183F77: conditional instruction was optimized away because %var_118.8<0
// 146184022: conditional instruction was optimized away because %var_118.8<0
// 146183D54: variable 'v4' is possibly undefined
// 146183D54: variable 'v5' is possibly undefined
// 146183D94: variable 'v7' is possibly undefined
// 146183D94: variable 'v8' is possibly undefined
// 146183DE4: variable 'v12' is possibly undefined
// 146183DE4: variable 'v13' is possibly undefined
// 1461840A3: variable 'v30' is possibly undefined
// 1461840A3: variable 'v31' is possibly undefined
// 1461840D4: variable 'v37' is possibly undefined
// 1461840D4: variable 'v38' is possibly undefined
// 1461840E9: variable 'v10' is possibly undefined
// 1461840E9: variable 'v11' is possibly undefined
// 146184175: variable 'v42' is possibly undefined
// 146184175: variable 'v43' is possibly undefined
// 146184247: variable 'v46' is possibly undefined
// 146184247: variable 'v47' is possibly undefined
// 1461842A7: variable 'v16' is possibly undefined
// 1461842A7: variable 'v17' is possibly undefined
// 1461842E5: variable 'v51' is possibly undefined
// 1461842E5: variable 'v52' is possibly undefined
// 1461843B7: variable 'v55' is possibly undefined
// 1461843B7: variable 'v56' is possibly undefined
// 146184488: variable 'v59' is possibly undefined
// 146184488: variable 'v60' is possibly undefined
// 14618457C: variable 'v65' is possibly undefined
// 14618457C: variable 'v66' is possibly undefined
// 146184651: variable 'v69' is possibly undefined
// 146184651: variable 'v70' is possibly undefined
// 146184726: variable 'v73' is possibly undefined
// 146184726: variable 'v74' is possibly undefined
// 1461847F3: variable 'v77' is possibly undefined
// 1461847F3: variable 'v78' is possibly undefined
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14612A930: using guessed type __int128 xmmword_14612A930;
// 14612CC44: using guessed type int dword_14612CC44;
// 14612CC4C: using guessed type int dword_14612CC4C;
// 14612E0F0: using guessed type __int128 xmmword_14612E0F0;
// 14612E100: using guessed type __int128 xmmword_14612E100;
// 14612E110: using guessed type __int128 xmmword_14612E110;
// 1461A8F1C: using guessed type __int64 __fastcall _std_exception_destroy(_QWORD);
// 146183CC0: using guessed type __m128i var_F8;
// 146183CC0: using guessed type char var_58[24];

//----- (00000001461849E0) ----------------------------------------------------
char *__fastcall sub_1461849E0(char *Src, __int64 a2, double a3)
{
  double v3; // xmm6_8
  char *result; // rax
  __int64 v6; // rcx
  unsigned __int64 v7; // r8
  __int64 v8; // rax
  int v9; // edx
  __int64 v10; // r8
  int v11; // r9d
  char v12; // cl
  __int64 v13; // r10
  __int64 v14; // r10
  bool v15; // sf
  __int64 v16; // r10
  __int128 v17; // [rsp+30h] [rbp-19h] BYREF
  __int128 v18; // [rsp+40h] [rbp-9h] BYREF
  __int128 v19; // [rsp+50h] [rbp+7h] BYREF
  __int128 v20; // [rsp+60h] [rbp+17h]
  __int128 v21; // [rsp+70h] [rbp+27h]
  __int128 v22; // [rsp+80h] [rbp+37h]
  int v23; // [rsp+C0h] [rbp+77h] BYREF
  int v24; // [rsp+C8h] [rbp+7Fh] BYREF

  v3 = a3;
  if ( dsign(a3) )
  {
    v3 = -a3;
    *Src++ = 45;
  }
  if ( v3 == 0.0 )
  {
    *(_WORD *)Src = 11824;
    result = Src + 3;
    Src[2] = 48;
  }
  else
  {
    v24 = 0;
    v23 = 0;
    v6 = *(_QWORD *)&v3 & 0xFFFFFFFFFFFFFi64;
    v7 = *(_QWORD *)&v3 >> 52;
    if ( *(_QWORD *)&v3 >> 52 )
    {
      v9 = v7 - 1075;
      v8 = v6 + 0x10000000000000i64;
    }
    else
    {
      v8 = *(_QWORD *)&v3 & 0xFFFFFFFFFFFFFi64;
      v9 = -1074;
    }
    if ( v6 || v7 <= 1 )
    {
      v13 = 2 * v8;
      v12 = v9 - 1;
      v10 = 2 * v8 + 1;
      v11 = v9 - 1;
    }
    else
    {
      v10 = 2 * v8 + 1;
      v11 = v9 - 1;
      v12 = v9 - 2;
      v13 = 4 * v8;
    }
    v14 = v13 - 1;
    do
    {
      --v11;
      v15 = (v10 & 0x4000000000000000i64) != 0;
      v10 *= 2i64;
    }
    while ( !v15 );
    v16 = v14 << (v12 - (unsigned __int8)v11);
    do
    {
      --v9;
      v15 = (v8 & 0x4000000000000000i64) != 0;
      v8 *= 2i64;
    }
    while ( !v15 );
    *(_QWORD *)&v20 = v8;
    *(_QWORD *)&v22 = v10;
    *((_QWORD *)&v22 + 1) = __PAIR64__(HIDWORD(v19), v11);
    *((_QWORD *)&v20 + 1) = __PAIR64__(HIDWORD(v19), v9);
    *((_QWORD *)&v21 + 1) = __PAIR64__(HIDWORD(v19), v11);
    v17 = v22;
    *(_QWORD *)&v21 = v16;
    v18 = v20;
    v19 = v21;
    sub_14618EA40((__int64)Src, &v24, &v23, (unsigned __int64 *)&v19, (__int64)&v18, (__int64)&v17);
    return sub_14618E470(Src, v24, v23, -4, 15);
  }
  return result;
}

//----- (0000000146184B70) ----------------------------------------------------
_OWORD *__fastcall sub_146184B70(__int64 a1, __int64 *a2, __int64 a3, __int128 *a4)
{
  __int64 *v5; // rbx
  _OWORD *result; // rax
  unsigned int v7; // r13d
  __int128 v8; // xmm0
  __m128i si128; // xmm8
  __int64 v10; // r8
  __int64 v11; // r9
  __m128i v12; // xmm6
  __int64 v13; // rax
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int128 v17; // xmm7
  __int64 v18; // rax
  __int64 v19; // r14
  _OWORD *v20; // r15
  __int64 v21; // r8
  __int64 v22; // r9
  unsigned __int64 v23; // xmm6_8
  void *v24; // rcx
  __int64 **v25; // rcx
  __int64 *i; // rax
  __int64 *j; // rcx
  __int128 v28; // [rsp+40h] [rbp-C8h] BYREF
  _OWORD *v29; // [rsp+50h] [rbp-B8h]
  __int64 v30; // [rsp+58h] [rbp-B0h]
  _QWORD v31[3]; // [rsp+60h] [rbp-A8h] BYREF
  __int64 v32; // [rsp+78h] [rbp-90h]
  __int64 v33; // [rsp+88h] [rbp-80h]
  __int128 v34; // [rsp+90h] [rbp-78h] BYREF
  __m128i v35; // [rsp+A0h] [rbp-68h]
  const void *v36[4]; // [rsp+B8h] [rbp-50h] BYREF
  __int128 v37; // [rsp+D8h] [rbp-30h]
  __m128i v38; // [rsp+E8h] [rbp-20h]

  v33 = -2i64;
  v5 = a2;
  result = (_OWORD *)a1;
  v29 = (_OWORD *)a1;
  v7 = 0;
  v8 = *a4;
  v28 = *a4;
  if ( a2 != (__int64 *)a3 )
  {
    si128 = _mm_load_si128((const __m128i *)&Size);
    do
    {
      v34 = 0i64;
      v35 = si128;
      LOBYTE(v34) = 0;
      sub_1461810F0((__int64)(v5 + 8), &v34, a3, (__int64)a4);
      sub_146170E60((__int64)v36, (__int64)(v5 + 4), v10, v11);
      v37 = v34;
      v12 = v35;
      v38 = v35;
      v7 = v7 & 0xFFFFFFF8 | 3;
      v13 = sub_146178070((__int64 *)v28, (__int64)&v34, *((__int64 *)&v28 + 1), v36);
      v17 = *(_OWORD *)v13;
      v32 = *(_QWORD *)(v13 + 16);
      if ( (_BYTE)v32 )
      {
        v18 = v17;
      }
      else
      {
        if ( *(_QWORD *)(v28 + 8) == 0x2AAAAAAAAAAAAAAi64 )
          unknown_libname_3(v15, v14, v16);
        v19 = *(_QWORD *)v28;
        v30 = v28;
        v31[0] = 0i64;
        v20 = operator new(0x60ui64);
        v31[0] = v20;
        sub_146170E60((__int64)(v20 + 2), (__int64)v36, v21, v22);
        v20[4] = v37;
        v20[5] = v38;
        v12 = si128;
        LOBYTE(v37) = 0;
        *(_QWORD *)v20 = v19;
        *((_QWORD *)v20 + 1) = v19;
        *((_QWORD *)v20 + 2) = v19;
        *((_WORD *)v20 + 12) = 0;
        v31[0] = 0i64;
        *(_OWORD *)&v31[1] = v17;
        v18 = sub_146165130((_QWORD *)v28, (__int64)&v31[1], (__int64)v20);
      }
      *((_QWORD *)&v28 + 1) = v18;
      sub_146179760((__int64 *)&v28 + 1);
      v23 = _mm_srli_si128(v12, 8).m128i_u64[0];
      if ( v23 > 0xF )
      {
        v24 = (void *)v37;
        if ( v23 + 1 >= 0x1000 )
        {
          v24 = *(void **)(v37 - 8);
          if ( (unsigned __int64)(v37 - (_QWORD)v24 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v24);
      }
      v38 = si128;
      LOBYTE(v37) = 0;
      sub_1461626B0((__int64)v36);
      v25 = (__int64 **)v5[2];
      if ( *((_BYTE *)v25 + 25) )
      {
        for ( i = (__int64 *)v5[1]; !*((_BYTE *)i + 25); i = (__int64 *)i[1] )
        {
          if ( v5 != (__int64 *)i[2] )
            break;
          v5 = i;
        }
        v5 = i;
      }
      else
      {
        v5 = (__int64 *)v5[2];
        for ( j = *v25; !*((_BYTE *)j + 25); j = (__int64 *)*j )
          v5 = j;
      }
    }
    while ( v5 != (__int64 *)a3 );
    v8 = v28;
    result = v29;
  }
  *result = v8;
  return result;
}
// 146184C12: variable 'a3' is possibly undefined
// 146184C12: variable 'a4' is possibly undefined
// 146184C2C: variable 'v10' is possibly undefined
// 146184C2C: variable 'v11' is possibly undefined
// 146184CB6: variable 'v21' is possibly undefined
// 146184CB6: variable 'v22' is possibly undefined
// 146184E25: variable 'v15' is possibly undefined
// 146184E25: variable 'v14' is possibly undefined
// 146184E25: variable 'v16' is possibly undefined
// 1461653B0: using guessed type void __fastcall __noreturn unknown_libname_3(_QWORD, _QWORD, _QWORD);

//----- (0000000146184E30) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_146184E30(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rdi
  __int64 v4; // rbx
  struct std::locale::_Locimp *v5; // rax
  __int64 v6; // rcx
  __int64 v7; // rbx
  __int64 v9; // [rsp+50h] [rbp+8h] BYREF
  char v10; // [rsp+58h] [rbp+10h] BYREF
  __int64 v11; // [rsp+60h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
  v11 = qword_14611AB88;
  if ( !std::codecvt<char,char,_Mbstatet>::id )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v9, 0);
    std::codecvt<char,char,_Mbstatet>::id = ++std::locale::id::_Id_cnt;
    std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  }
  v2 = *(_QWORD *)(a1 + 8);
  v3 = 8i64 * std::codecvt<char,char,_Mbstatet>::id;
  if ( std::codecvt<char,char,_Mbstatet>::id >= *(_QWORD *)(v2 + 24) )
  {
    v4 = 0i64;
  }
  else
  {
    v4 = *(_QWORD *)(v3 + *(_QWORD *)(v2 + 16));
    if ( v4 )
      goto LABEL_14;
  }
  if ( !*(_BYTE *)(v2 + 36) )
    goto LABEL_10;
  v5 = std::locale::_Getgloballocale();
  if ( std::codecvt<char,char,_Mbstatet>::id < *((_QWORD *)v5 + 3) )
  {
    v4 = *(_QWORD *)(v3 + *((_QWORD *)v5 + 2));
LABEL_10:
    if ( v4 )
      goto LABEL_14;
  }
  v4 = v11;
  if ( !v11 )
  {
    if ( std::codecvt<char,char,_Mbstatet>::_Getcat(&v11, a1) == -1 )
      sub_14618B750(v6);
    v7 = v11;
    v9 = v11;
    sub_1461A7888(v11);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 8i64))(v7);
    v4 = v11;
    qword_14611AB88 = v11;
  }
LABEL_14:
  std::_Lockit::~_Lockit((std::_Lockit *)&v10);
  return v4;
}
// 146184E8A: write access to const memory at 14611C398 has been detected
// 146184E96: write access to const memory at 14611C3A0 has been detected
// 146184F48: variable 'v6' is possibly undefined
// 14611AB88: using guessed type __int64 qword_14611AB88;
// 14611C398: using guessed type int std::locale::id::_Id_cnt;
// 14611C468: using guessed type _QWORD __fastcall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 14611C470: using guessed type void std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 14611C4A8: using guessed type __int64 __fastcall std::codecvt<char,char,_Mbstatet>::_Getcat(_QWORD, _QWORD);
// 14618B750: using guessed type void __fastcall __noreturn sub_14618B750(_QWORD);

//----- (0000000146184F50) ----------------------------------------------------
_QWORD *__fastcall sub_146184F50(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // rax

  *a1 = 0i64;
  a1[1] = 0i64;
  v2 = a2[1];
  if ( v2 )
    _InterlockedIncrement((volatile signed __int32 *)(v2 + 8));
  *a1 = *a2;
  a1[1] = a2[1];
  return a1;
}

//----- (0000000146184F80) ----------------------------------------------------
__int64 __fastcall sub_146184F80(__int64 a1, __int64 *a2)
{
  __int64 *v4; // rbx
  __int64 *v5; // rax
  __int64 v6; // rdx
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // rax
  void **v11; // rax
  __int64 lpName; // rax
  _BYTE *v13; // rcx
  void *v14; // rcx
  DWORD LastError; // ebx
  _WORD *v16; // rax
  _WORD *v17; // rdi
  __int128 v19[2]; // [rsp+38h] [rbp-69h] BYREF
  __int128 v20; // [rsp+58h] [rbp-49h] BYREF
  __int64 v21; // [rsp+68h] [rbp-39h]
  void *v22[3]; // [rsp+70h] [rbp-31h] BYREF
  unsigned __int64 v23; // [rsp+88h] [rbp-19h]
  void *Block; // [rsp+90h] [rbp-11h] BYREF
  __m128i si128; // [rsp+A0h] [rbp-1h]
  __int64 v26[6]; // [rsp+B0h] [rbp+Fh] BYREF

  v21 = -2i64;
  *(_QWORD *)(a1 + 8) = &unk_1461091A0;
  v4 = (__int64 *)sub_146187DB0();
  v5 = sub_146187CF0();
  v6 = (__int64)v5;
  if ( (unsigned __int64)v5[3] > 0xF )
    v6 = *v5;
  v7 = v5[2];
  v8 = (__int64)v4;
  if ( (unsigned __int64)v4[3] > 0xF )
    v8 = *v4;
  v9 = v4[2];
  v10 = (__int64)a2;
  if ( (unsigned __int64)a2[3] > 0xF )
    v10 = *a2;
  v26[0] = v6;
  v26[1] = v7;
  v26[2] = v8;
  v26[3] = v9;
  v26[4] = v10;
  v26[5] = a2[2];
  *(_QWORD *)&v19[0] = "CFX_%s_%s_SharedData_%s";
  *((_QWORD *)&v19[0] + 1) = 23i64;
  *(_QWORD *)&v20 = 3549i64;
  *((_QWORD *)&v20 + 1) = v26;
  sub_1461784D0(v22, v19, &v20);
  v11 = v22;
  if ( v23 > 0xF )
    v11 = (void **)v22[0];
  *(_QWORD *)&v19[0] = v11;
  *((void **)&v19[0] + 1) = v22[2];
  lpName = sub_1461A2C60((__int64)&Block, (__int64)v19);
  if ( *(_QWORD *)(lpName + 24) > 7ui64 )
    lpName = *(_QWORD *)lpName;
  *(_QWORD *)a1 = CreateFileMappingW((HANDLE)0xFFFFFFFFFFFFFFFFi64, 0i64, 4u, 0, 0x810u, (LPCWSTR)lpName);
  if ( si128.m128i_i64[1] > 7ui64 )
  {
    v13 = Block;
    if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
    {
      v13 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v13 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v13);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(Block) = 0;
  if ( v23 > 0xF )
  {
    v14 = v22[0];
    if ( v23 + 1 >= 0x1000 )
    {
      v14 = (void *)*((_QWORD *)v22[0] - 1);
      if ( (unsigned __int64)(v22[0] - v14 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v14);
  }
  if ( *(_QWORD *)a1 )
  {
    LastError = GetLastError();
    v16 = MapViewOfFile(*(HANDLE *)a1, 0xF001Fu, 0, 0, 0x810ui64);
    v17 = v16;
    *(_QWORD *)(a1 + 8) = v16;
    if ( LastError != 183 )
    {
      v16[1024] = 256;
      *((_QWORD *)v16 + 257) = 0xBFF0000000000000ui64;
      memset(v16, 0, 0x400ui64);
      memset(v17 + 512, 0, 0x400ui64);
      *(_QWORD *)(a1 + 8) = v17;
    }
  }
  return a1;
}
// 14611DA20: using guessed type __int128 xmmword_14611DA20;

//----- (0000000146185200) ----------------------------------------------------
__int64 __fastcall sub_146185200(__int64 a1, const wchar_t *a2, int a3, int a4, int a5)
{
  FILE *v9; // rsi
  __int64 v10; // rcx
  std::codecvt_base *v11; // rsi
  void (__fastcall ***v12)(_QWORD, __int64); // rax
  int *Count; // [rsp+48h] [rbp-40h] BYREF
  char **Pointer; // [rsp+50h] [rbp-38h] BYREF
  char **Base; // [rsp+58h] [rbp-30h] BYREF
  __int64 v17; // [rsp+60h] [rbp-28h]
  __int64 v18; // [rsp+68h] [rbp-20h]

  v18 = -2i64;
  if ( a5 )
  {
    *(_QWORD *)a1 = &unk_14612C260;
    std::ios::ios(a1 + 176);
  }
  std::istream::istream(a1, a1 + 16, 0i64, 0i64);
  *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1) = &std::ifstream::`vftable';
  *(_DWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 - 4) = *(_DWORD *)(*(_QWORD *)a1 + 4i64) - 176;
  std::streambuf::streambuf(a1 + 16);
  *(_QWORD *)(a1 + 16) = &std::filebuf::`vftable';
  *(_BYTE *)(a1 + 140) = 0;
  *(_BYTE *)(a1 + 129) = 0;
  std::streambuf::_Init(a1 + 16);
  *(_QWORD *)(a1 + 144) = 0i64;
  *(_QWORD *)(a1 + 132) = qword_14611AB90;
  *(_QWORD *)(a1 + 120) = 0i64;
  v9 = std::_Fiopen(a2, a3 | 1u, a4);
  if ( v9 )
  {
    *(_BYTE *)(a1 + 140) = 1;
    *(_BYTE *)(a1 + 129) = 0;
    std::streambuf::_Init(a1 + 16);
    Base = 0i64;
    Pointer = 0i64;
    Count = 0i64;
    get_stream_buffer_pointers(v9, &Base, &Pointer, &Count);
    std::streambuf::_Init(a1 + 16);
    *(_QWORD *)(a1 + 144) = v9;
    *(_QWORD *)(a1 + 132) = qword_14611AB90;
    *(_QWORD *)(a1 + 120) = 0i64;
    v10 = std::streambuf::getloc(a1 + 16, &Base);
    v11 = (std::codecvt_base *)sub_146184E30(v10);
    if ( std::codecvt_base::always_noconv(v11) )
    {
      *(_QWORD *)(a1 + 120) = 0i64;
    }
    else
    {
      *(_QWORD *)(a1 + 120) = v11;
      std::streambuf::_Init(a1 + 16);
    }
    if ( v17 )
    {
      v12 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v17 + 16i64))(v17);
      if ( v12 )
        (**v12)(v12, 1i64);
    }
  }
  else
  {
    std::ios::setstate(a1 + *(int *)(*(_QWORD *)a1 + 4i64), 2i64, 0i64);
  }
  return a1;
}
// 14611AB90: using guessed type __int64 qword_14611AB90;
// 14611C330: using guessed type __int64 __fastcall std::streambuf::_Init(_QWORD);
// 14611C338: using guessed type __int64 __fastcall std::streambuf::_Init(_QWORD);
// 14611C360: using guessed type __int64 __fastcall std::ios::setstate(_QWORD, _QWORD, _QWORD);
// 14611C370: using guessed type __int64 __fastcall std::ios::ios(_QWORD);
// 14611C378: using guessed type __int64 __fastcall std::istream::istream(_QWORD, _QWORD, _QWORD, _QWORD);
// 14611C488: using guessed type bool std::codecvt_base::always_noconv(std::codecvt_base *__hidden this);
// 14611C4B8: using guessed type __int64 __fastcall std::streambuf::streambuf(_QWORD);
// 14611C4C8: using guessed type __int64 __fastcall std::streambuf::getloc(_QWORD, _QWORD);
// 14612C1D8: using guessed type void *std::filebuf::`vftable';
// 14612C258: using guessed type void *std::ifstream::`vftable';

//----- (0000000146185420) ----------------------------------------------------
__int64 __fastcall sub_146185420(__int64 a1, __int64 a2)
{
  _QWORD *v3; // rbx
  __int64 *v4; // rdi
  _QWORD *v5; // rax
  _QWORD *v6; // r8
  __int64 **v7; // rdx
  __int64 *i; // rcx
  __int64 v9; // rcx
  __int64 j; // rax
  __int64 *v11; // r15
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  _QWORD *v15; // r14
  unsigned __int64 v16; // rdi
  size_t v17; // rdi
  _QWORD *v18; // rbx
  __int64 v19; // rbp
  __int64 k; // rdi
  __int64 v21; // rbx
  void *v22; // rdi
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // r15
  __int64 v26; // rdx
  __int64 v27; // rcx
  __int64 v28; // r8
  size_t v29; // rbx
  _QWORD *v30; // rdi
  size_t v31; // rbx
  __int64 v33; // [rsp+80h] [rbp+8h]

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_QWORD *)(a1 + 8) = 0i64;
  switch ( *(_BYTE *)a1 )
  {
    case 1:
      v3 = *(_QWORD **)(a2 + 8);
      v4 = (__int64 *)operator new(0x10ui64);
      *v4 = 0i64;
      v4[1] = 0i64;
      v5 = operator new(0x50ui64);
      *v5 = v5;
      v5[1] = v5;
      v5[2] = v5;
      *((_WORD *)v5 + 12) = 257;
      *v4 = (__int64)v5;
      *(_QWORD *)(*v4 + 8) = sub_14617DC00(v4, *(_QWORD *)(*v3 + 8i64), (__int64)v5);
      v4[1] = v3[1];
      v6 = (_QWORD *)*v4;
      v7 = *(__int64 ***)(*v4 + 8);
      if ( *((_BYTE *)v7 + 25) )
      {
        *v6 = v6;
        *(_QWORD *)(*v4 + 16) = *v4;
      }
      else
      {
        for ( i = *v7; !*((_BYTE *)i + 25); i = (__int64 *)*i )
          v7 = (__int64 **)i;
        *v6 = v7;
        v9 = *(_QWORD *)(*v4 + 8);
        for ( j = *(_QWORD *)(v9 + 16); !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 16) )
          v9 = j;
        *(_QWORD *)(*v4 + 16) = v9;
      }
      *(_QWORD *)(a1 + 8) = v4;
      break;
    case 2:
      v11 = *(__int64 **)(a2 + 8);
      v15 = operator new(0x18ui64);
      *v15 = 0i64;
      v15[1] = 0i64;
      v15[2] = 0i64;
      v16 = (v11[1] - *v11) >> 4;
      if ( v16 )
      {
        if ( v16 > 0xFFFFFFFFFFFFFFFi64 )
          unknown_libname_6(v13, v12, v14);
        v17 = 2 * v16;
        v18 = sub_14615A5E0(v17 * 8);
        *v15 = v18;
        v15[1] = v18;
        v15[2] = &v18[v17];
        v19 = v11[1];
        for ( k = *v11; k != v19; k += 16i64 )
        {
          sub_146185420(v18, k);
          v18 += 2;
        }
        v15[1] = v18;
      }
      goto LABEL_24;
    case 3:
      v21 = *(_QWORD *)(a2 + 8);
      v22 = operator new(0x20ui64);
      sub_146170E60((__int64)v22, v21, v23, v24);
      *(_QWORD *)(a1 + 8) = v22;
      break;
    case 4:
      LOBYTE(v33) = *(_BYTE *)(a2 + 8);
      *(_QWORD *)(a1 + 8) = v33;
      break;
    case 5:
    case 6:
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      break;
    case 7:
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      break;
    case 8:
      v25 = *(_QWORD *)(a2 + 8);
      v15 = operator new(0x28ui64);
      *v15 = 0i64;
      v15[1] = 0i64;
      v15[2] = 0i64;
      v29 = *(_QWORD *)(v25 + 8) - *(_QWORD *)v25;
      if ( v29 )
      {
        if ( v29 > 0x7FFFFFFFFFFFFFFFi64 )
          unknown_libname_6(v27, v26, v28);
        v30 = sub_14615A5E0(v29);
        *v15 = v30;
        v15[1] = v30;
        v15[2] = (char *)v30 + v29;
        v31 = *(_QWORD *)(v25 + 8) - *(_QWORD *)v25;
        memmove(v30, *(const void **)v25, v31);
        v15[1] = (char *)v30 + v31;
      }
      v15[3] = *(_QWORD *)(v25 + 24);
      *((_BYTE *)v15 + 32) = *(_BYTE *)(v25 + 32);
LABEL_24:
      *(_QWORD *)(a1 + 8) = v15;
      break;
    default:
      return a1;
  }
  return a1;
}
// 14618562F: variable 'v23' is possibly undefined
// 14618562F: variable 'v24' is possibly undefined
// 146185731: variable 'v27' is possibly undefined
// 146185731: variable 'v26' is possibly undefined
// 146185731: variable 'v28' is possibly undefined
// 146185737: variable 'v13' is possibly undefined
// 146185737: variable 'v12' is possibly undefined
// 146185737: variable 'v14' is possibly undefined
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (0000000146185760) ----------------------------------------------------
char *__fastcall sub_146185760(__int64 a1, __int64 *a2, char a3, char a4)
{
  char *v5; // r12
  __int64 v6; // r15
  __int64 v7; // rbx
  __int64 v8; // rdi
  __int64 v9; // rsi
  _BYTE *v10; // rax
  __int64 v11; // rcx
  __int64 v12; // r14
  char v13; // al
  char v14; // cl
  __int64 v15; // rdx
  unsigned __int8 v16; // si
  unsigned __int8 **v17; // rax
  __int64 *v18; // r14
  unsigned __int8 *v19; // r13
  __int64 v20; // r12
  __int64 v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // rdi
  _OWORD *v26; // rax
  char *v27; // rsi
  __int64 v28; // r8
  unsigned __int64 v29; // r14
  size_t v30; // r14
  __int64 *v31; // rdi
  __int64 v32; // rdx
  void **v34; // rax
  char v35; // [rsp+20h] [rbp-A9h] BYREF
  char *v36; // [rsp+28h] [rbp-A1h] BYREF
  __int64 v37; // [rsp+30h] [rbp-99h] BYREF
  unsigned __int8 **v38; // [rsp+38h] [rbp-91h] BYREF
  __int128 v39; // [rsp+40h] [rbp-89h] BYREF
  __int64 *v40; // [rsp+50h] [rbp-79h]
  __int64 *v41; // [rsp+58h] [rbp-71h]
  char *i; // [rsp+60h] [rbp-69h]
  __int64 v43; // [rsp+68h] [rbp-61h]
  __int64 v44; // [rsp+80h] [rbp-49h]
  char pExceptionObject[56]; // [rsp+88h] [rbp-41h] BYREF
  void *Src[4]; // [rsp+C0h] [rbp-9h] BYREF

  v43 = -2i64;
  v35 = a3;
  v5 = (char *)a1;
  v36 = (char *)a1;
  *(_BYTE *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0i64;
  v6 = a2[1];
  v7 = *a2;
  v8 = *a2;
  if ( *a2 == v6 )
  {
LABEL_14:
    v13 = 1;
  }
  else
  {
    while ( 1 )
    {
      v9 = *(_QWORD *)(v8 + 16);
      v10 = (_BYTE *)v8;
      if ( v9 )
        v10 = *(_BYTE **)(v8 + 16);
      if ( *v10 != 2 )
        break;
      v11 = v8;
      if ( v9 )
        v11 = *(_QWORD *)(v8 + 16);
      if ( sub_1461922B0(v11) != 2 )
        break;
      v12 = v8;
      if ( v9 )
        v12 = v9;
      if ( *(_BYTE *)v12 != 2 )
      {
        v36 = (char *)sub_146192A40((_BYTE *)v12);
        v34 = sub_14617F740(Src, "cannot use operator[] with a numeric argument with ", (const char **)&v36);
        sub_1461804D0((__int64)pExceptionObject, 0x131u, v34, v12);
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVtype_error_detail_json_abi_v3_11_2_nlohmann__);
      }
      if ( ***(_BYTE ***)(v12 + 8) != 3 )
        break;
      v8 += 24i64;
      if ( v8 == v6 )
      {
        a3 = v35;
        goto LABEL_14;
      }
    }
    v13 = 0;
    a3 = v35;
  }
  if ( !a3 )
  {
    v14 = 0;
    if ( a4 != 2 )
      v14 = v13;
    v13 = v14;
    if ( a4 == 1 && !v14 )
    {
      sub_146178620(Src, "cannot create object from initializer list");
      sub_1461804D0((__int64)pExceptionObject, 0x12Du, Src, 0i64);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVtype_error_detail_json_abi_v3_11_2_nlohmann__);
    }
  }
  if ( v13 )
  {
    *v5 = 1;
    sub_1461862B0(&v37, 1);
    for ( *((_QWORD *)v5 + 1) = v37; v7 != v6; v5 = v36 )
    {
      v15 = *(_QWORD *)(v7 + 16);
      if ( v15 )
      {
        sub_146185420((__int64)&v37, v15);
        v17 = v38;
        v16 = v37;
      }
      else
      {
        v16 = *(_BYTE *)v7;
        LOBYTE(v37) = *(_BYTE *)v7;
        v17 = *(unsigned __int8 ***)(v7 + 8);
        v38 = v17;
        *(_BYTE *)v7 = 0;
        *(_QWORD *)(v7 + 8) = 0i64;
      }
      v18 = (__int64 *)*((_QWORD *)v5 + 1);
      v19 = *v17;
      v20 = *((_QWORD *)*v17 + 1);
      v21 = sub_146178280(v18, (__int64)Src, (const void **)v20);
      v39 = *(_OWORD *)v21;
      v44 = *(_QWORD *)(v21 + 16);
      v24 = v44;
      if ( *(_BYTE *)(v44 + 25)
        || (unsigned __int8)sub_1461797D0((__int64)v18, (size_t *)v20, (const void **)(v44 + 32)) )
      {
        if ( v18[1] == 0x333333333333333i64 )
          unknown_libname_3(v23, v22, v24);
        v25 = *v18;
        v40 = v18;
        v41 = 0i64;
        v26 = operator new(0x50ui64);
        v26[2] = 0i64;
        *((_QWORD *)v26 + 6) = 0i64;
        *((_QWORD *)v26 + 7) = 0i64;
        v26[2] = *(_OWORD *)v20;
        v26[3] = *(_OWORD *)(v20 + 16);
        *(_QWORD *)(v20 + 16) = 0i64;
        *(_QWORD *)(v20 + 24) = 15i64;
        *(_BYTE *)v20 = 0;
        *((_BYTE *)v26 + 64) = v19[16];
        *((_QWORD *)v26 + 9) = *((_QWORD *)v19 + 3);
        v19[16] = 0;
        *((_QWORD *)v19 + 3) = 0i64;
        *(_QWORD *)v26 = v25;
        *((_QWORD *)v26 + 1) = v25;
        *((_QWORD *)v26 + 2) = v25;
        *((_WORD *)v26 + 12) = 0;
        v41 = 0i64;
        sub_146165130(v18, (__int64)&v39, (__int64)v26);
      }
      sub_14618BD60(&v38, v16);
      v7 += 24i64;
    }
  }
  else
  {
    *v5 = 2;
    v27 = (char *)operator new(0x18ui64);
    *(_QWORD *)&v39 = &v35;
    *((_QWORD *)&v39 + 1) = v27;
    *(_QWORD *)v27 = 0i64;
    *((_QWORD *)v27 + 1) = 0i64;
    *((_QWORD *)v27 + 2) = 0i64;
    v29 = (v6 - v7) / 24;
    if ( v29 )
    {
      if ( v29 > 0xFFFFFFFFFFFFFFFi64 )
        unknown_libname_6(v6 - v7, (unsigned __int128)((v6 - v7) * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64, v28);
      v30 = 2 * v29;
      v31 = sub_14615A5E0(v30 * 8);
      *(_QWORD *)v27 = v31;
      *((_QWORD *)v27 + 1) = v31;
      *((_QWORD *)v27 + 2) = &v31[v30];
      v36 = v27;
      v40 = v31;
      v41 = v31;
      for ( i = v27; v7 != v6; v7 += 24i64 )
      {
        v32 = *(_QWORD *)(v7 + 16);
        if ( v32 )
        {
          sub_146185420((__int64)v31, v32);
        }
        else
        {
          *(_BYTE *)v31 = *(_BYTE *)v7;
          v31[1] = *(_QWORD *)(v7 + 8);
          *(_BYTE *)v7 = 0;
          *(_QWORD *)(v7 + 8) = 0i64;
        }
        v31 += 2;
        v41 = v31;
      }
      *((_QWORD *)v27 + 1) = v31;
    }
    *((_QWORD *)v5 + 1) = v27;
  }
  return v5;
}
// 146185AFA: variable 'v28' is possibly undefined
// 146185B7F: variable 'v23' is possibly undefined
// 146185B7F: variable 'v22' is possibly undefined
// 146185B7F: variable 'v24' is possibly undefined
// 1461653B0: using guessed type void __fastcall __noreturn unknown_libname_3(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (0000000146185B90) ----------------------------------------------------
__int64 __fastcall sub_146185B90(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_OWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0i64;
  *(_WORD *)a2 = 0;
  result = a1;
  *(_QWORD *)(a2 + 24) = 7i64;
  return result;
}

//----- (0000000146185BD0) ----------------------------------------------------
char *__fastcall sub_146185BD0(char *a1, __int64 a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *v4; // rbx
  _QWORD *v6; // rsi
  unsigned __int64 v7; // r15
  unsigned __int64 v8; // r14
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // r13
  char *v12; // rax
  unsigned __int64 v13; // rcx
  size_t v14; // r15
  void *v15; // rsi
  __int64 v16; // rbp
  __int64 v17; // rcx
  _QWORD *v18; // rax
  _QWORD *v19; // r12
  size_t v20; // r15

  v4 = a3;
  *(_OWORD *)a1 = 0i64;
  *((_QWORD *)a1 + 2) = 0i64;
  v6 = a4;
  *((_QWORD *)a1 + 3) = 0i64;
  v7 = a3[2];
  v8 = a4[2];
  v9 = a3[3];
  v10 = a4[3];
  v11 = v8 + v7;
  if ( v8 > v9 - v7 || v10 > v9 )
  {
    v13 = v10 - v8;
    if ( v7 > v13 )
    {
      v16 = 0x7FFFFFFFFFFFFFFEi64;
      if ( 0x7FFFFFFFFFFFFFFEi64 - v7 < v8 )
        unknown_libname_4(v13, v9, 0i64, a4);
      if ( (v11 | 7) <= 0x7FFFFFFFFFFFFFFEi64 )
      {
        v16 = v11 | 7;
        if ( (v11 | 7) < 0xA )
          v16 = 10i64;
        v17 = v16 + 1;
        if ( (unsigned __int64)(v16 + 1) > 0x7FFFFFFFFFFFFFFFi64 )
          sub_146165390(v17, v9, 0i64);
      }
      else
      {
        v17 = 0x7FFFFFFFFFFFFFFFi64;
      }
      v18 = sub_14615A5E0(2 * v17);
      *(_QWORD *)a1 = v18;
      v19 = v18;
      *((_QWORD *)a1 + 2) = v11;
      *((_QWORD *)a1 + 3) = v16;
      if ( v4[3] > 7ui64 )
        v4 = (_QWORD *)*v4;
      v20 = 2 * v7;
      memcpy(v18, v4, v20);
      if ( v6[3] > 7ui64 )
        v6 = (_QWORD *)*v6;
      memcpy((char *)v19 + v20, v6, 2 * v8 + 2);
    }
    else
    {
      v14 = 2 * v7;
      *(_OWORD *)a1 = *(_OWORD *)a4;
      *((_OWORD *)a1 + 1) = *((_OWORD *)a4 + 1);
      a4[2] = 0i64;
      *(_WORD *)a4 = 0;
      a4[3] = 7i64;
      v15 = *(void **)a1;
      memmove((void *)(v14 + *(_QWORD *)a1), *(const void **)a1, 2 * v8 + 2);
      if ( v4[3] > 7ui64 )
        v4 = (_QWORD *)*v4;
      memcpy(v15, v4, v14);
      *((_QWORD *)a1 + 2) = v11;
    }
  }
  else
  {
    v12 = a1;
    *(_OWORD *)a1 = *(_OWORD *)a3;
    *((_OWORD *)a1 + 1) = *((_OWORD *)a3 + 1);
    a3[2] = 0i64;
    a3[3] = 7i64;
    *(_WORD *)a3 = 0;
    if ( *((_QWORD *)a1 + 3) > 7ui64 )
      v12 = *(char **)a1;
    if ( a4[3] > 7ui64 )
      v6 = (_QWORD *)*a4;
    memcpy(&v12[2 * v7], v6, 2 * v8 + 2);
    *((_QWORD *)a1 + 2) = v11;
  }
  return a1;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146185DB0) ----------------------------------------------------
__int64 __fastcall sub_146185DB0(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v7; // rsi
  __int64 (__fastcall ***v8)(_QWORD, __int64); // rcx
  __int64 v9; // rdx
  __int64 v10; // rcx
  char v12[8]; // [rsp+20h] [rbp-58h] BYREF
  __int64 v13; // [rsp+28h] [rbp-50h]
  __int64 v14; // [rsp+30h] [rbp-48h]
  __int64 v15; // [rsp+38h] [rbp-40h]
  __int64 v16; // [rsp+40h] [rbp-38h]

  v13 = -2i64;
  v14 = a1;
  v16 = a3;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_QWORD *)(a1 + 80) = 0i64;
  *(_QWORD *)(a1 + 88) = 0i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  *(_BYTE *)(a1 + 104) = 0;
  v7 = a1 + 112;
  v15 = a1 + 112;
  *(_QWORD *)(a1 + 168) = 0i64;
  v8 = *(__int64 (__fastcall ****)(_QWORD, __int64))(a3 + 56);
  if ( v8 )
    *(_QWORD *)(v7 + 56) = (**v8)(v8, v7);
  *(_BYTE *)(a1 + 176) = a4;
  *(_BYTE *)(a1 + 184) = 9;
  sub_1461862B0((_QWORD *)(a1 + 192), 9);
  v12[0] = 1;
  sub_1461907F0((__int64 *)(a1 + 32), v12);
  v10 = *(_QWORD *)(a3 + 56);
  if ( v10 )
  {
    LOBYTE(v9) = v10 != a3;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v10 + 32i64))(v10, v9);
    *(_QWORD *)(a3 + 56) = 0i64;
  }
  return a1;
}
// 146185E89: variable 'v9' is possibly undefined
// 146185DB0: using guessed type char var_58[8];

//----- (0000000146185EC0) ----------------------------------------------------
_QWORD *__fastcall sub_146185EC0(_QWORD *a1, unsigned __int64 a2, __int64 a3)
{
  size_t v4; // rdi
  _QWORD *v5; // rax
  _QWORD *v6; // rbx

  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x7FFFFFFFFFFFFFFFi64 )
      unknown_libname_6(a1, a2, a3);
    v4 = 2 * a2;
    v5 = sub_14615A5E0(2 * a2);
    *a1 = v5;
    v6 = v5;
    a1[2] = (char *)v5 + v4;
    memset(v5, 0, v4);
    a1[1] = (char *)v6 + v4;
  }
  return a1;
}
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (0000000146185F40) ----------------------------------------------------
void **__fastcall sub_146185F40(void **a1, __int64 a2)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rax
  __int64 ***v6; // r8
  __int64 **v7; // r8
  _QWORD *v8; // rbx
  _QWORD *v9; // rcx
  _QWORD *v10; // rsi
  void *v11; // rdi
  void **v13; // rax
  void *Block[2]; // [rsp+30h] [rbp-A8h] BYREF
  __int128 v15; // [rsp+40h] [rbp-98h] BYREF
  __int64 v16; // [rsp+50h] [rbp-88h]
  void **v17; // [rsp+58h] [rbp-80h]
  char pExceptionObject[56]; // [rsp+60h] [rbp-78h] BYREF
  void *Src[4]; // [rsp+98h] [rbp-40h] BYREF

  v16 = -2i64;
  v17 = a1;
  *a1 = 0i64;
  a1[1] = 0i64;
  v4 = operator new(0x60ui64);
  *v4 = v4;
  v4[1] = v4;
  v4[2] = v4;
  *((_WORD *)v4 + 12) = 257;
  *a1 = v4;
  sub_146185420((__int64)(a1 + 2), a2);
  if ( *(_BYTE *)a2 != 1 )
  {
    *(_QWORD *)&v15 = sub_146192A40((_BYTE *)a2);
    v13 = sub_14617F740(Src, "type must be object, but is ", (const char **)&v15);
    sub_1461804D0((__int64)pExceptionObject, 0x12Eu, v13, a2);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVtype_error_detail_json_abi_v3_11_2_nlohmann__);
  }
  *(_OWORD *)Block = 0i64;
  v5 = operator new(0x60ui64);
  *v5 = v5;
  v5[1] = v5;
  v5[2] = v5;
  *((_WORD *)v5 + 12) = 257;
  Block[0] = v5;
  if ( *(_BYTE *)a2 == 1 )
    v6 = *(__int64 ****)(a2 + 8);
  else
    v6 = 0i64;
  v7 = *v6;
  *(_QWORD *)&v15 = Block;
  *((_QWORD *)&v15 + 1) = v5;
  sub_146184B70((__int64)Src, *v7, (__int64)v7, &v15);
  if ( a1 == Block )
  {
    v9 = Block[0];
  }
  else
  {
    v8 = *a1;
    sub_146177D60((__int64)a1, (__int64)a1, *((_QWORD *)*a1 + 1));
    v8[1] = v8;
    *v8 = v8;
    v8[2] = v8;
    v9 = *a1;
    *a1 = Block[0];
    Block[0] = v9;
    a1[1] = Block[1];
    Block[1] = 0i64;
  }
  v10 = (_QWORD *)v9[1];
  if ( !*((_BYTE *)v10 + 25) )
  {
    do
    {
      sub_146177D60((__int64)Block, (__int64)Block, v10[2]);
      v11 = v10;
      v10 = (_QWORD *)*v10;
      sub_1461626B0((__int64)v11 + 64);
      sub_1461626B0((__int64)v11 + 32);
      j_j_free(v11);
    }
    while ( !*((_BYTE *)v10 + 25) );
    v9 = Block[0];
  }
  j_j_free(v9);
  return a1;
}

//----- (0000000146186140) ----------------------------------------------------
__int64 __fastcall sub_146186140(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0i64;
  _std_exception_copy(a2 + 8);
  *(_QWORD *)a1 = &std::bad_cast::`vftable';
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14612BB20: using guessed type void *std::bad_cast::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146186180) ----------------------------------------------------
_QWORD *__fastcall sub_146186180(_QWORD *a1)
{
  a1[2] = 0i64;
  a1[1] = "bad cast";
  *a1 = &std::bad_cast::`vftable';
  return a1;
}
// 14612BB20: using guessed type void *std::bad_cast::`vftable';

//----- (00000001461861B0) ----------------------------------------------------
__int64 __fastcall sub_1461861B0(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0i64;
  _std_exception_copy(a2 + 8);
  *(_QWORD *)a1 = &nlohmann::json_abi_v3_11_2::detail::exception::`vftable';
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = &std::exception::`vftable';
  *(_OWORD *)(a1 + 40) = 0i64;
  _std_exception_copy(a2 + 40);
  *(_QWORD *)(a1 + 32) = &std::runtime_error::`vftable';
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CE48: using guessed type void *std::runtime_error::`vftable';
// 14612BC10: using guessed type void *nlohmann::json_abi_v3_11_2::detail::exception::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146186230) ----------------------------------------------------
_QWORD *__fastcall sub_146186230(_QWORD *a1, const wchar_t *a2)
{
  unsigned __int64 v4; // rax
  __int64 v5; // r9

  *(_OWORD *)a1 = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  v4 = wcslen(a2);
  sub_146168F30(a1, a2, v4, v5);
  return a1;
}
// 146186261: variable 'v5' is possibly undefined

//----- (0000000146186280) ----------------------------------------------------
_QWORD *__fastcall sub_146186280(_QWORD *a1, __int64 a2)
{
  sub_1461861B0((__int64)a1, a2);
  *a1 = &nlohmann::json_abi_v3_11_2::detail::invalid_iterator::`vftable';
  return a1;
}
// 14612BC80: using guessed type void *nlohmann::json_abi_v3_11_2::detail::invalid_iterator::`vftable';

//----- (00000001461862B0) ----------------------------------------------------
_QWORD *__fastcall sub_1461862B0(_QWORD *a1, char a2)
{
  _QWORD *v3; // rbx
  _QWORD *v4; // rax
  _QWORD *v5; // rax
  _QWORD *result; // rax
  char v7; // [rsp+20h] [rbp-88h] BYREF
  __int64 v8; // [rsp+28h] [rbp-80h]
  char pExceptionObject[56]; // [rsp+30h] [rbp-78h] BYREF
  __int64 v10[6]; // [rsp+68h] [rbp-40h] BYREF

  v8 = -2i64;
  switch ( a2 )
  {
    case 0:
    case 5:
    case 6:
    case 7:
      *a1 = 0i64;
      return a1;
    case 1:
      v3 = operator new(0x10ui64);
      v10[0] = (__int64)&v7;
      v10[1] = (__int64)v3;
      *v3 = 0i64;
      v3[1] = 0i64;
      v4 = operator new(0x50ui64);
      *v4 = v4;
      v4[1] = v4;
      v4[2] = v4;
      *((_WORD *)v4 + 12) = 257;
      *v3 = v4;
      *a1 = v3;
      return a1;
    case 2:
      v5 = operator new(0x18ui64);
      *v5 = 0i64;
      v5[1] = 0i64;
      v5[2] = 0i64;
      goto LABEL_4;
    case 3:
      v5 = operator new(0x20ui64);
      *(_OWORD *)v5 = 0i64;
      v5[2] = 0i64;
      v5[3] = 15i64;
      *(_BYTE *)v5 = 0;
      goto LABEL_4;
    case 4:
      *(_BYTE *)a1 = 0;
      return a1;
    case 8:
      v5 = operator new(0x28ui64);
      *v5 = 0i64;
      v5[1] = 0i64;
      v5[2] = 0i64;
      v5[3] = 0i64;
      *((_BYTE *)v5 + 32) = 0;
LABEL_4:
      *a1 = v5;
      break;
    default:
      *a1 = 0i64;
      if ( !a2 )
      {
        sub_146178620(v10, "961c151d2e87f2686a955a9be24d316f1362bf21 3.11.2");
        sub_14617FCF0((__int64)pExceptionObject, 0x1F4u, v10, 0i64);
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVother_error_detail_json_abi_v3_11_2_nlohmann__);
      }
      return result;
  }
  return a1;
}

//----- (0000000146186440) ----------------------------------------------------
_QWORD *__fastcall sub_146186440(_QWORD *a1, __int64 a2)
{
  sub_1461861B0((__int64)a1, a2);
  *a1 = &nlohmann::json_abi_v3_11_2::detail::other_error::`vftable';
  return a1;
}
// 14612BCC8: using guessed type void *nlohmann::json_abi_v3_11_2::detail::other_error::`vftable';

//----- (0000000146186470) ----------------------------------------------------
_QWORD *__fastcall sub_146186470(_QWORD *a1, __int64 a2)
{
  sub_1461861B0((__int64)a1, a2);
  *a1 = &nlohmann::json_abi_v3_11_2::detail::out_of_range::`vftable';
  return a1;
}
// 14612BCB0: using guessed type void *nlohmann::json_abi_v3_11_2::detail::out_of_range::`vftable';

//----- (00000001461864A0) ----------------------------------------------------
__int64 __fastcall sub_1461864A0(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax
  __int64 v7; // [rsp+20h] [rbp-18h] BYREF
  char v8; // [rsp+28h] [rbp-10h]

  v7 = a4;
  *(_OWORD *)(a1 + 8) = 0i64;
  *(_DWORD *)(a1 + 24) = a2;
  *(_QWORD *)a1 = &nlohmann::json_abi_v3_11_2::detail::exception::`vftable';
  v8 = 1;
  *(_QWORD *)(a1 + 32) = &std::exception::`vftable';
  *(_OWORD *)(a1 + 40) = 0i64;
  _std_exception_copy(&v7);
  *(_QWORD *)(a1 + 32) = &std::runtime_error::`vftable';
  *(_QWORD *)a1 = &nlohmann::json_abi_v3_11_2::detail::parse_error::`vftable';
  result = a1;
  *(_QWORD *)(a1 + 56) = a3;
  return result;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CE48: using guessed type void *std::runtime_error::`vftable';
// 14612BC10: using guessed type void *nlohmann::json_abi_v3_11_2::detail::exception::`vftable';
// 14612BC48: using guessed type void *nlohmann::json_abi_v3_11_2::detail::parse_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146186520) ----------------------------------------------------
_QWORD *__fastcall sub_146186520(_QWORD *a1, __int64 a2)
{
  sub_1461861B0((__int64)a1, a2);
  *a1 = &nlohmann::json_abi_v3_11_2::detail::parse_error::`vftable';
  a1[7] = *(_QWORD *)(a2 + 56);
  return a1;
}
// 14612BC48: using guessed type void *nlohmann::json_abi_v3_11_2::detail::parse_error::`vftable';

//----- (0000000146186560) ----------------------------------------------------
_QWORD *__fastcall sub_146186560(_QWORD *a1, __int64 a2)
{
  sub_1461861B0((__int64)a1, a2);
  *a1 = &nlohmann::json_abi_v3_11_2::detail::type_error::`vftable';
  return a1;
}
// 14612BC98: using guessed type void *nlohmann::json_abi_v3_11_2::detail::type_error::`vftable';

//----- (0000000146186590) ----------------------------------------------------
__int64 __fastcall sub_146186590(__int64 a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax

  v1 = *(volatile signed __int32 **)(a1 + 8);
  if ( v1 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      if ( _InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF) == 1 )
        return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8i64))(v1);
    }
  }
  return result;
}

//----- (00000001461865E0) ----------------------------------------------------
int __fastcall sub_1461865E0(__int64 a1)
{
  const void *v2; // rcx
  void *v3; // rax

  v2 = *(const void **)(a1 + 8);
  if ( v2 )
  {
    v3 = &unk_146106050;
    if ( v2 != &unk_146106050 )
    {
      LODWORD(v3) = UnmapViewOfFile(v2);
      *(_QWORD *)(a1 + 8) = 0i64;
    }
  }
  if ( *(_QWORD *)a1 )
  {
    LODWORD(v3) = CloseHandle(*(HANDLE *)a1);
    *(_QWORD *)a1 = 0i64;
  }
  return (int)v3;
}
// 146186621: variable 'v3' is possibly undefined

//----- (00000001461866A0) ----------------------------------------------------
void __fastcall sub_1461866A0(__int64 *a1)
{
  void **v1; // rbx

  v1 = (void **)a1[1];
  if ( v1 )
  {
    sub_14617F3A0(a1[1], *a1, *((unsigned __int8 ***)*v1 + 1));
    j_j_free(*v1);
  }
}

//----- (00000001461866E0) ----------------------------------------------------
void __fastcall sub_1461866E0(unsigned __int8 ****a1)
{
  unsigned __int8 *v1; // rdi
  unsigned __int8 ***i; // rbx

  v1 = (unsigned __int8 *)a1[1];
  for ( i = *a1; i != (unsigned __int8 ***)v1; i += 2 )
    sub_14618BD60(i + 1, *(unsigned __int8 *)i);
}

//----- (0000000146186730) ----------------------------------------------------
__int64 __fastcall sub_146186730(__int64 a1)
{
  *(_QWORD *)a1 = &std::filebuf::`vftable';
  if ( *(_QWORD *)(a1 + 128) && std::streambuf::eback(a1) == a1 + 112 )
    std::streambuf::setg(a1, *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144));
  if ( *(_BYTE *)(a1 + 124) )
  {
    if ( *(_QWORD *)(a1 + 128) )
    {
      if ( std::streambuf::eback(a1) == a1 + 112 )
        std::streambuf::setg(a1, *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144));
      sub_14618AF10(a1);
      fclose(*(FILE **)(a1 + 128));
    }
    *(_BYTE *)(a1 + 124) = 0;
    *(_BYTE *)(a1 + 113) = 0;
    std::streambuf::_Init(a1);
    *(_QWORD *)(a1 + 128) = 0i64;
    *(_QWORD *)(a1 + 116) = qword_14611AB90;
    *(_QWORD *)(a1 + 104) = 0i64;
  }
  return std::streambuf::~streambuf<char,std::char_traits<char>>(a1);
}
// 14611AB90: using guessed type __int64 qword_14611AB90;
// 14611C330: using guessed type __int64 __fastcall std::streambuf::_Init(_QWORD);
// 14611C4C0: using guessed type __int64 __fastcall std::streambuf::~streambuf<char,std::char_traits<char>>(_QWORD);
// 14611C4D8: using guessed type __int64 __fastcall std::streambuf::eback(_QWORD);
// 14611C500: using guessed type __int64 __fastcall std::streambuf::setg(_QWORD, _QWORD, _QWORD, _QWORD);
// 14612C1D8: using guessed type void *std::filebuf::`vftable';

//----- (0000000146186810) ----------------------------------------------------
__int64 __fastcall sub_146186810(unsigned __int8 *a1)
{
  return sub_14618BD60(a1 + 8, *a1);
}
// 14618BD60: using guessed type __int64 __fastcall sub_14618BD60(_QWORD, _QWORD);

//----- (0000000146186830) ----------------------------------------------------
void __fastcall sub_146186830(__int64 a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx

  sub_14618BD60((unsigned __int8 ***)(a1 + 192), *(unsigned __int8 *)(a1 + 184));
  v3 = *(_QWORD *)(a1 + 168);
  if ( v3 )
  {
    LOBYTE(v2) = v3 != a1 + 112;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 32i64))(v3, v2);
    *(_QWORD *)(a1 + 168) = 0i64;
  }
  sub_146186B70(a1 + 64);
  sub_146186B70(a1 + 32);
  sub_146166C80(a1 + 8);
}
// 146186871: variable 'v2' is possibly undefined

//----- (00000001461868C0) ----------------------------------------------------
void __fastcall sub_1461868C0(__int64 a1)
{
  std::ios_base *v2; // rbx
  char v3; // al

  sub_1461626B0(a1 + 80);
  sub_146176C60(a1 + 56);
  if ( *(_QWORD *)a1 )
  {
    v2 = (std::ios_base *)(*(_QWORD *)a1 + *(int *)(**(_QWORD **)a1 + 4i64));
    v3 = std::ios_base::rdstate(v2);
    std::ios::clear(v2, v3 & 1, 0i64);
  }
}
// 14611C358: using guessed type __int64 __fastcall std::ios::clear(_QWORD, _QWORD, _QWORD);
// 14611C4B0: using guessed type _DWORD std::ios_base::rdstate(std::ios_base *__hidden this);

//----- (0000000146186920) ----------------------------------------------------
__int64 __fastcall sub_146186920(__int64 a1)
{
  volatile signed __int32 *v1; // rbx
  __int64 result; // rax

  v1 = *(volatile signed __int32 **)(a1 + 8);
  if ( v1 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(v1 + 2, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))v1)(v1);
      if ( _InterlockedExchangeAdd(v1 + 3, 0xFFFFFFFF) == 1 )
        return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v1 + 8i64))(v1);
    }
  }
  return result;
}

//----- (0000000146186970) ----------------------------------------------------
void __fastcall sub_146186970(__int64 a1)
{
  __int64 v2; // rdx
  std::ios_base *v3; // rbx
  char v4; // al
  __int64 v5; // rcx

  sub_1461626B0(a1 + 152);
  sub_146176C60(a1 + 128);
  v2 = *(_QWORD *)(a1 + 72);
  if ( v2 )
  {
    v3 = (std::ios_base *)(v2 + *(int *)(*(_QWORD *)v2 + 4i64));
    v4 = std::ios_base::rdstate(v3);
    std::ios::clear(v3, v4 & 1, 0i64);
  }
  v5 = *(_QWORD *)(a1 + 56);
  if ( v5 )
  {
    LOBYTE(v2) = v5 != a1;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v5 + 32i64))(v5, v2);
    *(_QWORD *)(a1 + 56) = 0i64;
  }
}
// 1461869E0: variable 'v2' is possibly undefined
// 14611C358: using guessed type __int64 __fastcall std::ios::clear(_QWORD, _QWORD, _QWORD);
// 14611C4B0: using guessed type _DWORD std::ios_base::rdstate(std::ios_base *__hidden this);

//----- (0000000146186A00) ----------------------------------------------------
void __fastcall sub_146186A00(__int64 a1)
{
  volatile signed __int32 *v2; // rbx

  sub_1461626B0(a1 + 608);
  v2 = *(volatile signed __int32 **)(a1 + 8);
  if ( v2 && _InterlockedExchangeAdd(v2 + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(volatile signed __int32 *))v2)(v2);
    if ( _InterlockedExchangeAdd(v2 + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
  }
}

//----- (0000000146186AE0) ----------------------------------------------------
void __fastcall sub_146186AE0(_QWORD **a1)
{
  _QWORD *v1; // rsi
  volatile signed __int32 *v2; // rbx

  v1 = *a1;
  if ( *a1 )
  {
    v2 = (volatile signed __int32 *)v1[1];
    if ( v2 && _InterlockedExchangeAdd(v2 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v2)(v2);
      if ( _InterlockedExchangeAdd(v2 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
    }
    j_j_free(v1);
  }
}

//----- (0000000146186B70) ----------------------------------------------------
void __fastcall sub_146186B70(__int64 a1)
{
  _QWORD *v2; // rcx

  v2 = *(_QWORD **)a1;
  if ( v2 )
  {
    if ( ((*(_QWORD *)(a1 + 16) - (_QWORD)v2) & 0xFFFFFFFFFFFFFFFCui64) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - *(v2 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v2 = (_QWORD *)*(v2 - 1);
    }
    j_j_free(v2);
    *(_QWORD *)a1 = 0i64;
    *(_QWORD *)(a1 + 8) = 0i64;
    *(_QWORD *)(a1 + 16) = 0i64;
  }
}

//----- (0000000146186BF0) ----------------------------------------------------
void __fastcall sub_146186BF0(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 i; // rdi
  _QWORD *v4; // rcx

  v1 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v1 != i; v1 += 32i64 )
      sub_146162730(v1);
    v4 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFE0ui64) >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - *(v4 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v4 = (_QWORD *)*(v4 - 1);
    }
    j_j_free(v4);
    *a1 = 0i64;
    a1[1] = 0i64;
    a1[2] = 0i64;
  }
}

//----- (0000000146186CB0) ----------------------------------------------------
void __fastcall sub_146186CB0(_QWORD *a1)
{
  unsigned __int8 *v2; // rsi
  unsigned __int8 *i; // rbx
  _QWORD *v4; // rcx

  if ( a1[1] )
  {
    v2 = (unsigned __int8 *)a1[4];
    for ( i = (unsigned __int8 *)a1[3]; i != v2; i += 16 )
      sub_14618BD60(i + 8, *i);
    v4 = (_QWORD *)a1[1];
    if ( (unsigned __int64)(16i64 * a1[2]) >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - *(v4 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v4 = (_QWORD *)*(v4 - 1);
    }
    j_j_free(v4);
  }
}
// 14618BD60: using guessed type __int64 __fastcall sub_14618BD60(_QWORD, _QWORD);

//----- (0000000146186D60) ----------------------------------------------------
void __fastcall sub_146186D60(__int64 a1)
{
  std::ios_base *v1; // rbx
  char v2; // al

  if ( *(_QWORD *)a1 )
  {
    v1 = (std::ios_base *)(*(_QWORD *)a1 + *(int *)(**(_QWORD **)a1 + 4i64));
    v2 = std::ios_base::rdstate(v1);
    std::ios::clear(v1, v2 & 1, 0i64);
  }
}
// 14611C358: using guessed type __int64 __fastcall std::ios::clear(_QWORD, _QWORD, _QWORD);
// 14611C4B0: using guessed type _DWORD std::ios_base::rdstate(std::ios_base *__hidden this);

//----- (0000000146186DB0) ----------------------------------------------------
__int64 __fastcall sub_146186DB0(_QWORD *a1)
{
  a1[4] = &std::exception::`vftable';
  _std_exception_destroy(a1 + 5);
  *a1 = &std::exception::`vftable';
  return _std_exception_destroy(a1 + 1);
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 1461A8F1C: using guessed type __int64 __fastcall _std_exception_destroy(_QWORD);

//----- (0000000146186DF0) ----------------------------------------------------
void __fastcall sub_146186DF0(__int64 a1)
{
  __int64 v1; // rcx
  void (__fastcall ***v2)(_QWORD, __int64); // rax

  v1 = *(_QWORD *)(a1 + 8);
  if ( v1 )
  {
    v2 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 16i64))(v1);
    if ( v2 )
      (**v2)(v2, 1i64);
  }
}

//----- (0000000146186E30) ----------------------------------------------------
char *__fastcall sub_146186E30(char *a1, unsigned __int8 *a2)
{
  unsigned __int8 v3; // r8
  __int64 v4; // r8

  v3 = *a1;
  *a1 = *a2;
  *a2 = v3;
  v4 = *((_QWORD *)a1 + 1);
  *((_QWORD *)a1 + 1) = *((_QWORD *)a2 + 1);
  *((_QWORD *)a2 + 1) = v4;
  sub_14618BD60((unsigned __int8 ***)a2 + 1, *a2);
  return a1;
}

//----- (0000000146186E80) ----------------------------------------------------
__int64 __fastcall sub_146186E80(__int64 *a1, const void **a2)
{
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // rbx
  __int64 v8; // rsi
  _BYTE *v9; // rdi
  __int64 v10; // r8
  __int64 v11; // r9
  __int128 v13; // [rsp+30h] [rbp-38h] BYREF
  __int128 v14; // [rsp+40h] [rbp-28h] BYREF
  __int64 v15; // [rsp+50h] [rbp-18h]

  sub_146178280(a1, (__int64)&v14, a2);
  v7 = v15;
  if ( *(_BYTE *)(v15 + 25) || (unsigned __int8)sub_1461797D0((__int64)a1, (size_t *)a2, (const void **)(v15 + 32)) )
  {
    if ( a1[1] == 0x333333333333333i64 )
      unknown_libname_3(v5, v4, v6);
    v8 = *a1;
    v9 = operator new(0x50ui64);
    sub_146170E60((__int64)(v9 + 32), (__int64)a2, v10, v11);
    v9[64] = 0;
    sub_1461862B0((_QWORD *)v9 + 9, 0);
    *(_QWORD *)v9 = v8;
    *((_QWORD *)v9 + 1) = v8;
    *((_QWORD *)v9 + 2) = v8;
    *((_WORD *)v9 + 12) = 0;
    v13 = v14;
    v7 = sub_146165130(a1, (__int64)&v13, (__int64)v9);
  }
  return v7 + 64;
}
// 146186F13: variable 'v10' is possibly undefined
// 146186F13: variable 'v11' is possibly undefined
// 146186F76: variable 'v5' is possibly undefined
// 146186F76: variable 'v4' is possibly undefined
// 146186F76: variable 'v6' is possibly undefined
// 1461653B0: using guessed type void __fastcall __noreturn unknown_libname_3(_QWORD, _QWORD, _QWORD);

//----- (0000000146186F80) ----------------------------------------------------
__int64 __fastcall sub_146186F80(_OWORD *a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v4; // rcx
  __int64 result; // rax
  unsigned __int64 v6; // rax
  __int64 v7; // rdx

  *(_OWORD *)a2 = *a1;
  if ( a3 >= 0 || (v4 = *(_QWORD *)(a2 + 8), v4 >= -a3) )
  {
    *(_QWORD *)(a2 + 8) += a3;
    v6 = *(_QWORD *)(a2 + 8);
    v7 = v6 & 0x1F;
    *(_QWORD *)a2 += 4 * (v6 >> 5);
    result = a2;
    *(_QWORD *)(a2 + 8) = v7;
  }
  else
  {
    *(_QWORD *)(a2 + 8) = v4 + a3;
    *(_QWORD *)a2 += -4i64 - 4 * (~(v4 + a3) >> 5);
    result = a2;
    *(_QWORD *)(a2 + 8) = ((_BYTE)v4 + (_BYTE)a3) & 0x1F;
  }
  return result;
}

//----- (0000000146186FF0) ----------------------------------------------------
void __fastcall sub_146186FF0(void (__fastcall ***a1)(_QWORD *))
{
  void (__fastcall **v2)(__int64); // rax
  void (__fastcall *v3)(_QWORD *); // rdi
  __int64 v4; // r9
  __int64 v5; // r8
  __int64 v6; // r9
  _QWORD *v7; // rax
  __int64 v8; // r9
  void *v9; // rcx
  void (__fastcall *v10)(_QWORD *); // rbx
  __int64 v11; // r8
  __int64 v12; // r9
  _QWORD *v13; // rax
  void *v14; // rcx
  __int128 v15; // [rsp+30h] [rbp-68h] BYREF
  __int64 v16; // [rsp+40h] [rbp-58h]
  __int64 v17; // [rsp+48h] [rbp-50h]
  __int64 v18; // [rsp+58h] [rbp-40h]
  void *Block[3]; // [rsp+60h] [rbp-38h] BYREF
  unsigned __int64 v20; // [rsp+78h] [rbp-20h]

  v18 = -2i64;
  if ( **a1 )
  {
    v2 = (void (__fastcall **)(__int64))a1[1];
    if ( *v2 )
    {
      (*v2)(5120i64);
      v3 = **a1;
      v15 = 0i64;
      v16 = 0i64;
      v17 = 0i64;
      sub_146168F30(&v15, &Default, 0i64, v4);
      v7 = (_QWORD *)sub_1461645B0((__int64)Block, (void **)&v15, v5, v6);
      if ( v7[3] > 7ui64 )
        v7 = (_QWORD *)*v7;
      v3(v7);
      if ( v20 > 7 )
      {
        v9 = Block[0];
        if ( 2 * v20 + 2 >= 0x1000 )
        {
          v9 = (void *)*((_QWORD *)Block[0] - 1);
          if ( (unsigned __int64)(Block[0] - v9 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v9);
      }
      v10 = **a1;
      v15 = 0i64;
      v16 = 0i64;
      v17 = 0i64;
      sub_146168F30(&v15, L"bin", 3ui64, v8);
      v13 = (_QWORD *)sub_1461645B0((__int64)Block, (void **)&v15, v11, v12);
      if ( v13[3] > 7ui64 )
        v13 = (_QWORD *)*v13;
      v10(v13);
      if ( v20 > 7 )
      {
        v14 = Block[0];
        if ( 2 * v20 + 2 >= 0x1000 )
        {
          v14 = (void *)*((_QWORD *)Block[0] - 1);
          if ( (unsigned __int64)(Block[0] - v14 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v14);
      }
    }
  }
}
// 14618706D: variable 'v4' is possibly undefined
// 14618707C: variable 'v5' is possibly undefined
// 14618707C: variable 'v6' is possibly undefined
// 146187110: variable 'v8' is possibly undefined
// 14618711F: variable 'v11' is possibly undefined
// 14618711F: variable 'v12' is possibly undefined
// 14612C3C0: using guessed type wchar_t aBin[4];

//----- (00000001461871B0) ----------------------------------------------------
void __fastcall sub_1461871B0(__int64 a1, const wchar_t *a2, __int64 a3, __int64 a4)
{
  __int64 v5; // rax
  _BYTE *v6; // rcx
  unsigned __int64 v7; // rax
  __int64 v8; // r9
  void *v9; // rcx
  void *v10[2]; // [rsp+40h] [rbp-58h] BYREF
  __int128 v11; // [rsp+50h] [rbp-48h]
  void *Block; // [rsp+60h] [rbp-38h] BYREF
  unsigned __int64 v13; // [rsp+78h] [rbp-20h]

  *(_OWORD *)v10 = 0i64;
  if ( a2 )
  {
    v11 = 0i64;
    v7 = wcslen(a2);
    sub_146168F30(v10, a2, v7, v8);
    sub_146167DB0((wchar_t *)v10, 0);
    if ( *((_QWORD *)&v11 + 1) > 7ui64 )
    {
      v9 = v10[0];
      if ( (unsigned __int64)(2i64 * *((_QWORD *)&v11 + 1) + 2) >= 0x1000 )
      {
        v9 = (void *)*((_QWORD *)v10[0] - 1);
        if ( (unsigned __int64)(v10[0] - v9 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v9);
    }
  }
  else
  {
    v11 = 0ui64;
    sub_146168F30(v10, &Default, 0i64, a4);
    v5 = sub_146188490((__int64)&Block, v10);
    if ( *(_QWORD *)(v5 + 24) > 7ui64 )
      v5 = *(_QWORD *)v5;
    SetCurrentDirectoryW((LPCWSTR)v5);
    if ( v13 > 7 )
    {
      v6 = Block;
      if ( 2 * v13 + 2 >= 0x1000 )
      {
        v6 = (_BYTE *)*((_QWORD *)Block - 1);
        if ( (unsigned __int64)((_BYTE *)Block - v6 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v6);
    }
    if ( !OpenMutexW(0x100000u, 0, L"CitizenFX_GameMutex") )
    {
      CreateMutexW(0i64, 1, L"CitizenFX_GameMutex");
      sub_146167DB0((wchar_t *)&qword_14611AB60, 0);
    }
  }
}
// 1461872DC: variable 'v8' is possibly undefined

//----- (0000000146187360) ----------------------------------------------------
bool sub_146187360()
{
  HMODULE ModuleHandleW; // rax
  WCHAR Filename[264]; // [rsp+20h] [rbp-228h] BYREF

  ModuleHandleW = GetModuleHandleW(0i64);
  GetModuleFileNameW(ModuleHandleW, Filename, 0x104u);
  return wcsstr(Filename, L"subprocess") != 0i64;
}

//----- (00000001461873D0) ----------------------------------------------------
BOOL sub_1461873D0()
{
  _DWORD *v0; // rbx
  void *v2; // rcx
  void *v3; // rcx
  void *Block[2]; // [rsp+38h] [rbp-30h] BYREF
  __m128i si128; // [rsp+48h] [rbp-20h]

  v0 = (_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 380i64);
  if ( dword_14611AB40 > *v0 )
  {
    sub_1461A7CF4(&dword_14611AB40);
    if ( dword_14611AB40 == -1 )
    {
      si128 = _mm_load_si128((const __m128i *)&xmmword_14611E150);
      strcpy((char *)Block, "CfxInitState");
      BYTE5(Block[1]) = 0;
      HIWORD(Block[1]) = 0;
      sub_146166700((__int64)&qword_14611AB30, (__int64 *)Block);
      if ( si128.m128i_i64[1] > 0xFui64 )
      {
        v2 = Block[0];
        if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
        {
          v2 = (void *)*((_QWORD *)Block[0] - 1);
          if ( (unsigned __int64)(Block[0] - v2 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v2);
      }
      atexit(sub_1461AE840);
      Init_thread_footer(&dword_14611AB40);
    }
  }
  if ( dword_14611AB58 > *v0 )
  {
    sub_1461A7CF4(&dword_14611AB58);
    if ( dword_14611AB58 == -1 )
    {
      si128 = _mm_load_si128((const __m128i *)&xmmword_14612A940);
      Block[0] = (void *)0x7453495555786643i64;
      Block[1] = (void *)6648929;
      sub_146184F80((__int64)&qword_14611AB48, (__int64 *)Block);
      if ( si128.m128i_i64[1] > 0xFui64 )
      {
        v3 = Block[0];
        if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
        {
          v3 = (void *)*((_QWORD *)Block[0] - 1);
          if ( (unsigned __int64)(Block[0] - v3 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v3);
      }
      atexit(sub_1461AE900);
      Init_thread_footer(&dword_14611AB58);
    }
  }
  return SetEvent(hEvent);
}
// 14611AB40: using guessed type int dword_14611AB40;
// 14611AB58: using guessed type int dword_14611AB58;
// 14611AE78: using guessed type int TlsIndex;
// 14611E150: using guessed type __int128 xmmword_14611E150;
// 14612A940: using guessed type __int128 xmmword_14612A940;
// 146162580: using guessed type __int64 __fastcall guard_check_icall_nop();
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);

//----- (0000000146187600) ----------------------------------------------------
_QWORD *__fastcall sub_146187600(_QWORD *Src, wchar_t *a2)
{
  unsigned __int64 v4; // rax
  __int64 v5; // r9

  v4 = wcslen(a2);
  return sub_1461653F0(Src, a2, v4, v5);
}
// 14618762B: variable 'v5' is possibly undefined

//----- (0000000146187630) ----------------------------------------------------
__int64 __fastcall sub_146187630(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1 + 176;
  *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + v1 - 176) = &std::ifstream::`vftable';
  *(_DWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + v1 - 180) = *(_DWORD *)(*(_QWORD *)a1 + 4i64) - 176;
  sub_146186730(a1 + 16);
  std::istream::~istream<char,std::char_traits<char>>(v1 - 152);
  return std::ios::~ios<char,std::char_traits<char>>(v1);
}
// 14611C350: using guessed type __int64 __fastcall std::ios::~ios<char,std::char_traits<char>>(_QWORD);
// 14611C380: using guessed type __int64 __fastcall std::istream::~istream<char,std::char_traits<char>>(_QWORD);
// 14612C258: using guessed type void *std::ifstream::`vftable';

//----- (0000000146187690) ----------------------------------------------------
void *__fastcall sub_146187690(__int64 a1, char a2)
{
  return sub_146187740(a1 - *(int *)(a1 - 4), a2);
}

//----- (00000001461876D0) ----------------------------------------------------
_QWORD *__fastcall sub_1461876D0(_QWORD *a1, char a2)
{
  *a1 = &std::_Ref_count_obj2<fx::MinModeManifest>::`vftable';
  if ( (a2 & 1) != 0 )
    j_j_free(a1);
  return a1;
}
// 14612CB08: using guessed type void *std::_Ref_count_obj2<fx::MinModeManifest>::`vftable';

//----- (0000000146187740) ----------------------------------------------------
void *__fastcall sub_146187740(__int64 a1, char a2)
{
  void *v2; // rsi
  __int64 v5; // r8

  v2 = (void *)(a1 - 176);
  *(_QWORD *)(*(int *)(*(_QWORD *)(a1 - 176) + 4i64) + a1 - 176) = &std::ifstream::`vftable';
  v5 = *(int *)(*(_QWORD *)(a1 - 176) + 4i64);
  *(_DWORD *)(v5 + a1 - 180) = v5 - 176;
  sub_146186730(a1 - 176 + 16);
  std::istream::~istream<char,std::char_traits<char>>(a1 - 152);
  std::ios::~ios<char,std::char_traits<char>>(a1);
  if ( (a2 & 1) != 0 )
    j_j_free(v2);
  return v2;
}
// 14611C350: using guessed type __int64 __fastcall std::ios::~ios<char,std::char_traits<char>>(_QWORD);
// 14611C380: using guessed type __int64 __fastcall std::istream::~istream<char,std::char_traits<char>>(_QWORD);
// 14612C258: using guessed type void *std::ifstream::`vftable';

//----- (0000000146187800) ----------------------------------------------------
_QWORD *__fastcall sub_146187800(_QWORD *Block, char a2)
{
  Block[4] = &std::exception::`vftable';
  _std_exception_destroy(Block + 5);
  *Block = &std::exception::`vftable';
  _std_exception_destroy(Block + 1);
  if ( (a2 & 1) != 0 )
    j_j_free(Block);
  return Block;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 1461A8F1C: using guessed type __int64 __fastcall _std_exception_destroy(_QWORD);

//----- (0000000146187860) ----------------------------------------------------
_QWORD *__fastcall sub_146187860(_QWORD *Block, char a2)
{
  Block[4] = &std::exception::`vftable';
  _std_exception_destroy(Block + 5);
  *Block = &std::exception::`vftable';
  _std_exception_destroy(Block + 1);
  if ( (a2 & 1) != 0 )
    j_j_free(Block);
  return Block;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 1461A8F1C: using guessed type __int64 __fastcall _std_exception_destroy(_QWORD);

//----- (00000001461878C0) ----------------------------------------------------
void __fastcall sub_1461878C0(signed int dwMessageId, __m128i *a2, __int64 a3, __int64 a4)
{
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rax
  void *v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  size_t v12; // rax
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rdi
  void *v16; // rcx
  __m128i v17; // xmm2
  void *v18; // rcx
  _QWORD *v19; // rax
  __m128i v20; // xmm0
  _QWORD *v21; // rdx
  __int64 v22; // rax
  void **v23; // rcx
  unsigned int v24; // ebx
  _BYTE *v25; // r8
  __m128i v26; // xmm0
  void *v27; // rcx
  WCHAR Buffer[4]; // [rsp+48h] [rbp-C0h] BYREF
  __int128 v29; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v30; // [rsp+68h] [rbp-A0h]
  __int64 v31; // [rsp+70h] [rbp-98h]
  __int64 v32; // [rsp+78h] [rbp-90h]
  __int64 v33; // [rsp+80h] [rbp-88h]
  void *v34[2]; // [rsp+88h] [rbp-80h] BYREF
  __m128i v35; // [rsp+98h] [rbp-70h]
  void *Block[2]; // [rsp+A8h] [rbp-60h] BYREF
  __m128i si128; // [rsp+B8h] [rbp-50h]
  __int128 v38; // [rsp+C8h] [rbp-40h]
  void **v39; // [rsp+D8h] [rbp-30h]
  __int64 v40; // [rsp+E0h] [rbp-28h]
  void *v41; // [rsp+E8h] [rbp-20h] BYREF
  __m128i v42; // [rsp+F8h] [rbp-10h]

  v33 = -2i64;
  LODWORD(v32) = 0;
  v29 = 0i64;
  v30 = 0i64;
  v31 = 0i64;
  sub_146168F30(&v29, L"content_index.xml", 0x11ui64, a4);
  v8 = sub_1461645B0((__int64)Block, (void **)&v29, v6, v7);
  if ( *(_QWORD *)(v8 + 24) > 7ui64 )
    v8 = *(_QWORD *)v8;
  wunlink((const wchar_t *)v8);
  if ( si128.m128i_i64[1] > 7ui64 )
  {
    v9 = Block[0];
    if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
    {
      v9 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v9 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v9);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(Block[0]) = 0;
  *(_QWORD *)Buffer = 0i64;
  if ( !FormatMessageW(0x13FFu, 0i64, dwMessageId, 0x409u, Buffer, 0, 0i64) )
    FormatMessageW(0x13FFu, 0i64, dwMessageId, 0x400u, Buffer, 0, 0i64);
  *(_OWORD *)v34 = 0i64;
  v35 = _mm_load_si128((const __m128i *)&Size);
  LOBYTE(v34[0]) = 0;
  LODWORD(v32) = 1;
  if ( *(_QWORD *)Buffer )
  {
    v12 = wcslen(*(const wchar_t **)Buffer);
    *(_QWORD *)&v29 = *(_QWORD *)Buffer;
    *((_QWORD *)&v29 + 1) = v12;
    v15 = sub_1461A2B60((__int64)Block, (unsigned __int16 **)&v29, v13, v14);
    if ( v34 == (void **)v15 )
    {
      v17 = _mm_load_si128((const __m128i *)&Size);
    }
    else
    {
      if ( v35.m128i_i64[1] > 0xFui64 )
      {
        v16 = v34[0];
        if ( (unsigned __int64)(v35.m128i_i64[1] + 1) >= 0x1000 )
        {
          v16 = (void *)*((_QWORD *)v34[0] - 1);
          if ( (unsigned __int64)(v34[0] - v16 - 8) > 0x1F )
LABEL_21:
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v16);
      }
      v17 = _mm_load_si128((const __m128i *)&Size);
      v35 = v17;
      LOBYTE(v34[0]) = 0;
      *(_OWORD *)v34 = *(_OWORD *)v15;
      v35 = *(__m128i *)(v15 + 16);
      *(_QWORD *)(v15 + 16) = 0i64;
      *(_QWORD *)(v15 + 24) = 15i64;
      *(_BYTE *)v15 = 0;
    }
    if ( si128.m128i_i64[1] > 0xFui64 )
    {
      v18 = Block[0];
      if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
      {
        v18 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)(Block[0] - v18 - 8) > 0x1F )
          goto LABEL_21;
      }
      j_j_free(v18);
      v17 = _mm_load_si128((const __m128i *)&Size);
    }
    si128 = v17;
    LOBYTE(Block[0]) = 0;
    LocalFree(*(HLOCAL *)Buffer);
  }
  if ( dwMessageId > 0 )
    dwMessageId = (unsigned __int16)dwMessageId | 0x80070000;
  *(_QWORD *)&v29 = L"ChanCity";
  *((_QWORD *)&v29 + 1) = 8i64;
  v19 = (_QWORD *)sub_1461A2B60((__int64)&v41, (unsigned __int16 **)&v29, v10, v11);
  v20 = *a2;
  v21 = v19;
  if ( v19[3] > 0xFui64 )
    v21 = (_QWORD *)*v19;
  v22 = v19[2];
  LODWORD(v29) = dwMessageId;
  v23 = v34;
  if ( v35.m128i_i64[1] > 0xFui64 )
    v23 = (void **)v34[0];
  Block[0] = (void *)v20.m128i_i64[0];
  Block[1] = (void *)_mm_srli_si128(v20, 8).m128i_u64[0];
  si128.m128i_i64[0] = (__int64)v21;
  si128.m128i_i64[1] = v22;
  v38 = v29;
  v39 = v23;
  v40 = v35.m128i_i64[0];
  *(_QWORD *)&v29 = 53725i64;
  *((_QWORD *)&v29 + 1) = Block;
  v24 = (unsigned int)sub_146163F20(
                        "F:\\NewBuildFivem\\LauncherGTA\\code\\client\\launcher\\Main.cpp",
                        122,
                        -592818331,
                        "Could not load %s\n"
                        "This is usually a sign of an incomplete game installation. Please restart %s and try again.\n"
                        "\n"
                        "Error 0x%08x - %s",
                        &v29) >> 31;
  if ( v42.m128i_i64[1] > 0xFui64 )
  {
    v25 = v41;
    if ( (unsigned __int64)(v42.m128i_i64[1] + 1) >= 0x1000 )
    {
      v25 = (_BYTE *)*((_QWORD *)v41 - 1);
      if ( (unsigned __int64)((_BYTE *)v41 - v25 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v25);
  }
  v26 = _mm_load_si128((const __m128i *)&Size);
  v42 = v26;
  LOBYTE(v41) = 0;
  if ( v35.m128i_i64[1] > 0xFui64 )
  {
    v27 = v34[0];
    if ( (unsigned __int64)(v35.m128i_i64[1] + 1) >= 0x1000 )
    {
      v27 = (void *)*((_QWORD *)v34[0] - 1);
      if ( (unsigned __int64)(v34[0] - v27 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v27);
    v26 = _mm_load_si128((const __m128i *)&Size);
  }
  v35 = v26;
  LOBYTE(v34[0]) = 0;
  if ( (_BYTE)v24 )
    MEMORY[0xDEED] = 0;
}
// 146187930: variable 'v6' is possibly undefined
// 146187930: variable 'v7' is possibly undefined
// 146187A51: variable 'v13' is possibly undefined
// 146187A51: variable 'v14' is possibly undefined
// 146187B66: variable 'v10' is possibly undefined
// 146187B66: variable 'v11' is possibly undefined
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 14612C298: using guessed type wchar_t aContentIndexXm[18];
// 14612C2C0: using guessed type wchar_t aChancity[9];

//----- (0000000146187CF0) ----------------------------------------------------
_QWORD *sub_146187CF0()
{
  __int64 v0; // rdx
  int v1; // eax
  _QWORD *v2; // rdi
  __int64 v3; // rcx
  __int64 v4; // rcx
  const char *v5; // rbx
  size_t v6; // r8

  v0 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v1 = *(_DWORD *)(v0 + 272);
  v2 = (_QWORD *)(v0 + 240);
  if ( (v1 & 1) == 0 )
  {
    *(_DWORD *)(v0 + 272) = v1 | 1;
    if ( (unsigned __int8)sub_1461883F0(272i64) || (unsigned __int8)sub_146167D30(v3) )
    {
      v5 = "fxdk";
    }
    else
    {
      v5 = "cl2";
      if ( !(unsigned __int8)sub_146188370(v4) )
        v5 = Src;
    }
    *(_OWORD *)v2 = 0i64;
    v2[2] = 0i64;
    v2[3] = 0i64;
    v6 = strlen(v5);
    sub_14615A650(v2, v5, v6);
    _tlregdtor(qword_1461AE4B0);
  }
  return v2;
}
// 146187D3A: variable 'v3' is possibly undefined
// 146187D43: variable 'v4' is possibly undefined
// 14611AE78: using guessed type int TlsIndex;
// 146167D30: using guessed type __int64 __fastcall sub_146167D30(_QWORD);
// 146188370: using guessed type __int64 __fastcall sub_146188370(_QWORD);
// 1461883F0: using guessed type __int64 __fastcall sub_1461883F0(_QWORD);
// 1461A7E18: using guessed type __int64 __fastcall _tlregdtor(_QWORD);
// 1461AE4B0: using guessed type __int64 qword_1461AE4B0[4];

//----- (0000000146187DB0) ----------------------------------------------------
_OWORD *sub_146187DB0()
{
  __int64 v0; // rdx
  int v1; // eax
  _OWORD *v2; // rbx

  v0 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v1 = *(_DWORD *)(v0 + 312);
  v2 = (_OWORD *)(v0 + 280);
  if ( (v1 & 1) == 0 )
  {
    *(_DWORD *)(v0 + 312) = v1 | 1;
    *v2 = 0i64;
    *(_QWORD *)(v0 + 296) = 4i64;
    *(_QWORD *)(v0 + 304) = 15i64;
    strcpy((char *)(v0 + 280), "Five");
    _tlregdtor(qword_1461AE4D0);
  }
  return v2;
}
// 14611AE78: using guessed type int TlsIndex;
// 1461A7E18: using guessed type __int64 __fastcall _tlregdtor(_QWORD);
// 1461AE4D0: using guessed type __int64 qword_1461AE4D0[4];

//----- (0000000146187E30) ----------------------------------------------------
_QWORD *__fastcall sub_146187E30(_QWORD *a1)
{
  const wchar_t *CommandLineW; // rax
  wchar_t *v3; // rax
  const void *v4; // rbx
  unsigned __int64 v5; // r8
  __int64 v6; // r9
  void **v7; // rsi
  char *v8; // rcx
  unsigned __int64 v9; // rax
  const __m128i *v10; // rbx
  const __m128i *v11; // rax
  __int64 v12; // r9
  unsigned __int64 v13; // r8
  void **v14; // rdx
  void *v15; // rcx
  void **v16; // rdx
  __int64 v17; // rax
  __int64 v18; // rdx
  std::ios_base *v19; // rbx
  char v20; // al
  void **v21; // rax
  void **v22; // rbx
  void *v23; // rcx
  unsigned __int64 v25; // rdx
  char *v26; // rax
  _DWORD *v27; // rax
  _DWORD *v28; // rsi
  _QWORD *v29; // rax
  __int128 v30; // [rsp+30h] [rbp-2C8h] BYREF
  _QWORD *v31; // [rsp+40h] [rbp-2B8h]
  __int64 v32; // [rsp+50h] [rbp-2A8h]
  int v33; // [rsp+5Ch] [rbp-29Ch]
  __int64 v34[2]; // [rsp+60h] [rbp-298h] BYREF
  char v35[8]; // [rsp+70h] [rbp-288h] BYREF
  char v36[152]; // [rsp+78h] [rbp-280h] BYREF
  char v37[96]; // [rsp+110h] [rbp-1E8h] BYREF
  char v38[56]; // [rsp+170h] [rbp-188h] BYREF
  __int64 v39; // [rsp+1A8h] [rbp-150h]
  void *Block[2]; // [rsp+1B0h] [rbp-148h] BYREF
  __m128i v41; // [rsp+1C0h] [rbp-138h]
  __int128 v42; // [rsp+1D0h] [rbp-128h] BYREF
  __m128i v43; // [rsp+1E0h] [rbp-118h]
  char v44[56]; // [rsp+1F0h] [rbp-108h] BYREF
  char *v45; // [rsp+228h] [rbp-D0h]
  __int64 v46; // [rsp+238h] [rbp-C0h]
  char v47[24]; // [rsp+270h] [rbp-88h] BYREF
  char v48[96]; // [rsp+288h] [rbp-70h] BYREF

  v32 = -2i64;
  v31 = a1;
  CommandLineW = GetCommandLineW();
  v3 = wcsstr(CommandLineW, L"+set minmodemanifest \"");
  if ( !v3 )
  {
LABEL_37:
    v27 = operator new(0x30ui64);
    v28 = v27;
    *(_QWORD *)&v42 = v27;
    if ( v27 )
    {
      *(_OWORD *)v27 = 0i64;
      v27[2] = 1;
      v27[3] = 1;
      *(_QWORD *)v27 = &std::_Ref_count_obj2<fx::MinModeManifest>::`vftable';
      v31 = v27 + 4;
      *((_QWORD *)v27 + 2) = 0i64;
      *((_QWORD *)v27 + 3) = 0i64;
      v29 = operator new(0x60ui64);
      *v29 = v29;
      v29[1] = v29;
      v29[2] = v29;
      *((_WORD *)v29 + 12) = 257;
      *((_QWORD *)v28 + 2) = v29;
      v30 = 0i64;
      sub_146185760((__int64)(v28 + 8), (__int64 *)&v30, 0, 1);
    }
    else
    {
      v28 = 0i64;
    }
    *a1 = v28 + 4;
    a1[1] = v28;
    return a1;
  }
  v4 = v3 + 22;
  *(_OWORD *)Block = 0i64;
  v41 = 0ui64;
  v5 = wcslen(v3 + 22);
  sub_146168F30(Block, v4, v5, v6);
  v7 = Block;
  v8 = (char *)Block[0];
  v9 = v41.m128i_u64[1];
  if ( v41.m128i_i64[1] > 7ui64 )
    v7 = (void **)Block[0];
  if ( !v41.m128i_i64[0] )
  {
LABEL_32:
    if ( v9 > 7 )
    {
      v25 = 2 * v9 + 2;
      v26 = v8;
      if ( v25 >= 0x1000 )
      {
        v8 = (char *)*((_QWORD *)v8 - 1);
        if ( (unsigned __int64)(v26 - v8 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v8);
    }
    goto LABEL_37;
  }
  v10 = (const __m128i *)((char *)v7 + 2 * v41.m128i_i64[0]);
  v11 = sub_1461A7830((const __m128i *)v7, v10, 34);
  if ( v11 == v10 || (v13 = ((char *)v11 - (char *)v7) >> 1, v13 == -1i64) )
  {
    v9 = v41.m128i_u64[1];
    v8 = (char *)Block[0];
    goto LABEL_32;
  }
  v42 = 0i64;
  v43 = 0i64;
  if ( v41.m128i_i64[0] < v13 )
    v13 = v41.m128i_i64[0];
  v14 = Block;
  if ( v41.m128i_i64[1] > 7ui64 )
    v14 = (void **)Block[0];
  sub_146168F30(&v42, v14, v13, v12);
  if ( v41.m128i_i64[1] > 7ui64 )
  {
    v15 = Block[0];
    if ( (unsigned __int64)(2 * v41.m128i_i64[1] + 2) >= 0x1000 )
    {
      v15 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v15 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v15);
  }
  *(_OWORD *)Block = v42;
  v41 = v43;
  v16 = Block;
  if ( _mm_srli_si128(v43, 8).m128i_u64[0] > 7 )
    v16 = (void **)v42;
  sub_146185200((__int64)v34, (const wchar_t *)v16, 1, 64, 1);
  *(__int64 *)((char *)v34 + *(int *)(v34[0] + 4)) = (__int64)&std::ifstream::`vftable';
  *(int *)((char *)&v33 + *(int *)(v34[0] + 4)) = *(_DWORD *)(v34[0] + 4) - 176;
  LOBYTE(v30) = 0;
  sub_1461862B0((_QWORD *)&v30 + 1, 0);
  v39 = 0i64;
  *(_QWORD *)&v42 = v34;
  *((_QWORD *)&v42 + 1) = std::ios::rdbuf((char *)v34 + *(int *)(v34[0] + 4));
  v17 = sub_146182DF0((__int64)v44, &v42, (__int64)v38, 1, 0);
  sub_14618F930(v17, 0, (unsigned __int8 *)&v30);
  sub_1461626B0((__int64)v48);
  sub_146176C60((__int64)v47);
  v18 = v46;
  if ( v46 )
  {
    v19 = (std::ios_base *)(v46 + *(int *)(*(_QWORD *)v46 + 4i64));
    v20 = std::ios_base::rdstate(v19);
    std::ios::clear(v19, v20 & 1, 0i64);
  }
  if ( v45 )
  {
    LOBYTE(v18) = v45 != v44;
    (*(void (__fastcall **)(char *, __int64))(*(_QWORD *)v45 + 32i64))(v45, v18);
  }
  v21 = (void **)operator new(0x30ui64);
  v22 = v21;
  *(_QWORD *)&v42 = v21;
  if ( v21 )
  {
    *((_DWORD *)v21 + 2) = 1;
    *((_DWORD *)v21 + 3) = 1;
    *v21 = &std::_Ref_count_obj2<fx::MinModeManifest>::`vftable';
    sub_146185F40(v21 + 2, (__int64)&v30);
  }
  else
  {
    v22 = 0i64;
  }
  *a1 = v22 + 2;
  a1[1] = v22;
  sub_14618BD60((unsigned __int8 ***)&v30 + 1, (unsigned __int8)v30);
  *(__int64 *)((char *)v34 + *(int *)(v34[0] + 4)) = (__int64)&std::ifstream::`vftable';
  *(int *)((char *)&v33 + *(int *)(v34[0] + 4)) = *(_DWORD *)(v34[0] + 4) - 176;
  sub_146186730((__int64)v35);
  std::istream::~istream<char,std::char_traits<char>>(v36);
  std::ios::~ios<char,std::char_traits<char>>(v37);
  if ( v41.m128i_i64[1] > 7ui64 )
  {
    v23 = Block[0];
    if ( (unsigned __int64)(2 * v41.m128i_i64[1] + 2) >= 0x1000 )
    {
      v23 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v23 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v23);
  }
  return a1;
}
// 146187EC1: variable 'v6' is possibly undefined
// 146187F73: variable 'v12' is possibly undefined
// 14618813E: variable 'v18' is possibly undefined
// 14611C350: using guessed type __int64 __fastcall std::ios::~ios<char,std::char_traits<char>>(_QWORD);
// 14611C358: using guessed type __int64 __fastcall std::ios::clear(_QWORD, _QWORD, _QWORD);
// 14611C368: using guessed type __int64 __fastcall std::ios::rdbuf(_QWORD);
// 14611C380: using guessed type __int64 __fastcall std::istream::~istream<char,std::char_traits<char>>(_QWORD);
// 14611C4B0: using guessed type _DWORD std::ios_base::rdstate(std::ios_base *__hidden this);
// 14612C258: using guessed type void *std::ifstream::`vftable';
// 14612CB08: using guessed type void *std::_Ref_count_obj2<fx::MinModeManifest>::`vftable';
// 146187E30: using guessed type char var_188[56];
// 146187E30: using guessed type char var_70[96];
// 146187E30: using guessed type char var_88[24];
// 146187E30: using guessed type char var_288[8];
// 146187E30: using guessed type char var_280[152];
// 146187E30: using guessed type char var_1E8[96];

//----- (0000000146188370) ----------------------------------------------------
__int64 sub_146188370()
{
  const wchar_t *CommandLineW; // rax

  if ( dword_14610A9AC <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 380i64) )
    return (unsigned __int8)byte_14610A9A8;
  sub_1461A7CF4(&dword_14610A9AC);
  if ( dword_14610A9AC != -1 )
    return (unsigned __int8)byte_14610A9A8;
  CommandLineW = GetCommandLineW();
  byte_14610A9A8 = wcsstr(CommandLineW, L"cl2") != 0i64;
  Init_thread_footer(&dword_14610A9AC);
  return (unsigned __int8)byte_14610A9A8;
}
// 14610A9A8: using guessed type char byte_14610A9A8;
// 14610A9AC: using guessed type int dword_14610A9AC;
// 14611AE78: using guessed type int TlsIndex;
// 146188370: using guessed type __int64 sub_146188370();
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);

//----- (00000001461883F0) ----------------------------------------------------
__int64 sub_1461883F0()
{
  const wchar_t *CommandLineW; // rax
  bool v2; // al

  if ( dword_14610A9BC <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 380i64) )
    return (unsigned __int8)byte_14610A9B8;
  sub_1461A7CF4(&dword_14610A9BC);
  if ( dword_14610A9BC != -1 )
    return (unsigned __int8)byte_14610A9B8;
  CommandLineW = GetCommandLineW();
  v2 = wcsstr(CommandLineW, L"fxdk") && !(unsigned __int8)sub_146167D30();
  byte_14610A9B8 = v2;
  Init_thread_footer(&dword_14610A9BC);
  return (unsigned __int8)byte_14610A9B8;
}
// 14610A9B8: using guessed type char byte_14610A9B8;
// 14610A9BC: using guessed type int dword_14610A9BC;
// 14611AE78: using guessed type int TlsIndex;
// 146167D30: using guessed type __int64 sub_146167D30(void);
// 1461883F0: using guessed type __int64 sub_1461883F0();
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);

//----- (0000000146188490) ----------------------------------------------------
__int64 __fastcall sub_146188490(__int64 a1, void **a2)
{
  _QWORD *v4; // rax
  __int64 v5; // r9
  void *v6; // rdx
  _QWORD *v7; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  void *v10; // rcx
  _BYTE *v11; // rcx
  void *Block[2]; // [rsp+48h] [rbp-50h] BYREF
  __int128 v14; // [rsp+58h] [rbp-40h]
  void *v15; // [rsp+68h] [rbp-30h] BYREF
  __m128i si128; // [rsp+78h] [rbp-20h]

  v4 = sub_1461A1680(&v15);
  v6 = a2;
  if ( (unsigned __int64)a2[3] > 7 )
    v6 = *a2;
  v7 = sub_1461653F0(v4, v6, (unsigned __int64)a2[2], v5);
  *(_OWORD *)Block = *(_OWORD *)v7;
  v14 = *((_OWORD *)v7 + 1);
  v7[2] = 0i64;
  v7[3] = 7i64;
  *(_WORD *)v7 = 0;
  sub_146170F20(a1, (__int64)Block, v8, v9);
  if ( *((_QWORD *)&v14 + 1) > 7ui64 )
  {
    v10 = Block[0];
    if ( (unsigned __int64)(2i64 * *((_QWORD *)&v14 + 1) + 2) >= 0x1000 )
    {
      v10 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v10 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v10);
  }
  if ( si128.m128i_i64[1] > 7ui64 )
  {
    v11 = v15;
    if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
    {
      v11 = (_BYTE *)*((_QWORD *)v15 - 1);
      if ( (unsigned __int64)((_BYTE *)v15 - v11 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v11);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(v15) = 0;
  sub_146162730((__int64)a2);
  return a1;
}
// 1461884EC: variable 'v5' is possibly undefined
// 146188519: variable 'v8' is possibly undefined
// 146188519: variable 'v9' is possibly undefined
// 14611DA20: using guessed type __int128 xmmword_14611DA20;

//----- (0000000146188610) ----------------------------------------------------
int __stdcall WinMain_0(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  HMODULE ModuleHandleW; // rax
  FARPROC ProcAddress; // rax
  wchar_t **v6; // rsi
  __int64 v7; // rbx
  char *v8; // r12
  char *v9; // r14
  unsigned __int64 v10; // r8
  __int64 v11; // r9
  wchar_t *v12; // r13
  void **v13; // rax
  __int64 v14; // r8
  __int64 v15; // r9
  _QWORD *v16; // rbx
  void **v17; // rax
  __int64 v18; // r8
  __int64 v19; // r9
  _QWORD *v20; // rax
  _QWORD *v21; // rax
  _QWORD *v22; // rax
  const WCHAR *v23; // rdx
  void **v24; // rax
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // rax
  void **v28; // rax
  __int64 v29; // r8
  __int64 v30; // r9
  __int64 v31; // rax
  void **v32; // rax
  __int64 v33; // r8
  __int64 v34; // r9
  __int64 v35; // rax
  HMODULE v36; // rax
  HMODULE v37; // rax
  ULONGLONG v38; // rax
  ULONGLONG v39; // rax
  DWORDLONG v40; // rax
  const wchar_t *CommandLineW; // rax
  void **v42; // rax
  __int64 v43; // r8
  __int64 v44; // r9
  _QWORD *v45; // rax
  __int64 v46; // rbx
  __m128i v47; // xmm6
  int v48; // ebx
  void **v49; // rax
  __int64 v50; // r8
  __int64 v51; // r9
  LPCVOID *lpData; // rcx
  __int64 v53; // rcx
  char v54; // al
  const wchar_t *v55; // rcx
  const WCHAR *v56; // rax
  DWORD CurrentProcessId; // eax
  HANDLE v58; // rax
  void *v59; // rbx
  const wchar_t *v60; // rax
  void **v61; // rax
  __int64 v62; // r8
  __int64 v63; // r9
  _QWORD *v64; // rax
  const WCHAR *v65; // rax
  signed int LastError; // ebx
  __int64 v67; // r8
  __int64 v68; // r9
  void **v69; // rax
  __int64 v70; // r8
  __int64 v71; // r9
  __int64 v72; // rax
  const WCHAR *v73; // rax
  size_t v74; // r12
  DWORD v75; // esi
  wchar_t *v76; // rbx
  signed __int64 v77; // r15
  unsigned __int64 v78; // rax
  __int64 v79; // r9
  __m128i *v80; // rdx
  const WCHAR *Hnd; // rbx
  const WCHAR *i; // rsi
  const WCHAR *v83; // rdx
  char *v84; // rbx
  char *v85; // rsi
  struct _OSVERSIONINFOEXW *v86; // rbx
  __int64 v87; // r15
  __int64 v88; // rsi
  __int64 v89; // rcx
  struct _OSVERSIONINFOEXW *v90; // rax
  __int64 v91; // rax
  bool v92; // zf
  __int64 v93; // rdx
  char *v94; // rax
  __int64 v95; // rcx
  signed __int64 v96; // r9
  __int16 v97; // r8
  char *v98; // rcx
  void *v99; // r12
  int v100; // esi
  HMODULE LibraryW; // rax
  __int64 v102; // r9
  FARPROC v103; // rax
  __int64 v104; // r8
  __int64 v105; // r9
  __int64 v106; // rax
  __int64 v107; // r9
  __int64 v108; // r8
  __int64 v109; // r9
  __int64 v110; // rax
  __int64 v111; // r9
  __int64 v112; // r8
  __int64 v113; // r9
  __int64 v114; // rax
  DWORD FileAttributesW; // ebx
  HANDLE JobObjectW; // rbx
  HANDLE CurrentProcess; // rax
  HANDLE v118; // rax
  HMODULE v119; // rax
  const wchar_t *v120; // rbx
  const wchar_t *v121; // rax
  __int64 v122; // rcx
  struct _OSVERSIONINFOEXW *v123; // rax
  __int64 v124; // rax
  __int64 v125; // rdx
  char *v126; // rcx
  __int64 v127; // rax
  char *v128; // r9
  __int16 v129; // r8
  char *v130; // rax
  __int64 v131; // rcx
  struct _OSVERSIONINFOEXW *v132; // rax
  __int64 v133; // rdi
  char *v134; // rcx
  char *v135; // rdx
  __int16 v136; // ax
  char *v137; // rax
  __int64 v138; // r9
  __int64 v139; // r8
  __int64 v140; // r9
  __int64 v141; // rax
  __int64 v142; // r9
  __int64 v143; // r8
  __int64 v144; // r9
  __int64 v145; // rax
  __int64 v146; // r9
  __int64 v147; // r8
  __int64 v148; // r9
  __int64 v149; // rax
  __int64 v150; // r9
  __int64 v151; // r8
  __int64 v152; // r9
  __int64 v153; // rax
  __int64 v154; // r9
  __int64 v155; // r8
  __int64 v156; // r9
  __int64 v157; // rax
  __int64 v158; // r9
  __int64 v159; // r8
  __int64 v160; // r9
  __int64 v161; // rax
  __int64 v162; // r9
  __int64 v163; // r8
  __int64 v164; // r9
  __int64 v165; // rax
  __int64 v166; // r9
  __int64 v167; // r8
  __int64 v168; // r9
  __int64 v169; // rax
  __int64 v170; // r9
  void (__fastcall *v171)(_QWORD); // rbx
  _QWORD *v172; // rax
  const WCHAR *v173; // rax
  const wchar_t *v174; // rax
  void **v175; // rax
  __int64 v176; // r8
  __int64 v177; // r9
  const wchar_t *v178; // rax
  void **v179; // rax
  __int64 v180; // r8
  __int64 v181; // r9
  LPCVOID *v182; // rcx
  const wchar_t *v183; // rdx
  unsigned __int64 v184; // rax
  __int64 v185; // r9
  __int64 v186; // r9
  _QWORD *v187; // rsi
  __int64 v188; // r9
  __int64 v189; // r8
  __int64 v190; // r9
  _QWORD *v191; // rdi
  __int64 v192; // r9
  __int64 v193; // r8
  __int64 v194; // r9
  _QWORD *v195; // rbx
  __int64 v196; // r9
  __int64 v197; // r8
  __int64 v198; // r9
  _QWORD *v199; // rax
  __int64 v200; // r9
  _QWORD *v201; // rax
  __int64 v202; // r9
  _QWORD *v203; // rax
  __int64 v204; // r9
  _QWORD *v205; // rax
  __int64 v206; // r9
  _QWORD *v207; // rax
  WCHAR *v208; // rcx
  void *v209; // rcx
  LPWSTR v210; // rcx
  void *v211; // rcx
  void *v212; // rcx
  void *v213; // rcx
  void *v214; // rcx
  void *v215; // rcx
  void *v216; // rcx
  void *v217; // rcx
  void *v218; // rcx
  void *v219; // rcx
  void *v220; // rcx
  const WCHAR *v221; // rdx
  __int64 v222; // rcx
  __int64 v223; // r9
  __int64 v224; // rax
  __int64 v225; // rax
  void *v226; // rcx
  _QWORD *v227; // rbx
  __int64 **v228; // rdx
  __int64 *j; // rcx
  __int64 v230; // rcx
  __int64 k; // rax
  __int64 v232; // rdx
  __int64 v233; // rcx
  __int64 v234; // r8
  __int64 v235; // rbx
  void *v236; // rbx
  _OWORD *v237; // rax
  void *v238; // rcx
  __int64 v239; // rbx
  __int64 v240; // rcx
  char v241; // al
  wchar_t *v242; // rcx
  const WCHAR *v243; // rax
  __int64 v244; // rcx
  const WCHAR *v245; // rax
  __int64 v246; // rcx
  _QWORD *v247; // rax
  _Thrd_t *v248; // rax
  _Thrd_t *v249; // rbx
  __int64 v250; // rdx
  __int64 v251; // r8
  __int64 v252; // r9
  HMODULE v253; // rax
  __int64 v254; // rcx
  void **v255; // rax
  __int64 v256; // r8
  __int64 v257; // r9
  __int64 v258; // rax
  HMODULE v259; // rbx
  void (*v260)(void); // rax
  void **v261; // rax
  __int64 v262; // r8
  __int64 v263; // r9
  __int64 v264; // rax
  HMODULE v265; // rbx
  void (*v266)(void); // rdi
  FARPROC v267; // rbx
  void *v268; // rcx
  WCHAR *v269; // rcx
  __int64 v271; // r8
  __int64 v272; // r9
  char v273[16]; // [rsp+48h] [rbp-C0h] BYREF
  __int128 v274; // [rsp+58h] [rbp-B0h] BYREF
  FARPROC v275; // [rsp+68h] [rbp-A0h] BYREF
  FARPROC v276; // [rsp+70h] [rbp-98h] BYREF
  HANDLE hObject; // [rsp+78h] [rbp-90h] BYREF
  LPCVOID lpBaseAddress; // [rsp+80h] [rbp-88h]
  __int64 v279; // [rsp+88h] [rbp-80h]
  void *v280[2]; // [rsp+98h] [rbp-70h] BYREF
  LPCVOID v281[2]; // [rsp+A8h] [rbp-60h] BYREF
  __m128i v282; // [rsp+B8h] [rbp-50h]
  wchar_t *NewFileName[2]; // [rsp+C8h] [rbp-40h] BYREF
  __m128i v284; // [rsp+D8h] [rbp-30h]
  _Thrd_t v285; // [rsp+E8h] [rbp-20h] BYREF
  __m128i si128; // [rsp+F8h] [rbp-10h]
  __int128 v287[2]; // [rsp+108h] [rbp+0h] BYREF
  void *v288[2]; // [rsp+128h] [rbp+20h] BYREF
  __m128i v289; // [rsp+138h] [rbp+30h]
  void *v290[2]; // [rsp+148h] [rbp+40h] BYREF
  __int128 v291; // [rsp+158h] [rbp+50h]
  void *v292[2]; // [rsp+168h] [rbp+60h] BYREF
  __m128i v293; // [rsp+178h] [rbp+70h]
  __int128 v294; // [rsp+188h] [rbp+80h] BYREF
  __m128i v295; // [rsp+198h] [rbp+90h]
  __int128 ExitCode; // [rsp+1A8h] [rbp+A0h] BYREF
  __m128i v297; // [rsp+1B8h] [rbp+B0h]
  __int128 v298; // [rsp+1C8h] [rbp+C0h] BYREF
  __m128i v299; // [rsp+1D8h] [rbp+D0h]
  LPWSTR lpValueName[2]; // [rsp+1E8h] [rbp+E0h] BYREF
  __m128i v301; // [rsp+1F8h] [rbp+F0h]
  void *v302[2]; // [rsp+208h] [rbp+100h] BYREF
  __m128i v303; // [rsp+218h] [rbp+110h]
  __int128 phkResult; // [rsp+228h] [rbp+120h] BYREF
  __m128i v305; // [rsp+238h] [rbp+130h]
  LPCWSTR lpValue[2]; // [rsp+248h] [rbp+140h] BYREF
  __int128 v307; // [rsp+258h] [rbp+150h]
  void *Block[2]; // [rsp+268h] [rbp+160h] BYREF
  __int128 v309; // [rsp+278h] [rbp+170h]
  void *Src[2]; // [rsp+288h] [rbp+180h] BYREF
  __m128i v311; // [rsp+298h] [rbp+190h]
  void *v312[2]; // [rsp+2A8h] [rbp+1A0h] BYREF
  __int128 v313; // [rsp+2B8h] [rbp+1B0h]
  void *v314[2]; // [rsp+2C8h] [rbp+1C0h] BYREF
  __int128 v315; // [rsp+2D8h] [rbp+1D0h]
  void *v316[2]; // [rsp+2E8h] [rbp+1E0h] BYREF
  __int128 v317; // [rsp+2F8h] [rbp+1F0h]
  __int64 v318[4]; // [rsp+308h] [rbp+200h] BYREF
  struct _OSVERSIONINFOEXW Buffer[3]; // [rsp+328h] [rbp+220h] BYREF
  WCHAR PathName[1024]; // [rsp+728h] [rbp+620h] BYREF

  v279 = -2i64;
  ModuleHandleW = GetModuleHandleW(L"kernel32.dll");
  ProcAddress = GetProcAddress(ModuleHandleW, "SetSearchPathMode");
  if ( ProcAddress )
    ((void (__fastcall *)(__int64))ProcAddress)(32769i64);
  v6 = off_146109100;
  do
  {
    v7 = (__int64)*v6;
    GetSystemDirectoryW((LPWSTR)Buffer, 0x200u);
    sub_14618AC00(Buffer, 512i64, (__int64)asc_14612C3A4);
    sub_14618AC00(Buffer, 512i64, v7);
    LoadLibraryW((LPCWSTR)Buffer);
    ++v6;
  }
  while ( v6 != (wchar_t **)&unk_1461091A0 );
  v8 = getenv("CitizenFX_ToolMode");
  v280[0] = v8;
  sub_146187360();
  unlink("CitizenFX.exe.new");
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611E150);
  strcpy((char *)&v285, "CfxInitState");
  *((_BYTE *)&v285._Id + 5) = 0;
  *((_WORD *)&v285._Id + 3) = 0;
  sub_146166700((__int64)&hObject, (__int64 *)&v285);
  if ( si128.m128i_i64[1] > 0xFui64 )
    sub_146173950((__int64)&v285, v285._Hnd, si128.m128i_i64[1]);
  si128 = _mm_load_si128((const __m128i *)&Size);
  LOBYTE(v285._Hnd) = 0;
  v9 = (char *)lpBaseAddress;
  wcsncpy((wchar_t *)lpBaseAddress + 6152, L"fivem", 0x1Fui64);
  GetEnvironmentVariableW(L"PATH", String, 0x8000u);
  *(_OWORD *)NewFileName = 0i64;
  v284 = 0i64;
  v10 = wcslen(String);
  sub_146168F30(NewFileName, String, v10, v11);
  v12 = (wchar_t *)&Default;
  v13 = (void **)sub_146186230(v287, &Default);
  v16 = (_QWORD *)sub_1461645B0((__int64)v290, v13, v14, v15);
  v17 = (void **)sub_146186230(&v294, L"bin");
  v20 = (_QWORD *)sub_1461645B0((__int64)Src, v17, v18, v19);
  v21 = (_QWORD *)sub_14617D9A0((__int64)v288, v20, L";");
  sub_146185BD0((char *)v292, (unsigned __int8)v273[0], v21, v16);
  v22 = (_QWORD *)sub_14617D9A0((__int64)lpValueName, v292, L";");
  sub_146185BD0((char *)lpValue, (unsigned __int8)v273[0], v22, NewFileName);
  sub_146162730((__int64)lpValueName);
  sub_146162730((__int64)v292);
  sub_146162730((__int64)v288);
  sub_146162730((__int64)Src);
  sub_146162730((__int64)v290);
  sub_146162730((__int64)NewFileName);
  v23 = (const WCHAR *)lpValue;
  if ( *((_QWORD *)&v307 + 1) > 7ui64 )
    v23 = lpValue[0];
  SetEnvironmentVariableW(L"PATH", v23);
  v24 = (void **)sub_146186230(NewFileName, L"bin");
  v27 = sub_1461645B0((__int64)v281, v24, v25, v26);
  if ( *(_QWORD *)(v27 + 24) > 7ui64 )
    v27 = *(_QWORD *)v27;
  SetDllDirectoryW((LPCWSTR)v27);
  sub_146162730((__int64)v281);
  v28 = (void **)sub_146186230(NewFileName, L"CitiLaunch_TLSDummy.dll");
  v31 = sub_1461645B0((__int64)v281, v28, v29, v30);
  if ( *(_QWORD *)(v31 + 24) > 7ui64 )
    v31 = *(_QWORD *)v31;
  hModule = LoadLibraryW((LPCWSTR)v31);
  sub_146162730((__int64)v281);
  GetCurrentDirectoryW(0x400u, PathName);
  if ( !v8 )
  {
    v32 = (void **)sub_146186230(NewFileName, &Default);
    v35 = sub_1461645B0((__int64)v281, v32, v33, v34);
    if ( *(_QWORD *)(v35 + 24) > 7ui64 )
      v35 = *(_QWORD *)v35;
    SetCurrentDirectoryW((LPCWSTR)v35);
    sub_146162730((__int64)v281);
  }
  v36 = GetModuleHandleW(L"kernel32.dll");
  v276 = GetProcAddress(v36, "AddDllDirectory");
  v37 = GetModuleHandleW(L"kernel32.dll");
  v275 = GetProcAddress(v37, "SetDefaultDllDirectories");
  wcscpy((wchar_t *)Buffer, L"");
  *(_QWORD *)&Buffer[0].dwBuildNumber = 0i64;
  memset(Buffer[0].szCSDVersion, 0, sizeof(Buffer[0].szCSDVersion));
  Buffer[0].wServicePackMinor = 0;
  *(_DWORD *)&Buffer[0].wSuiteMask = 0;
  v38 = VerSetConditionMask(0i64, 2u, 3u);
  v39 = VerSetConditionMask(v38, 1u, 3u);
  v40 = VerSetConditionMask(v39, 0x20u, 3u);
  Buffer[0].dwMajorVersion = 6;
  Buffer[0].dwMinorVersion = 2;
  Buffer[0].wServicePackMajor = 0;
  if ( !VerifyVersionInfoW(Buffer, 0x23u, v40) )
  {
    if ( v8 )
    {
      CommandLineW = GetCommandLineW();
      if ( wcsstr(CommandLineW, L"ros:legit") )
        v275 = 0i64;
    }
  }
  *(_QWORD *)&v298 = &v276;
  *((_QWORD *)&v298 + 1) = &v275;
  sub_146186FF0((void (__fastcall ***)(_QWORD *))&v298);
  v42 = (void **)sub_146186230(NewFileName, &Default);
  v45 = (_QWORD *)sub_1461645B0((__int64)v281, v42, v43, v44);
  v46 = sub_14618E3C0(v45, L"cache\\subprocess", 0i64);
  sub_146162730((__int64)v281);
  v47 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  if ( v46 != -1 )
  {
    v48 = 0;
    goto LABEL_319;
  }
  v49 = (void **)sub_146186230(NewFileName, &Default);
  sub_1461645B0((__int64)v281, v49, v50, v51);
  lpData = v281;
  if ( v282.m128i_i64[1] > 7ui64 )
    lpData = (LPCVOID *)v281[0];
  RegSetKeyValueW(
    HKEY_CURRENT_USER,
    L"SOFTWARE\\CitizenFX\\ChanCity",
    L"Last Run Location",
    1u,
    lpData,
    2 * v282.m128i_i32[0] + 2);
  sub_146162730((__int64)v281);
  NewFileName[0] = L"ChanCity";
  NewFileName[1] = (wchar_t *)v274;
  v54 = sub_1461883F0(v53);
  v55 = L"Client";
  if ( v54 )
    v55 = L"SDK";
  v284.m128i_i64[0] = (__int64)v55;
  v284.m128i_i64[1] = v274;
  *(_QWORD *)&v274 = 204i64;
  *((_QWORD *)&v274 + 1) = NewFileName;
  *(_QWORD *)&phkResult = L"CitizenFX.%s.%s";
  *((_QWORD *)&phkResult + 1) = 15i64;
  v56 = (const WCHAR *)sub_1461A30F0(&phkResult, &v274);
  SetCurrentProcessExplicitAppUserModelID(v56);
  CurrentProcessId = *((_DWORD *)v9 + 1);
  if ( !CurrentProcessId )
  {
    CurrentProcessId = GetCurrentProcessId();
    *((_DWORD *)v9 + 1) = CurrentProcessId;
  }
  v58 = OpenProcess(0x1000u, 0, CurrentProcessId);
  v59 = v58;
  if ( v58 )
  {
    LODWORD(ExitCode) = 259;
    GetExitCodeProcess(v58, (LPDWORD)&ExitCode);
    if ( (_DWORD)ExitCode != 259 )
      *((_DWORD *)v9 + 1) = GetCurrentProcessId();
    CloseHandle(v59);
  }
  else
  {
    *((_DWORD *)v9 + 1) = GetCurrentProcessId();
  }
  if ( !*((_DWORD *)v9 + 1) )
    *((_DWORD *)v9 + 1) = GetCurrentProcessId();
  if ( *((_DWORD *)v9 + 1) == GetCurrentProcessId() )
  {
    v60 = GetCommandLineW();
    wcsncpy((wchar_t *)v9 + 4104, v60, 0x7FFui64);
  }
  *(_QWORD *)&v274 = 0i64;
  if ( !hModule )
  {
    v61 = (void **)sub_146186230(v287, L"CitiLaunch_TLSDummy.dll");
    v64 = (_QWORD *)sub_1461645B0((__int64)v292, v61, v62, v63);
    v65 = (const WCHAR *)sub_14618BC90(v64);
    hModule = LoadLibraryW(v65);
    sub_146162730((__int64)v292);
    if ( !hModule )
    {
      LastError = GetLastError();
      *(_OWORD *)v290 = *(_OWORD *)sub_146178670((const char **)&v285, "TLS DLL");
      sub_1461878C0(LastError, (__m128i *)v290, v67, v68);
      if ( !hModule )
        sub_1461A1C30(
          (wchar_t *)L"tlsDll",
          (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\code\\client\\launcher\\Main.cpp",
          436);
    }
  }
  if ( !RegOpenKeyW(
          HKEY_CURRENT_USER,
          L"Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Layers",
          (PHKEY)&phkResult) )
  {
    sub_146185EC0(lpValueName, 0x8000ui64, (__int64)v273);
    v69 = (void **)sub_146186230(v287, &Default);
    v72 = sub_1461645B0((__int64)v292, v69, v70, v71);
    sub_146185B90((__int64)NewFileName, v72);
    sub_146162730((__int64)v292);
    if ( sub_14618E3C0(NewFileName, L".app", 0i64) != -1 )
      sub_146187600(NewFileName, L"..\\");
    v73 = (const WCHAR *)sub_14618BC90(NewFileName);
    GetFullPathNameW(v73, 0x200u, (LPWSTR)Buffer, 0i64);
    v74 = wcslen((const wchar_t *)Buffer);
    v285 = 0i64;
    si128.m128i_i64[0] = 0i64;
    v75 = 0;
    v76 = lpValueName[0];
    v77 = lpValueName[1] - lpValueName[0];
    LODWORD(ExitCode) = v77;
    if ( !RegEnumValueW((HKEY)phkResult, 0, lpValueName[0], (LPDWORD)&ExitCode, 0i64, 0i64, 0i64, 0i64) )
    {
      do
      {
        if ( !wcsnicmp(v76, (const wchar_t *)Buffer, v74) )
        {
          *(_OWORD *)v288 = 0i64;
          v289 = 0i64;
          v78 = wcslen(v76);
          sub_146168F30(v288, v76, v78, v79);
          v80 = *(__m128i **)&v285._Id;
          if ( *(_QWORD *)&v285._Id == si128.m128i_i64[0] )
          {
            sub_14617F010((__int64 *)&v285, *(__int64 *)&v285._Id, (__int64)v288);
          }
          else
          {
            **(_OWORD **)&v285._Id = *(_OWORD *)v288;
            v80[1] = v289;
            v289 = v47;
            LOWORD(v288[0]) = 0;
            *(_QWORD *)&v285._Id += 32i64;
          }
          sub_146162730((__int64)v288);
        }
        ++v75;
        LODWORD(ExitCode) = v77;
      }
      while ( !RegEnumValueW((HKEY)phkResult, v75, v76, (LPDWORD)&ExitCode, 0i64, 0i64, 0i64, 0i64) );
      v9 = (char *)lpBaseAddress;
    }
    Hnd = (const WCHAR *)v285._Hnd;
    for ( i = *(const WCHAR **)&v285._Id; Hnd != i; Hnd += 16 )
    {
      v83 = Hnd;
      if ( *((_QWORD *)Hnd + 3) > 7ui64 )
        v83 = *(const WCHAR **)Hnd;
      RegDeleteValueW((HKEY)phkResult, v83);
    }
    RegCloseKey((HKEY)phkResult);
    v84 = (char *)v285._Hnd;
    if ( v285._Hnd )
    {
      v85 = *(char **)&v285._Id;
      if ( v285._Hnd != *(void **)&v285._Id )
      {
        do
        {
          sub_146162730((__int64)v84);
          v84 += 32;
        }
        while ( v84 != v85 );
        v84 = (char *)v285._Hnd;
      }
      sub_14618BD00((__int64)&v285, v84, (si128.m128i_i64[0] - (__int64)v84) >> 5);
      v285 = 0i64;
      si128.m128i_i64[0] = 0i64;
    }
    sub_146162730((__int64)NewFileName);
    sub_14618B820((__int64)lpValueName);
  }
  sub_146186FF0((void (__fastcall ***)(_QWORD *))&v298);
  if ( !*((_DWORD *)v9 + 1) )
    *((_DWORD *)v9 + 1) = GetCurrentProcessId();
  if ( *((_DWORD *)v9 + 1) == GetCurrentProcessId() )
    sub_146194AE0();
  if ( InitializeExceptionHandler() )
    goto LABEL_318;
  sub_146172E80();
  v318[0] = (__int64)L"\\dinput8.dll";
  v318[1] = (__int64)L"\\dsound.dll";
  v318[2] = (__int64)L"\\xinput1_4.dll";
  v318[3] = (__int64)L"\\version.dll";
  v86 = (struct _OSVERSIONINFOEXW *)v318;
  v87 = 2147483646i64;
  do
  {
    v88 = *(_QWORD *)&v86->dwOSVersionInfoSize;
    GetSystemDirectoryW((LPWSTR)Buffer, 0x200u);
    v89 = 512i64;
    v90 = Buffer;
    do
    {
      if ( !LOWORD(v90->dwOSVersionInfoSize) )
        break;
      v90 = (struct _OSVERSIONINFOEXW *)((char *)v90 + 2);
      --v89;
    }
    while ( v89 );
    v91 = 512 - v89;
    if ( v89 )
    {
      v93 = v89;
      v92 = v91 == 512;
      v94 = (char *)Buffer + 2 * v91;
      if ( !v92 )
      {
        v95 = 2147483646i64;
        v96 = (char *)asc_14612C3A4 - v94;
        do
        {
          if ( !v95 )
            break;
          v97 = *(_WORD *)&v94[v96];
          if ( !v97 )
            break;
          *(_WORD *)v94 = v97;
          v94 += 2;
          --v95;
          --v93;
        }
        while ( v93 );
      }
      v98 = v94 - 2;
      if ( v93 )
        v98 = v94;
      *(_WORD *)v98 = 0;
    }
    sub_14618AC00(Buffer, 512i64, v88);
    LoadLibraryW((LPCWSTR)Buffer);
    v86 = (struct _OSVERSIONINFOEXW *)((char *)v86 + 8);
  }
  while ( v86 != Buffer );
  v99 = v280[0];
  if ( !*((_DWORD *)v9 + 1) )
    *((_DWORD *)v9 + 1) = GetCurrentProcessId();
  v100 = 9;
  if ( *((_DWORD *)v9 + 1) == GetCurrentProcessId() )
  {
    LibraryW = LoadLibraryW(L"shcore.dll");
    if ( LibraryW )
    {
      v103 = GetProcAddress(LibraryW, "SetProcessDpiAwareness");
      if ( v103 )
        ((void (__fastcall *)(__int64))v103)(2i64);
    }
    *(_OWORD *)v281 = 0i64;
    v282 = 0ui64;
    sub_146168F30(v281, L"data\\cache\\crashometry", 0x16ui64, v102);
    v106 = sub_1461645B0((__int64)v287, (void **)v281, v104, v105);
    if ( *(_QWORD *)(v106 + 24) > 7ui64 )
      v106 = *(_QWORD *)v106;
    wunlink((const wchar_t *)v106);
    sub_146162730((__int64)v287);
    *(_OWORD *)v281 = 0i64;
    v282 = 0ui64;
    sub_146168F30(v281, L"data\\cache\\error_out", 0x14ui64, v107);
    v110 = sub_1461645B0((__int64)v287, (void **)v281, v108, v109);
    if ( *(_QWORD *)(v110 + 24) > 7ui64 )
      v110 = *(_QWORD *)v110;
    wunlink((const wchar_t *)v110);
    sub_146162730((__int64)v287);
    *(_OWORD *)v281 = 0i64;
    v282 = 0ui64;
    sub_146168F30(v281, L"permalauncher", 0xDui64, v111);
    v114 = sub_1461645B0((__int64)v287, (void **)v281, v112, v113);
    if ( *(_QWORD *)(v114 + 24) > 7ui64 )
      v114 = *(_QWORD *)v114;
    FileAttributesW = GetFileAttributesW((LPCWSTR)v114);
    sub_146162730((__int64)v287);
    if ( FileAttributesW == -1 )
    {
      JobObjectW = CreateJobObjectW(0i64, 0i64);
      if ( JobObjectW )
      {
        CurrentProcess = GetCurrentProcess();
        if ( AssignProcessToJobObject(JobObjectW, CurrentProcess) )
        {
          memset(Buffer, 0, 144);
          Buffer[0].dwPlatformId = 10240;
          if ( SetInformationJobObject(JobObjectW, JobObjectExtendedLimitInformation, Buffer, 0x90u) )
            v9[12] = 1;
        }
      }
    }
  }
  if ( v9[12] )
  {
    v118 = GetCurrentProcess();
    IsProcessInJob(v118, 0i64, (PBOOL)&ExitCode);
    if ( !(_DWORD)ExitCode )
    {
      v119 = GetModuleHandleW(0i64);
      GetModuleFileNameW(v119, (LPWSTR)Buffer, 0x104u);
      if ( !wcsstr((const wchar_t *)Buffer, L"subprocess") )
      {
        if ( !wcslen((const wchar_t *)v9 + 6152) )
          sub_1461A1C30(
            (wchar_t *)L"wcslen(linkProtocol)",
            (wchar_t *)L"F:\\NewBuildFivem\\LauncherGTA\\code\\client\\shared\\CfxState.h",
            59);
        NewFileName[0] = (wchar_t *)(v9 + 12304);
        NewFileName[1] = (wchar_t *)v274;
        v284.m128i_i64[0] = (__int64)L"://";
        v284.m128i_i64[1] = v274;
        *(_QWORD *)&v298 = 204i64;
        *((_QWORD *)&v298 + 1) = NewFileName;
        v280[0] = L"%s%s";
        v280[1] = (void *)4;
        v120 = (const wchar_t *)sub_1461A30F0((__int128 *)v280, &v298);
        v121 = GetCommandLineW();
        if ( !wcsstr(v121, v120) )
        {
LABEL_318:
          v48 = 0;
          goto LABEL_319;
        }
      }
    }
  }
  sub_146194A90();
  unknown_libname_17(v280);
  if ( BYTE4(v280[0]) )
  {
    v48 = (int)v280[0];
    goto LABEL_319;
  }
  sub_14617DA20((__int64)v273, (__int64)L"\\dxgi.dll");
  sub_14617DA20((__int64)v273, (__int64)L"\\d3d11.dll");
  sub_14617DA20((__int64)v273, (__int64)L"\\d3d9.dll");
  sub_14617DA20((__int64)v273, (__int64)L"\\d3d10.dll");
  GetSystemDirectoryW((LPWSTR)Buffer, 0x200u);
  sub_14618AC00(Buffer, 512i64, (__int64)asc_14612C3A4);
  v122 = 512i64;
  v123 = Buffer;
  do
  {
    if ( !LOWORD(v123->dwOSVersionInfoSize) )
      break;
    v123 = (struct _OSVERSIONINFOEXW *)((char *)v123 + 2);
    --v122;
  }
  while ( v122 );
  v124 = 512 - v122;
  if ( v122 )
  {
    v125 = v122;
    v126 = (char *)Buffer + 2 * v124;
    if ( v124 != 512 )
    {
      v127 = 2147483646i64;
      v128 = (char *)((char *)L"\\d3d10_1.dll" - v126);
      do
      {
        if ( !v127 )
          break;
        v129 = *(_WORD *)&v128[(_QWORD)v126];
        if ( !v129 )
          break;
        *(_WORD *)v126 = v129;
        v126 += 2;
        --v127;
        --v125;
      }
      while ( v125 );
    }
    v130 = v126 - 2;
    if ( v125 )
      v130 = v126;
    *(_WORD *)v130 = 0;
  }
  LoadLibraryW((LPCWSTR)Buffer);
  GetSystemDirectoryW((LPWSTR)Buffer, 0x200u);
  sub_14618AC00(Buffer, 512i64, (__int64)asc_14612C3A4);
  v131 = 512i64;
  v132 = Buffer;
  do
  {
    if ( !LOWORD(v132->dwOSVersionInfoSize) )
      break;
    v132 = (struct _OSVERSIONINFOEXW *)((char *)v132 + 2);
    --v131;
  }
  while ( v131 );
  if ( v131 )
  {
    v133 = v131;
    v134 = (char *)Buffer + 2 * (512 - v131);
    v135 = (char *)((char *)L"\\opengl32.dll" - v134);
    do
    {
      if ( !v87 )
        break;
      v136 = *(_WORD *)&v135[(_QWORD)v134];
      if ( !v136 )
        break;
      *(_WORD *)v134 = v136;
      v134 += 2;
      --v87;
      --v133;
    }
    while ( v133 );
    v137 = v134 - 2;
    if ( v133 )
      v137 = v134;
    *(_WORD *)v137 = 0;
  }
  LoadLibraryW((LPCWSTR)Buffer);
  *(_OWORD *)v281 = 0i64;
  v282 = 0ui64;
  sub_146168F30(v281, L"botan.dll", 9ui64, v138);
  v141 = sub_1461645B0((__int64)v287, (void **)v281, v139, v140);
  if ( *(_QWORD *)(v141 + 24) > 7ui64 )
    v141 = *(_QWORD *)v141;
  LoadLibraryW((LPCWSTR)v141);
  sub_146162730((__int64)v287);
  *(_OWORD *)v281 = 0i64;
  v282 = 0ui64;
  sub_146168F30(v281, L"dinput8.dll", 0xBui64, v142);
  v145 = sub_1461645B0((__int64)v287, (void **)v281, v143, v144);
  if ( *(_QWORD *)(v145 + 24) > 7ui64 )
    v145 = *(_QWORD *)v145;
  LoadLibraryW((LPCWSTR)v145);
  sub_146162730((__int64)v287);
  *(_OWORD *)v281 = 0i64;
  v282 = 0ui64;
  sub_146168F30(v281, L"steam_api64.dll", 0xFui64, v146);
  v149 = sub_1461645B0((__int64)v287, (void **)v281, v147, v148);
  if ( *(_QWORD *)(v149 + 24) > 7ui64 )
    v149 = *(_QWORD *)v149;
  LoadLibraryW((LPCWSTR)v149);
  sub_146162730((__int64)v287);
  *(_OWORD *)v281 = 0i64;
  v282 = 0ui64;
  sub_146168F30(v281, L"bin/icuuc.dll", 0xDui64, v150);
  v153 = sub_1461645B0((__int64)v287, (void **)v281, v151, v152);
  if ( *(_QWORD *)(v153 + 24) > 7ui64 )
    v153 = *(_QWORD *)v153;
  LoadLibraryW((LPCWSTR)v153);
  sub_146162730((__int64)v287);
  *(_OWORD *)v281 = 0i64;
  v282 = 0ui64;
  sub_146168F30(v281, L"bin/icui18n.dll", 0xFui64, v154);
  v157 = sub_1461645B0((__int64)v287, (void **)v281, v155, v156);
  if ( *(_QWORD *)(v157 + 24) > 7ui64 )
    v157 = *(_QWORD *)v157;
  LoadLibraryW((LPCWSTR)v157);
  sub_146162730((__int64)v287);
  *(_OWORD *)v281 = 0i64;
  v282 = 0ui64;
  sub_146168F30(v281, L"v8_libplatform.dll", 0x12ui64, v158);
  v161 = sub_1461645B0((__int64)v287, (void **)v281, v159, v160);
  if ( *(_QWORD *)(v161 + 24) > 7ui64 )
    v161 = *(_QWORD *)v161;
  LoadLibraryW((LPCWSTR)v161);
  sub_146162730((__int64)v287);
  *(_OWORD *)v281 = 0i64;
  v282 = 0ui64;
  sub_146168F30(v281, L"v8_libbase.dll", 0xEui64, v162);
  v165 = sub_1461645B0((__int64)v287, (void **)v281, v163, v164);
  if ( *(_QWORD *)(v165 + 24) > 7ui64 )
    v165 = *(_QWORD *)v165;
  LoadLibraryW((LPCWSTR)v165);
  sub_146162730((__int64)v287);
  *(_OWORD *)v281 = 0i64;
  v282 = 0ui64;
  sub_146168F30(v281, L"v8.dll", 6ui64, v166);
  v169 = sub_1461645B0((__int64)v287, (void **)v281, v167, v168);
  if ( *(_QWORD *)(v169 + 24) > 7ui64 )
    v169 = *(_QWORD *)v169;
  LoadLibraryW((LPCWSTR)v169);
  sub_146162730((__int64)v287);
  v171 = (void (__fastcall *)(_QWORD))v276;
  if ( v276 )
  {
    *(_OWORD *)v281 = 0i64;
    v282 = 0ui64;
    sub_146168F30(v281, &Default, 0i64, v170);
    v172 = (_QWORD *)sub_146188490((__int64)v287, (void **)v281);
    if ( v172[3] > 7ui64 )
      v172 = (_QWORD *)*v172;
    v171(v172);
    sub_146162730((__int64)v287);
  }
  if ( !v99 && !OpenMutexW(0x100000u, 0, L"CitizenFX_LogMutex") )
  {
    CreateMutexW(0i64, 1, L"CitizenFX_LogMutex");
    do
    {
      if ( v100 )
      {
        LODWORD(Src[0]) = v100;
        *(_OWORD *)v280 = *(_OWORD *)Src;
        *(_QWORD *)&v298 = 1i64;
        *((_QWORD *)&v298 + 1) = v280;
        *(_QWORD *)&phkResult = L".%d";
        *((_QWORD *)&phkResult + 1) = 3i64;
        v173 = (const WCHAR *)sub_1461A30F0(&phkResult, &v298);
      }
      else
      {
        v173 = &Default;
      }
      v288[0] = (void *)v173;
      *(_OWORD *)v280 = *(_OWORD *)v288;
      *(_QWORD *)&ExitCode = 12i64;
      *((_QWORD *)&ExitCode + 1) = v280;
      v312[0] = L"CitizenFX.log%s";
      v312[1] = (void *)15;
      v174 = (const wchar_t *)sub_1461A30F0((__int128 *)v312, &ExitCode);
      v175 = (void **)sub_146186230(v287, v174);
      sub_1461645B0((__int64)&v294, v175, v176, v177);
      *(_OWORD *)v281 = v294;
      v282 = v295;
      v295 = v47;
      LOWORD(v294) = 0;
      sub_146162730((__int64)&v294);
      LODWORD(lpValueName[0]) = v100 + 1;
      *(_OWORD *)v280 = *(_OWORD *)lpValueName;
      v314[0] = (void *)1;
      v314[1] = v280;
      v316[0] = L".%d";
      v316[1] = (void *)3;
      v285._Hnd = (void *)sub_1461A30F0((__int128 *)v316, (__int128 *)v314);
      *(_Thrd_t *)v280 = v285;
      Block[0] = (void *)12;
      Block[1] = v280;
      v290[0] = L"CitizenFX.log%s";
      v290[1] = (void *)15;
      v178 = (const wchar_t *)sub_1461A30F0((__int128 *)v290, (__int128 *)Block);
      v179 = (void **)sub_146186230(v287, v178);
      sub_1461645B0((__int64)&v294, v179, v180, v181);
      *(_OWORD *)NewFileName = v294;
      v284 = v295;
      v295 = v47;
      LOWORD(v294) = 0;
      sub_146162730((__int64)&v294);
      v182 = v281;
      if ( v100 == 9 )
      {
        if ( v282.m128i_i64[1] > 7ui64 )
          v182 = (LPCVOID *)v281[0];
        wunlink((const wchar_t *)v182);
      }
      else
      {
        v183 = (const wchar_t *)NewFileName;
        if ( v284.m128i_i64[1] > 7ui64 )
          v183 = NewFileName[0];
        if ( v282.m128i_i64[1] > 7ui64 )
          v182 = (LPCVOID *)v281[0];
        wrename((const wchar_t *)v182, v183);
      }
      sub_146162730((__int64)NewFileName);
      sub_146162730((__int64)v281);
      --v100;
    }
    while ( v100 >= 0 );
  }
  if ( !*((_DWORD *)v9 + 1) )
    *((_DWORD *)v9 + 1) = GetCurrentProcessId();
  if ( *((_DWORD *)v9 + 1) == GetCurrentProcessId() )
    GetModuleFileNameW(0i64, (LPWSTR)v9 + 3080, 0x400u);
  *(_OWORD *)v290 = 0i64;
  v291 = 0i64;
  v184 = wcslen(String);
  sub_146168F30(v290, String, v184, v185);
  *(_OWORD *)NewFileName = 0i64;
  v284 = 0ui64;
  sub_146168F30(NewFileName, &Default, 0i64, v186);
  v187 = (_QWORD *)sub_146188490((__int64)v292, (void **)NewFileName);
  v294 = 0i64;
  v295 = 0ui64;
  sub_146168F30(&v294, &Default, 0i64, v188);
  v191 = (_QWORD *)sub_1461645B0((__int64)&ExitCode, (void **)&v294, v189, v190);
  *(_OWORD *)v281 = 0i64;
  v282 = 0ui64;
  sub_146168F30(v281, L"bin", 3ui64, v192);
  v195 = (_QWORD *)sub_1461645B0((__int64)&phkResult, (void **)v281, v193, v194);
  v285 = 0i64;
  si128 = 0ui64;
  sub_146168F30(&v285, L"bin\\crt", 7ui64, v196);
  v199 = (_QWORD *)sub_1461645B0((__int64)&v298, &v285._Hnd, v197, v198);
  v201 = sub_1461653F0(v199, L";", 1ui64, v200);
  *(_OWORD *)v312 = *(_OWORD *)v201;
  v313 = *((_OWORD *)v201 + 1);
  v201[2] = 0i64;
  v201[3] = 7i64;
  *(_WORD *)v201 = 0;
  sub_146185BD0((char *)Src, (unsigned __int8)v273[0], v312, v195);
  v203 = sub_1461653F0(Src, L";", 1ui64, v202);
  *(_OWORD *)v314 = *(_OWORD *)v203;
  v315 = *((_OWORD *)v203 + 1);
  v203[2] = 0i64;
  v203[3] = 7i64;
  *(_WORD *)v203 = 0;
  sub_146185BD0((char *)v288, (unsigned __int8)v273[0], v314, v191);
  v205 = sub_1461653F0(v288, L";", 1ui64, v204);
  *(_OWORD *)v316 = *(_OWORD *)v205;
  v317 = *((_OWORD *)v205 + 1);
  v205[2] = 0i64;
  v205[3] = 7i64;
  *(_WORD *)v205 = 0;
  sub_146185BD0((char *)lpValueName, (unsigned __int8)v273[0], v316, v187);
  v207 = sub_1461653F0(lpValueName, L"; ", 2ui64, v206);
  *(_OWORD *)Block = *(_OWORD *)v207;
  v309 = *((_OWORD *)v207 + 1);
  v207[2] = 0i64;
  v207[3] = 7i64;
  *(_WORD *)v207 = 0;
  sub_146185BD0((char *)v287, (unsigned __int8)v273[0], Block, v290);
  if ( *((_QWORD *)&v307 + 1) > 7ui64 )
  {
    v208 = (WCHAR *)lpValue[0];
    if ( (unsigned __int64)(2i64 * *((_QWORD *)&v307 + 1) + 2) >= 0x1000 )
    {
      v208 = (WCHAR *)*((_QWORD *)lpValue[0] - 1);
      if ( (unsigned __int64)((char *)lpValue[0] - (char *)v208 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v208);
  }
  *(_OWORD *)lpValue = v287[0];
  v307 = v287[1];
  if ( *((_QWORD *)&v309 + 1) > 7ui64 )
  {
    v209 = Block[0];
    if ( (unsigned __int64)(2i64 * *((_QWORD *)&v309 + 1) + 2) >= 0x1000 )
    {
      v209 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v209 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v209);
  }
  if ( v301.m128i_i64[1] > 7ui64 )
  {
    v210 = lpValueName[0];
    if ( (unsigned __int64)(2 * v301.m128i_i64[1] + 2) >= 0x1000 )
    {
      v210 = (LPWSTR)*((_QWORD *)lpValueName[0] - 1);
      if ( (unsigned __int64)((char *)lpValueName[0] - (char *)v210 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v210);
  }
  v301 = v47;
  LOWORD(lpValueName[0]) = 0;
  if ( *((_QWORD *)&v317 + 1) > 7ui64 )
  {
    v211 = v316[0];
    if ( (unsigned __int64)(2i64 * *((_QWORD *)&v317 + 1) + 2) >= 0x1000 )
    {
      v211 = (void *)*((_QWORD *)v316[0] - 1);
      if ( (unsigned __int64)(v316[0] - v211 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v211);
  }
  if ( v289.m128i_i64[1] > 7ui64 )
  {
    v212 = v288[0];
    if ( (unsigned __int64)(2 * v289.m128i_i64[1] + 2) >= 0x1000 )
    {
      v212 = (void *)*((_QWORD *)v288[0] - 1);
      if ( (unsigned __int64)(v288[0] - v212 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v212);
  }
  v289 = v47;
  LOWORD(v288[0]) = 0;
  if ( *((_QWORD *)&v315 + 1) > 7ui64 )
  {
    v213 = v314[0];
    if ( (unsigned __int64)(2i64 * *((_QWORD *)&v315 + 1) + 2) >= 0x1000 )
    {
      v213 = (void *)*((_QWORD *)v314[0] - 1);
      if ( (unsigned __int64)(v314[0] - v213 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v213);
  }
  if ( v311.m128i_i64[1] > 7ui64 )
  {
    v214 = Src[0];
    if ( (unsigned __int64)(2 * v311.m128i_i64[1] + 2) >= 0x1000 )
    {
      v214 = (void *)*((_QWORD *)Src[0] - 1);
      if ( (unsigned __int64)(Src[0] - v214 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v214);
  }
  v311 = v47;
  LOWORD(Src[0]) = 0;
  if ( *((_QWORD *)&v313 + 1) > 7ui64 )
  {
    v215 = v312[0];
    if ( (unsigned __int64)(2i64 * *((_QWORD *)&v313 + 1) + 2) >= 0x1000 )
    {
      v215 = (void *)*((_QWORD *)v312[0] - 1);
      if ( (unsigned __int64)(v312[0] - v215 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v215);
  }
  if ( v299.m128i_i64[1] > 7ui64 )
  {
    v216 = (void *)v298;
    if ( (unsigned __int64)(2 * v299.m128i_i64[1] + 2) >= 0x1000 )
    {
      v216 = *(void **)(v298 - 8);
      if ( (unsigned __int64)(v298 - (_QWORD)v216 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v216);
  }
  v299 = v47;
  LOWORD(v298) = 0;
  if ( v305.m128i_i64[1] > 7ui64 )
  {
    v217 = (void *)phkResult;
    if ( (unsigned __int64)(2 * v305.m128i_i64[1] + 2) >= 0x1000 )
    {
      v217 = *(void **)(phkResult - 8);
      if ( (unsigned __int64)(phkResult - (_QWORD)v217 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v217);
  }
  v305 = v47;
  LOWORD(phkResult) = 0;
  if ( v297.m128i_i64[1] > 7ui64 )
  {
    v218 = (void *)ExitCode;
    if ( (unsigned __int64)(2 * v297.m128i_i64[1] + 2) >= 0x1000 )
    {
      v218 = *(void **)(ExitCode - 8);
      if ( (unsigned __int64)(ExitCode - (_QWORD)v218 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v218);
  }
  v297 = v47;
  LOWORD(ExitCode) = 0;
  if ( v293.m128i_i64[1] > 7ui64 )
  {
    v219 = v292[0];
    if ( (unsigned __int64)(2 * v293.m128i_i64[1] + 2) >= 0x1000 )
    {
      v219 = (void *)*((_QWORD *)v292[0] - 1);
      if ( (unsigned __int64)(v292[0] - v219 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v219);
  }
  v293 = v47;
  LOWORD(v292[0]) = 0;
  if ( *((_QWORD *)&v291 + 1) > 7ui64 )
  {
    v220 = v290[0];
    if ( (unsigned __int64)(2i64 * *((_QWORD *)&v291 + 1) + 2) >= 0x1000 )
    {
      v220 = (void *)*((_QWORD *)v290[0] - 1);
      if ( (unsigned __int64)(v290[0] - v220 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v220);
  }
  v221 = (const WCHAR *)lpValue;
  if ( *((_QWORD *)&v307 + 1) > 7ui64 )
    v221 = lpValue[0];
  SetEnvironmentVariableW(L"PATH", v221);
  if ( (unsigned __int8)sub_1461883F0(v222) )
  {
    SetCurrentDirectoryW(PathName);
  }
  else if ( !v99 )
  {
    *(_OWORD *)NewFileName = 0i64;
    v284 = 0ui64;
    sub_146168F30(NewFileName, &Default, 0i64, v223);
    v224 = sub_146188490((__int64)v287, (void **)NewFileName);
    if ( *(_QWORD *)(v224 + 24) > 7ui64 )
      v224 = *(_QWORD *)v224;
    SetCurrentDirectoryW((LPCWSTR)v224);
    sub_146162730((__int64)v287);
  }
  *(_OWORD *)NewFileName = 0i64;
  v284 = 0ui64;
  sub_146168F30(NewFileName, L"GTA5.exe", 8ui64, v223);
  v225 = sub_146188490((__int64)v292, (void **)NewFileName);
  *(_OWORD *)v302 = 0i64;
  v303 = 0i64;
  *(_OWORD *)v302 = *(_OWORD *)v225;
  v303 = *(__m128i *)(v225 + 16);
  *(_QWORD *)(v225 + 16) = 0i64;
  *(_QWORD *)(v225 + 24) = 7i64;
  *(_WORD *)v225 = 0;
  if ( v293.m128i_i64[1] > 7ui64 )
  {
    v226 = v292[0];
    if ( (unsigned __int64)(2 * v293.m128i_i64[1] + 2) >= 0x1000 )
    {
      v226 = (void *)*((_QWORD *)v292[0] - 1);
      if ( (unsigned __int64)(v292[0] - v226 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v226);
  }
  v293 = v47;
  LOWORD(v292[0]) = 0;
  if ( sub_146176900() )
  {
    sub_146179E30((__int64)v280);
    if ( !v280[1] )
    {
      sub_146177D60((__int64)v280, (__int64)v280, *((_QWORD *)v280[0] + 1));
      j_j_free(v280[0]);
      v48 = 0;
      goto LABEL_312;
    }
    v227 = qword_14610AB20;
    sub_146177D60((__int64)&qword_14610AB20, (__int64)&qword_14610AB20, *((_QWORD *)qword_14610AB20 + 1));
    v227[1] = v227;
    *v227 = v227;
    v227[2] = v227;
    qword_14610AB28 = 0i64;
    *((_QWORD *)qword_14610AB20 + 1) = sub_14617DB10(
                                         (__int64 *)&qword_14610AB20,
                                         *((_QWORD *)v280[0] + 1),
                                         (__int64)qword_14610AB20);
    qword_14610AB28 = (__int64)v280[1];
    v228 = (__int64 **)*((_QWORD *)qword_14610AB20 + 1);
    if ( *((_BYTE *)v228 + 25) )
    {
      *(_QWORD *)qword_14610AB20 = qword_14610AB20;
      *((_QWORD *)qword_14610AB20 + 2) = qword_14610AB20;
    }
    else
    {
      for ( j = *v228; !*((_BYTE *)j + 25); j = (__int64 *)*j )
        v228 = (__int64 **)j;
      *(_QWORD *)qword_14610AB20 = v228;
      v230 = *((_QWORD *)qword_14610AB20 + 1);
      for ( k = *(_QWORD *)(v230 + 16); !*(_BYTE *)(k + 25); k = *(_QWORD *)(k + 16) )
        v230 = k;
      *((_QWORD *)qword_14610AB20 + 2) = v230;
    }
    v288[1] = 0i64;
    v289 = _mm_load_si128((const __m128i *)&xmmword_14612A920);
    v288[0] = (void *)0x6578652E35415447i64;
    sub_146178280((__int64 *)v280, (__int64)lpValueName, (const void **)v288);
    v235 = v301.m128i_i64[0];
    if ( *(_BYTE *)(v301.m128i_i64[0] + 25)
      || (unsigned __int8)sub_1461797D0((__int64)v280, (size_t *)v288, (const void **)(v301.m128i_i64[0] + 32)) )
    {
      if ( v280[1] == (void *)0x2AAAAAAAAAAAAAAi64 )
        unknown_libname_3(v233, v232, v234);
      v236 = v280[0];
      v285._Hnd = v280;
      *(_QWORD *)&v285._Id = 0i64;
      v237 = operator new(0x60ui64);
      v237[2] = *(_OWORD *)v288;
      v237[3] = v289;
      v289.m128i_i64[0] = 0i64;
      v289.m128i_i64[1] = 15i64;
      LOBYTE(v288[0]) = 0;
      v237[4] = 0i64;
      *((_QWORD *)v237 + 10) = 0i64;
      *((_QWORD *)v237 + 11) = 15i64;
      *((_BYTE *)v237 + 64) = 0;
      *(_QWORD *)v237 = v236;
      *((_QWORD *)v237 + 1) = v236;
      *((_QWORD *)v237 + 2) = v236;
      *((_WORD *)v237 + 12) = 0;
      v285 = *(_Thrd_t *)lpValueName;
      v235 = sub_146165130(v280, (__int64)&v285, (__int64)v237);
    }
    v238 = (void *)(v235 + 64);
    if ( *(_QWORD *)(v235 + 88) > 0xFui64 )
      v238 = *(void **)(v235 + 64);
    v290[0] = v238;
    v290[1] = *(void **)(v235 + 80);
    v239 = sub_1461A2C60((__int64)v287, (__int64)v290);
    if ( v302 != (void **)v239 )
    {
      if ( v303.m128i_i64[1] > 7ui64 )
        sub_1461650D0((__int64)v302, v302[0], v303.m128i_i64[1]);
      v303 = v47;
      LOWORD(v302[0]) = 0;
      *(_OWORD *)v302 = *(_OWORD *)v239;
      v303 = *(__m128i *)(v239 + 16);
      *(_QWORD *)(v239 + 16) = 0i64;
      *(_QWORD *)(v239 + 24) = 7i64;
      *(_WORD *)v239 = 0;
    }
    sub_146162730((__int64)v287);
    sub_1461626B0((__int64)v288);
    sub_146177D60((__int64)v280, (__int64)v280, *((_QWORD *)v280[0] + 1));
    j_j_free(v280[0]);
    *(_QWORD *)&v274 = 0i64;
    sub_146187E30(&v298);
    v241 = sub_146188370(v240);
    v242 = (wchar_t *)&Default;
    if ( v241 )
      v242 = L"CL2";
    v285._Hnd = v242;
    v290[0] = (void *)12;
    v290[1] = &v285;
    Block[0] = L"CitizenFX_PreUIExit%s";
    Block[1] = (void *)21;
    v243 = (const WCHAR *)sub_1461A30F0((__int128 *)Block, (__int128 *)v290);
    qword_14610AB00 = (__int64)CreateEventW(0i64, 1, 0, v243);
    if ( (unsigned __int8)sub_146188370(v244) )
      v12 = L"CL2";
    v285._Hnd = v12;
    v290[0] = (void *)12;
    v290[1] = &v285;
    Block[0] = L"CitizenFX_PreUIDone%s";
    Block[1] = (void *)21;
    v245 = (const WCHAR *)sub_1461A30F0((__int128 *)Block, (__int128 *)v290);
    hEvent = CreateEventW(0i64, 0, 0, v245);
    if ( !*((_DWORD *)v9 + 1) )
      *((_DWORD *)v9 + 1) = GetCurrentProcessId();
    if ( *((_DWORD *)v9 + 1) == GetCurrentProcessId() && !v99 && !(unsigned __int8)sub_1461883F0(v246) )
    {
      v247 = sub_146184F50(v288, &v298);
      v248 = (_Thrd_t *)sub_14617D900((__int64)lpValueName, v247);
      v249 = v248;
      if ( v248->_Id )
      {
        v285 = *v248;
        if ( !Thrd_detach(&v285) )
        {
          *v249 = 0i64;
          if ( !LODWORD(lpValueName[1]) )
          {
            sub_146186920((__int64)v288);
            goto LABEL_282;
          }
          terminate();
        }
      }
      std::_Throw_Cpp_error(1);
      JUMPOUT(0x14618ABF2i64);
    }
LABEL_282:
    if ( (unsigned __int8)sub_146167D30(v246) )
      SetEvent(hEvent);
    if ( v99 )
    {
      v261 = (void **)sub_146186230(v287, L"CoreRT.dll");
      v264 = sub_1461645B0((__int64)v292, v261, v262, v263);
      if ( *(_QWORD *)(v264 + 24) > 7ui64 )
        v264 = *(_QWORD *)v264;
      v265 = LoadLibraryW((LPCWSTR)v264);
      sub_146162730((__int64)v292);
      if ( v265 )
      {
        v266 = (void (*)(void))GetProcAddress(v265, "ToolMode_Init");
        if ( v266 )
        {
          v267 = GetProcAddress(v265, "ToolMode_SetGameFunction");
          if ( v267 )
          {
            if ( dword_14611AB80 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer
                                               + (unsigned int)TlsIndex)
                                             + 380i64) )
            {
              sub_1461A7CF4(&dword_14611AB80);
              if ( dword_14611AB80 == -1 )
              {
                sub_146170F20((__int64)&qword_14611AB60, (__int64)v302, v271, v272);
                atexit(sub_1461AE7C0);
                Init_thread_footer(&dword_14611AB80);
              }
            }
            ((void (__fastcall *)(void (__fastcall *)(const wchar_t *, __int64, __int64, __int64)))v267)(sub_14617D800);
          }
          sub_146168980();
          v266();
        }
        else
        {
          sub_146193140("Could not find ToolMode_Init in CoreRT.dll.\n");
        }
      }
      else
      {
        sub_146193140("Could not initialize CoreRT.dll.\n");
      }
    }
    else
    {
      sub_14618C320((unsigned __int8 *)(v298 + 16), (__int64)v287, -1, 32, 0, 1);
      sub_1461689C0((void **)v287, v250, v251, v252);
      sub_1461626B0((__int64)v287);
      v253 = GetModuleHandleW(0i64);
      GetModuleFileNameW(v253, (LPWSTR)Buffer, 0x104u);
      if ( !(unsigned __int8)sub_1461883F0(v254) )
        goto LABEL_338;
      if ( !*((_DWORD *)v9 + 1) )
        *((_DWORD *)v9 + 1) = GetCurrentProcessId();
      if ( *((_DWORD *)v9 + 1) == GetCurrentProcessId() )
      {
        v255 = (void **)sub_146186230(v287, L"CoreRT.dll");
        v258 = sub_1461645B0((__int64)v292, v255, v256, v257);
        if ( *(_QWORD *)(v258 + 24) > 7ui64 )
          v258 = *(_QWORD *)v258;
        v259 = LoadLibraryW((LPCWSTR)v258);
        sub_146162730((__int64)v292);
        if ( v259 )
        {
          v260 = (void (*)(void))GetProcAddress(v259, "GameMode_RunSDK");
          if ( v260 )
            v260();
        }
      }
      else
      {
LABEL_338:
        if ( !*((_DWORD *)v9 + 1) )
          *((_DWORD *)v9 + 1) = GetCurrentProcessId();
        if ( *((_DWORD *)v9 + 1) == GetCurrentProcessId() || wcsstr((const wchar_t *)Buffer, L"GameRuntime") )
          sub_146167DB0((wchar_t *)v302, 0);
        else
          sub_146167DB0((wchar_t *)v302, 1);
      }
    }
    v48 = 0;
    if ( *((_QWORD *)&v298 + 1) )
      sub_14618AE40(*((volatile signed __int32 **)&v298 + 1));
    goto LABEL_312;
  }
  v48 = 0;
LABEL_312:
  if ( v303.m128i_i64[1] > 7ui64 )
  {
    v268 = v302[0];
    if ( (unsigned __int64)(2 * v303.m128i_i64[1] + 2) >= 0x1000 )
    {
      v268 = (void *)*((_QWORD *)v302[0] - 1);
      if ( (unsigned __int64)(v302[0] - v268 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v268);
  }
  v303 = v47;
  LOWORD(v302[0]) = 0;
LABEL_319:
  if ( *((_QWORD *)&v307 + 1) > 7ui64 )
  {
    v269 = (WCHAR *)lpValue[0];
    if ( (unsigned __int64)(2i64 * *((_QWORD *)&v307 + 1) + 2) >= 0x1000 )
    {
      v269 = (WCHAR *)*((_QWORD *)lpValue[0] - 1);
      if ( (unsigned __int64)((char *)lpValue[0] - (char *)v269 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v269);
  }
  v307 = (__int128)v47;
  LOWORD(lpValue[0]) = 0;
  if ( v9 && v9 != (char *)&unk_146106050 )
    UnmapViewOfFile(v9);
  if ( hObject )
    CloseHandle(hObject);
  return v48;
}
// 14618ABED: control flows out of bounds to 14618ABF2
// 14618958C: conditional instruction was optimized away because rdi.8!=0
// 1461899D0: conditional instruction was optimized away because esi.4>=0
// 1461887D3: variable 'v11' is possibly undefined
// 1461887F3: variable 'v14' is possibly undefined
// 1461887F3: variable 'v15' is possibly undefined
// 146188818: variable 'v18' is possibly undefined
// 146188818: variable 'v19' is possibly undefined
// 1461888F4: variable 'v25' is possibly undefined
// 1461888F4: variable 'v26' is possibly undefined
// 14618892C: variable 'v29' is possibly undefined
// 14618892C: variable 'v30' is possibly undefined
// 14618897E: variable 'v33' is possibly undefined
// 14618897E: variable 'v34' is possibly undefined
// 146188ADA: variable 'v43' is possibly undefined
// 146188ADA: variable 'v44' is possibly undefined
// 146188B26: variable 'v50' is possibly undefined
// 146188B26: variable 'v51' is possibly undefined
// 146188B8A: variable 'v53' is possibly undefined
// 146188CC7: variable 'v62' is possibly undefined
// 146188CC7: variable 'v63' is possibly undefined
// 146188D1C: variable 'v67' is possibly undefined
// 146188D1C: variable 'v68' is possibly undefined
// 146188D91: variable 'v70' is possibly undefined
// 146188D91: variable 'v71' is possibly undefined
// 146188EA8: variable 'v79' is possibly undefined
// 14618919C: variable 'v102' is possibly undefined
// 1461891A9: variable 'v104' is possibly undefined
// 1461891A9: variable 'v105' is possibly undefined
// 1461891E9: variable 'v107' is possibly undefined
// 1461891F6: variable 'v108' is possibly undefined
// 1461891F6: variable 'v109' is possibly undefined
// 146189236: variable 'v111' is possibly undefined
// 146189243: variable 'v112' is possibly undefined
// 146189243: variable 'v113' is possibly undefined
// 1461895F7: variable 'v138' is possibly undefined
// 146189604: variable 'v139' is possibly undefined
// 146189604: variable 'v140' is possibly undefined
// 146189645: variable 'v142' is possibly undefined
// 146189652: variable 'v143' is possibly undefined
// 146189652: variable 'v144' is possibly undefined
// 146189693: variable 'v146' is possibly undefined
// 1461896A0: variable 'v147' is possibly undefined
// 1461896A0: variable 'v148' is possibly undefined
// 1461896E1: variable 'v150' is possibly undefined
// 1461896EE: variable 'v151' is possibly undefined
// 1461896EE: variable 'v152' is possibly undefined
// 14618972F: variable 'v154' is possibly undefined
// 14618973C: variable 'v155' is possibly undefined
// 14618973C: variable 'v156' is possibly undefined
// 14618977D: variable 'v158' is possibly undefined
// 14618978A: variable 'v159' is possibly undefined
// 14618978A: variable 'v160' is possibly undefined
// 1461897CB: variable 'v162' is possibly undefined
// 1461897D8: variable 'v163' is possibly undefined
// 1461897D8: variable 'v164' is possibly undefined
// 146189819: variable 'v166' is possibly undefined
// 146189826: variable 'v167' is possibly undefined
// 146189826: variable 'v168' is possibly undefined
// 14618986A: variable 'v170' is possibly undefined
// 146189994: variable 'v176' is possibly undefined
// 146189994: variable 'v177' is possibly undefined
// 146189A79: variable 'v180' is possibly undefined
// 146189A79: variable 'v181' is possibly undefined
// 146189B5E: variable 'v185' is possibly undefined
// 146189B7D: variable 'v186' is possibly undefined
// 146189BB7: variable 'v188' is possibly undefined
// 146189BCA: variable 'v189' is possibly undefined
// 146189BCA: variable 'v190' is possibly undefined
// 146189BF2: variable 'v192' is possibly undefined
// 146189C02: variable 'v193' is possibly undefined
// 146189C02: variable 'v194' is possibly undefined
// 146189C2A: variable 'v196' is possibly undefined
// 146189C3A: variable 'v197' is possibly undefined
// 146189C3A: variable 'v198' is possibly undefined
// 146189C50: variable 'v200' is possibly undefined
// 146189CAA: variable 'v202' is possibly undefined
// 146189CFE: variable 'v204' is possibly undefined
// 146189D58: variable 'v206' is possibly undefined
// 14618A2A3: variable 'v222' is possibly undefined
// 14618A2D9: variable 'v223' is possibly undefined
// 14618A6BB: variable 'v240' is possibly undefined
// 14618A730: variable 'v244' is possibly undefined
// 14618A7BA: variable 'v246' is possibly undefined
// 14618A871: variable 'v250' is possibly undefined
// 14618A871: variable 'v251' is possibly undefined
// 14618A871: variable 'v252' is possibly undefined
// 14618A89E: variable 'v254' is possibly undefined
// 14618A8DE: variable 'v256' is possibly undefined
// 14618A8DE: variable 'v257' is possibly undefined
// 14618A99D: variable 'v262' is possibly undefined
// 14618A99D: variable 'v263' is possibly undefined
// 14618ABB9: variable 'v271' is possibly undefined
// 14618ABB9: variable 'v272' is possibly undefined
// 14618ABDC: variable 'v233' is possibly undefined
// 14618ABDC: variable 'v232' is possibly undefined
// 14618ABDC: variable 'v234' is possibly undefined
// 146109100: using guessed type wchar_t *off_146109100[20];
// 14610AB00: using guessed type __int64 qword_14610AB00;
// 14610AB28: using guessed type __int64 qword_14610AB28;
// 14610AB30: using guessed type wchar_t String[32768];
// 14611AB80: using guessed type int dword_14611AB80;
// 14611AE78: using guessed type int TlsIndex;
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 14611E150: using guessed type __int128 xmmword_14611E150;
// 14612A920: using guessed type __int128 xmmword_14612A920;
// 14612BBF8: using guessed type wchar_t aSS[5];
// 14612C2C0: using guessed type wchar_t aChancity[9];
// 14612C3C0: using guessed type wchar_t aBin[4];
// 14612C3C8: using guessed type wchar_t aD_0[4];
// 14612C3D0: using guessed type wchar_t aCitizenfxLogS[16];
// 14612C474: using guessed type wchar_t asc_14612C474[2];
// 14612C478: using guessed type wchar_t aCitilaunchTlsd[24];
// 14612C4F0: using guessed type wchar_t aCacheSubproces[17];
// 14612C578: using guessed type wchar_t aSdk[4];
// 14612C580: using guessed type wchar_t aClient[7];
// 14612C590: using guessed type wchar_t aCitizenfxSS[16];
// 14612C6D8: using guessed type wchar_t aApp[5];
// 14612C6E8: using guessed type wchar_t asc_14612C6E8[4];
// 14612C6F0: using guessed type wchar_t aDinput8Dll[13];
// 14612C710: using guessed type wchar_t aDsoundDll[12];
// 14612C728: using guessed type wchar_t aXinput14Dll_0[15];
// 14612C748: using guessed type wchar_t aVersionDll[13];
// 14612C780: using guessed type wchar_t aDataCacheCrash[23];
// 14612C7B0: using guessed type wchar_t aDataCacheError[21];
// 14612C7E0: using guessed type wchar_t aPermalauncher[14];
// 14612C800: using guessed type wchar_t asc_14612C800[4];
// 14612C808: using guessed type wchar_t aDxgiDll[10];
// 14612C820: using guessed type wchar_t aD3d11Dll[11];
// 14612C838: using guessed type wchar_t aD3d9Dll_0[10];
// 14612C850: using guessed type wchar_t aD3d10Dll[11];
// 14612C868: using guessed type wchar_t aD3d101Dll[13];
// 14612C888: using guessed type wchar_t aOpengl32Dll[14];
// 14612C8A8: using guessed type wchar_t aBotanDll[10];
// 14612C8C0: using guessed type wchar_t aDinput8Dll_0[12];
// 14612C8D8: using guessed type wchar_t aSteamApi64Dll[16];
// 14612C8F8: using guessed type wchar_t aBinIcuucDll[14];
// 14612C918: using guessed type wchar_t aBinIcui18nDll[16];
// 14612C938: using guessed type wchar_t aV8LibplatformD[19];
// 14612C960: using guessed type wchar_t aV8LibbaseDll[15];
// 14612C980: using guessed type wchar_t aV8Dll[7];
// 14612C9B8: using guessed type wchar_t asc_14612C9B8[3];
// 14612C9C0: using guessed type wchar_t aBinCrt[8];
// 14612C9D0: using guessed type wchar_t aGta5Exe_0[9];
// 14612C9E8: using guessed type wchar_t aCl2_1[4];
// 14612C9F0: using guessed type wchar_t aCitizenfxPreui[22];
// 14612CA20: using guessed type wchar_t aCitizenfxPreui_0[22];
// 1461653B0: using guessed type void __fastcall __noreturn unknown_libname_3(_QWORD, _QWORD, _QWORD);
// 146167D30: using guessed type __int64 __fastcall sub_146167D30(_QWORD);
// 146188370: using guessed type __int64 __fastcall sub_146188370(_QWORD);
// 1461883F0: using guessed type __int64 __fastcall sub_1461883F0(_QWORD);
// 146194900: using guessed type __int64 __fastcall unknown_libname_17(_QWORD);
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);
// 1461A8FE2: using guessed type __int64 terminate(void);

//----- (000000014618AC00) ----------------------------------------------------
__int64 __fastcall sub_14618AC00(_WORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r9
  _WORD *v4; // rax
  __int64 result; // rax
  _WORD *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r10
  __int16 v10; // r8
  _WORD *v11; // rcx

  if ( (unsigned __int64)(a2 - 1) > 0x7FFFFFFE )
    return 2147942487i64;
  v3 = a2;
  v4 = a1;
  do
  {
    if ( !*v4 )
      break;
    ++v4;
    --v3;
  }
  while ( v3 );
  result = 2147942487i64;
  if ( v3 )
  {
    v6 = &a1[a2 - v3];
    v7 = v3;
    v8 = 2147483646i64;
    v9 = a3 - (_QWORD)v6;
    do
    {
      if ( !v8 )
        break;
      v10 = *(_WORD *)((char *)v6 + v9);
      if ( !v10 )
        break;
      *v6 = v10;
      --v8;
      ++v6;
      --v7;
    }
    while ( v7 );
    v11 = v6 - 1;
    if ( v7 )
      v11 = v6;
    result = 2147942522i64;
    if ( v7 )
      result = 0i64;
    *v11 = 0;
  }
  return result;
}
// 14618AC4E: conditional instruction was optimized away because r9.8!=0
// 14618AC57: conditional instruction was optimized away because r9.8!=0

//----- (000000014618ACC0) ----------------------------------------------------
__int64 __fastcall sub_14618ACC0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v6; // rcx
  __int64 result; // rax

  v6 = *(_QWORD **)a1;
  if ( v6 )
  {
    if ( ((*(_QWORD *)(a1 + 16) - (_QWORD)v6) & 0xFFFFFFFFFFFFFFF8ui64) >= 0x1000 )
    {
      if ( (unsigned __int64)v6 - *(v6 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v6 = (_QWORD *)*(v6 - 1);
    }
    j_j_free(v6);
  }
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a2 + 8 * a3;
  result = a2 + 8 * a4;
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

//----- (000000014618AD60) ----------------------------------------------------
void __fastcall sub_14618AD60(unsigned __int8 **a1, unsigned __int8 *a2, __int64 a3, __int64 a4)
{
  unsigned __int8 *v8; // rbx
  unsigned __int8 *i; // rdi
  unsigned __int8 *v10; // rcx

  v8 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v8 != i; v8 += 16 )
      sub_14618BD60(v8 + 8, *v8);
    v10 = *a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF0ui64) >= 0x1000 )
    {
      if ( (unsigned __int64)&v10[-*((_QWORD *)v10 - 1) - 8] > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v10 = (unsigned __int8 *)*((_QWORD *)v10 - 1);
    }
    j_j_free(v10);
  }
  *a1 = a2;
  a1[1] = &a2[16 * a3];
  a1[2] = &a2[16 * a4];
}
// 14618BD60: using guessed type __int64 __fastcall sub_14618BD60(_QWORD, _QWORD);

//----- (000000014618AE40) ----------------------------------------------------
__int64 __fastcall sub_14618AE40(volatile signed __int32 *a1)
{
  __int64 result; // rax

  result = (unsigned int)_InterlockedExchangeAdd(a1 + 2, 0xFFFFFFFF);
  if ( (_DWORD)result == 1 )
  {
    result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))a1)(a1);
    if ( _InterlockedExchangeAdd(a1 + 3, 0xFFFFFFFF) == 1 )
      return (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)a1 + 8i64))(a1);
  }
  return result;
}

//----- (000000014618AE90) ----------------------------------------------------
__int64 __fastcall sub_14618AE90(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 16i64))(a1, 1i64);
  return result;
}

//----- (000000014618AEB0) ----------------------------------------------------
__int64 __fastcall sub_14618AEB0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 + 16) + 16i64))(a1 + 16, 0i64);
}

//----- (000000014618AEC0) ----------------------------------------------------
void __fastcall sub_14618AEC0(__int64 a1)
{
  void **v1; // rbx

  v1 = (void **)(a1 + 16);
  sub_14618BD60((unsigned __int8 ***)(a1 + 40), *(unsigned __int8 *)(a1 + 32));
  sub_146177D60((__int64)v1, (__int64)v1, *((_QWORD *)*v1 + 1));
  j_j_free(*v1);
}

//----- (000000014618AF10) ----------------------------------------------------
bool __fastcall sub_14618AF10(__int64 a1)
{
  int v2; // eax
  int v3; // eax
  signed __int64 v5; // rdi
  char *v6; // [rsp+30h] [rbp-38h] BYREF
  char Buffer[32]; // [rsp+38h] [rbp-30h] BYREF
  __int64 v8; // [rsp+58h] [rbp-10h] BYREF

  if ( !*(_QWORD *)(a1 + 104) || !*(_BYTE *)(a1 + 113) )
    return 1;
  if ( (*(unsigned int (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 24i64))(a1, 0xFFFFFFFFi64) == -1 )
    return 0;
  v2 = std::codecvt<char,char,_Mbstatet>::unshift(*(_QWORD *)(a1 + 104), a1 + 116, Buffer, &v8, &v6);
  if ( !v2 )
  {
    *(_BYTE *)(a1 + 113) = 0;
    goto LABEL_10;
  }
  v3 = v2 - 1;
  if ( !v3 )
  {
LABEL_10:
    if ( v6 == Buffer )
      return *(_BYTE *)(a1 + 113) == 0;
    v5 = v6 - Buffer;
    if ( v5 == fwrite(Buffer, 1ui64, v6 - Buffer, *(FILE **)(a1 + 128)) )
      return *(_BYTE *)(a1 + 113) == 0;
    return 0;
  }
  if ( v3 != 2 )
    return 0;
  *(_BYTE *)(a1 + 113) = 0;
  return 1;
}
// 14611C4A0: using guessed type __int64 __fastcall std::codecvt<char,char,_Mbstatet>::unshift(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014618B000) ----------------------------------------------------
__int64 __fastcall sub_14618B000(_QWORD *a1, __int64 a2)
{
  __int64 v2; // r9
  __int64 v4; // rdi
  __int64 *v5; // r11
  __int64 v6; // r14
  __int64 v7; // rbp
  char v8; // r10
  __int64 j; // rax
  __int64 *i; // r8
  __int64 v11; // rdx
  __int64 v12; // rbx
  __int64 k; // rdx
  __int64 v14; // rcx
  __int64 v15; // rdx
  _BYTE *v16; // r8
  __int64 v17; // rax
  __int64 m; // rcx
  _QWORD *v19; // rcx
  _QWORD *v20; // rcx
  char v21; // dl
  __int64 v22; // r9
  _BYTE *v23; // rcx
  __int64 *v24; // rcx
  __int64 **v25; // rax
  _BYTE *v26; // rcx
  __int64 v27; // rax
  _QWORD *v28; // rax
  __int64 v29; // rdx
  __int64 v30; // rcx
  __int64 result; // rax

  v2 = a2 + 16;
  v4 = *(_QWORD *)(a2 + 16);
  v5 = (__int64 *)a2;
  v6 = a2;
  v7 = a2;
  v8 = *(_BYTE *)(v4 + 25);
  if ( v8 )
  {
    j = *(_QWORD *)(a2 + 8);
    for ( i = (__int64 *)(a2 + 8); !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 8) )
    {
      if ( a2 != *(_QWORD *)(j + 16) )
        break;
      a2 = j;
    }
  }
  else
  {
    v11 = *(_QWORD *)v4;
    for ( j = v4; !*(_BYTE *)(v11 + 25); v11 = *(_QWORD *)v11 )
      j = v11;
    i = (__int64 *)(v7 + 8);
  }
  if ( !*(_BYTE *)(*v5 + 25) )
  {
    if ( v8 )
    {
      v4 = *v5;
    }
    else
    {
      v4 = *(_QWORD *)(j + 16);
      if ( j != v6 )
      {
        *(_QWORD *)(*v5 + 8) = j;
        *(_QWORD *)j = *v5;
        if ( j == *(_QWORD *)v2 )
        {
          v12 = j;
        }
        else
        {
          v12 = *(_QWORD *)(j + 8);
          if ( !*(_BYTE *)(v4 + 25) )
            *(_QWORD *)(v4 + 8) = v12;
          *(_QWORD *)v12 = v4;
          *(_QWORD *)(j + 16) = *(_QWORD *)v2;
          *(_QWORD *)(*(_QWORD *)v2 + 8i64) = j;
        }
        if ( *(_QWORD *)(*a1 + 8i64) == v6 )
        {
          *(_QWORD *)(*a1 + 8i64) = j;
        }
        else
        {
          v19 = (_QWORD *)*i;
          if ( *(_QWORD *)*i == v6 )
            *v19 = j;
          else
            v19[2] = j;
        }
        v20 = (_QWORD *)*i;
        v16 = (_BYTE *)(v6 + 24);
        v21 = *(_BYTE *)(j + 24);
        *(_QWORD *)(j + 8) = v20;
        *(_BYTE *)(j + 24) = *(_BYTE *)(v6 + 24);
        *(_BYTE *)(v6 + 24) = v21;
        goto LABEL_44;
      }
    }
  }
  v12 = *i;
  if ( !*(_BYTE *)(v4 + 25) )
    *(_QWORD *)(v4 + 8) = v12;
  if ( *(_QWORD *)(*a1 + 8i64) == v6 )
  {
    *(_QWORD *)(*a1 + 8i64) = v4;
  }
  else if ( *(_QWORD *)v12 == v6 )
  {
    *(_QWORD *)v12 = v4;
  }
  else
  {
    *(_QWORD *)(v12 + 16) = v4;
  }
  if ( *(_QWORD *)*a1 == v6 )
  {
    if ( *(_BYTE *)(v4 + 25) )
    {
      k = v12;
    }
    else
    {
      v14 = *(_QWORD *)v4;
      for ( k = v4; !*(_BYTE *)(v14 + 25); v14 = *(_QWORD *)v14 )
        k = v14;
    }
    *(_QWORD *)*a1 = k;
  }
  v15 = *a1;
  if ( *(_QWORD *)(*a1 + 16i64) == v6 )
  {
    if ( *(_BYTE *)(v4 + 25) )
    {
      *(_QWORD *)(v15 + 16) = v12;
      v16 = (_BYTE *)(v7 + 24);
      goto LABEL_44;
    }
    v17 = *(_QWORD *)(v4 + 16);
    for ( m = v4; !*(_BYTE *)(v17 + 25); v17 = *(_QWORD *)(v17 + 16) )
      m = v17;
    *(_QWORD *)(v15 + 16) = m;
  }
  v16 = (_BYTE *)(v7 + 24);
LABEL_44:
  if ( *v16 == 1 )
  {
    if ( v4 != *(_QWORD *)(*a1 + 8i64) )
    {
      do
      {
        v22 = v12;
        if ( *(_BYTE *)(v4 + 24) != 1 )
          break;
        v23 = *(_BYTE **)v12;
        if ( v4 == *(_QWORD *)v12 )
        {
          v23 = *(_BYTE **)(v12 + 16);
          if ( !v23[24] )
          {
            v23[24] = 1;
            v24 = *(__int64 **)(v12 + 16);
            *(_BYTE *)(v12 + 24) = 0;
            *(_QWORD *)(v12 + 16) = *v24;
            if ( !*(_BYTE *)(*v24 + 25) )
              *(_QWORD *)(*v24 + 8) = v12;
            v24[1] = *(_QWORD *)(v12 + 8);
            if ( v12 == *(_QWORD *)(*a1 + 8i64) )
            {
              *(_QWORD *)(*a1 + 8i64) = v24;
            }
            else
            {
              v25 = *(__int64 ***)(v12 + 8);
              if ( (__int64 *)v12 == *v25 )
                *v25 = v24;
              else
                v25[2] = v24;
            }
            *v24 = v12;
            *(_QWORD *)(v12 + 8) = v24;
            v23 = *(_BYTE **)(v12 + 16);
          }
          if ( v23[25] )
            goto LABEL_76;
          if ( *(_BYTE *)(*(_QWORD *)v23 + 24i64) != 1 || *(_BYTE *)(*((_QWORD *)v23 + 2) + 24i64) != 1 )
          {
            if ( *(_BYTE *)(*((_QWORD *)v23 + 2) + 24i64) == 1 )
            {
              *(_BYTE *)(*(_QWORD *)v23 + 24i64) = 1;
              v23[24] = 0;
              sub_14618B6F0((__int64)a1, v23);
              v23 = *(_BYTE **)(v12 + 16);
            }
            v23[24] = *(_BYTE *)(v12 + 24);
            *(_BYTE *)(v12 + 24) = 1;
            *(_BYTE *)(*((_QWORD *)v23 + 2) + 24i64) = 1;
            sub_14618B650((__int64)a1, v12);
            break;
          }
        }
        else
        {
          if ( !v23[24] )
          {
            v23[24] = 1;
            v26 = *(_BYTE **)v12;
            *(_BYTE *)(v12 + 24) = 0;
            *(_QWORD *)v12 = *((_QWORD *)v26 + 2);
            v27 = *((_QWORD *)v26 + 2);
            if ( !*(_BYTE *)(v27 + 25) )
              *(_QWORD *)(v27 + 8) = v12;
            *((_QWORD *)v26 + 1) = *(_QWORD *)(v12 + 8);
            if ( v12 == *(_QWORD *)(*a1 + 8i64) )
            {
              *(_QWORD *)(*a1 + 8i64) = v26;
            }
            else
            {
              v28 = *(_QWORD **)(v12 + 8);
              if ( v12 == v28[2] )
                v28[2] = v26;
              else
                *v28 = v26;
            }
            *((_QWORD *)v26 + 2) = v12;
            *(_QWORD *)(v12 + 8) = v26;
            v23 = *(_BYTE **)v12;
          }
          if ( v23[25] )
            goto LABEL_76;
          v29 = *((_QWORD *)v23 + 2);
          if ( *(_BYTE *)(v29 + 24) != 1 || *(_BYTE *)(*(_QWORD *)v23 + 24i64) != 1 )
          {
            if ( *(_BYTE *)(*(_QWORD *)v23 + 24i64) == 1 )
            {
              *(_BYTE *)(v29 + 24) = 1;
              v23[24] = 0;
              sub_14618B650((__int64)a1, (__int64)v23);
              v23 = *(_BYTE **)v12;
            }
            v23[24] = *(_BYTE *)(v12 + 24);
            *(_BYTE *)(v12 + 24) = 1;
            *(_BYTE *)(*(_QWORD *)v23 + 24i64) = 1;
            sub_14618B6F0((__int64)a1, (_QWORD *)v12);
            break;
          }
        }
        v23[24] = 0;
LABEL_76:
        v4 = v12;
        v12 = *(_QWORD *)(v12 + 8);
      }
      while ( v22 != *(_QWORD *)(*a1 + 8i64) );
    }
    *(_BYTE *)(v4 + 24) = 1;
  }
  v30 = a1[1];
  result = v6;
  if ( v30 )
    a1[1] = v30 - 1;
  return result;
}

//----- (000000014618B3B0) ----------------------------------------------------
HRESULT __stdcall DllCanUnloadNow()
{
  return 0;
}

//----- (000000014618B3C0) ----------------------------------------------------
__int64 __fastcall sub_14618B3C0(__int64 *a1, _QWORD *a2, unsigned __int64 a3)
{
  __int64 v4; // rcx
  __int64 v6; // r14
  __int64 v7; // r8
  int v8; // edx
  char *v9; // rsi
  unsigned __int64 v10; // rbx
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // rbx
  __int64 v13; // rcx
  unsigned __int8 v14; // al
  __int64 v15; // rbx
  unsigned __int64 v16; // r8
  __int64 v17; // rdx
  __int64 v19; // r11
  _DWORD *v20; // r9
  __int64 v21; // rcx
  bool v22; // sf
  unsigned __int64 v23; // rdx
  int *v24; // r10
  __int64 v25; // rdx
  _DWORD *v26; // r11
  __int64 v27; // rbx
  __int64 v28; // r8
  int v29; // r8d
  int v30; // [rsp+20h] [rbp-18h] BYREF
  int v31[5]; // [rsp+24h] [rbp-14h] BYREF

  v4 = *a1;
  v6 = a2[1] + 32 * ((*a2 - v4) >> 2);
  if ( !a3 )
    return v6;
  v7 = a1[3];
  if ( 0x7FFFFFFFFFFFFFFFi64 - v7 < a3 )
    unknown_libname_7(v4);
  v8 = 0;
  v9 = (char *)a1[1];
  v10 = (v7 + a3 + 31) >> 5;
  v30 = 0;
  v11 = (__int64)&v9[-v4] >> 2;
  if ( v10 < v11 )
  {
    a1[1] = v4 + 4 * v10;
    goto LABEL_19;
  }
  if ( v10 > v11 )
  {
    if ( v10 > (a1[2] - v4) >> 2 )
    {
      sub_14617F4C0((__int64)a1, v10, &v30);
      goto LABEL_19;
    }
    v12 = v10 - v11;
    v31[0] = 0;
    v13 = 0i64;
    while ( 1 )
    {
      v14 = *((_BYTE *)&v31[-1] + v13++);
      if ( v14 != *((_BYTE *)v31 + v13 - 1) )
        break;
      if ( v13 == 4 )
        goto LABEL_13;
    }
    v8 = v14 < *((_BYTE *)v31 + v13 - 1) ? -1 : 1;
LABEL_13:
    if ( v8 )
    {
      if ( !v12 )
      {
LABEL_18:
        a1[1] = (__int64)v9;
        goto LABEL_19;
      }
      v15 = 4 * v12;
      v16 = v15 & 0xFFFFFFFFFFFFFFFCui64;
    }
    else
    {
      v15 = 4 * v12;
      v16 = v15;
    }
    memset(v9, 0, v16);
    v9 += v15;
    goto LABEL_18;
  }
LABEL_19:
  v17 = a1[3];
  if ( v17 )
  {
    v19 = *a1;
    if ( v17 >= 0 )
      v20 = (_DWORD *)(v19 + 4 * ((unsigned __int64)v17 >> 5));
    else
      v20 = (_DWORD *)(v19 - (4 * ((unsigned __int64)~v17 >> 5) + 4));
    v21 = a1[3] & 0x1F;
    v22 = (__int64)(a3 + v17) < 0;
    v23 = a3 + v17;
    a1[3] = v23;
    if ( v22 && v23 )
      v24 = (int *)(v19 - (4 * (~v23 >> 5) + 4));
    else
      v24 = (int *)(v19 + 4 * (v23 >> 5));
    v25 = v23 & 0x1F;
    if ( v6 >= 0 )
      v26 = (_DWORD *)(v19 + 4 * ((unsigned __int64)v6 >> 5));
    else
      v26 = (_DWORD *)(v19 - (4 * ((unsigned __int64)~v6 >> 5) + 4));
    while ( 1 )
    {
      v27 = v25;
      v28 = v21;
      if ( v26 == v20 && (v6 & 0x1F) == v21 )
        break;
      if ( v21 )
        --v21;
      else
        v21 = 31i64;
      if ( !v28 )
        --v20;
      if ( v25 )
        --v25;
      else
        v25 = 31i64;
      if ( !v27 )
        --v24;
      v29 = *v24;
      if ( ((1 << v21) & *v20) != 0 )
        *v24 = v29 | (1 << v25);
      else
        *v24 = v29 & ~(1 << v25);
    }
  }
  else
  {
    a1[3] = a3;
  }
  return v6;
}
// 14618B51F: conditional instruction was optimized away because rdx.8<0
// 14618B590: conditional instruction was optimized away because r14.8<0
// 14618B8B0: using guessed type void __fastcall __noreturn unknown_libname_7(_QWORD);

//----- (000000014618B630) ----------------------------------------------------
void __fastcall sub_14618B630(__int64 a1)
{
  FILE *v1; // rcx

  v1 = *(FILE **)(a1 + 128);
  if ( v1 )
    lock_file(v1);
}

//----- (000000014618B650) ----------------------------------------------------
_QWORD *__fastcall sub_14618B650(__int64 a1, __int64 a2)
{
  _QWORD *v2; // r8
  _QWORD *result; // rax

  v2 = *(_QWORD **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = *v2;
  if ( !*(_BYTE *)(*v2 + 25i64) )
    *(_QWORD *)(*v2 + 8i64) = a2;
  v2[1] = *(_QWORD *)(a2 + 8);
  result = *(_QWORD **)a1;
  if ( a2 == *(_QWORD *)(*(_QWORD *)a1 + 8i64) )
  {
    result[1] = v2;
    *v2 = a2;
    *(_QWORD *)(a2 + 8) = v2;
  }
  else
  {
    result = *(_QWORD **)(a2 + 8);
    if ( a2 == *result )
      *result = v2;
    else
      result[2] = v2;
    *v2 = a2;
    *(_QWORD *)(a2 + 8) = v2;
  }
  return result;
}

//----- (000000014618B6B0) ----------------------------------------------------
__int64 __fastcall sub_14618B6B0(__int64 a1)
{
  __int64 result; // rax

  result = std::streambuf::eback();
  if ( result == a1 + 112 )
    return std::streambuf::setg(a1, *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144));
  return result;
}
// 14611C4D8: using guessed type __int64 std::streambuf::eback(void);
// 14611C500: using guessed type __int64 __fastcall std::streambuf::setg(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014618B6F0) ----------------------------------------------------
_QWORD *__fastcall sub_14618B6F0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // r8
  __int64 v3; // rax
  _QWORD *result; // rax

  v2 = *a2;
  *a2 = *(_QWORD *)(*a2 + 16i64);
  v3 = *(_QWORD *)(v2 + 16);
  if ( !*(_BYTE *)(v3 + 25) )
    *(_QWORD *)(v3 + 8) = a2;
  *(_QWORD *)(v2 + 8) = a2[1];
  result = *(_QWORD **)a1;
  if ( a2 == *(_QWORD **)(*(_QWORD *)a1 + 8i64) )
  {
    result[1] = v2;
    *(_QWORD *)(v2 + 16) = a2;
    a2[1] = v2;
  }
  else
  {
    result = (_QWORD *)a2[1];
    if ( a2 == (_QWORD *)result[2] )
      result[2] = v2;
    else
      *result = v2;
    *(_QWORD *)(v2 + 16) = a2;
    a2[1] = v2;
  }
  return result;
}

//----- (000000014618B750) ----------------------------------------------------
void __noreturn sub_14618B750()
{
  _QWORD pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_146186180(pExceptionObject);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
}
// 14618B750: using guessed type void __noreturn sub_14618B750();
// 14618B750: using guessed type _QWORD pExceptionObject[5];

//----- (000000014618B770) ----------------------------------------------------
void __fastcall sub_14618B770(unsigned __int8 **a1)
{
  unsigned __int8 *v2; // rbx
  unsigned __int8 *i; // rsi
  unsigned __int8 *v4; // rcx

  v2 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v2 != i; v2 += 16 )
      sub_14618BD60(v2 + 8, *v2);
    v4 = *a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFF0ui64) >= 0x1000 )
    {
      if ( (unsigned __int64)&v4[-*((_QWORD *)v4 - 1) - 8] > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v4 = (unsigned __int8 *)*((_QWORD *)v4 - 1);
    }
    j_j_free(v4);
    *a1 = 0i64;
    a1[1] = 0i64;
    a1[2] = 0i64;
  }
}
// 14618BD60: using guessed type __int64 __fastcall sub_14618BD60(_QWORD, _QWORD);

//----- (000000014618B820) ----------------------------------------------------
void __fastcall sub_14618B820(__int64 a1)
{
  _QWORD *v2; // rcx

  v2 = *(_QWORD **)a1;
  if ( v2 )
  {
    if ( (unsigned __int64)(2 * ((__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v2) >> 1)) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - *(v2 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v2 = (_QWORD *)*(v2 - 1);
    }
    j_j_free(v2);
    *(_QWORD *)a1 = 0i64;
    *(_QWORD *)(a1 + 8) = 0i64;
    *(_QWORD *)(a1 + 16) = 0i64;
  }
}

//----- (000000014618B890) ----------------------------------------------------
void __fastcall sub_14618B890(__int64 a1)
{
  FILE *v1; // rcx

  v1 = *(FILE **)(a1 + 128);
  if ( v1 )
    unlock_file(v1);
}

//----- (000000014618B8D0) ----------------------------------------------------
_QWORD *__fastcall sub_14618B8D0(_QWORD *Src, void *a2, size_t Size, __int64 a4)
{
  unsigned __int64 v4; // r15
  size_t v6; // r14
  _QWORD *v9; // rax
  char *v10; // rbx
  size_t v11; // rbx
  size_t v12; // r12
  size_t v13; // rcx
  unsigned __int64 v14; // rdx
  _QWORD *v15; // rax
  _QWORD *v16; // rbp
  char *v17; // r12
  _QWORD *v18; // rbx

  v4 = Src[3];
  v6 = Src[2];
  if ( Size > v4 - v6 )
  {
    v11 = 0x7FFFFFFFFFFFFFFFi64;
    if ( 0x7FFFFFFFFFFFFFFFi64 - v6 < Size )
      unknown_libname_4(Src, a2, Size, a4);
    v12 = v6 + Size;
    v13 = (v6 + Size) | 0xF;
    if ( v13 <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      v14 = v4 >> 1;
      if ( v4 <= 0x7FFFFFFFFFFFFFFFi64 - (v4 >> 1) )
      {
        v11 = (v6 + Size) | 0xF;
        if ( v13 < v4 + v14 )
          v11 = v4 + v14;
      }
    }
    v15 = sub_14615A5E0(v11 + 1);
    Src[2] = v12;
    v16 = v15;
    Src[3] = v11;
    v17 = (char *)v15 + v6;
    if ( v4 <= 0xF )
    {
      memcpy(v15, Src, v6);
      memcpy(v17, a2, Size);
      v17[Size] = 0;
    }
    else
    {
      v18 = (_QWORD *)*Src;
      memcpy(v15, (const void *)*Src, v6);
      memcpy(v17, a2, Size);
      v17[Size] = 0;
      if ( v4 + 1 >= 0x1000 )
      {
        if ( (unsigned __int64)v18 - *(v18 - 1) - 8 > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        v18 = (_QWORD *)*(v18 - 1);
      }
      j_j_free(v18);
    }
    *Src = v16;
  }
  else
  {
    Src[2] = v6 + Size;
    v9 = Src;
    if ( v4 > 0xF )
      v9 = (_QWORD *)*Src;
    v10 = (char *)v9 + v6;
    memmove((char *)v9 + v6, a2, Size);
    v10[Size] = 0;
  }
  return Src;
}
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014618BA50) ----------------------------------------------------
_QWORD *__fastcall sub_14618BA50(_QWORD *Src, size_t Size, __int64 a3, __int64 a4)
{
  unsigned __int64 v4; // r15
  size_t v6; // r14
  int v7; // r13d
  _QWORD *v9; // rax
  char *v10; // rbx
  __int64 v11; // rbx
  size_t v12; // r12
  size_t v13; // rcx
  unsigned __int64 v14; // rdx
  _QWORD *v15; // rax
  _QWORD *v16; // rbp
  char *v17; // r12
  _QWORD *v18; // rbx

  v4 = Src[3];
  v6 = Src[2];
  v7 = (char)a3;
  if ( Size > v4 - v6 )
  {
    v11 = 0x7FFFFFFFFFFFFFFFi64;
    if ( 0x7FFFFFFFFFFFFFFFi64 - v6 < Size )
      unknown_libname_4(Src, Size, a3, a4);
    v12 = v6 + Size;
    v13 = (v6 + Size) | 0xF;
    if ( v13 <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      v14 = v4 >> 1;
      if ( v4 <= 0x7FFFFFFFFFFFFFFFi64 - (v4 >> 1) )
      {
        v11 = v13;
        if ( v13 < v4 + v14 )
          v11 = v4 + v14;
      }
    }
    v15 = sub_14615A5E0(v11 + 1);
    Src[2] = v12;
    v16 = v15;
    Src[3] = v11;
    v17 = (char *)v15 + v6;
    if ( v4 <= 0xF )
    {
      memcpy(v15, Src, v6);
      memset(v17, v7, Size);
      v17[Size] = 0;
    }
    else
    {
      v18 = (_QWORD *)*Src;
      memcpy(v15, (const void *)*Src, v6);
      memset(v17, v7, Size);
      v17[Size] = 0;
      if ( v4 + 1 >= 0x1000 )
      {
        if ( (unsigned __int64)v18 - *(v18 - 1) - 8 > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        v18 = (_QWORD *)*(v18 - 1);
      }
      j_j_free(v18);
    }
    *Src = v16;
  }
  else
  {
    Src[2] = v6 + Size;
    v9 = Src;
    if ( v4 > 0xF )
      v9 = (_QWORD *)*Src;
    v10 = (char *)v9 + v6;
    memset((char *)v9 + v6, (char)a3, Size);
    v10[Size] = 0;
  }
  return Src;
}
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014618BBD0) ----------------------------------------------------
char *__fastcall sub_14618BBD0(_QWORD *a1)
{
  _QWORD *v1; // rdx

  v1 = a1;
  if ( a1[3] > 0xFui64 )
    v1 = (_QWORD *)*a1;
  return (char *)v1 + a1[2] - 1;
}

//----- (000000014618BBF0) ----------------------------------------------------
__int64 __fastcall sub_14618BBF0(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) - 8i64;
}

//----- (000000014618BC00) ----------------------------------------------------
_QWORD *__fastcall sub_14618BC00(__int64 *a1, _QWORD *a2)
{
  __int64 v2; // r9
  __int64 v3; // r8
  __int64 v4; // r8
  unsigned __int64 v5; // rax
  __int64 v6; // r8
  _QWORD *result; // rax
  __int64 v8; // r8

  v2 = a1[3];
  v3 = *a1;
  if ( v2 >= 0 )
    v4 = v3 + 4 * ((unsigned __int64)v2 >> 5);
  else
    v4 = v3 - (4 * ((unsigned __int64)~v2 >> 5) + 4);
  v5 = (a1[3] & 0x1F) - 1;
  if ( (v2 & 0x1F) != 0 )
  {
    a2[1] = ((v2 & 0x1F) - 1) & 0x1F;
    v8 = v4 + 4 * (v5 >> 5);
    result = a2;
    *a2 = v8;
  }
  else
  {
    v6 = v4 - (4 * (~v5 >> 5) + 4);
    result = a2;
    *a2 = v6;
    a2[1] = ((v2 & 0x1F) - 1) & 0x1F;
  }
  return result;
}
// 14618BC12: conditional instruction was optimized away because r9.8<0

//----- (000000014618BC90) ----------------------------------------------------
_QWORD *__fastcall sub_14618BC90(_QWORD *a1)
{
  if ( a1[3] <= 7ui64 )
    return a1;
  else
    return (_QWORD *)*a1;
}

//----- (000000014618BCA0) ----------------------------------------------------
void __fastcall sub_14618BCA0(__int64 a1, void *a2, __int64 a3)
{
  void *v3; // rax

  v3 = a2;
  if ( (unsigned __int64)(4 * a3) >= 0x1000 )
  {
    if ( (unsigned __int64)a2 - *((_QWORD *)a2 - 1) - 8 > 0x1F )
      invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    v3 = (void *)*((_QWORD *)a2 - 1);
  }
  j_j_free(v3);
}

//----- (000000014618BD00) ----------------------------------------------------
void __fastcall sub_14618BD00(__int64 a1, void *a2, __int64 a3)
{
  void *v3; // rax

  v3 = a2;
  if ( (unsigned __int64)(32 * a3) >= 0x1000 )
  {
    if ( (unsigned __int64)a2 - *((_QWORD *)a2 - 1) - 8 > 0x1F )
      invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    v3 = (void *)*((_QWORD *)a2 - 1);
  }
  j_j_free(v3);
}

//----- (000000014618BD60) ----------------------------------------------------
void __fastcall sub_14618BD60(unsigned __int8 ***a1, __int64 a2)
{
  int v2; // r12d
  __int64 v4; // r8
  unsigned __int64 v5; // r14
  unsigned __int64 v6; // r14
  size_t v7; // r14
  _QWORD *v8; // rdi
  unsigned __int8 *v9; // rbx
  unsigned __int8 *v10; // rsi
  _QWORD *v11; // rcx
  unsigned __int8 *v12; // rax
  unsigned __int8 *v13; // rsi
  unsigned __int8 *v14; // rbx
  size_t v15; // r14
  unsigned __int8 *v16; // rbx
  unsigned __int8 *v17; // rsi
  _QWORD *v18; // rcx
  unsigned __int8 *v19; // rax
  char *v20; // rbx
  char **v21; // rcx
  char *i; // rax
  char *j; // rcx
  char *v24; // rdx
  __int64 v25; // rdi
  char *v26; // rsi
  char *v27; // rbx
  unsigned __int8 *v28; // rsi
  unsigned __int8 *v29; // rbx
  char **v30; // rdi
  __int64 *v31; // rbx
  char *v32; // r8
  __int64 **v33; // rcx
  __int64 *k; // rax
  __int64 *m; // rcx
  char *v36; // rbx
  void **v37; // rbx
  unsigned __int8 v38; // [rsp+38h] [rbp-28h]
  char **v39; // [rsp+40h] [rbp-20h] BYREF
  void *Block[2]; // [rsp+48h] [rbp-18h] BYREF
  char *v41; // [rsp+58h] [rbp-8h]

  v2 = (unsigned __int8)a2;
  if ( (unsigned __int8)(a2 - 1) > 1u )
    goto LABEL_79;
  *(_OWORD *)Block = 0i64;
  v4 = 0i64;
  v41 = 0i64;
  v5 = (unsigned __int64)(*a1)[1];
  if ( (_BYTE)a2 != 2 )
  {
    if ( v5 )
    {
      if ( v5 > 0xFFFFFFFFFFFFFFFi64 )
        goto LABEL_89;
      v15 = 2 * v5;
      v8 = sub_14615A5E0(v15 * 8);
      v16 = (unsigned __int8 *)Block[0];
      v17 = (unsigned __int8 *)Block[1];
      v18 = v8;
      if ( Block[0] != Block[1] )
      {
        do
        {
          *(_BYTE *)v18 = *v16;
          v18[1] = *((_QWORD *)v16 + 1);
          *v16 = 0;
          *((_QWORD *)v16 + 1) = 0i64;
          v18 += 2;
          v16 += 16;
        }
        while ( v16 != v17 );
        v17 = (unsigned __int8 *)Block[1];
        v16 = (unsigned __int8 *)Block[0];
      }
      if ( v16 )
      {
        if ( v16 != v17 )
        {
          do
          {
            sub_14618BD60(v16 + 8, *v16);
            v16 += 16;
          }
          while ( v16 != v17 );
          v16 = (unsigned __int8 *)Block[0];
        }
        v19 = v16;
        if ( ((v41 - (char *)v16) & 0xFFFFFFFFFFFFFFF0ui64) >= 0x1000 )
        {
          v16 = (unsigned __int8 *)*((_QWORD *)v16 - 1);
          if ( (unsigned __int64)(v19 - v16 - 8) > 0x1F )
            goto LABEL_34;
        }
        j_j_free(v16);
      }
      Block[0] = v8;
      Block[1] = v8;
      v4 = (__int64)&v8[v15];
      v41 = (char *)&v8[v15];
    }
    else
    {
      v8 = Block[1];
    }
    v20 = *(char **)**a1;
    if ( !v20[25] )
    {
      while ( 1 )
      {
        if ( v8 == (_QWORD *)v4 )
        {
          sub_14617EE50((__int64)Block, (__int64)v8, v20 + 64);
          v8 = Block[1];
        }
        else
        {
          *(_BYTE *)v8 = v20[64];
          v8[1] = *((_QWORD *)v20 + 9);
          v20[64] = 0;
          *((_QWORD *)v20 + 9) = 0i64;
          v8 = (char *)Block[1] + 16;
          Block[1] = (char *)Block[1] + 16;
        }
        v21 = (char **)*((_QWORD *)v20 + 2);
        if ( *((_BYTE *)v21 + 25) )
        {
          for ( i = (char *)*((_QWORD *)v20 + 1); !i[25]; i = (char *)*((_QWORD *)i + 1) )
          {
            if ( v20 != *((char **)i + 2) )
              break;
            v20 = i;
          }
          v20 = i;
        }
        else
        {
          v20 = (char *)*((_QWORD *)v20 + 2);
          for ( j = *v21; !j[25]; j = *(char **)j )
            v20 = j;
        }
        if ( v20[25] )
          break;
        v4 = (__int64)v41;
      }
    }
    goto LABEL_51;
  }
  v6 = (__int64)(v5 - (_QWORD)**a1) >> 4;
  if ( v6 )
  {
    if ( v6 <= 0xFFFFFFFFFFFFFFFi64 )
    {
      v7 = 2 * v6;
      v8 = sub_14615A5E0(v7 * 8);
      v9 = (unsigned __int8 *)Block[0];
      v10 = (unsigned __int8 *)Block[1];
      v11 = v8;
      if ( Block[0] != Block[1] )
      {
        do
        {
          *(_BYTE *)v11 = *v9;
          v11[1] = *((_QWORD *)v9 + 1);
          *v9 = 0;
          *((_QWORD *)v9 + 1) = 0i64;
          v11 += 2;
          v9 += 16;
        }
        while ( v9 != v10 );
        v10 = (unsigned __int8 *)Block[1];
        v9 = (unsigned __int8 *)Block[0];
      }
      if ( !v9 )
        goto LABEL_15;
      if ( v9 != v10 )
      {
        do
        {
          sub_14618BD60(v9 + 8, *v9);
          v9 += 16;
        }
        while ( v9 != v10 );
        v9 = (unsigned __int8 *)Block[0];
      }
      v12 = v9;
      if ( ((v41 - (char *)v9) & 0xFFFFFFFFFFFFFFF0ui64) < 0x1000
        || (v9 = (unsigned __int8 *)*((_QWORD *)v9 - 1), (unsigned __int64)(v12 - v9 - 8) <= 0x1F) )
      {
        j_j_free(v9);
LABEL_15:
        Block[0] = v8;
        Block[1] = v8;
        v4 = (__int64)&v8[v7];
        v41 = (char *)&v8[v7];
        goto LABEL_17;
      }
LABEL_34:
      invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
LABEL_89:
    unknown_libname_6(a1, a2, 0i64);
  }
  v8 = Block[1];
LABEL_17:
  v13 = (*a1)[1];
  v14 = **a1;
  if ( v14 != v13 )
  {
    while ( 1 )
    {
      if ( v8 == (_QWORD *)v4 )
      {
        sub_14617EE50((__int64)Block, (__int64)v8, (char *)v14);
        v8 = Block[1];
      }
      else
      {
        *(_BYTE *)v8 = *v14;
        v8[1] = *((_QWORD *)v14 + 1);
        *v14 = 0;
        *((_QWORD *)v14 + 1) = 0i64;
        v8 = (char *)Block[1] + 16;
        Block[1] = (char *)Block[1] + 16;
      }
      v14 += 16;
      if ( v14 == v13 )
        break;
      v4 = (__int64)v41;
    }
  }
LABEL_51:
  if ( Block[0] != v8 )
  {
    do
    {
      v38 = *((_BYTE *)v8 - 16);
      v39 = (char **)*(v8 - 1);
      *((_BYTE *)v8 - 16) = 0;
      *(v8 - 1) = 0i64;
      sub_14618BD60((char *)Block[1] - 8, *((unsigned __int8 *)Block[1] - 16));
      v24 = (char *)Block[1] - 16;
      Block[1] = (char *)Block[1] - 16;
      if ( v38 == 2 )
      {
        v25 = (__int64)v39;
        v26 = v39[1];
        v27 = *v39;
        if ( *v39 != v26 )
        {
          do
          {
            if ( v24 == v41 )
            {
              sub_14617EE50((__int64)Block, (__int64)v24, v27);
              v24 = (char *)Block[1];
            }
            else
            {
              *v24 = *v27;
              *((_QWORD *)v24 + 1) = *((_QWORD *)v27 + 1);
              *v27 = 0;
              *((_QWORD *)v27 + 1) = 0i64;
              v24 = (char *)Block[1] + 16;
              Block[1] = (char *)Block[1] + 16;
            }
            v27 += 16;
          }
          while ( v27 != v26 );
          v25 = (__int64)v39;
        }
        v28 = *(unsigned __int8 **)(v25 + 8);
        v29 = *(unsigned __int8 **)v25;
        if ( *(unsigned __int8 **)v25 != v28 )
        {
          do
          {
            sub_14618BD60(v29 + 8, *v29);
            v29 += 16;
          }
          while ( v29 != v28 );
          *(_QWORD *)(v25 + 8) = *(_QWORD *)v25;
        }
      }
      else if ( v38 == 1 )
      {
        v30 = v39;
        v31 = *(__int64 **)*v39;
        if ( !*((_BYTE *)v31 + 25) )
        {
          do
          {
            v32 = (char *)(v31 + 8);
            if ( v24 == v41 )
            {
              sub_14617EE50((__int64)Block, (__int64)v24, v32);
              v24 = (char *)Block[1];
            }
            else
            {
              *v24 = *v32;
              *((_QWORD *)v24 + 1) = v31[9];
              *v32 = 0;
              v31[9] = 0i64;
              v24 = (char *)Block[1] + 16;
              Block[1] = (char *)Block[1] + 16;
            }
            v33 = (__int64 **)v31[2];
            if ( *((_BYTE *)v33 + 25) )
            {
              for ( k = (__int64 *)v31[1]; !*((_BYTE *)k + 25); k = (__int64 *)k[1] )
              {
                if ( v31 != (__int64 *)k[2] )
                  break;
                v31 = k;
              }
              v31 = k;
            }
            else
            {
              v31 = (__int64 *)v31[2];
              for ( m = *v33; !*((_BYTE *)m + 25); m = (__int64 *)*m )
                v31 = m;
            }
          }
          while ( !*((_BYTE *)v31 + 25) );
          v30 = v39;
        }
        v36 = *v30;
        sub_14617F3A0(v30, v30, *((_QWORD *)*v30 + 1));
        *((_QWORD *)v36 + 1) = v36;
        *(_QWORD *)v36 = v36;
        *((_QWORD *)v36 + 2) = v36;
        v30[1] = 0i64;
      }
      sub_14618BD60(&v39, v38);
      v8 = Block[1];
    }
    while ( Block[0] != Block[1] );
  }
  sub_14618B770((unsigned __int8 **)Block);
LABEL_79:
  switch ( v2 )
  {
    case 1:
      v37 = (void **)*a1;
      sub_14617F3A0(*a1, *a1, *((_QWORD *)**a1 + 1));
      j_j_free(*v37);
      break;
    case 2:
      sub_14618B770(*a1);
      break;
    case 3:
      sub_1461626B0((__int64)*a1);
      break;
    case 8:
      sub_146176C60((__int64)*a1);
      break;
    default:
      return;
  }
  j_j_free(*a1);
}
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);
// 14617F3A0: using guessed type __int64 __fastcall sub_14617F3A0(_QWORD, _QWORD, _QWORD);

//----- (000000014618C320) ----------------------------------------------------
__int64 __fastcall sub_14618C320(unsigned __int8 *a1, __int64 a2, int a3, char a4, unsigned __int8 a5, int a6)
{
  int v6; // esi
  _DWORD *v10; // rax
  __int64 v11; // rdi
  struct lconv *v12; // rcx
  char *thousands_sep; // rax
  _BYTE *v14; // rbx
  void *v15; // rcx
  volatile signed __int32 *v16; // rbx
  __int64 *v18; // [rsp+70h] [rbp-90h] BYREF
  volatile signed __int32 *v19; // [rsp+78h] [rbp-88h]
  __int128 v20; // [rsp+80h] [rbp-80h]
  __int128 v21; // [rsp+90h] [rbp-70h]
  __int128 v22; // [rsp+A0h] [rbp-60h]
  __int128 v23; // [rsp+B0h] [rbp-50h]
  struct lconv *v24; // [rsp+C0h] [rbp-40h]
  char v25; // [rsp+C8h] [rbp-38h]
  char v26; // [rsp+C9h] [rbp-37h]
  _WORD v27[256]; // [rsp+CAh] [rbp-36h] BYREF
  char v28; // [rsp+2CAh] [rbp+1CAh]
  void *Block[2]; // [rsp+2D0h] [rbp+1D0h]
  __m128i si128; // [rsp+2E0h] [rbp+1E0h]
  int v31; // [rsp+2F0h] [rbp+1F0h]

  v6 = a4;
  *(_OWORD *)a2 = 0i64;
  *(_QWORD *)(a2 + 16) = 0i64;
  *(_QWORD *)(a2 + 24) = 15i64;
  *(_BYTE *)a2 = 0;
  v10 = operator new(0x20ui64);
  v11 = (__int64)v10;
  if ( v10 )
  {
    *(_OWORD *)v10 = 0i64;
    v10[2] = 1;
    v10[3] = 1;
    *(_QWORD *)v10 = &std::_Ref_count_obj2<nlohmann::json_abi_v3_11_2::detail::output_string_adapter<char,std::string>>::`vftable';
    *((_QWORD *)v10 + 2) = &nlohmann::json_abi_v3_11_2::detail::output_string_adapter<char,std::string>::`vftable';
    *((_QWORD *)v10 + 3) = a2;
  }
  else
  {
    v11 = 0i64;
  }
  if ( v11 )
    _InterlockedIncrement((volatile signed __int32 *)(v11 + 8));
  v18 = (__int64 *)(v11 + 16);
  v19 = (volatile signed __int32 *)v11;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0i64;
  v12 = localeconv();
  v24 = v12;
  thousands_sep = v12->thousands_sep;
  if ( thousands_sep )
    v25 = *thousands_sep;
  else
    v25 = 0;
  if ( v12->decimal_point )
    v26 = *v12->decimal_point;
  else
    v26 = 0;
  memset(v27, 0, sizeof(v27));
  v28 = v6;
  *(_OWORD *)Block = 0i64;
  si128 = 0i64;
  v14 = sub_14615A5E0(0x210ui64);
  Block[0] = v14;
  si128 = _mm_load_si128((const __m128i *)&xmmword_14612E120);
  memset(v14, v6, 0x200ui64);
  v14[512] = 0;
  v31 = a6;
  if ( v11 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v11 + 8), 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(__int64))v11)(v11);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v11 + 12), 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 8i64))(v11);
    }
  }
  if ( a3 < 0 )
    sub_14618C640(&v18, a1, 0, a5, 0, 0);
  else
    sub_14618C640(&v18, a1, 1, a5, a3, 0);
  if ( si128.m128i_i64[1] > 0xFui64 )
  {
    v15 = Block[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v15 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v15 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v15);
  }
  si128 = _mm_load_si128((const __m128i *)&Size);
  LOBYTE(Block[0]) = 0;
  v16 = v19;
  if ( v19 )
  {
    if ( _InterlockedExchangeAdd(v19 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v16)(v16);
      if ( _InterlockedExchangeAdd(v16 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v16 + 8i64))(v16);
    }
  }
  return a2;
}
// 14612CBB8: using guessed type void *nlohmann::json_abi_v3_11_2::detail::output_string_adapter<char,std::string>::`vftable';
// 14612CEF0: using guessed type void *std::_Ref_count_obj2<nlohmann::json_abi_v3_11_2::detail::output_string_adapter<char,std::string>>::`vftable';
// 14612E120: using guessed type __int128 xmmword_14612E120;

//----- (000000014618C640) ----------------------------------------------------
__int64 __fastcall sub_14618C640(
        __int64 **a1,
        unsigned __int8 *a2,
        char a3,
        unsigned __int8 a4,
        int a5,
        unsigned int a6)
{
  __int64 result; // rax
  unsigned __int8 *v8; // rbp
  __int64 *v10; // rcx
  __int64 v11; // r9
  __int64 v12; // r9
  size_t v13; // rdx
  unsigned int v14; // r12d
  unsigned __int64 v15; // r8
  __int64 v16; // rax
  _QWORD *v17; // rcx
  __int64 v18; // rax
  unsigned __int64 v19; // rsi
  _QWORD *v20; // rbx
  __int64 *v21; // rdx
  __int64 v22; // rdx
  int v23; // r8d
  __int64 **v24; // rcx
  __int64 i; // rax
  __int64 *j; // rcx
  _QWORD *v27; // rsi
  _QWORD **v28; // rdx
  __int64 v29; // rdx
  int v30; // r8d
  __int64 v31; // rdx
  __int64 *v32; // rcx
  __int64 v33; // rax
  __int64 v34; // r8
  __int64 v35; // rdx
  __int64 v36; // rax
  unsigned __int64 v37; // rsi
  _QWORD *v38; // rbx
  __int64 v39; // rdx
  __int64 **v40; // rcx
  __int64 k; // rax
  __int64 *m; // rcx
  __int64 v43; // rdx
  __int64 *v44; // rcx
  __int64 **v45; // rsi
  _QWORD *v46; // rdx
  __int64 v47; // r9
  __int64 v48; // r8
  __int64 v49; // r9
  size_t v50; // rdx
  unsigned int v51; // r12d
  _QWORD *v52; // rcx
  __int64 v53; // rbx
  __int64 *v54; // rdx
  int v55; // r8d
  _QWORD *v56; // rbx
  _QWORD **v57; // rdx
  int v58; // r8d
  __int64 v59; // rdx
  __int64 v60; // rdx
  __int64 *v61; // rdx
  __int64 n; // rbx
  __int64 v63; // rdx
  __int64 v64; // rdx
  __int64 v65; // rdx
  __int64 *v66; // rcx
  void (__fastcall *v67)(__int64 *, void *, __int64); // r9
  __int64 v68; // r8
  __int64 v69; // r9
  size_t v70; // rdx
  unsigned int v71; // r15d
  _QWORD *v72; // rcx
  _QWORD **v73; // rdx
  unsigned __int8 **v74; // rdx
  unsigned __int8 *v75; // r14
  unsigned __int8 *v76; // rax
  unsigned __int8 *v77; // rbx
  _QWORD *v78; // rdx
  __int64 v79; // rdx
  __int64 v80; // rdx
  unsigned __int8 **v81; // rdx
  unsigned __int8 *v82; // rsi
  unsigned __int8 *v83; // rax
  unsigned __int8 *v84; // rbx
  __int64 v85; // rdx
  __int64 v86; // rdx
  __int64 *v87; // rcx
  __int64 (__fastcall *v88)(__int64 *, const char *, __int64); // r9
  double v89; // xmm6_8
  char *v90; // rax
  unsigned __int8 *v91; // [rsp+78h] [rbp+10h]

  v91 = a2;
  result = *a2;
  v8 = a2;
  switch ( *a2 )
  {
    case 0u:
      return (*(__int64 (__fastcall **)(__int64 *, const char *, __int64))(**a1 + 8))(*a1, "null", 4i64);
    case 1u:
      v10 = *a1;
      v11 = **a1;
      if ( !*(_QWORD *)(*((_QWORD *)a2 + 1) + 8i64) )
        return (*(__int64 (__fastcall **)(__int64 *, const char *, __int64))(v11 + 8))(v10, "{}", 2i64);
      if ( a3 )
      {
        (*(void (__fastcall **)(__int64 *, void *, __int64))(v11 + 8))(v10, &unk_14612CB30, 2i64);
        v13 = (size_t)a1[78];
        v14 = a6 + a5;
        v15 = a6 + a5;
        if ( v13 < v15 )
        {
          v16 = 2 * v13;
          v17 = a1 + 76;
          if ( 2 * v13 > v13 )
          {
            LOBYTE(v15) = 32;
            sub_14618BA50(v17, v13, v15, v12);
            v15 = v14;
          }
          else
          {
            a1[78] = (__int64 *)v16;
            if ( (unsigned __int64)a1[79] > 0xF )
              v17 = (_QWORD *)*v17;
            *((_BYTE *)v17 + v16) = 0;
          }
        }
        v18 = *((_QWORD *)v8 + 1);
        v19 = 0i64;
        v20 = **(_QWORD ***)v18;
        if ( *(_QWORD *)(v18 + 8) != 1i64 )
        {
          do
          {
            v21 = (__int64 *)(a1 + 76);
            if ( (unsigned __int64)a1[79] > 0xF )
              v21 = a1[76];
            (*(void (__fastcall **)(__int64 *, __int64 *, unsigned __int64))(**a1 + 8))(*a1, v21, v15);
            LOBYTE(v22) = 34;
            (*(void (__fastcall **)(__int64 *, __int64))**a1)(*a1, v22);
            sub_14618D010(a1, v20 + 4, a4);
            (*(void (__fastcall **)(__int64 *, void *, __int64))(**a1 + 8))(*a1, &unk_14612CB34, 3i64);
            LOBYTE(v23) = 1;
            sub_14618C640((_DWORD)a1, (_DWORD)v20 + 64, v23, a4, a5, v14);
            (*(void (__fastcall **)(__int64 *, void *, __int64))(**a1 + 8))(*a1, &unk_14612CB38, 2i64);
            v24 = (__int64 **)v20[2];
            ++v19;
            if ( *((_BYTE *)v24 + 25) )
            {
              for ( i = v20[1]; !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
              {
                if ( v20 != *(_QWORD **)(i + 16) )
                  break;
                v20 = (_QWORD *)i;
              }
              v20 = (_QWORD *)i;
            }
            else
            {
              v20 = (_QWORD *)v20[2];
              for ( j = *v24; !*((_BYTE *)j + 25); j = (__int64 *)*j )
                v20 = j;
            }
            v15 = v14;
          }
          while ( v19 < *(_QWORD *)(*((_QWORD *)v8 + 1) + 8i64) - 1i64 );
        }
        v27 = a1 + 76;
        v28 = a1 + 76;
        if ( (unsigned __int64)a1[79] > 0xF )
          v28 = (_QWORD **)*v27;
        (*(void (__fastcall **)(__int64 *, _QWORD **, _QWORD))(**a1 + 8))(*a1, v28, v14);
        LOBYTE(v29) = 34;
        (*(void (__fastcall **)(__int64 *, __int64))**a1)(*a1, v29);
        sub_14618D010(a1, v20 + 4, a4);
        (*(void (__fastcall **)(__int64 *, void *, __int64))(**a1 + 8))(*a1, &unk_14612CB34, 3i64);
        LOBYTE(v30) = 1;
        sub_14618C640((_DWORD)a1, (_DWORD)v20 + 64, v30, a4, a5, v14);
        LOBYTE(v31) = 10;
        (*(void (__fastcall **)(__int64 *, __int64))**a1)(*a1, v31);
        v32 = *a1;
        v33 = **a1;
        if ( (unsigned __int64)a1[79] > 0xF )
          v27 = (_QWORD *)*v27;
        v34 = a6;
        goto LABEL_82;
      }
      LOBYTE(a2) = 123;
      (*(void (__fastcall **)(__int64 *, unsigned __int8 *))v11)(v10, a2);
      v36 = *((_QWORD *)v8 + 1);
      v37 = 0i64;
      v38 = **(_QWORD ***)v36;
      if ( *(_QWORD *)(v36 + 8) != 1i64 )
      {
        do
        {
          LOBYTE(v35) = 34;
          (*(void (__fastcall **)(__int64 *, __int64))**a1)(*a1, v35);
          sub_14618D010(a1, v38 + 4, a4);
          (*(void (__fastcall **)(__int64 *, void *, __int64))(**a1 + 8))(*a1, &unk_14612CB3C, 2i64);
          sub_14618C640((_DWORD)a1, (_DWORD)v38 + 64, 0, a4, a5, a6);
          LOBYTE(v39) = 44;
          (*(void (__fastcall **)(__int64 *, __int64))**a1)(*a1, v39);
          v40 = (__int64 **)v38[2];
          ++v37;
          if ( *((_BYTE *)v40 + 25) )
          {
            for ( k = v38[1]; !*(_BYTE *)(k + 25); k = *(_QWORD *)(k + 8) )
            {
              if ( v38 != *(_QWORD **)(k + 16) )
                break;
              v38 = (_QWORD *)k;
            }
            v38 = (_QWORD *)k;
          }
          else
          {
            v38 = (_QWORD *)v38[2];
            for ( m = *v40; !*((_BYTE *)m + 25); m = (__int64 *)*m )
              v38 = m;
          }
        }
        while ( v37 < *(_QWORD *)(*((_QWORD *)v8 + 1) + 8i64) - 1i64 );
      }
      LOBYTE(v35) = 34;
      (*(void (__fastcall **)(__int64 *, __int64))**a1)(*a1, v35);
      sub_14618D010(a1, v38 + 4, a4);
      (*(void (__fastcall **)(__int64 *, void *, __int64))(**a1 + 8))(*a1, &unk_14612CB3C, 2i64);
      sub_14618C640((_DWORD)a1, (_DWORD)v38 + 64, 0, a4, a5, a6);
      LOBYTE(v43) = 125;
      result = (*(__int64 (__fastcall **)(__int64 *, __int64))**a1)(*a1, v43);
      break;
    case 2u:
      v44 = *a1;
      v45 = (__int64 **)(a2 + 8);
      v46 = (_QWORD *)*((_QWORD *)a2 + 1);
      v47 = **a1;
      if ( *v46 == v46[1] )
        return (*(__int64 (__fastcall **)(__int64 *, void *, __int64))(v47 + 8))(v44, &unk_14612CB40, 2i64);
      if ( a3 )
      {
        (*(void (__fastcall **)(__int64 *, void *, __int64))(v47 + 8))(v44, &unk_14612CB44, 2i64);
        v50 = (size_t)a1[78];
        v51 = a6 + a5;
        if ( v50 < a6 + a5 )
        {
          v52 = a1 + 76;
          if ( 2 * v50 > v50 )
          {
            LOBYTE(v48) = 32;
            sub_14618BA50(v52, v50, v48, v49);
          }
          else
          {
            a1[78] = (__int64 *)(2 * v50);
            if ( (unsigned __int64)a1[79] > 0xF )
            {
              v52 = (_QWORD *)*v52;
              v45 = (__int64 **)(v8 + 8);
            }
            *((_BYTE *)v52 + 2 * v50) = 0;
          }
        }
        v53 = **v45;
        if ( v53 != (*v45)[1] - 16 )
        {
          do
          {
            v54 = (__int64 *)(a1 + 76);
            if ( (unsigned __int64)a1[79] > 0xF )
              v54 = a1[76];
            (*(void (__fastcall **)(__int64 *, __int64 *, _QWORD))(**a1 + 8))(*a1, v54, v51);
            LOBYTE(v55) = 1;
            sub_14618C640((_DWORD)a1, v53, v55, a4, a5, v51);
            (*(void (__fastcall **)(__int64 *, void *, __int64))(**a1 + 8))(*a1, &unk_14612CB38, 2i64);
            v53 += 16i64;
          }
          while ( v53 != (*v45)[1] - 16 );
          v45 = (__int64 **)(v91 + 8);
        }
        v56 = a1 + 76;
        v57 = a1 + 76;
        if ( (unsigned __int64)a1[79] > 0xF )
          v57 = (_QWORD **)*v56;
        (*(void (__fastcall **)(__int64 *, _QWORD **, _QWORD))(**a1 + 8))(*a1, v57, v51);
        LOBYTE(v58) = 1;
        sub_14618C640((_DWORD)a1, (*v45)[1] - 16, v58, a4, a5, v51);
        LOBYTE(v59) = 10;
        (*(void (__fastcall **)(__int64 *, __int64))**a1)(*a1, v59);
        if ( (unsigned __int64)a1[79] > 0xF )
          v56 = (_QWORD *)*v56;
        (*(void (__fastcall **)(__int64 *, _QWORD *, _QWORD))(**a1 + 8))(*a1, v56, a6);
        LOBYTE(v60) = 93;
        return (*(__int64 (__fastcall **)(__int64 *, __int64))**a1)(*a1, v60);
      }
      else
      {
        LOBYTE(v46) = 91;
        (*(void (__fastcall **)(__int64 *, _QWORD *))v47)(v44, v46);
        v61 = *v45;
        for ( n = **v45; n != (*v45)[1] - 16; n += 16i64 )
        {
          sub_14618C640((_DWORD)a1, n, 0, a4, a5, a6);
          LOBYTE(v63) = 44;
          (*(void (__fastcall **)(__int64 *, __int64))**a1)(*a1, v63);
          v61 = *v45;
        }
        sub_14618C640((_DWORD)a1, *((_DWORD *)v61 + 2) - 16, 0, a4, a5, a6);
        LOBYTE(v64) = 93;
        return (*(__int64 (__fastcall **)(__int64 *, __int64))**a1)(*a1, v64);
      }
    case 3u:
      LOBYTE(a2) = 34;
      (*(void (__fastcall **)(__int64 *, unsigned __int8 *))**a1)(*a1, a2);
      sub_14618D010(a1, *((_QWORD **)v8 + 1), a4);
      LOBYTE(v65) = 34;
      return (*(__int64 (__fastcall **)(__int64 *, __int64))**a1)(*a1, v65);
    case 4u:
      v87 = *a1;
      v88 = *(__int64 (__fastcall **)(__int64 *, const char *, __int64))(**a1 + 8);
      if ( a2[8] )
        return v88(v87, "true", 4i64);
      else
        return v88(v87, "false", 5i64);
    case 5u:
      return sub_146180AF0(a1, *((_QWORD *)a2 + 1));
    case 6u:
      return sub_146180CC0(a1, *((_QWORD *)a2 + 1));
    case 7u:
      v89 = *((double *)a2 + 1);
      if ( dclass(v89) > 0 )
        return (*(__int64 (__fastcall **)(__int64 *, const char *, __int64))(**a1 + 8))(*a1, "null", 4i64);
      v90 = sub_1461849E0((char *)a1 + 16, (__int64)(a1 + 10), v89);
      return (*(__int64 (__fastcall **)(__int64 *, __int64 **, signed __int64))(**a1 + 8))(
               *a1,
               a1 + 2,
               v90 - (char *)(a1 + 2));
    case 8u:
      v66 = *a1;
      v67 = *(void (__fastcall **)(__int64 *, void *, __int64))(**a1 + 8);
      if ( a3 )
      {
        v67(v66, &unk_14612CB30, 2i64);
        v70 = (size_t)a1[78];
        v71 = a6 + a5;
        if ( v70 < a6 + a5 )
        {
          v72 = a1 + 76;
          if ( 2 * v70 > v70 )
          {
            LOBYTE(v68) = 32;
            sub_14618BA50(v72, v70, v68, v69);
          }
          else
          {
            a1[78] = (__int64 *)(2 * v70);
            if ( (unsigned __int64)a1[79] > 0xF )
              v72 = (_QWORD *)*v72;
            *((_BYTE *)v72 + 2 * v70) = 0;
          }
        }
        v27 = a1 + 76;
        v73 = a1 + 76;
        if ( (unsigned __int64)a1[79] > 0xF )
          v73 = (_QWORD **)*v27;
        (*(void (__fastcall **)(__int64 *, _QWORD **, _QWORD))(**a1 + 8))(*a1, v73, v71);
        (*(void (__fastcall **)(__int64 *, const char *, __int64))(**a1 + 8))(*a1, "\"bytes\": [", 10i64);
        v74 = (unsigned __int8 **)*((_QWORD *)v8 + 1);
        v75 = v8 + 8;
        v76 = v74[1];
        v77 = *v74;
        if ( *v74 != v76 )
        {
          if ( v77 != v76 - 1 )
          {
            do
            {
              sub_1461809B0(a1, *v77);
              (*(void (__fastcall **)(__int64 *, const char *, __int64))(**a1 + 8))(*a1, ", ", 2i64);
              v74 = *(unsigned __int8 ***)v75;
              ++v77;
            }
            while ( v77 != (unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)v75 + 8i64) - 1i64) );
            v27 = a1 + 76;
            v75 = v8 + 8;
          }
          sub_1461809B0(a1, *(v74[1] - 1));
        }
        (*(void (__fastcall **)(__int64 *, const char *, __int64))(**a1 + 8))(*a1, "],\n", 3i64);
        v78 = v27;
        if ( v27[3] > 0xFui64 )
          v78 = (_QWORD *)*v27;
        (*(void (__fastcall **)(__int64 *, _QWORD *, _QWORD))(**a1 + 8))(*a1, v78, v71);
        (*(void (__fastcall **)(__int64 *, const char *, __int64))(**a1 + 8))(*a1, "\"subtype\": ", 11i64);
        if ( *(_BYTE *)(*(_QWORD *)v75 + 32i64) )
          sub_146180CC0(a1, *(_QWORD *)(*(_QWORD *)v75 + 24i64));
        else
          (*(void (__fastcall **)(__int64 *, const char *, __int64))(**a1 + 8))(*a1, "null", 4i64);
        LOBYTE(v79) = 10;
        (*(void (__fastcall **)(__int64 *, __int64))**a1)(*a1, v79);
        v32 = *a1;
        v33 = **a1;
        if ( v27[3] > 0xFui64 )
          v27 = (_QWORD *)*v27;
        v34 = a6;
LABEL_82:
        (*(void (__fastcall **)(__int64 *, _QWORD *, __int64))(v33 + 8))(v32, v27, v34);
        LOBYTE(v80) = 125;
        result = (*(__int64 (__fastcall **)(__int64 *, __int64))**a1)(*a1, v80);
      }
      else
      {
        v67(v66, "{\"bytes\":[", 10i64);
        v81 = (unsigned __int8 **)*((_QWORD *)v8 + 1);
        v82 = v8 + 8;
        v83 = v81[1];
        v84 = *v81;
        if ( *v81 != v83 )
        {
          if ( v84 != v83 - 1 )
          {
            do
            {
              sub_1461809B0(a1, *v84);
              LOBYTE(v85) = 44;
              (*(void (__fastcall **)(__int64 *, __int64))**a1)(*a1, v85);
              v81 = *(unsigned __int8 ***)v82;
              ++v84;
            }
            while ( v84 != (unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)v82 + 8i64) - 1i64) );
            v82 = v8 + 8;
          }
          sub_1461809B0(a1, *(v81[1] - 1));
        }
        (*(void (__fastcall **)(__int64 *, const char *, __int64))(**a1 + 8))(*a1, "],\"subtype\":", 12i64);
        if ( *(_BYTE *)(*(_QWORD *)v82 + 32i64) )
        {
          sub_146180CC0(a1, *(_QWORD *)(*(_QWORD *)v82 + 24i64));
          LOBYTE(v86) = 125;
          result = (*(__int64 (__fastcall **)(__int64 *, __int64))**a1)(*a1, v86);
        }
        else
        {
          result = (*(__int64 (__fastcall **)(__int64 *, const char *, __int64))(**a1 + 8))(*a1, "null}", 5i64);
        }
      }
      break;
    case 9u:
      return (*(__int64 (__fastcall **)(__int64 *, const char *, __int64))(**a1 + 8))(*a1, "<discarded>", 11i64);
    default:
      return result;
  }
  return result;
}
// 14618C719: variable 'v12' is possibly undefined
// 14618C769: variable 'v22' is possibly undefined
// 14618C7A9: variable 'v23' is possibly undefined
// 14618C85E: variable 'v29' is possibly undefined
// 14618C89E: variable 'v30' is possibly undefined
// 14618C8AB: variable 'v31' is possibly undefined
// 14618C8F9: variable 'v35' is possibly undefined
// 14618C946: variable 'v39' is possibly undefined
// 14618CA08: variable 'v43' is possibly undefined
// 14618CAA4: variable 'v48' is possibly undefined
// 14618CAA4: variable 'v49' is possibly undefined
// 14618CAFB: variable 'v55' is possibly undefined
// 14618CB72: variable 'v58' is possibly undefined
// 14618CB7F: variable 'v59' is possibly undefined
// 14618CBA2: variable 'v60' is possibly undefined
// 14618CBF3: variable 'v63' is possibly undefined
// 14618CC31: variable 'v64' is possibly undefined
// 14618CC5A: variable 'v65' is possibly undefined
// 14618CCCD: variable 'v68' is possibly undefined
// 14618CCCD: variable 'v69' is possibly undefined
// 14618CDEC: variable 'v79' is possibly undefined
// 14618CE0F: variable 'v80' is possibly undefined
// 14618CE55: variable 'v85' is possibly undefined
// 14618CEB0: variable 'v86' is possibly undefined

//----- (000000014618D010) ----------------------------------------------------
void __fastcall sub_14618D010(__int64 **a1, _QWORD *a2, char a3)
{
  unsigned int v6; // esi
  int v7; // r15d
  __int64 v8; // rbx
  __int64 v9; // r8
  __int64 v10; // r10
  unsigned __int64 v11; // rbp
  _QWORD *v12; // rax
  unsigned __int64 v13; // r11
  __int64 v14; // r9
  __int64 v15; // rdx
  __int64 v16; // rcx
  _QWORD *v17; // rax
  int v18; // edx
  char *v19; // rdx
  __int64 v20; // rcx
  _QWORD *v21; // rax
  wchar_t *v22; // r10
  __int64 *v23; // rcx
  char *v24; // rdx
  __int64 v25; // rax
  int v26; // ecx
  int v27; // ecx
  __int64 *v28; // rcx
  void (__fastcall *v29)(__int64 *, const char *, __int64); // r9
  void **v30; // rbx
  _QWORD *v31; // rax
  void **v32; // rax
  unsigned __int8 *v33; // rax
  _QWORD *v34; // rax
  void **v35; // rax
  void *v36; // [rsp+20h] [rbp-F8h]
  char pExceptionObject[56]; // [rsp+38h] [rbp-E0h] BYREF
  void *Src[4]; // [rsp+70h] [rbp-A8h] BYREF
  void *v39[4]; // [rsp+90h] [rbp-88h] BYREF
  char v40[32]; // [rsp+B0h] [rbp-68h] BYREF

  v6 = 0;
  LOBYTE(v7) = 0;
  v8 = 0i64;
  v9 = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  if ( a2[2] )
  {
    do
    {
      v12 = a2;
      v13 = a2[3];
      if ( v13 > 0xF )
        v12 = (_QWORD *)*a2;
      v14 = *((unsigned __int8 *)v12 + v11);
      v15 = byte_14612D1E0[v14];
      if ( (_BYTE)v7 )
        v6 = (v6 << 6) | v14 & 0x3F;
      else
        v6 = v14 & (0xFFu >> v15);
      v16 = v15 + 16i64 * (unsigned __int8)v7;
      v7 = byte_14612D1E0[v16 + 256];
      if ( byte_14612D1E0[v16 + 256] )
      {
        if ( v7 == 1 )
        {
          v18 = *((_DWORD *)a1 + 160);
          if ( !v18 )
          {
            v30 = (void **)sub_14618EF10((__int64)v40, v14);
            v31 = sub_1461928C0(Src, v11);
            v32 = sub_14617F9D0(v39, "invalid UTF-8 byte at index ", v31, ": 0x", v30);
            sub_1461804D0((__int64)pExceptionObject, 0x13Cu, v32, 0i64);
            CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVtype_error_detail_json_abi_v3_11_2_nlohmann__);
          }
          if ( (unsigned int)(v18 - 1) <= 1 )
          {
            if ( v10 )
              --v11;
            v8 = v9;
            if ( v18 == 1 )
            {
              v19 = (char *)a1 + 90;
              if ( a3 )
              {
                v19[v9] = 92;
                *(_WORD *)((char *)a1 + v9 + 91) = 26229;
                *(_WORD *)((char *)a1 + v9 + 93) = 26214;
                v20 = v9 + 5;
                *((_BYTE *)a1 + v9 + 95) = 100;
              }
              else
              {
                v19[v9] = -17;
                *(_WORD *)((char *)a1 + v9 + 91) = -16961;
                v20 = v9 + 2;
              }
              v8 = v20 + 1;
              if ( (unsigned __int64)(511 - v20) < 0xD )
              {
                (*(void (__fastcall **)(__int64 *, char *, __int64))(**a1 + 8))(*a1, v19, v8);
                v8 = 0i64;
              }
              v9 = v8;
            }
            v10 = 0i64;
            LOBYTE(v7) = 0;
          }
        }
        else
        {
          if ( !a3 )
          {
            v17 = a2;
            if ( v13 > 0xF )
              v17 = (_QWORD *)*a2;
            *((_BYTE *)a1 + v8++ + 90) = *((_BYTE *)v17 + v11);
          }
          ++v10;
        }
      }
      else
      {
        switch ( v6 )
        {
          case 8u:
            *((_BYTE *)a1 + v8 + 90) = 92;
            *((_BYTE *)a1 + v8 + 91) = 98;
            v8 += 2i64;
            break;
          case 9u:
            *((_BYTE *)a1 + v8 + 90) = 92;
            *((_BYTE *)a1 + v8 + 91) = 116;
            v8 += 2i64;
            break;
          case 0xAu:
            *((_BYTE *)a1 + v8 + 90) = 92;
            *((_BYTE *)a1 + v8 + 91) = 110;
            v8 += 2i64;
            break;
          case 0xCu:
            *((_BYTE *)a1 + v8 + 90) = 92;
            *((_BYTE *)a1 + v8 + 91) = 102;
            v8 += 2i64;
            break;
          case 0xDu:
            *((_BYTE *)a1 + v8 + 90) = 92;
            *((_BYTE *)a1 + v8 + 91) = 114;
            v8 += 2i64;
            break;
          case 0x22u:
            *((_BYTE *)a1 + v8 + 90) = 92;
            *((_BYTE *)a1 + v8 + 91) = 34;
            v8 += 2i64;
            break;
          case 0x5Cu:
            *((_BYTE *)a1 + v8 + 90) = 92;
            *((_BYTE *)a1 + v8 + 91) = 92;
            v8 += 2i64;
            break;
          default:
            if ( v6 <= 0x1F || a3 && v6 >= 0x7F )
            {
              v22 = (wchar_t *)((char *)a1 + v8);
              if ( v6 > 0xFFFF )
              {
                LODWORD(v36) = (unsigned __int16)((v6 & 0x3FF) - 9216);
                swprintf(v22 + 45, (const wchar_t *)0xD, "\\u%04x\\u%04x", (unsigned __int16)((v6 >> 10) - 10304), v36);
                v8 += 12i64;
              }
              else
              {
                swprintf(v22 + 45, (const wchar_t *)7, "\\u%04x", (unsigned __int16)v6);
                v8 += 6i64;
              }
            }
            else
            {
              v21 = a2;
              if ( v13 > 0xF )
                v21 = (_QWORD *)*a2;
              *((_BYTE *)a1 + v8++ + 90) = *((_BYTE *)v21 + v11);
            }
            break;
        }
        if ( (unsigned __int64)(512 - v8) < 0xD )
        {
          (*(void (__fastcall **)(__int64 *, __int64, __int64))(**a1 + 8))(*a1, (__int64)a1 + 90, v8);
          v8 = 0i64;
        }
        v9 = v8;
        v10 = 0i64;
      }
      ++v11;
    }
    while ( v11 < a2[2] );
    if ( !(_BYTE)v7 )
    {
      if ( !v8 )
        return;
      v23 = *a1;
      v24 = (char *)a1 + 90;
      v25 = **a1;
      v9 = v8;
      goto LABEL_50;
    }
    v26 = *((_DWORD *)a1 + 160);
    if ( !v26 )
    {
      v33 = (unsigned __int8 *)sub_14618BBD0(a2);
      v34 = (_QWORD *)sub_14618EF10((__int64)v39, *v33);
      v35 = sub_14617F690(Src, "incomplete UTF-8 string; last byte: 0x", v34);
      sub_1461804D0((__int64)pExceptionObject, 0x13Cu, v35, 0i64);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVtype_error_detail_json_abi_v3_11_2_nlohmann__);
    }
    v27 = v26 - 1;
    if ( v27 )
    {
      if ( v27 == 1 )
      {
        v23 = *a1;
        v24 = (char *)a1 + 90;
        v25 = **a1;
LABEL_50:
        (*(void (__fastcall **)(__int64 *, char *, __int64))(v25 + 8))(v23, v24, v9);
      }
    }
    else
    {
      (*(void (__fastcall **)(__int64 *, __int64, __int64))(**a1 + 8))(*a1, (__int64)a1 + 90, v9);
      v28 = *a1;
      v29 = *(void (__fastcall **)(__int64 *, const char *, __int64))(**a1 + 8);
      if ( a3 )
        v29(v28, "\\ufffd", 6i64);
      else
        v29(v28, byte_14612D028, 3i64);
    }
  }
}
// 14618D2C3: variable 'v36' is possibly undefined
// 14612D1E0: using guessed type unsigned __int8[400];
// 14618D010: using guessed type char var_68[32];

//----- (000000014618D4F0) ----------------------------------------------------
_QWORD *__fastcall sub_14618D4F0(__int64 a1, _QWORD *a2)
{
  _BYTE *v2; // r8
  _QWORD *result; // rax

  *a2 = a1;
  a2[1] = 0i64;
  a2[2] = 0i64;
  a2[3] = 0x8000000000000000ui64;
  v2 = (_BYTE *)*a2;
  switch ( *(_BYTE *)*a2 )
  {
    case 1:
      result = a2;
      a2[1] = **((_QWORD **)v2 + 1);
      break;
    case 2:
      result = a2;
      a2[2] = *(_QWORD *)(*((_QWORD *)v2 + 1) + 8i64);
      break;
    default:
      a2[3] = 1i64;
      result = a2;
      break;
  }
  return result;
}

//----- (000000014618D580) ----------------------------------------------------
char __fastcall sub_14618D580(_QWORD *a1)
{
  __int64 v2; // rax
  __int64 v3; // rcx
  unsigned __int8 *v4; // rax
  __int64 v5; // r9
  unsigned __int8 v6; // dl
  __int64 v7; // r8
  __int64 v8; // rax
  __int64 v9; // rbx
  __int64 v10; // rbx
  char v12[32]; // [rsp+28h] [rbp-20h] BYREF
  char v13; // [rsp+50h] [rbp+8h] BYREF
  int v14; // [rsp+58h] [rbp+10h] BYREF

  v2 = a1[2];
  if ( !*(_QWORD *)(v2 - 8) )
    goto LABEL_7;
  v14 = ((v2 - a1[1]) >> 3) - 1;
  v13 = 3;
  v3 = a1[21];
  if ( !v3 )
  {
    std::_Xbad_function_call();
    JUMPOUT(0x14618D67Di64);
  }
  if ( (*(unsigned __int8 (__fastcall **)(__int64, int *, char *))(*(_QWORD *)v3 + 16i64))(v3, &v14, &v13) )
  {
LABEL_7:
    a1[2] -= 8i64;
    sub_1461900F0(a1 + 4);
  }
  else
  {
    v4 = (unsigned __int8 *)sub_146185420((__int64)v12, (__int64)(a1 + 23));
    v5 = *(_QWORD *)(a1[2] - 8i64);
    v6 = *(_BYTE *)v5;
    *(_BYTE *)v5 = *v4;
    *v4 = v6;
    v7 = *(_QWORD *)(v5 + 8);
    *(_QWORD *)(v5 + 8) = *((_QWORD *)v4 + 1);
    *((_QWORD *)v4 + 1) = v7;
    sub_14618BD60((unsigned __int8 ***)v4 + 1, *v4);
    a1[2] -= 8i64;
    sub_1461900F0(a1 + 4);
    v8 = a1[2];
    if ( a1[1] != v8 )
    {
      v9 = *(_QWORD *)(v8 - 8);
      if ( *(_BYTE *)v9 == 2 )
      {
        v10 = *(_QWORD *)(v9 + 8);
        sub_14618BD60(
          (unsigned __int8 ***)(*(_QWORD *)(v10 + 8) - 8i64),
          *(unsigned __int8 *)(*(_QWORD *)(v10 + 8) - 16i64));
        *(_QWORD *)(v10 + 8) -= 16i64;
        return 1;
      }
    }
  }
  return 1;
}
// 14618D678: control flows out of bounds to 14618D67D
// 14618D580: using guessed type char var_20[32];

//----- (000000014618D680) ----------------------------------------------------
char __fastcall sub_14618D680(_QWORD *a1)
{
  __int64 v2; // rax
  __int64 v3; // rcx
  unsigned __int8 *v4; // rax
  unsigned __int8 *v5; // r9
  unsigned __int8 v6; // dl
  __int64 v7; // r8
  __int64 v8; // rdx
  unsigned __int8 *v9; // rdi
  unsigned __int64 v10; // r8
  int v11; // ebx
  __int64 *v12; // rax
  _BYTE *v13; // r10
  unsigned __int64 v14; // r9
  __int64 v15; // rcx
  __int64 v16; // rdx
  bool v17; // zf
  _BYTE *v18; // rcx
  __int64 *v19; // rcx
  __int64 *v20; // rdx
  char v22[8]; // [rsp+28h] [rbp-29h] BYREF
  __int64 pExceptionObject; // [rsp+30h] [rbp-21h] BYREF
  __int128 v24; // [rsp+38h] [rbp-19h]
  unsigned __int64 v25; // [rsp+48h] [rbp-9h]
  __int64 v26; // [rsp+68h] [rbp+17h]
  __int64 v27[4]; // [rsp+70h] [rbp+1Fh] BYREF

  v26 = -2i64;
  v2 = a1[2];
  if ( *(_QWORD *)(v2 - 8) )
  {
    LODWORD(pExceptionObject) = ((v2 - a1[1]) >> 3) - 1;
    v22[0] = 1;
    v3 = a1[21];
    if ( !v3 )
    {
      std::_Xbad_function_call();
      __debugbreak();
    }
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64 *, char *))(*(_QWORD *)v3 + 16i64))(
            v3,
            &pExceptionObject,
            v22) )
    {
      v4 = (unsigned __int8 *)sub_146185420((__int64)&pExceptionObject, (__int64)(a1 + 23));
      v5 = *(unsigned __int8 **)(a1[2] - 8i64);
      v6 = *v5;
      *v5 = *v4;
      *v4 = v6;
      v7 = *((_QWORD *)v5 + 1);
      *((_QWORD *)v5 + 1) = *((_QWORD *)v4 + 1);
      *((_QWORD *)v4 + 1) = v7;
      sub_14618BD60((unsigned __int8 ***)v4 + 1, *v4);
    }
  }
  a1[2] -= 8i64;
  sub_1461900F0(a1 + 4);
  v8 = a1[2];
  if ( a1[1] != v8 )
  {
    v9 = *(unsigned __int8 **)(v8 - 8);
    if ( v9 )
    {
      if ( *v9 == 2 || *v9 == 1 )
      {
        v24 = 0ui64;
        v10 = 0x8000000000000000ui64;
        v25 = 0x8000000000000000ui64;
        v11 = *v9;
        switch ( *v9 )
        {
          case 0u:
          case 3u:
          case 4u:
          case 5u:
          case 6u:
          case 7u:
          case 8u:
          case 9u:
            switch ( *v9 )
            {
              case 0u:
                v10 = 1i64;
                goto LABEL_15;
              case 1u:
                goto LABEL_12;
              case 2u:
                goto LABEL_13;
              default:
                goto LABEL_14;
            }
          case 1u:
LABEL_12:
            v12 = (__int64 *)***((_QWORD ***)v9 + 1);
            *(_QWORD *)&v24 = v12;
            goto LABEL_16;
          case 2u:
LABEL_13:
            v13 = (_BYTE *)**((_QWORD **)v9 + 1);
            *((_QWORD *)&v24 + 1) = v13;
            v12 = (__int64 *)v24;
            goto LABEL_17;
          default:
LABEL_14:
            v10 = 0i64;
LABEL_15:
            v12 = (__int64 *)v24;
            v25 = v10;
LABEL_16:
            v13 = (_BYTE *)*((_QWORD *)&v24 + 1);
            break;
        }
        while ( 1 )
        {
LABEL_17:
          memset(&v27[1], 0, 24);
          v14 = 0x8000000000000000ui64;
          switch ( *v9 )
          {
            case 0u:
            case 3u:
            case 4u:
            case 5u:
            case 6u:
            case 7u:
            case 8u:
            case 9u:
              switch ( *v9 )
              {
                case 1u:
                  goto LABEL_19;
                case 2u:
                  goto LABEL_20;
                default:
                  goto LABEL_21;
              }
            case 1u:
LABEL_19:
              v15 = **((_QWORD **)v9 + 1);
              goto LABEL_22;
            case 2u:
LABEL_20:
              v16 = *(_QWORD *)(*((_QWORD *)v9 + 1) + 8i64);
              v15 = v27[1];
              goto LABEL_23;
            default:
LABEL_21:
              v14 = 1i64;
              v15 = v27[1];
LABEL_22:
              v16 = v27[2];
LABEL_23:
              switch ( v11 )
              {
                case 1:
                  v17 = v12 == (__int64 *)v15;
                  break;
                case 2:
                  v17 = v13 == (_BYTE *)v16;
                  break;
                default:
                  v17 = v10 == v14;
                  break;
              }
              if ( v17 )
                return 1;
              switch ( v11 )
              {
                case 1:
                  v18 = v12 + 8;
                  break;
                case 2:
                  v18 = v13;
                  break;
                default:
                  if ( v10 )
                  {
                    sub_146178620(v27, "cannot get value");
                    sub_146180740((__int64)&pExceptionObject, 0xD6u, v27);
                    CxxThrowException(
                      &pExceptionObject,
                      (_ThrowInfo *)&_TI3_AVinvalid_iterator_detail_json_abi_v3_11_2_nlohmann__);
                  }
                  v18 = v9;
                  break;
              }
              if ( *v18 == 9 )
              {
                v27[0] = (__int64)v9;
                *(_OWORD *)&v27[1] = v24;
                v27[3] = v25;
                sub_146180E30((__int64)v9, &pExceptionObject, v27);
                return 1;
              }
              switch ( v11 )
              {
                case 1:
                  v19 = v12;
                  v12 = (__int64 *)v12[2];
                  if ( *((_BYTE *)v12 + 25) )
                  {
                    v12 = (__int64 *)v19[1];
                    if ( !*((_BYTE *)v12 + 25) )
                    {
                      while ( v19 == (__int64 *)v12[2] )
                      {
                        v19 = v12;
                        v12 = (__int64 *)v12[1];
                        if ( *((_BYTE *)v12 + 25) )
                        {
                          *(_QWORD *)&v24 = v12;
                          goto LABEL_17;
                        }
                      }
                    }
                  }
                  else
                  {
                    v20 = (__int64 *)*v12;
                    if ( !*(_BYTE *)(*v12 + 25) )
                    {
                      do
                      {
                        v12 = v20;
                        v20 = (__int64 *)*v20;
                      }
                      while ( !*((_BYTE *)v20 + 25) );
                    }
                  }
                  *(_QWORD *)&v24 = v12;
                  break;
                case 2:
                  v13 += 16;
                  *((_QWORD *)&v24 + 1) = v13;
                  break;
                default:
                  v25 = ++v10;
                  break;
              }
              break;
          }
        }
      }
    }
  }
  return 1;
}
// 14618D680: using guessed type char var_80[8];

//----- (000000014618DB00) ----------------------------------------------------
__int64 __fastcall sub_14618DB00(unsigned __int64 *a1, __int64 a2, __m128i *a3)
{
  __m128i v5; // xmm0
  __int64 v6; // r9
  __int64 v7; // r10
  unsigned __int64 v8; // r8
  __int64 v9; // rdx
  signed __int64 v10; // r8
  __int64 v11; // rsi
  __int64 v12; // r9
  __int64 v13; // rdx
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rdx
  __int64 v16; // r9
  unsigned __int64 v17; // rax
  int v18; // ecx
  __int128 v20; // [rsp+30h] [rbp-48h] BYREF
  __int128 v21; // [rsp+40h] [rbp-38h] BYREF
  __int128 v22; // [rsp+50h] [rbp-28h] BYREF
  __int128 v23; // [rsp+60h] [rbp-18h] BYREF

  v5 = *a3;
  v6 = *a1;
  v7 = *a1;
  v20 = *a1;
  v8 = 0i64;
  v9 = a1[3];
  if ( v9 )
  {
    v10 = _mm_srli_si128(v5, 8).m128i_u64[0] + 32 * ((v5.m128i_i64[0] - v6) >> 2);
    if ( v10 >= 0 )
      v7 = v6 + 4 * ((unsigned __int64)v10 >> 5);
    else
      v7 -= 4 * ((unsigned __int64)~v10 >> 5) + 4;
    v8 = v10 & 0x1F;
    *((_QWORD *)&v20 + 1) = (unsigned int)v8;
    *(_QWORD *)&v20 = v7;
  }
  v11 = v8 + 32 * ((v7 - v6) >> 2);
  if ( v9 >= 0 )
    v12 = v6 + 4 * ((unsigned __int64)v9 >> 5);
  else
    v12 = v6 - (4 * ((unsigned __int64)~v9 >> 5) + 4);
  v13 = v9 & 0x1F;
  if ( v8 >= 0x1F )
    v20 = (unsigned __int64)(v20 + 4);
  else
    *((_QWORD *)&v20 + 1) = v8 + 1;
  *(_QWORD *)&v21 = v7;
  *((_QWORD *)&v21 + 1) = v8;
  v22 = v21;
  *(_QWORD *)&v21 = v12;
  *((_QWORD *)&v21 + 1) = v13;
  sub_14617DCF0(&v23, (__int64)&v20, (__int64)&v21, (__int64)&v22);
  v14 = a1[3] - 1;
  if ( v14 > 0x7FFFFFFFFFFFFFFFi64 )
    unknown_libname_7(v14);
  v15 = (v14 + 31) >> 5;
  v16 = *a1;
  if ( v15 < (__int64)(a1[1] - *a1) >> 2 )
  {
    v17 = v16 + 4 * v15;
    if ( v17 != a1[1] )
      a1[1] = v17;
  }
  a1[3] = v14;
  v18 = v14 & 0x1F;
  if ( v18 )
    *(_DWORD *)(v16 + 4 * v15 - 4) &= (1 << v18) - 1;
  v21 = *a1;
  sub_146186F80(&v21, a2, v11);
  return a2;
}
// 14618DB63: conditional instruction was optimized away because r8.8<0
// 14618DBB1: conditional instruction was optimized away because rdx.8<0
// 14618B8B0: using guessed type void __fastcall __noreturn unknown_libname_7(_QWORD);

//----- (000000014618DCE0) ----------------------------------------------------
__int64 __fastcall sub_14618DCE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  __int64 v6; // r12
  __int64 v7; // rdx
  size_t v8; // rsi
  __int64 v9; // r9
  __int64 v10; // r9
  size_t v11; // r8
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  size_t v16; // r14
  size_t v17; // r15
  void **v18; // rax
  size_t v19; // rbx
  size_t v20; // r8
  _QWORD *v21; // rdi
  size_t v22; // rcx
  _WORD *v23; // r12
  size_t v24; // r8
  char *v25; // r14
  char *v26; // rax
  void **v27; // rdx
  void *v28; // rcx
  __int64 v29; // r8
  __int64 v30; // r9
  int v31; // ecx
  _QWORD *v32; // r14
  char *v33; // rdi
  unsigned __int64 v34; // rdx
  __int64 v35; // r8
  __int64 v36; // r9
  size_t v37; // rax
  __int64 v38; // r9
  __int64 v39; // r9
  __int64 v40; // r9
  size_t v41; // r8
  __int64 v42; // rdx
  __int64 v43; // rcx
  __int64 v44; // r8
  __int64 v45; // r9
  size_t v46; // rdi
  size_t v47; // r14
  void **v48; // rax
  size_t v49; // r12
  _QWORD *v50; // rbx
  size_t v51; // rcx
  size_t v52; // rdx
  _WORD *v53; // r15
  size_t v54; // r8
  char *v55; // rdi
  char *v56; // rax
  void **v57; // rdx
  void *v58; // rcx
  void *v59; // rcx
  char *v60; // rbx
  unsigned __int64 v61; // rdx
  __int64 v62; // r8
  __int64 v63; // r9
  __int64 v64; // r9
  size_t v65; // rax
  __int64 v66; // r9
  __int64 v67; // r9
  void **v68; // rdx
  char *v69; // rbx
  unsigned __int64 v70; // rdx
  __int64 v71; // r8
  __int64 v72; // r9
  __int64 v73; // r9
  size_t v74; // rax
  __int64 v75; // r9
  __int64 v76; // r9
  void **v77; // rdx
  void *v78; // rcx
  int v80; // [rsp+34h] [rbp-55h]
  size_t v81; // [rsp+38h] [rbp-51h]
  void *Src[2]; // [rsp+58h] [rbp-31h] BYREF
  size_t Size[2]; // [rsp+68h] [rbp-21h]
  void *v85; // [rsp+78h] [rbp-11h] BYREF
  unsigned __int64 v86; // [rsp+90h] [rbp+7h]

  v4 = (_QWORD *)a4;
  v80 = a3;
  v6 = a1;
  *(_OWORD *)a2 = 0i64;
  *(_QWORD *)(a2 + 16) = 13i64;
  *(_QWORD *)(a2 + 24) = 15i64;
  strcpy((char *)a2, "syntax error ");
  v7 = *(_QWORD *)(a4 + 16);
  v8 = 0x7FFFFFFFFFFFFFFFi64;
  if ( v7 )
  {
    *(_OWORD *)Src = 0i64;
    Size[0] = 0i64;
    Size[1] = 15i64;
    LOBYTE(Src[0]) = 0;
    sub_146190960(Src, v7 + 15, a3, a4);
    sub_14618B8D0(Src, "while parsing ", 0xEui64, v9);
    v11 = v4[2];
    if ( v4[3] > 0xFui64 )
      v4 = (_QWORD *)*v4;
    sub_14618B8D0(Src, v4, v11, v10);
    v16 = Size[0];
    v17 = Size[1];
    if ( Size[0] >= Size[1] )
    {
      if ( Size[0] == 0x7FFFFFFFFFFFFFFFi64 )
        unknown_libname_4(v13, v12, v14, v15);
      v81 = Size[0] + 1;
      v19 = (Size[0] + 1) | 0xF;
      if ( v19 <= 0x7FFFFFFFFFFFFFFFi64 )
      {
        v22 = Size[1] >> 1;
        if ( Size[1] <= 0x7FFFFFFFFFFFFFFFi64 - (Size[1] >> 1) )
        {
          if ( v19 < Size[1] + v22 )
            v19 = Size[1] + v22;
        }
        else
        {
          v19 = 0x7FFFFFFFFFFFFFFFi64;
        }
      }
      else
      {
        v19 = 0x7FFFFFFFFFFFFFFFi64;
      }
      v21 = sub_14615A5E0(v19 + 1);
      Size[0] = v16 + 1;
      Size[1] = v19;
      v23 = (_WORD *)((char *)v21 + v16);
      v24 = v16;
      if ( v17 <= 0xF )
      {
        memcpy(v21, Src, v16);
        *v23 = 32;
      }
      else
      {
        v25 = (char *)Src[0];
        memcpy(v21, Src[0], v24);
        *v23 = 32;
        v26 = v25;
        if ( v17 + 1 >= 0x1000 )
        {
          v25 = (char *)*((_QWORD *)v25 - 1);
          if ( (unsigned __int64)(v26 - v25 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v25);
      }
      v6 = a1;
      v20 = v81;
      Src[0] = v21;
    }
    else
    {
      ++Size[0];
      v18 = Src;
      if ( Size[1] > 0xF )
        v18 = (void **)Src[0];
      *(_WORD *)((char *)v18 + v16) = 32;
      v19 = Size[1];
      v20 = Size[0];
      v21 = Src[0];
    }
    v27 = Src;
    if ( v19 > 0xF )
      v27 = (void **)v21;
    sub_14618B8D0((_QWORD *)a2, v27, v20, v15);
    if ( Size[1] > 0xF )
    {
      v28 = Src[0];
      if ( Size[1] + 1 >= 0x1000 )
      {
        v28 = (void *)*((_QWORD *)Src[0] - 1);
        if ( (unsigned __int64)(Src[0] - v28 - 8) > 0x1F )
          goto LABEL_70;
      }
      j_j_free(v28);
    }
  }
  sub_14618B8D0((_QWORD *)a2, "- ", 2ui64, a4);
  v31 = *(_DWORD *)(v6 + 64);
  if ( v31 != 14 )
  {
    v60 = (char *)sub_146192950(v31);
    *(_OWORD *)Src = 0i64;
    *(__m128i *)Size = _mm_load_si128((const __m128i *)&::Size);
    LOBYTE(Src[0]) = 0;
    v61 = strlen(v60) + 11;
    sub_146190960(Src, v61, v62, v63);
    sub_14618B8D0(Src, "unexpected ", 0xBui64, v64);
    v65 = strlen(v60);
    sub_14618B8D0(Src, v60, v65, v66);
    v68 = Src;
    if ( Size[1] > 0xF )
      v68 = (void **)Src[0];
    sub_14618B8D0((_QWORD *)a2, v68, Size[0], v67);
    if ( Size[1] <= 0xF )
      goto LABEL_64;
    v59 = Src[0];
    if ( Size[1] + 1 < 0x1000 || (v59 = (void *)*((_QWORD *)Src[0] - 1), (unsigned __int64)(Src[0] - v59 - 8) <= 0x1F) )
    {
LABEL_63:
      j_j_free(v59);
      goto LABEL_64;
    }
LABEL_70:
    invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
  }
  v32 = sub_14618E820(v6 + 72, &v85, v29, v30);
  v33 = *(char **)(v6 + 184);
  *(_OWORD *)Src = 0i64;
  Size[0] = 0i64;
  Size[1] = 15i64;
  LOBYTE(Src[0]) = 0;
  v34 = v32[2] + strlen(v33) + 15;
  sub_146190960(Src, v34, v35, v36);
  v37 = strlen(v33);
  sub_14618B8D0(Src, v33, v37, v38);
  sub_14618B8D0(Src, "; last read: '", 0xEui64, v39);
  v41 = v32[2];
  if ( v32[3] > 0xFui64 )
    v32 = (_QWORD *)*v32;
  sub_14618B8D0(Src, v32, v41, v40);
  v46 = Size[0];
  v47 = Size[1];
  if ( Size[0] >= Size[1] )
  {
    if ( Size[0] == 0x7FFFFFFFFFFFFFFFi64 )
      unknown_libname_4(v43, v42, v44, v45);
    v49 = Size[0] + 1;
    v51 = (Size[0] + 1) | 0xF;
    if ( v51 <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      v52 = Size[1] >> 1;
      if ( Size[1] <= 0x7FFFFFFFFFFFFFFFi64 - (Size[1] >> 1) )
      {
        v8 = (Size[0] + 1) | 0xF;
        if ( v51 < Size[1] + v52 )
          v8 = Size[1] + v52;
      }
    }
    v50 = sub_14615A5E0(v8 + 1);
    Size[0] = v46 + 1;
    Size[1] = v8;
    v53 = (_WORD *)((char *)v50 + v46);
    v54 = v46;
    if ( v47 <= 0xF )
    {
      memcpy(v50, Src, v46);
      *v53 = 39;
    }
    else
    {
      v55 = (char *)Src[0];
      memcpy(v50, Src[0], v54);
      *v53 = 39;
      v56 = v55;
      if ( v47 + 1 >= 0x1000 )
      {
        v55 = (char *)*((_QWORD *)v55 - 1);
        if ( (unsigned __int64)(v56 - v55 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v55);
    }
    Src[0] = v50;
  }
  else
  {
    ++Size[0];
    v48 = Src;
    if ( Size[1] > 0xF )
      v48 = (void **)Src[0];
    *(_WORD *)((char *)v48 + v46) = 39;
    v8 = Size[1];
    v49 = Size[0];
    v50 = Src[0];
  }
  v57 = Src;
  if ( v8 > 0xF )
    v57 = (void **)v50;
  sub_14618B8D0((_QWORD *)a2, v57, v49, v45);
  if ( Size[1] > 0xF )
  {
    v58 = Src[0];
    if ( Size[1] + 1 >= 0x1000 )
    {
      v58 = (void *)*((_QWORD *)Src[0] - 1);
      if ( (unsigned __int64)(Src[0] - v58 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v58);
  }
  if ( v86 > 0xF )
  {
    v59 = v85;
    if ( v86 + 1 >= 0x1000 )
    {
      v59 = (void *)*((_QWORD *)v85 - 1);
      if ( (unsigned __int64)((_BYTE *)v85 - (_BYTE *)v59 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    goto LABEL_63;
  }
LABEL_64:
  if ( v80 )
  {
    v69 = (char *)sub_146192950(v80);
    *(_OWORD *)Src = 0i64;
    *(__m128i *)Size = _mm_load_si128((const __m128i *)&::Size);
    LOBYTE(Src[0]) = 0;
    v70 = strlen(v69) + 11;
    sub_146190960(Src, v70, v71, v72);
    sub_14618B8D0(Src, "; expected ", 0xBui64, v73);
    v74 = strlen(v69);
    sub_14618B8D0(Src, v69, v74, v75);
    v77 = Src;
    if ( Size[1] > 0xF )
      v77 = (void **)Src[0];
    sub_14618B8D0((_QWORD *)a2, v77, Size[0], v76);
    if ( Size[1] > 0xF )
    {
      v78 = Src[0];
      if ( Size[1] + 1 >= 0x1000 )
      {
        v78 = (void *)*((_QWORD *)Src[0] - 1);
        if ( (unsigned __int64)(Src[0] - v78 - 8) > 0x1F )
          goto LABEL_70;
      }
      j_j_free(v78);
    }
  }
  return a2;
}
// 14618DDC2: variable 'v9' is possibly undefined
// 14618DDDC: variable 'v10' is possibly undefined
// 14618DF10: variable 'v15' is possibly undefined
// 14618DF67: variable 'a4' is possibly undefined
// 14618DF83: variable 'v29' is possibly undefined
// 14618DF83: variable 'v30' is possibly undefined
// 14618DFC9: variable 'v35' is possibly undefined
// 14618DFC9: variable 'v36' is possibly undefined
// 14618DFE0: variable 'v38' is possibly undefined
// 14618DFF6: variable 'v39' is possibly undefined
// 14618E010: variable 'v40' is possibly undefined
// 14618E131: variable 'v45' is possibly undefined
// 14618E218: variable 'v62' is possibly undefined
// 14618E218: variable 'v63' is possibly undefined
// 14618E22E: variable 'v64' is possibly undefined
// 14618E245: variable 'v66' is possibly undefined
// 14618E25F: variable 'v67' is possibly undefined
// 14618E2E4: variable 'v71' is possibly undefined
// 14618E2E4: variable 'v72' is possibly undefined
// 14618E2FA: variable 'v73' is possibly undefined
// 14618E311: variable 'v75' is possibly undefined
// 14618E32B: variable 'v76' is possibly undefined
// 14618E3A5: variable 'v43' is possibly undefined
// 14618E3A5: variable 'v42' is possibly undefined
// 14618E3A5: variable 'v44' is possibly undefined
// 14618E3AB: variable 'v13' is possibly undefined
// 14618E3AB: variable 'v12' is possibly undefined
// 14618E3AB: variable 'v14' is possibly undefined
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014618E3C0) ----------------------------------------------------
__int64 __fastcall sub_14618E3C0(_QWORD *a1, const wchar_t *a2, size_t a3)
{
  size_t v6; // rax
  size_t v7; // r8
  char *v9; // rbx
  __int64 v10; // rax

  v6 = wcslen(a2);
  v7 = a1[2];
  if ( a1[3] > 7ui64 )
    a1 = (_QWORD *)*a1;
  if ( v6 > v7 || a3 > v7 - v6 )
    return -1i64;
  if ( !v6 )
    return a3;
  v9 = (char *)a1 + 2 * v7;
  v10 = sub_1461A7850((char *)a1 + 2 * a3, v9, a2, v6);
  if ( (char *)v10 == v9 )
    return -1i64;
  else
    return (v10 - (__int64)a1) >> 1;
}
// 1461A7850: using guessed type __int64 __fastcall sub_1461A7850(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014618E470) ----------------------------------------------------
char *__fastcall sub_14618E470(char *Src, int a2, int a3, int a4, int a5)
{
  int v5; // esi
  char *result; // rax
  __int64 v8; // rdi
  char *v9; // rbx
  __int64 v10; // rdi
  int v11; // esi
  char *v12; // rdi
  __int64 v13; // rbx
  char v14; // al
  unsigned int v15; // r8d
  _BYTE *v16; // r10

  v5 = a2 + a3;
  if ( a2 > a2 + a3 || v5 > a5 )
  {
    if ( v5 <= 0 || v5 > a5 )
    {
      if ( a4 >= v5 || v5 > 0 )
      {
        v12 = Src + 1;
        if ( a2 != 1 )
        {
          v13 = a2;
          memmove(Src + 2, v12, a2 - 1i64);
          *v12 = 46;
          v12 = &Src[v13 + 1];
        }
        *v12 = 101;
        v14 = 45;
        v15 = 1 - v5;
        if ( v5 - 1 >= 0 )
        {
          v14 = 43;
          v15 = v5 - 1;
        }
        v12[1] = v14;
        if ( v15 >= 0xA )
        {
          if ( v15 >= 0x64 )
          {
            v16 = v12 + 4;
            v12[2] = v15 / 0x64 + 48;
            v15 %= 0x64u;
            v12[4] = v15 % 0xA + 48;
            LOBYTE(v15) = v15 / 0xA;
          }
          else
          {
            v16 = v12 + 3;
            v12[2] = v15 / 0xA + 48;
            LOBYTE(v15) = v15 % 0xA;
          }
        }
        else
        {
          v12[2] = 48;
          v16 = v12 + 3;
        }
        result = v16 + 1;
        v12[3] = v15 + 48;
      }
      else
      {
        v10 = a2;
        v11 = -v5;
        memmove(&Src[v11 + 2], Src, a2);
        *(_WORD *)Src = 11824;
        memset(Src + 2, 48, v11);
        return &Src[v11 + 2 + v10];
      }
    }
    else
    {
      v8 = a2;
      v9 = &Src[v5];
      memmove(v9 + 1, v9, a2 - (__int64)v5);
      *v9 = 46;
      return &Src[v8 + 1];
    }
  }
  else
  {
    memset(&Src[a2], 48, v5 - (__int64)a2);
    *(_WORD *)&Src[v5] = 12334;
    return &Src[v5 + 2];
  }
  return result;
}

//----- (000000014618E640) ----------------------------------------------------
__int64 __fastcall sub_14618E640(__int64 a1, __int64 a2, __int64 a3)
{
  int v4; // esi
  std::ios_base *v5; // rbx
  int v6; // eax
  __int64 result; // rax
  char v8; // [rsp+30h] [rbp+8h] BYREF

  ++*(_QWORD *)(a1 + 32);
  ++*(_QWORD *)(a1 + 40);
  if ( *(_BYTE *)(a1 + 24) )
  {
    *(_BYTE *)(a1 + 24) = 0;
  }
  else
  {
    v4 = std::streambuf::sbumpc(*(_QWORD *)(a1 + 8));
    if ( v4 == -1 )
    {
      v5 = (std::ios_base *)(*(_QWORD *)a1 + *(int *)(**(_QWORD **)a1 + 4i64));
      v6 = std::ios_base::rdstate(v5);
      std::ios::clear(v5, v6 | 1u, 0i64);
    }
    *(_DWORD *)(a1 + 20) = v4;
  }
  if ( *(_DWORD *)(a1 + 20) != -1 )
  {
    v8 = *(_DWORD *)(a1 + 20);
    sub_14617E120((_QWORD *)(a1 + 56), &v8, a3);
  }
  result = *(unsigned int *)(a1 + 20);
  if ( (_DWORD)result == 10 )
  {
    ++*(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 40) = 0i64;
  }
  return result;
}
// 14618E6C1: variable 'a3' is possibly undefined
// 14611C358: using guessed type __int64 __fastcall std::ios::clear(_QWORD, _QWORD, _QWORD);
// 14611C4B0: using guessed type _DWORD std::ios_base::rdstate(std::ios_base *__hidden this);
// 14611C4D0: using guessed type __int64 __fastcall std::streambuf::sbumpc(_QWORD);

//----- (000000014618E6E0) ----------------------------------------------------
__int64 __fastcall sub_14618E6E0(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // ebx
  __int64 *v4; // r15
  int v5; // ebp
  unsigned int v7; // r12d
  std::ios_base *v8; // rdi
  int v9; // eax
  int *v10; // rdi
  int v11; // eax
  char v13[8]; // [rsp+20h] [rbp-48h] BYREF
  int v14[2]; // [rsp+28h] [rbp-40h] BYREF
  __int64 v15; // [rsp+30h] [rbp-38h]
  __int64 v16; // [rsp+38h] [rbp-30h] BYREF

  v3 = *(_DWORD *)(a1 + 20);
  v4 = (__int64 *)v14;
  LOBYTE(v5) = 12;
  v14[1] = 8;
  v14[0] = 12;
  v7 = 0;
  v15 = 4i64;
  while ( 1 )
  {
    ++*(_QWORD *)(a1 + 32);
    ++*(_QWORD *)(a1 + 40);
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_BYTE *)(a1 + 24) = 0;
    }
    else
    {
      v3 = std::streambuf::sbumpc(*(_QWORD *)(a1 + 8));
      if ( v3 == -1 )
      {
        v8 = (std::ios_base *)(*(_QWORD *)a1 + *(int *)(**(_QWORD **)a1 + 4i64));
        v9 = std::ios_base::rdstate(v8);
        std::ios::clear(v8, v9 | 1u, 0i64);
      }
      *(_DWORD *)(a1 + 20) = v3;
    }
    v10 = (int *)(a1 + 20);
    if ( v3 != -1 )
    {
      v13[0] = v3;
      sub_14617E120((_QWORD *)(a1 + 56), v13, a3);
    }
    v3 = *v10;
    if ( *v10 == 10 )
      break;
    if ( (unsigned int)(v3 - 48) > 9 )
    {
      if ( (unsigned int)(v3 - 65) > 5 )
      {
        if ( (unsigned int)(v3 - 97) > 5 )
          return 0xFFFFFFFFi64;
        v11 = v3 - 87;
      }
      else
      {
        v11 = v3 - 55;
      }
    }
    else
    {
      v11 = v3 - 48;
    }
    v4 = (__int64 *)((char *)v4 + 4);
    v7 += v11 << v5;
    if ( v4 == &v16 )
      return v7;
    v5 = *(_DWORD *)v4;
  }
  ++*(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 40) = 0i64;
  return 0xFFFFFFFFi64;
}
// 14618E795: variable 'a3' is possibly undefined
// 14611C358: using guessed type __int64 __fastcall std::ios::clear(_QWORD, _QWORD, _QWORD);
// 14611C4B0: using guessed type _DWORD std::ios_base::rdstate(std::ios_base *__hidden this);
// 14611C4D0: using guessed type __int64 __fastcall std::streambuf::sbumpc(_QWORD);
// 14618E6E0: using guessed type char var_48[8];

//----- (000000014618E820) ----------------------------------------------------
_QWORD *__fastcall sub_14618E820(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  unsigned __int8 *v5; // r12
  unsigned int v6; // r15d
  size_t v7; // r8
  __int64 v8; // r9
  size_t v9; // rsi
  unsigned __int64 v10; // r14
  _QWORD *v11; // rax
  unsigned __int64 v12; // rdi
  unsigned __int64 v13; // rcx
  _QWORD *v14; // rbp
  _QWORD *v15; // rdi
  unsigned __int8 *i; // [rsp+38h] [rbp-70h]
  char Str[8]; // [rsp+50h] [rbp-58h] BYREF
  char v19; // [rsp+58h] [rbp-50h]

  *(_OWORD *)a2 = 0i64;
  a2[2] = 0i64;
  a2[3] = 15i64;
  *(_BYTE *)a2 = 0;
  v5 = *(unsigned __int8 **)(a1 + 56);
  for ( i = *(unsigned __int8 **)(a1 + 64); v5 != i; ++v5 )
  {
    v6 = *v5;
    if ( (unsigned __int8)v6 > 0x1Fu )
    {
      v9 = a2[2];
      v10 = a2[3];
      if ( v9 >= v10 )
      {
        if ( v9 == 0x7FFFFFFFFFFFFFFFi64 )
          unknown_libname_4(a1, 0x7FFFFFFFFFFFFFFFi64, a3, a4);
        v12 = (v9 + 1) | 0xF;
        if ( v12 <= 0x7FFFFFFFFFFFFFFFi64 )
        {
          v13 = v10 >> 1;
          if ( v10 <= 0x7FFFFFFFFFFFFFFFi64 - (v10 >> 1) )
          {
            if ( v12 < v10 + v13 )
              v12 = v10 + v13;
          }
          else
          {
            v12 = 0x7FFFFFFFFFFFFFFFi64;
          }
        }
        else
        {
          v12 = 0x7FFFFFFFFFFFFFFFi64;
        }
        v14 = sub_14615A5E0(v12 + 1);
        a2[2] = v9 + 1;
        a2[3] = v12;
        if ( v10 <= 0xF )
        {
          memcpy(v14, a2, v9);
          *((_BYTE *)v14 + v9) = v6;
          *((_BYTE *)v14 + v9 + 1) = 0;
        }
        else
        {
          v15 = (_QWORD *)*a2;
          memcpy(v14, (const void *)*a2, v9);
          *((_BYTE *)v14 + v9) = v6;
          *((_BYTE *)v14 + v9 + 1) = 0;
          if ( v10 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v15 - *(v15 - 1) - 8 > 0x1F )
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
            v15 = (_QWORD *)*(v15 - 1);
          }
          j_j_free(v15);
        }
        *a2 = v14;
      }
      else
      {
        a2[2] = v9 + 1;
        v11 = a2;
        if ( v10 > 0xF )
          v11 = (_QWORD *)*a2;
        *((_BYTE *)v11 + v9) = v6;
        *((_BYTE *)v11 + v9 + 1) = 0;
      }
    }
    else
    {
      *(_QWORD *)Str = 0i64;
      v19 = 0;
      swprintf((wchar_t *)Str, (const wchar_t *)9, "<U+%.4X>", v6);
      v7 = strlen(Str);
      sub_14618B8D0(a2, Str, v7, v8);
    }
  }
  return a2;
}
// 14618E8E4: variable 'v8' is possibly undefined
// 14618EA34: variable 'a1' is possibly undefined
// 14618EA34: variable 'a3' is possibly undefined
// 14618EA34: variable 'a4' is possibly undefined
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014618EA40) ----------------------------------------------------
unsigned __int64 __fastcall sub_14618EA40(__int64 a1, int *a2, int *a3, unsigned __int64 *a4, __int64 a5, __int64 a6)
{
  int v7; // r13d
  int v8; // kr04_4
  unsigned __int64 v9; // xmm0_8
  __int64 v10; // r14
  unsigned __int64 v11; // r15
  __int64 v12; // r11
  __int64 v13; // rdi
  unsigned __int64 v14; // r9
  int v15; // eax
  int v16; // ebp
  __int128 v17; // xmm0
  unsigned __int64 v19; // [rsp+30h] [rbp-68h] BYREF
  int v20; // [rsp+38h] [rbp-60h]
  unsigned __int64 v21; // [rsp+40h] [rbp-58h] BYREF
  int v22; // [rsp+48h] [rbp-50h]
  __int128 v23; // [rsp+50h] [rbp-48h] BYREF

  v7 = *(_DWORD *)(a6 + 8);
  v8 = (-61 - v7 > 0) + 307 + 78913 * (-61 - v7) / 0x40000;
  v9 = _mm_srli_si128(stru_14612BCE0[v8 / 8], 8).m128i_u64[0];
  v10 = (unsigned int)*(_OWORD *)&stru_14612BCE0[v8 / 8];
  v11 = HIDWORD(stru_14612BCE0[v8 / 8].m128i_i64[0]);
  v12 = (unsigned int)*(_QWORD *)a6;
  v13 = HIDWORD(*(_QWORD *)a6);
  v14 = *a4;
  v15 = v9 + *(_DWORD *)(a5 + 8) + 64;
  v21 = (((unsigned int)*(_QWORD *)a5 * v11) >> 32)
      + ((unsigned __int64)(HIDWORD(*(_QWORD *)a5) * v10) >> 32)
      + HIDWORD(*(_QWORD *)a5) * v11
      + (((unsigned int)*(_QWORD *)a5 * (unsigned int)v11
        + (unsigned int)(HIDWORD(*(_QWORD *)a5) * *(_OWORD *)&stru_14612BCE0[v8 / 8])
        + (((unsigned __int64)(unsigned int)*(_QWORD *)a5 * v10) >> 32)
        + 0x80000000) >> 32);
  v22 = v15;
  DWORD2(v23) = v9 + *((_DWORD *)a4 + 2) + 64;
  *(_QWORD *)&v23 = ((v11 * (unsigned int)v14) >> 32)
                  + ((unsigned __int64)(v10 * HIDWORD(v14)) >> 32)
                  + v11 * HIDWORD(v14)
                  + (((unsigned int)(v11 * v14)
                    + (unsigned int)(v10 * HIDWORD(v14))
                    + ((v10 * (unsigned __int64)(unsigned int)v14) >> 32)
                    + 0x80000000) >> 32)
                  + 1;
  v19 = ((unsigned __int64)(v10 * v13) >> 32)
      + v11 * v13
      + (((unsigned int)(v11 * v12) + (unsigned int)(v10 * v13) + ((unsigned __int64)(v10 * v12) >> 32) + 0x80000000) >> 32)
      + ((v11 * (unsigned int)v12) >> 32)
      - 1;
  v20 = v9 + v7 + 64;
  v16 = -HIDWORD(v9);
  v17 = v23;
  *a3 = v16;
  v23 = v17;
  return sub_14618EC80(a1, a2, a3, &v23, &v21, (__int64)&v19);
}
// 14612BCE0: using guessed type __m128i stru_14612BCE0[79];

//----- (000000014618EC80) ----------------------------------------------------
unsigned __int64 __fastcall sub_14618EC80(__int64 a1, int *a2, _DWORD *a3, _QWORD *a4, _QWORD *a5, __int64 a6)
{
  int v7; // ebp
  unsigned int v9; // r8d
  unsigned __int64 v10; // r14
  int v11; // r15d
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // r11
  __int64 v14; // rdi
  int v15; // r10d
  char v16; // al
  __int64 v17; // r13
  unsigned __int64 v18; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v20; // r10
  unsigned __int64 v21; // r8
  int v22; // edi
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rdx
  __int64 v25; // rdi
  unsigned __int64 v26; // r9
  unsigned __int64 v27; // r10
  __int64 v28; // r11
  unsigned __int64 v29; // r8
  __int64 v30; // [rsp+50h] [rbp+30h]

  v7 = 1;
  v9 = 1000000000;
  v10 = *(_QWORD *)a6 - *a4;
  v11 = -*(_DWORD *)(a6 + 8);
  v12 = *(_QWORD *)a6 - *a5;
  v13 = 1i64 << -*(_BYTE *)(a6 + 8);
  v14 = *(_QWORD *)a6 >> -*(_BYTE *)(a6 + 8);
  v30 = (v13 - 1) & *(_QWORD *)a6;
  if ( (unsigned int)v14 < 0x3B9ACA00 )
  {
    v9 = 100000000;
    if ( (unsigned int)v14 < 0x5F5E100 )
    {
      v9 = 10000000;
      if ( (unsigned int)v14 < 0x989680 )
      {
        v9 = 1000000;
        if ( (unsigned int)v14 < 0xF4240 )
        {
          v9 = 100000;
          if ( (unsigned int)v14 < 0x186A0 )
          {
            v9 = 10000;
            if ( (unsigned int)v14 < 0x2710 )
            {
              v9 = 1000;
              if ( (unsigned int)v14 < 0x3E8 )
              {
                if ( (unsigned int)v14 < 0x64 )
                {
                  if ( (unsigned int)v14 < 0xA )
                  {
                    v9 = 1;
                    v15 = 1;
                  }
                  else
                  {
                    v9 = 10;
                    v15 = 2;
                  }
                }
                else
                {
                  v9 = 100;
                  v15 = 3;
                }
              }
              else
              {
                v15 = 4;
              }
            }
            else
            {
              v15 = 5;
            }
          }
          else
          {
            v15 = 6;
          }
        }
        else
        {
          v15 = 7;
        }
      }
      else
      {
        v15 = 8;
      }
    }
    else
    {
      v15 = 9;
    }
  }
  else
  {
    v15 = 10;
  }
  while ( 1 )
  {
    --v15;
    v16 = (unsigned int)v14 / v9 + 48;
    LODWORD(v14) = (unsigned int)v14 % v9;
    *(_BYTE *)(*a2 + a1) = v16;
    v17 = *a2;
    v18 = v30 + ((unsigned __int64)(unsigned int)v14 << v11);
    result = (unsigned int)(v17 + 1);
    *a2 = result;
    if ( v18 <= v10 )
      break;
    v9 /= 0xAu;
    if ( v15 <= 0 )
    {
      v20 = 10 * v10;
      v21 = 10 * v12;
      *(_BYTE *)(v17 + a1 + 1) = ((unsigned __int64)(10 * v30) >> v11) + 48;
      result = (v13 - 1) & (10 * v30);
      v22 = *a2 + 1;
      *a2 = v22;
      if ( result > 10 * v10 )
      {
        do
        {
          v23 = 10 * result;
          v24 = v23 >> v11;
          result = (v13 - 1) & v23;
          ++v7;
          v20 *= 10i64;
          v21 *= 10i64;
          *(_BYTE *)(v22 + a1) = v24 + 48;
          v22 = ++*a2;
        }
        while ( result > v20 );
      }
      *a3 -= v7;
      if ( result < v21 )
      {
        v25 = *a2;
        do
        {
          if ( v20 - result < v13 )
            break;
          v26 = v13 + result;
          if ( v13 + result >= v21 && v21 - result <= result + v13 - v21 )
            break;
          --*(_BYTE *)(v25 + a1 - 1);
          result += v13;
        }
        while ( v26 < v21 );
      }
      return result;
    }
  }
  *a3 += v15;
  v27 = (unsigned __int64)v9 << v11;
  if ( v18 < v12 )
  {
    v28 = *a2;
    do
    {
      result = v10 - v18;
      if ( v10 - v18 < v27 )
        break;
      v29 = v18 + v27;
      if ( v18 + v27 >= v12 )
      {
        result = v12 - v18;
        if ( v12 - v18 <= v27 + v18 - v12 )
          break;
      }
      --*(_BYTE *)(v28 + a1 - 1);
      v18 += v27;
    }
    while ( v29 < v12 );
  }
  return result;
}

//----- (000000014618EF10) ----------------------------------------------------
__int64 __fastcall sub_14618EF10(__int64 a1, unsigned __int8 a2)
{
  char v2; // r8

  *(_OWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 16) = 2i64;
  *(_QWORD *)(a1 + 24) = 15i64;
  strcpy((char *)a1, "FF");
  *(_BYTE *)a1 = a0123456789abcd[(unsigned __int64)a2 >> 4];
  v2 = a0123456789abcd[a2 & 0xF];
  if ( *(_QWORD *)(a1 + 24) <= 0xFui64 )
    *(_BYTE *)(a1 + 1) = v2;
  else
    *(_BYTE *)(*(_QWORD *)a1 + 1i64) = v2;
  return a1;
}

//----- (000000014618EF80) ----------------------------------------------------
char __fastcall sub_14618EF80(__int64 a1, __int64 a2)
{
  std::codecvt_base *v3; // rdi
  char result; // al

  v3 = (std::codecvt_base *)sub_146184E30(a2);
  result = std::codecvt_base::always_noconv(v3);
  if ( result )
  {
    *(_QWORD *)(a1 + 104) = 0i64;
  }
  else
  {
    *(_QWORD *)(a1 + 104) = v3;
    return std::streambuf::_Init(a1);
  }
  return result;
}
// 14611C330: using guessed type __int64 __fastcall std::streambuf::_Init(_QWORD);
// 14611C488: using guessed type bool std::codecvt_base::always_noconv(std::codecvt_base *__hidden this);

//----- (000000014618EFD0) ----------------------------------------------------
char __fastcall sub_14618EFD0(_QWORD *a1, const void **a2)
{
  unsigned __int8 **v4; // rbx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rcx
  char v8; // bl
  unsigned __int8 *v9; // rdi
  __int64 v10; // rbx
  unsigned __int8 v11; // dl
  __int64 v12; // r8
  char v14[8]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int8 **v15; // [rsp+30h] [rbp-38h] BYREF
  __int64 v16[6]; // [rsp+38h] [rbp-30h] BYREF
  __int64 *v17; // [rsp+78h] [rbp+10h] BYREF
  int v18; // [rsp+80h] [rbp+18h] BYREF

  v15 = 0i64;
  sub_14618BD60(&v15, 0i64);
  v14[0] = 3;
  v4 = (unsigned __int8 **)operator new(0x20ui64);
  v16[0] = (__int64)&v17;
  v16[1] = (__int64)v4;
  sub_146170E60((__int64)v4, (__int64)a2, v5, v6);
  v15 = v4;
  LOBYTE(v17) = 4;
  v18 = (__int64)(a1[2] - a1[1]) >> 3;
  v7 = a1[21];
  if ( !v7 )
  {
    std::_Xbad_function_call();
    JUMPOUT(0x14618F11Di64);
  }
  v8 = (*(__int64 (__fastcall **)(__int64, int *, __int64 **, char *, __int64))(*(_QWORD *)v7 + 16i64))(
         v7,
         &v18,
         &v17,
         v14,
         -2i64);
  LOBYTE(v17) = v8;
  sub_1461907F0(a1 + 8, (char *)&v17);
  if ( v8 && *(_QWORD *)(a1[2] - 8i64) )
  {
    v17 = v16;
    v9 = (unsigned __int8 *)sub_146185420((__int64)v16, (__int64)(a1 + 23));
    v10 = sub_146186E80(*(__int64 **)(*(_QWORD *)(a1[2] - 8i64) + 8i64), a2);
    v11 = *(_BYTE *)v10;
    *(_BYTE *)v10 = *v9;
    *v9 = v11;
    v12 = *(_QWORD *)(v10 + 8);
    *(_QWORD *)(v10 + 8) = *((_QWORD *)v9 + 1);
    *((_QWORD *)v9 + 1) = v12;
    sub_14618BD60((unsigned __int8 ***)v9 + 1, *v9);
    a1[12] = v10;
  }
  sub_14618BD60(&v15, (unsigned __int8)v14[0]);
  return 1;
}
// 14618F11C: control flows out of bounds to 14618F11D
// 14618F02B: variable 'v5' is possibly undefined
// 14618F02B: variable 'v6' is possibly undefined
// 14618EFD0: using guessed type char var_40[8];

//----- (000000014618F120) ----------------------------------------------------
__int64 __fastcall sub_14618F120(__int64 a1)
{
  __int64 result; // rax

  switch ( *(_BYTE *)a1 )
  {
    case 1:
      result = 0x333333333333333i64;
      break;
    case 2:
      result = 0xFFFFFFFFFFFFFFFi64;
      break;
    default:
      result = sub_1461922B0(a1);
      break;
  }
  return result;
}

//----- (000000014618F180) ----------------------------------------------------
void **__fastcall sub_14618F180(void **Src, _QWORD *a2, __int64 a3, __int64 a4)
{
  char *v6; // rdi
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r15
  unsigned __int64 v10; // r13
  size_t v11; // r14
  __int64 v12; // r9
  __int64 v13; // r9
  size_t v14; // r8
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  size_t v19; // rdi
  unsigned __int64 v20; // r12
  _QWORD *v21; // rax
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // rdx
  _WORD *v24; // r15
  _QWORD *v25; // rbx
  void **v26; // rdx
  __int64 v27; // r9
  void *v28; // rcx
  _QWORD *v30; // [rsp+38h] [rbp-31h]
  void *Block[2]; // [rsp+50h] [rbp-19h] BYREF
  __m128i si128; // [rsp+60h] [rbp-9h]
  char v33[3]; // [rsp+85h] [rbp+1Ch] BYREF

  v6 = v33;
  if ( (int)a3 >= 0 )
  {
    do
    {
      --v6;
      v7 = (unsigned int)a3 / 0xA;
      v8 = (unsigned __int8)(4 * v7) + (unsigned int)v7;
      LOBYTE(v8) = 10 * v7;
      *v6 = (unsigned int)a3 % 0xA + 48;
      a3 = v7;
    }
    while ( (_DWORD)v7 );
  }
  else
  {
    LODWORD(a3) = -(int)a3;
    do
    {
      --v6;
      v7 = (unsigned int)a3 / 0xA;
      v8 = (unsigned __int8)(4 * v7) + (unsigned int)v7;
      LOBYTE(v8) = 10 * v7;
      *v6 = (unsigned int)a3 % 0xA + 48;
      a3 = v7;
    }
    while ( (_DWORD)v7 );
    *--v6 = 45;
  }
  *(_OWORD *)Block = 0i64;
  si128 = 0i64;
  v9 = 0x7FFFFFFFFFFFFFFFi64;
  if ( v6 == v33 )
  {
    si128 = _mm_load_si128((const __m128i *)&Size);
    LOBYTE(Block[0]) = 0;
    v10 = _mm_srli_si128(si128, 8).m128i_u64[0];
    v11 = si128.m128i_i64[0];
  }
  else
  {
    v11 = v33 - v6;
    if ( (unsigned __int64)(v33 - v6) > 0x7FFFFFFFFFFFFFFFi64 )
      unknown_libname_4(v8, v7, a3, a4);
    if ( v11 > 0xF )
    {
      v10 = v11 | 0xF;
      if ( (v11 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
      {
        if ( v10 < 0x16 )
          v10 = 22i64;
      }
      else
      {
        v10 = 0x7FFFFFFFFFFFFFFFi64;
      }
      Block[0] = sub_14615A5E0(v10 + 1);
      si128.m128i_i64[0] = v33 - v6;
      si128.m128i_i64[1] = v10;
      memcpy(Block[0], v6, v33 - v6);
      *((_BYTE *)Block[0] + v11) = 0;
    }
    else
    {
      si128.m128i_i64[0] = v33 - v6;
      si128.m128i_i64[1] = 15i64;
      memcpy(Block, v6, v33 - v6);
      *((_BYTE *)Block + v11) = 0;
      v10 = si128.m128i_u64[1];
      v11 = si128.m128i_i64[0];
    }
  }
  *(_OWORD *)Src = 0i64;
  Src[2] = 0i64;
  Src[3] = (void *)15;
  *(_BYTE *)Src = 0;
  sub_146190960(Src, v11 + a2[2] + 19i64, a3, a4);
  sub_14618B8D0(Src, "[json.exception.", 0x10ui64, v12);
  v14 = a2[2];
  if ( a2[3] > 0xFui64 )
    a2 = (_QWORD *)*a2;
  sub_14618B8D0(Src, a2, v14, v13);
  v19 = (size_t)Src[2];
  v20 = (unsigned __int64)Src[3];
  if ( v19 >= v20 )
  {
    if ( v19 == 0x7FFFFFFFFFFFFFFFi64 )
      unknown_libname_4(v16, v15, v17, v18);
    v22 = (v19 + 1) | 0xF;
    if ( v22 <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      v23 = v20 >> 1;
      if ( v20 <= 0x7FFFFFFFFFFFFFFFi64 - (v20 >> 1) )
      {
        v9 = (v19 + 1) | 0xF;
        if ( v22 < v20 + v23 )
          v9 = v20 + v23;
      }
    }
    v30 = sub_14615A5E0(v9 + 1);
    Src[2] = (void *)(v19 + 1);
    Src[3] = (void *)v9;
    v24 = (_WORD *)((char *)v30 + v19);
    if ( v20 <= 0xF )
    {
      memcpy(v30, Src, v19);
      *v24 = 46;
    }
    else
    {
      v25 = *Src;
      memcpy(v30, *Src, v19);
      *v24 = 46;
      if ( v20 + 1 >= 0x1000 )
      {
        if ( (unsigned __int64)v25 - *(v25 - 1) - 8 > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        v25 = (_QWORD *)*(v25 - 1);
      }
      j_j_free(v25);
    }
    *Src = v30;
  }
  else
  {
    Src[2] = (void *)(v19 + 1);
    v21 = Src;
    if ( v20 > 0xF )
      v21 = *Src;
    *(_WORD *)((char *)v21 + v19) = 46;
  }
  v26 = Block;
  if ( v10 > 0xF )
    v26 = (void **)Block[0];
  sub_14618B8D0(Src, v26, v11, v18);
  sub_14618B8D0(Src, &unk_14612BC20, 2ui64, v27);
  if ( si128.m128i_i64[1] > 0xFui64 )
  {
    v28 = Block[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v28 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v28 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v28);
  }
  return Src;
}
// 14618F33F: variable 'a3' is possibly undefined
// 14618F33F: variable 'a4' is possibly undefined
// 14618F354: variable 'v12' is possibly undefined
// 14618F370: variable 'v13' is possibly undefined
// 14618F488: variable 'v18' is possibly undefined
// 14618F49D: variable 'v27' is possibly undefined
// 14618F51E: variable 'v16' is possibly undefined
// 14618F51E: variable 'v15' is possibly undefined
// 14618F51E: variable 'v17' is possibly undefined
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);
// 14618F180: using guessed type __m128i var_60;

//----- (000000014618F530) ----------------------------------------------------
char __fastcall sub_14618F530(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v6; // r8
  __int64 v7; // r9
  _DWORD *v8; // rsi
  _DWORD *v9; // r15
  int v10; // ebp
  std::ios_base *v11; // rdi
  int v12; // eax
  __int64 v13; // rdx
  char v15; // [rsp+50h] [rbp+8h] BYREF

  sub_146190570((void **)(a1 + 80), *(unsigned __int8 *)(a1 + 20), a3, a4);
  v8 = *(_DWORD **)a2;
  v9 = *(_DWORD **)(a2 + 8);
  if ( *(_DWORD **)a2 == v9 )
    return 1;
  while ( 1 )
  {
    ++*(_QWORD *)(a1 + 32);
    ++*(_QWORD *)(a1 + 40);
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_BYTE *)(a1 + 24) = 0;
    }
    else
    {
      v10 = std::streambuf::sbumpc(*(_QWORD *)(a1 + 8));
      if ( v10 == -1 )
      {
        v11 = (std::ios_base *)(*(_QWORD *)a1 + *(int *)(**(_QWORD **)a1 + 4i64));
        v12 = std::ios_base::rdstate(v11);
        std::ios::clear(v11, v12 | 1u, 0i64);
      }
      *(_DWORD *)(a1 + 20) = v10;
    }
    if ( *(_DWORD *)(a1 + 20) != -1 )
    {
      v15 = *(_DWORD *)(a1 + 20);
      sub_14617E120((_QWORD *)(a1 + 56), &v15, v6);
    }
    v13 = *(unsigned int *)(a1 + 20);
    if ( (_DWORD)v13 == 10 )
    {
      ++*(_QWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 40) = 0i64;
    }
    if ( *v8 > (int)v13 || (int)v13 > v8[1] )
      break;
    sub_146190570((void **)(a1 + 80), v13, v6, v7);
    v8 += 2;
    if ( v8 == v9 )
      return 1;
  }
  *(_QWORD *)(a1 + 112) = "invalid string: ill-formed UTF-8 byte";
  return 0;
}
// 14618F5D4: variable 'v6' is possibly undefined
// 14618F5F6: variable 'v7' is possibly undefined
// 14611C358: using guessed type __int64 __fastcall std::ios::clear(_QWORD, _QWORD, _QWORD);
// 14611C4B0: using guessed type _DWORD std::ios_base::rdstate(std::ios_base *__hidden this);
// 14611C4D0: using guessed type __int64 __fastcall std::streambuf::sbumpc(_QWORD);

//----- (000000014618F630) ----------------------------------------------------
char __fastcall sub_14618F630(__int64 *a1)
{
  char v2[24]; // [rsp+20h] [rbp-18h] BYREF
  __int64 v3; // [rsp+48h] [rbp+10h] BYREF

  v3 = 0i64;
  sub_1461812B0(a1, (__int64)v2, (__int64)&v3, 0);
  return 1;
}
// 14618F630: using guessed type char var_18[24];

//----- (000000014618F660) ----------------------------------------------------
char __fastcall sub_14618F660(unsigned __int8 **a1)
{
  unsigned __int8 *v2; // rax
  __int64 v3; // r8
  __int64 v4; // rdx
  unsigned __int8 **v5; // rcx
  __int64 v7; // rcx
  __int64 v8; // rbx
  __int64 v9; // rdx
  unsigned __int8 *v10; // r8
  __int64 v11; // rdx
  unsigned __int8 **v12; // rcx
  unsigned __int8 **v13[3]; // [rsp+30h] [rbp-18h] BYREF

  v2 = a1[2];
  if ( a1[1] == v2 )
  {
    sub_1461862B0(v13, 0);
    v3 = (__int64)*a1;
    v4 = **a1;
    *(_BYTE *)v3 = 0;
    v5 = *(unsigned __int8 ***)(v3 + 8);
    *(unsigned __int8 ***)(v3 + 8) = v13[0];
    v13[0] = v5;
    sub_14618BD60(v13, v4);
    return 1;
  }
  else
  {
    v7 = *((_QWORD *)v2 - 1);
    if ( *(_BYTE *)v7 == 2 )
    {
      v8 = *(_QWORD *)(v7 + 8);
      v9 = *(_QWORD *)(v8 + 8);
      if ( v9 == *(_QWORD *)(v8 + 16) )
      {
        sub_14617E280(*(_QWORD *)(v7 + 8), v9);
      }
      else
      {
        *(_BYTE *)v9 = 0;
        sub_1461862B0((_QWORD *)(v9 + 8), 0);
        *(_QWORD *)(v8 + 8) += 16i64;
      }
      return 1;
    }
    else
    {
      sub_1461862B0(v13, 0);
      v10 = a1[4];
      v11 = *v10;
      *v10 = 0;
      v12 = (unsigned __int8 **)*((_QWORD *)v10 + 1);
      *((unsigned __int8 ***)v10 + 1) = v13[0];
      v13[0] = v12;
      sub_14618BD60(v13, v11);
      return 1;
    }
  }
}

//----- (000000014618F770) ----------------------------------------------------
__int64 __fastcall sub_14618F770(__int64 a1, unsigned int a2)
{
  unsigned __int64 v5; // rbx
  __int64 v6; // rcx
  int v7; // eax
  unsigned int v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11; // eax
  unsigned int v12; // ecx
  signed __int64 v13; // rbx
  unsigned int v14; // ecx
  char v15; // [rsp+40h] [rbp-48h] BYREF
  char v16[7]; // [rsp+41h] [rbp-47h] BYREF
  char *v17; // [rsp+48h] [rbp-40h] BYREF
  char *v18; // [rsp+50h] [rbp-38h] BYREF
  char Buffer[32]; // [rsp+58h] [rbp-30h] BYREF
  __int64 v20; // [rsp+78h] [rbp-10h] BYREF

  if ( a2 == -1 )
    return 0i64;
  if ( ((__int64 (*)(void))std::streambuf::pptr)() )
  {
    v5 = std::streambuf::epptr(a1);
    if ( std::streambuf::pptr(a1) < v5 )
    {
      *(_BYTE *)std::streambuf::_Pninc(a1) = a2;
      return a2;
    }
  }
  if ( !*(_QWORD *)(a1 + 128) )
    return 0xFFFFFFFFi64;
  if ( std::streambuf::eback(a1) == a1 + 112 )
    std::streambuf::setg(a1, *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144));
  v6 = *(_QWORD *)(a1 + 104);
  if ( !v6 )
  {
    v7 = fputc((char)a2, *(FILE **)(a1 + 128));
    v8 = -1;
    if ( v7 != -1 )
      return a2;
    return v8;
  }
  v15 = a2;
  v9 = std::codecvt<char,char,_Mbstatet>::out(v6, a1 + 116, &v15, v16, &v18, Buffer, &v20, &v17);
  if ( v9 )
  {
    v10 = v9 - 1;
    if ( v10 )
    {
      if ( v10 == 2 )
      {
        v11 = fputc(v15, *(FILE **)(a1 + 128));
        v12 = -1;
        if ( v11 != -1 )
          return a2;
        return v12;
      }
      return 0xFFFFFFFFi64;
    }
  }
  if ( v17 != Buffer )
  {
    v13 = v17 - Buffer;
    if ( v13 != fwrite(Buffer, 1ui64, v17 - Buffer, *(FILE **)(a1 + 128)) )
      return 0xFFFFFFFFi64;
  }
  *(_BYTE *)(a1 + 113) = 1;
  v14 = -1;
  if ( v18 != &v15 )
    return a2;
  return v14;
}
// 14611C320: using guessed type __int64 __fastcall std::streambuf::_Pninc(_QWORD);
// 14611C498: using guessed type __int64 __fastcall std::codecvt<char,char,_Mbstatet>::out(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 14611C4D8: using guessed type __int64 __fastcall std::streambuf::eback(_QWORD);
// 14611C4E8: using guessed type __int64 __fastcall std::streambuf::pptr(_QWORD);
// 14611C500: using guessed type __int64 __fastcall std::streambuf::setg(_QWORD, _QWORD, _QWORD, _QWORD);
// 14611C508: using guessed type __int64 __fastcall std::streambuf::epptr(_QWORD);
// 14618F770: using guessed type char var_47[7];

//----- (000000014618F930) ----------------------------------------------------
void __fastcall sub_14618F930(__int64 a1, char a2, unsigned __int8 *a3)
{
  __int64 (__fastcall ***v6)(_QWORD, unsigned __int8 **); // rcx
  char v7; // r15
  __int64 v8; // rdx
  __int64 v9; // r8
  __int64 v10; // r14
  int v11; // eax
  void **v12; // rax
  __int64 v13; // rsi
  __int64 v14; // r8
  __int64 v15; // r9
  void *v16; // rcx
  __m128i v17; // xmm6
  void *v18; // rcx
  void *v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // rdx
  __int64 v23; // rdx
  __int64 v24; // r8
  __int64 v25; // r14
  int v26; // eax
  void **v27; // rax
  __int64 v28; // rsi
  __int64 v29; // r8
  __int64 v30; // r9
  void *v31; // rcx
  void *v32; // rcx
  void *v33; // rcx
  __int64 v34; // rdx
  __int64 v35; // rcx
  void *v36; // rcx
  __int128 v37; // [rsp+38h] [rbp-D0h] BYREF
  __int64 v38; // [rsp+48h] [rbp-C0h]
  unsigned __int8 *v39; // [rsp+50h] [rbp-B8h] BYREF
  __int128 v40; // [rsp+58h] [rbp-B0h]
  __int128 v41; // [rsp+68h] [rbp-A0h]
  char v42; // [rsp+78h] [rbp-90h]
  char v43; // [rsp+79h] [rbp-8Fh]
  __int64 v44; // [rsp+88h] [rbp-80h]
  void **v45; // [rsp+90h] [rbp-78h] BYREF
  char v46[24]; // [rsp+98h] [rbp-70h] BYREF
  void **v47; // [rsp+B0h] [rbp-58h]
  char v48[24]; // [rsp+B8h] [rbp-50h] BYREF
  __int64 v49; // [rsp+D0h] [rbp-38h]
  _QWORD pExceptionObject[8]; // [rsp+D8h] [rbp-30h] BYREF
  void *v51[2]; // [rsp+118h] [rbp+10h] BYREF
  __m128i si128; // [rsp+128h] [rbp+20h]
  void *Block[2]; // [rsp+138h] [rbp+30h] BYREF
  __m128i v54; // [rsp+148h] [rbp+40h]
  void *v55[2]; // [rsp+158h] [rbp+50h] BYREF
  __m128i v56; // [rsp+168h] [rbp+60h]
  __int64 v57; // [rsp+178h] [rbp+70h] BYREF
  char v58[24]; // [rsp+180h] [rbp+78h] BYREF
  char v59[32]; // [rsp+198h] [rbp+90h] BYREF
  char v60[40]; // [rsp+1B8h] [rbp+B0h] BYREF
  char v61; // [rsp+1E0h] [rbp+D8h]
  char v62; // [rsp+1E8h] [rbp+E0h] BYREF
  char *v63; // [rsp+220h] [rbp+118h]
  char v64; // [rsp+228h] [rbp+120h]
  unsigned __int8 v65; // [rsp+230h] [rbp+128h]
  unsigned __int8 **v66[2]; // [rsp+238h] [rbp+130h] BYREF

  v49 = -2i64;
  v6 = *(__int64 (__fastcall ****)(_QWORD, unsigned __int8 **))(a1 + 56);
  v7 = *(_BYTE *)(a1 + 224);
  if ( !v6 )
  {
    v39 = a3;
    v40 = 0i64;
    v41 = 0i64;
    v42 = 0;
    v43 = v7;
    sub_146183CC0(a1, (__int64)&v39);
    if ( a2 )
    {
      v25 = a1 + 72;
      v26 = sub_146190AF0(a1 + 72, v23, v24);
      *(_DWORD *)(a1 + 64) = v26;
      if ( v26 != 15 )
      {
        *(_OWORD *)v51 = 0i64;
        si128 = _mm_load_si128((const __m128i *)&xmmword_14612E0F0);
        strcpy((char *)v51, "value");
        v27 = (void **)sub_14618DCE0(a1, (__int64)Block, 15i64, (__int64)v51);
        v37 = *(_OWORD *)(a1 + 104);
        v38 = *(_QWORD *)(a1 + 120);
        v28 = sub_1461801E0((__int64)&v45, 0x65u, (__int64 *)&v37, v27);
        sub_14618E820(v25, v55, v29, v30);
        v42 = 1;
        if ( v43 )
        {
          sub_146186520(pExceptionObject, v28);
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVparse_error_detail_json_abi_v3_11_2_nlohmann__);
        }
        if ( v56.m128i_i64[1] > 0xFui64 )
        {
          v31 = v55[0];
          if ( (unsigned __int64)(v56.m128i_i64[1] + 1) >= 0x1000 )
          {
            v31 = (void *)*((_QWORD *)v55[0] - 1);
            if ( (unsigned __int64)(v55[0] - v31 - 8) > 0x1F )
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v31);
        }
        v56 = _mm_load_si128((const __m128i *)&Size);
        LOBYTE(v55[0]) = 0;
        v47 = &std::exception::`vftable';
        _std_exception_destroy(v48);
        v45 = &std::exception::`vftable';
        _std_exception_destroy(v46);
        if ( v54.m128i_i64[1] > 0xFui64 )
        {
          v32 = Block[0];
          if ( (unsigned __int64)(v54.m128i_i64[1] + 1) >= 0x1000 )
          {
            v32 = (void *)*((_QWORD *)Block[0] - 1);
            if ( (unsigned __int64)(Block[0] - v32 - 8) > 0x1F )
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v32);
        }
        v54 = _mm_load_si128((const __m128i *)&Size);
        LOBYTE(Block[0]) = 0;
        if ( si128.m128i_i64[1] > 0xFui64 )
        {
          v33 = v51[0];
          if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
          {
            v33 = (void *)*((_QWORD *)v51[0] - 1);
            if ( (unsigned __int64)(v51[0] - v33 - 8) > 0x1F )
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v33);
        }
      }
    }
    if ( v42 )
    {
      LOBYTE(v37) = 9;
      sub_1461862B0((_QWORD *)&v37 + 1, 9);
      v34 = *a3;
      *a3 = v37;
      LOBYTE(v37) = v34;
      v35 = *((_QWORD *)a3 + 1);
      *((_QWORD *)a3 + 1) = *((_QWORD *)&v37 + 1);
      *((_QWORD *)&v37 + 1) = v35;
      sub_14618BD60((unsigned __int8 ***)&v37 + 1, v34);
      v36 = (void *)v40;
      if ( !(_QWORD)v40 )
        return;
      if ( (((_QWORD)v41 - (_QWORD)v40) & 0xFFFFFFFFFFFFFFF8ui64) < 0x1000 )
        goto LABEL_50;
      v36 = *(void **)(v40 - 8);
      if ( (unsigned __int64)(v40 - (_QWORD)v36 - 8) <= 0x1F )
        goto LABEL_50;
    }
    else
    {
      v36 = (void *)v40;
      if ( !(_QWORD)v40 )
        return;
      if ( (((_QWORD)v41 - (_QWORD)v40) & 0xFFFFFFFFFFFFFFF8ui64) < 0x1000
        || (v36 = *(void **)(v40 - 8), (unsigned __int64)(v40 - (_QWORD)v36 - 8) <= 0x1F) )
      {
LABEL_50:
        j_j_free(v36);
        return;
      }
    }
    invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
  }
  *(_QWORD *)&v37 = &v39;
  v44 = 0i64;
  v44 = (**v6)(v6, &v39);
  sub_146185DB0((__int64)&v57, (__int64)a3, (__int64)&v39, v7);
  sub_146183010(a1, &v57);
  if ( a2 )
  {
    v10 = a1 + 72;
    v11 = sub_146190AF0(a1 + 72, v8, v9);
    *(_DWORD *)(a1 + 64) = v11;
    if ( v11 != 15 )
    {
      *(_OWORD *)v51 = 0i64;
      si128 = _mm_load_si128((const __m128i *)&xmmword_14612E0F0);
      strcpy((char *)v51, "value");
      v12 = (void **)sub_14618DCE0(a1, (__int64)v55, 15i64, (__int64)v51);
      v37 = *(_OWORD *)(a1 + 104);
      v38 = *(_QWORD *)(a1 + 120);
      v13 = sub_1461801E0((__int64)&v45, 0x65u, (__int64 *)&v37, v12);
      sub_14618E820(v10, Block, v14, v15);
      v61 = 1;
      if ( v64 )
      {
        sub_146186520(&v39, v13);
        CxxThrowException(&v39, (_ThrowInfo *)&_TI3_AVparse_error_detail_json_abi_v3_11_2_nlohmann__);
      }
      if ( v54.m128i_i64[1] > 0xFui64 )
      {
        v16 = Block[0];
        if ( (unsigned __int64)(v54.m128i_i64[1] + 1) >= 0x1000 )
        {
          v16 = (void *)*((_QWORD *)Block[0] - 1);
          if ( (unsigned __int64)(Block[0] - v16 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v16);
      }
      v17 = _mm_load_si128((const __m128i *)&Size);
      v54 = v17;
      LOBYTE(Block[0]) = 0;
      v47 = &std::exception::`vftable';
      _std_exception_destroy(v48);
      v45 = &std::exception::`vftable';
      _std_exception_destroy(v46);
      if ( v56.m128i_i64[1] > 0xFui64 )
      {
        v18 = v55[0];
        if ( (unsigned __int64)(v56.m128i_i64[1] + 1) >= 0x1000 )
        {
          v18 = (void *)*((_QWORD *)v55[0] - 1);
          if ( (unsigned __int64)(v55[0] - v18 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v18);
        v17 = _mm_load_si128((const __m128i *)&Size);
      }
      v56 = v17;
      LOBYTE(v55[0]) = 0;
      if ( si128.m128i_i64[1] > 0xFui64 )
      {
        v19 = v51[0];
        if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
        {
          v19 = (void *)*((_QWORD *)v51[0] - 1);
          if ( (unsigned __int64)(v51[0] - v19 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v19);
      }
    }
  }
  if ( v61 )
  {
    LOBYTE(v37) = 9;
    sub_1461862B0((_QWORD *)&v37 + 1, 9);
    v20 = *a3;
    *a3 = v37;
    LOBYTE(v37) = v20;
    v21 = *((_QWORD *)a3 + 1);
    *((_QWORD *)a3 + 1) = *((_QWORD *)&v37 + 1);
    *((_QWORD *)&v37 + 1) = v21;
    sub_14618BD60((unsigned __int8 ***)&v37 + 1, v20);
    sub_14618BD60(v66, v65);
  }
  else
  {
    if ( *a3 == 9 )
    {
      LOBYTE(v37) = 0;
      sub_1461862B0((_QWORD *)&v37 + 1, 0);
      sub_146186E30((char *)a3, (unsigned __int8 *)&v37);
    }
    sub_14618BD60(v66, v65);
  }
  if ( v63 )
  {
    LOBYTE(v22) = v63 != &v62;
    (*(void (__fastcall **)(char *, __int64))(*(_QWORD *)v63 + 32i64))(v63, v22);
    v63 = 0i64;
  }
  sub_146186B70((__int64)v60);
  sub_146186B70((__int64)v59);
  sub_146166C80((__int64)v58);
}
// 14618F9D8: variable 'v8' is possibly undefined
// 14618F9D8: variable 'v9' is possibly undefined
// 14618FA63: variable 'v14' is possibly undefined
// 14618FA63: variable 'v15' is possibly undefined
// 14618FC57: variable 'v22' is possibly undefined
// 14618FCC7: variable 'v23' is possibly undefined
// 14618FCC7: variable 'v24' is possibly undefined
// 14618FD52: variable 'v29' is possibly undefined
// 14618FD52: variable 'v30' is possibly undefined
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14612E0F0: using guessed type __int128 xmmword_14612E0F0;
// 1461A8F1C: using guessed type __int64 __fastcall _std_exception_destroy(_QWORD);
// 14618F930: using guessed type char var_D0[40];
// 14618F930: using guessed type char var_F0[32];
// 14618F930: using guessed type char var_108[24];
// 14618F930: using guessed type _QWORD pExceptionObject[8];

//----- (000000014618FFD0) ----------------------------------------------------
__int64 __fastcall sub_14618FFD0(_QWORD *a1, unsigned int a2)
{
  unsigned __int64 v4; // rbx
  FILE *v6; // rdx
  _BYTE *v7; // rbx

  if ( ((__int64 (*)(void))std::streambuf::gptr)() )
  {
    v4 = std::streambuf::eback(a1);
    if ( v4 < std::streambuf::gptr(a1) && (a2 == -1 || *(unsigned __int8 *)(std::streambuf::gptr(a1) - 1) == a2) )
    {
      std::streambuf::_Gndec(a1);
      if ( a2 == -1 )
        return 0;
      return a2;
    }
  }
  v6 = (FILE *)a1[16];
  if ( !v6 || a2 == -1 )
    return 0xFFFFFFFFi64;
  if ( !a1[13] && ungetc((unsigned __int8)a2, v6) != -1 )
    return a2;
  v7 = a1 + 14;
  if ( (_QWORD *)std::streambuf::gptr(a1) == a1 + 14 )
    return 0xFFFFFFFFi64;
  *v7 = a2;
  if ( (_BYTE *)std::streambuf::eback(a1) != v7 )
  {
    a1[17] = std::streambuf::eback(a1);
    a1[18] = std::streambuf::egptr(a1);
  }
  std::streambuf::setg(a1, a1 + 14, a1 + 14, (char *)a1 + 113);
  return a2;
}
// 14611C420: using guessed type __int64 __fastcall std::streambuf::_Gndec(_QWORD);
// 14611C4D8: using guessed type __int64 __fastcall std::streambuf::eback(_QWORD);
// 14611C4E0: using guessed type __int64 __fastcall std::streambuf::gptr(_QWORD);
// 14611C4F0: using guessed type __int64 __fastcall std::streambuf::egptr(_QWORD);
// 14611C500: using guessed type __int64 __fastcall std::streambuf::setg(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001461900F0) ----------------------------------------------------
__int64 __fastcall sub_1461900F0(unsigned __int64 *a1)
{
  __int64 v1; // r8
  unsigned __int64 v3; // rdx
  unsigned __int64 v4; // rdx
  __int64 v5; // rcx
  unsigned __int64 v6; // rax
  __int64 v7; // r8
  __int64 v8; // rdx
  __m128i v10; // [rsp+20h] [rbp-28h] BYREF
  char v11[24]; // [rsp+30h] [rbp-18h] BYREF

  v1 = a1[3];
  v3 = *a1;
  if ( v1 >= 0 )
    v4 = v3 + 4 * ((unsigned __int64)v1 >> 5);
  else
    v4 = v3 - (4 * ((unsigned __int64)~v1 >> 5) + 4);
  v5 = a1[3] & 0x1F;
  v6 = v5 - 1;
  v7 = ((v1 & 0x1F) - 1) & 0x1F;
  if ( v5 )
    v8 = v4 + 4 * (v6 >> 5);
  else
    v8 = v4 - (4 * (~v6 >> 5) + 4);
  v10.m128i_i64[0] = v8;
  v10.m128i_i64[1] = v7;
  return sub_14618DB00(a1, (__int64)v11, &v10);
}
// 146190109: conditional instruction was optimized away because r8.8<0
// 1461900F0: using guessed type char var_18[24];

//----- (0000000146190190) ----------------------------------------------------
void **__fastcall sub_146190190(void **Src, __int64 a2)
{
  char *v3; // rdi
  unsigned __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // rcx
  unsigned __int64 v7; // r14
  __m128i si128; // xmm2
  unsigned __int64 v9; // r13
  size_t v10; // r15
  char *v11; // rsi
  unsigned __int64 v12; // r8
  __int64 v13; // rcx
  size_t v14; // rdi
  __int64 v15; // r9
  __int64 v16; // r9
  void **v17; // rdx
  __int64 v18; // r9
  __int64 v19; // r9
  void **v20; // rdx
  void *v21; // rcx
  void *v22; // rcx
  void *Block[2]; // [rsp+58h] [rbp-49h] BYREF
  __m128i v26; // [rsp+68h] [rbp-39h]
  void *v27[2]; // [rsp+78h] [rbp-29h] BYREF
  __m128i v28; // [rsp+88h] [rbp-19h]
  char v29[24]; // [rsp+ADh] [rbp+Ch] BYREF
  char v30[3]; // [rsp+C5h] [rbp+24h] BYREF

  v3 = v29;
  v4 = *(_QWORD *)(a2 + 8);
  v5 = 0xCCCCCCCCCCCCCCCDui64;
  do
  {
    --v3;
    v6 = (unsigned __int8)(4 * (v4 / 0xA)) + (unsigned int)(v4 / 0xA);
    LOBYTE(v6) = 10 * (v4 / 0xA);
    *v3 = v4 % 0xA + 48;
    v4 /= 0xAui64;
  }
  while ( v4 );
  *(_OWORD *)v27 = 0i64;
  v28 = 0i64;
  v7 = 0x7FFFFFFFFFFFFFFFi64;
  if ( v3 == v29 )
  {
    si128 = _mm_load_si128((const __m128i *)&Size);
    v28 = si128;
    LOBYTE(v27[0]) = 0;
    v9 = _mm_srli_si128(si128, 8).m128i_u64[0];
    v10 = si128.m128i_i64[0];
  }
  else
  {
    v10 = v29 - v3;
    if ( (unsigned __int64)(v29 - v3) > 0x7FFFFFFFFFFFFFFFi64 )
      unknown_libname_4(v6, 0i64, 0i64, 0xCCCCCCCCCCCCCCCDui64);
    if ( v10 > 0xF )
    {
      v9 = v10 | 0xF;
      if ( (v10 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
      {
        if ( v9 < 0x16 )
          v9 = 22i64;
      }
      else
      {
        v9 = 0x7FFFFFFFFFFFFFFFi64;
      }
      v27[0] = sub_14615A5E0(v9 + 1);
      v28.m128i_i64[0] = v29 - v3;
      v28.m128i_i64[1] = v9;
      memcpy(v27[0], v3, v29 - v3);
      *((_BYTE *)v27[0] + v10) = 0;
    }
    else
    {
      v28.m128i_i64[0] = v29 - v3;
      v28.m128i_i64[1] = 15i64;
      memcpy(v27, v3, v29 - v3);
      *((_BYTE *)v27 + v10) = 0;
      v9 = v28.m128i_u64[1];
      v10 = v28.m128i_i64[0];
    }
    v5 = 0xCCCCCCCCCCCCCCCDui64;
    si128 = _mm_load_si128((const __m128i *)&Size);
  }
  v11 = v30;
  v12 = *(_QWORD *)(a2 + 16) + 1i64;
  do
  {
    --v11;
    v13 = (unsigned __int8)(4 * (v12 / 0xA)) + (unsigned int)(v12 / 0xA);
    LOBYTE(v13) = 10 * (v12 / 0xA);
    *v11 = v12 % 0xA + 48;
    v12 /= 0xAui64;
  }
  while ( v12 );
  *(_OWORD *)Block = 0i64;
  v26 = 0i64;
  if ( v11 == v30 )
  {
    v26 = si128;
    LOBYTE(Block[0]) = 0;
    v7 = _mm_srli_si128(si128, 8).m128i_u64[0];
    v14 = si128.m128i_i64[0];
  }
  else
  {
    v14 = v30 - v11;
    if ( (unsigned __int64)(v30 - v11) > 0x7FFFFFFFFFFFFFFFi64 )
      unknown_libname_4(v13, 0i64, 0i64, 0xCCCCCCCCCCCCCCCDui64);
    if ( v14 > 0xF )
    {
      if ( (v14 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
      {
        v7 = v14 | 0xF;
        if ( (v14 | 0xF) < 0x16 )
          v7 = 22i64;
      }
      Block[0] = sub_14615A5E0(v7 + 1);
      v26.m128i_i64[0] = v30 - v11;
      v26.m128i_i64[1] = v7;
      memcpy(Block[0], v11, v30 - v11);
      *((_BYTE *)Block[0] + v14) = 0;
    }
    else
    {
      v26.m128i_i64[0] = v30 - v11;
      v26.m128i_i64[1] = 15i64;
      memcpy(Block, v11, v30 - v11);
      *((_BYTE *)Block + v14) = 0;
      v7 = v26.m128i_u64[1];
      v14 = v26.m128i_i64[0];
    }
  }
  *(_OWORD *)Src = 0i64;
  Src[2] = 0i64;
  Src[3] = (void *)15;
  *(_BYTE *)Src = 0;
  sub_146190960(Src, v10 + v14 + 18, v12, v5);
  sub_14618B8D0(Src, " at line ", 9ui64, v15);
  v17 = Block;
  if ( v7 > 0xF )
    v17 = (void **)Block[0];
  sub_14618B8D0(Src, v17, v14, v16);
  sub_14618B8D0(Src, ", column ", 9ui64, v18);
  v20 = v27;
  if ( v9 > 0xF )
    v20 = (void **)v27[0];
  sub_14618B8D0(Src, v20, v10, v19);
  if ( v26.m128i_i64[1] > 0xFui64 )
  {
    v21 = Block[0];
    if ( (unsigned __int64)(v26.m128i_i64[1] + 1) >= 0x1000 )
    {
      v21 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v21 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v21);
  }
  if ( v28.m128i_i64[1] > 0xFui64 )
  {
    v22 = v27[0];
    if ( (unsigned __int64)(v28.m128i_i64[1] + 1) >= 0x1000 )
    {
      v22 = (void *)*((_QWORD *)v27[0] - 1);
      if ( (unsigned __int64)(v27[0] - v22 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v22);
  }
  return Src;
}
// 146190430: variable 'v12' is possibly undefined
// 146190430: variable 'v5' is possibly undefined
// 146190445: variable 'v15' is possibly undefined
// 14619045D: variable 'v16' is possibly undefined
// 146190472: variable 'v18' is possibly undefined
// 14619048A: variable 'v19' is possibly undefined
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);
// 146190190: using guessed type __m128i var_70;

//----- (0000000146190570) ----------------------------------------------------
void __fastcall sub_146190570(void **Src, __int64 a2, __int64 a3, __int64 a4)
{
  size_t v4; // rsi
  char v5; // r15
  unsigned __int64 v6; // r14
  void **v7; // rbx
  __int64 v8; // rdi
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  _QWORD *v11; // rax
  _QWORD *v12; // rbp
  _QWORD *v13; // rdi

  v4 = (size_t)Src[2];
  v5 = a2;
  v6 = (unsigned __int64)Src[3];
  v7 = Src;
  if ( v4 >= v6 )
  {
    v8 = 0x7FFFFFFFFFFFFFFFi64;
    if ( v4 == 0x7FFFFFFFFFFFFFFFi64 )
      unknown_libname_4(Src, a2, a3, a4);
    v9 = (v4 + 1) | 0xF;
    if ( v9 <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      v10 = v6 >> 1;
      if ( v6 <= 0x7FFFFFFFFFFFFFFFi64 - (v6 >> 1) )
      {
        v8 = (v4 + 1) | 0xF;
        if ( v9 < v6 + v10 )
          v8 = v6 + v10;
      }
    }
    v11 = sub_14615A5E0(v8 + 1);
    v7[2] = (void *)(v4 + 1);
    v12 = v11;
    v7[3] = (void *)v8;
    if ( v6 <= 0xF )
    {
      memcpy(v11, v7, v4);
      *((_BYTE *)v12 + v4) = v5;
      *((_BYTE *)v12 + v4 + 1) = 0;
    }
    else
    {
      v13 = *v7;
      memcpy(v11, *v7, v4);
      *((_BYTE *)v12 + v4) = v5;
      *((_BYTE *)v12 + v4 + 1) = 0;
      if ( v6 + 1 >= 0x1000 )
      {
        if ( (unsigned __int64)v13 - *(v13 - 1) - 8 > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        v13 = (_QWORD *)*(v13 - 1);
      }
      j_j_free(v13);
    }
    *v7 = v12;
  }
  else
  {
    Src[2] = (void *)(v4 + 1);
    if ( v6 > 0xF )
      v7 = (void **)*Src;
    *((_BYTE *)v7 + v4) = a2;
    *((_BYTE *)v7 + v4 + 1) = 0;
  }
}
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001461906D0) ----------------------------------------------------
__int64 __fastcall sub_1461906D0(const void **a1, __int64 *a2)
{
  char *v4; // rcx
  char *v5; // rdi
  __int64 result; // rax
  __int64 v7; // rsi
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rbp
  _QWORD *v11; // r14
  _QWORD *v12; // rcx
  char *v13; // r8
  _BYTE *v14; // rdx
  size_t v15; // r8

  v4 = (char *)a1[2];
  v5 = (char *)a1[1];
  if ( v5 == v4 )
  {
    v7 = (v5 - (_BYTE *)*a1) >> 3;
    if ( v7 == 0x1FFFFFFFFFFFFFFFi64 )
      unknown_libname_6(v4, a2, 0x1FFFFFFFFFFFFFFFi64);
    v8 = (v4 - (_BYTE *)*a1) >> 3;
    v9 = v8 >> 1;
    if ( v8 <= 0x1FFFFFFFFFFFFFFFi64 - (v8 >> 1) )
    {
      v10 = v7 + 1;
      if ( v9 + v8 >= v7 + 1 )
        v10 = v9 + v8;
      if ( v10 > 0x1FFFFFFFFFFFFFFFi64 )
        sub_146165390(v8, v9, 0x1FFFFFFFFFFFFFFFi64);
    }
    else
    {
      v10 = 0x1FFFFFFFFFFFFFFFi64;
    }
    v11 = sub_14615A5E0(8 * v10);
    v11[v7] = *a2;
    v12 = v11;
    v13 = (char *)a1[1];
    v14 = *a1;
    if ( v5 == v13 )
    {
      v15 = v13 - v14;
    }
    else
    {
      memmove(v11, v14, v5 - v14);
      v15 = (_BYTE *)a1[1] - v5;
      v12 = &v11[v7 + 1];
      v14 = v5;
    }
    memmove(v12, v14, v15);
    return sub_14618ACC0((__int64)a1, (__int64)v11, v7 + 1, v10);
  }
  else
  {
    result = *a2;
    *(_QWORD *)v5 = *a2;
    a1[1] = (char *)a1[1] + 8;
  }
  return result;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (00000001461907F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1461907F0(__int64 *a1, char *a2)
{
  __int64 v2; // r8
  __int64 v4; // r9
  __int64 v6; // r9
  __int64 v7; // rax
  __int64 v8; // rdx
  int *v9; // rdx
  char v10; // r11
  __int64 v11; // rcx
  __int64 v12; // rdi
  unsigned __int64 result; // rax
  int *v14; // rsi
  int v15; // r9d
  int v16; // r8d
  int v17; // r10d
  int v18; // ebp
  __int64 v19[3]; // [rsp+20h] [rbp-18h] BYREF

  v2 = a1[3];
  v4 = *a1;
  if ( v2 >= 0 )
    v6 = v4 + 4 * ((unsigned __int64)v2 >> 5);
  else
    v6 = v4 - (4 * ((unsigned __int64)~v2 >> 5) + 4);
  v19[0] = v6;
  v19[1] = v2 & 0x1F;
  v7 = sub_14618B3C0(a1, v19, 1ui64);
  v8 = *a1;
  if ( v7 >= 0 )
    v9 = (int *)(v8 + 4 * ((unsigned __int64)v7 >> 5));
  else
    v9 = (int *)(v8 - (4 * ((unsigned __int64)~v7 >> 5) + 4));
  v10 = *a2;
  v11 = v7 & 0x1F;
  v12 = ((_DWORD)v11 + 1) & 0x1F;
  result = (unsigned __int64)(v11 + 1) >> 5;
  v14 = &v9[result];
  if ( v9 != v14 || v11 != v12 )
  {
    v15 = *v9;
    v16 = -1 << v11;
    v17 = ~(-1 << v11);
    v18 = -(v10 != 0);
    if ( v9 == v14 )
    {
      result = v18 & v16 & (0xFFFFFFFF >> (32 - ((v11 + 1) & 0x1F))) | v15 & (v17 | ~(0xFFFFFFFF >> (32 - ((v11 + 1) & 0x1F))));
      *v9 = result;
    }
    else
    {
      *v9 = v18 & v16 | v17 & v15;
      result = (unsigned __int64)memset(v9 + 1, (unsigned __int8)-(v10 != 0), 4 * result - 4);
      if ( v12 )
      {
        result = v18 & (0xFFFFFFFF >> (32 - v12)) | *v14 & ~(0xFFFFFFFF >> (32 - v12));
        *v14 = result;
      }
    }
  }
  return result;
}
// 14619081C: conditional instruction was optimized away because r8.8<0
// 146190870: conditional instruction was optimized away because rax.8<0

//----- (0000000146190960) ----------------------------------------------------
void __fastcall sub_146190960(void **Src, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v7; // r14
  __int64 v8; // rbx
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  _QWORD *v11; // rax
  _QWORD *v12; // r15
  size_t v13; // r8
  void *v14; // rbx
  _QWORD *v15; // rbx

  v4 = (unsigned __int64)Src[2];
  if ( v4 <= a2 )
  {
    v7 = (unsigned __int64)Src[3];
    if ( v7 != a2 )
    {
      if ( v7 >= a2 )
      {
        if ( a2 <= 0xF && v7 > 0xF )
        {
          v15 = *Src;
          memcpy(Src, *Src, v4 + 1);
          if ( (unsigned __int64)Src[3] + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v15 - *(v15 - 1) - 8 > 0x1F )
              goto LABEL_22;
            v15 = (_QWORD *)*(v15 - 1);
          }
          j_j_free(v15);
          Src[3] = (void *)15;
        }
      }
      else
      {
        v8 = 0x7FFFFFFFFFFFFFFFi64;
        if ( 0x7FFFFFFFFFFFFFFFi64 - v4 < a2 - v4 )
          unknown_libname_4(a2 - v4, a2, a3, a4);
        v9 = a2 | 0xF;
        if ( (a2 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
        {
          v10 = v7 >> 1;
          if ( v7 <= 0x7FFFFFFFFFFFFFFFi64 - (v7 >> 1) )
          {
            v8 = v9;
            if ( v9 < v7 + v10 )
              v8 = v7 + v10;
          }
        }
        v11 = sub_14615A5E0(v8 + 1);
        Src[2] = (void *)a2;
        v12 = v11;
        Src[3] = (void *)v8;
        v13 = v4 + 1;
        if ( v7 > 0xF )
        {
          v14 = *Src;
          memcpy(v11, *Src, v13);
          if ( v7 + 1 < 0x1000 )
          {
LABEL_13:
            j_j_free(v14);
            *Src = v12;
            Src[2] = (void *)v4;
            return;
          }
          if ( (unsigned __int64)v14 - *((_QWORD *)v14 - 1) - 8 <= 0x1F )
          {
            v14 = (void *)*((_QWORD *)v14 - 1);
            goto LABEL_13;
          }
LABEL_22:
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        memcpy(v11, Src, v13);
        *Src = v12;
        Src[2] = (void *)v4;
      }
    }
  }
}
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146190AF0) ----------------------------------------------------
__int64 __fastcall sub_146190AF0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rdx
  __int64 v5; // r8
  __int64 result; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // r8
  __int64 *v11; // r14
  int v12; // eax
  int v13; // esi
  std::ios_base *v14; // rdi
  int v15; // eax
  int v16; // esi
  int i; // eax
  __int64 v18; // rax
  __int64 v19; // rax
  std::ios_base *v20; // rdi
  int v21; // eax
  unsigned int v22; // r9d
  char v23[4]; // [rsp+20h] [rbp-28h] BYREF
  int v24[3]; // [rsp+24h] [rbp-24h] BYREF

  if ( !*(_QWORD *)(a1 + 32) )
  {
    if ( (unsigned int)sub_14618E640(a1, a2, a3) == 239 )
    {
      if ( (unsigned int)sub_14618E640(a1, a2, a3) != 187 || (unsigned int)sub_14618E640(a1, v4, v5) != 191 )
      {
        *(_QWORD *)(a1 + 112) = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
        return 14i64;
      }
    }
    else
    {
      --*(_QWORD *)(a1 + 32);
      v7 = *(_QWORD *)(a1 + 40);
      *(_BYTE *)(a1 + 24) = 1;
      if ( v7 )
      {
        *(_QWORD *)(a1 + 40) = v7 - 1;
      }
      else
      {
        v8 = *(_QWORD *)(a1 + 48);
        if ( v8 )
          *(_QWORD *)(a1 + 48) = v8 - 1;
      }
      if ( *(_DWORD *)(a1 + 20) != -1 )
        --*(_QWORD *)(a1 + 64);
    }
  }
  sub_146192320(a1, a2, a3);
  if ( *(_BYTE *)(a1 + 16) )
  {
    v11 = (__int64 *)(a1 + 40);
    while ( 1 )
    {
      if ( *(_DWORD *)(a1 + 20) != 47 )
        goto LABEL_55;
      v12 = sub_14618E640(a1, v9, v10);
      if ( v12 == 42 )
        break;
      if ( v12 != 47 )
      {
        *(_QWORD *)(a1 + 112) = "invalid comment; expecting '/' or '*' after '/'";
        return 14i64;
      }
      v13 = *(_DWORD *)(a1 + 20);
      while ( 1 )
      {
        ++*(_QWORD *)(a1 + 32);
        ++*v11;
        if ( *(_BYTE *)(a1 + 24) )
        {
          *(_BYTE *)(a1 + 24) = 0;
        }
        else
        {
          v13 = std::streambuf::sbumpc(*(_QWORD *)(a1 + 8));
          if ( v13 == -1 )
          {
            v14 = (std::ios_base *)(*(_QWORD *)a1 + *(int *)(**(_QWORD **)a1 + 4i64));
            v15 = std::ios_base::rdstate(v14);
            std::ios::clear(v14, v15 | 1u, 0i64);
          }
          *(_DWORD *)(a1 + 20) = v13;
        }
        if ( v13 != -1 )
        {
          v23[0] = v13;
          sub_14617E120((_QWORD *)(a1 + 56), v23, v10);
        }
        v13 = *(_DWORD *)(a1 + 20);
        if ( v13 == 10 )
          break;
        if ( (unsigned int)(v13 + 1) <= 1 || v13 == 13 )
          goto LABEL_28;
      }
      ++*(_QWORD *)(a1 + 48);
      *v11 = 0i64;
LABEL_28:
      v16 = *(_DWORD *)(a1 + 20);
      v11 = (__int64 *)(a1 + 40);
      do
      {
        while ( 1 )
        {
          ++*(_QWORD *)(a1 + 32);
          ++*v11;
          if ( *(_BYTE *)(a1 + 24) )
          {
            *(_BYTE *)(a1 + 24) = 0;
          }
          else
          {
            v16 = std::streambuf::sbumpc(*(_QWORD *)(a1 + 8));
            if ( v16 == -1 )
            {
              v20 = (std::ios_base *)(*(_QWORD *)a1 + *(int *)(**(_QWORD **)a1 + 4i64));
              v21 = std::ios_base::rdstate(v20);
              std::ios::clear(v20, v21 | 1u, 0i64);
            }
            *(_DWORD *)(a1 + 20) = v16;
          }
          if ( v16 != -1 )
          {
            v23[0] = v16;
            sub_14617E120((_QWORD *)(a1 + 56), v23, v10);
          }
          v16 = *(_DWORD *)(a1 + 20);
          if ( v16 != 10 )
            break;
          ++*(_QWORD *)(a1 + 48);
          *v11 = 0i64;
        }
      }
      while ( v16 == 32 || v16 == 9 || v16 == 13 );
      if ( !*(_BYTE *)(a1 + 16) )
        goto LABEL_55;
    }
    for ( i = sub_14618E640(a1, v9, v10); i != -1; i = sub_14618E640(a1, v9, v10) )
    {
      if ( !i )
        break;
      if ( i == 42 )
      {
        if ( (unsigned int)sub_14618E640(a1, v9, v10) == 47 )
          goto LABEL_28;
        --*(_QWORD *)(a1 + 32);
        v18 = *v11;
        *(_BYTE *)(a1 + 24) = 1;
        if ( v18 )
        {
          *v11 = v18 - 1;
        }
        else
        {
          v19 = *(_QWORD *)(a1 + 48);
          if ( v19 )
            *(_QWORD *)(a1 + 48) = v19 - 1;
        }
        if ( *(_DWORD *)(a1 + 20) != -1 )
          --*(_QWORD *)(a1 + 64);
      }
    }
    *(_QWORD *)(a1 + 112) = "invalid comment; missing closing '*/'";
    return 14i64;
  }
LABEL_55:
  switch ( *(_DWORD *)(a1 + 20) )
  {
    case 0xFFFFFFFF:
    case 0:
      return 15i64;
    case 0x22:
      return sub_1461916F0(a1, 0x140000000i64, v10);
    case 0x2C:
      return 13i64;
    case 0x2D:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
      return sub_146191050(a1, 0x140000000i64, v10);
    case 0x3A:
      return 12i64;
    case 0x5B:
      return 8i64;
    case 0x5D:
      return 10i64;
    case 0x66:
      qmemcpy(v24, "false", 5);
      return sub_146190F50(a1, (__int64)v24, 5ui64, 2u);
    case 0x6E:
      v24[0] = 1819047278;
      v22 = 3;
      goto LABEL_66;
    case 0x74:
      v24[0] = 1702195828;
      v22 = 1;
LABEL_66:
      result = sub_146190F50(a1, (__int64)v24, 4ui64, v22);
      break;
    case 0x7B:
      result = 9i64;
      break;
    case 0x7D:
      result = 11i64;
      break;
    default:
      *(_QWORD *)(a1 + 112) = "invalid literal";
      return 14i64;
  }
  return result;
}
// 146190B0F: variable 'a2' is possibly undefined
// 146190B0F: variable 'a3' is possibly undefined
// 146190B1E: variable 'v4' is possibly undefined
// 146190B1E: variable 'v5' is possibly undefined
// 146190BAD: variable 'v9' is possibly undefined
// 146190BAD: variable 'v10' is possibly undefined
// 14611C358: using guessed type __int64 __fastcall std::ios::clear(_QWORD, _QWORD, _QWORD);
// 14611C4B0: using guessed type _DWORD std::ios_base::rdstate(std::ios_base *__hidden this);
// 14611C4D0: using guessed type __int64 __fastcall std::streambuf::sbumpc(_QWORD);

//----- (0000000146190F50) ----------------------------------------------------
__int64 __fastcall sub_146190F50(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned int a4)
{
  __int64 v4; // rbp
  int v9; // esi
  std::ios_base *v10; // rdi
  int v11; // eax
  char v13; // [rsp+60h] [rbp+18h] BYREF

  v4 = 1i64;
  if ( a3 <= 1 )
    return a4;
  v9 = *(_DWORD *)(a1 + 20);
  while ( 1 )
  {
    ++*(_QWORD *)(a1 + 32);
    ++*(_QWORD *)(a1 + 40);
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_BYTE *)(a1 + 24) = 0;
    }
    else
    {
      v9 = std::streambuf::sbumpc(*(_QWORD *)(a1 + 8));
      if ( v9 == -1 )
      {
        v10 = (std::ios_base *)(*(_QWORD *)a1 + *(int *)(**(_QWORD **)a1 + 4i64));
        v11 = std::ios_base::rdstate(v10);
        std::ios::clear(v10, v11 | 1u, 0i64);
      }
      *(_DWORD *)(a1 + 20) = v9;
    }
    if ( v9 != -1 )
    {
      v13 = v9;
      sub_14617E120((_QWORD *)(a1 + 56), &v13, a3);
    }
    v9 = *(_DWORD *)(a1 + 20);
    if ( v9 == 10 )
    {
      ++*(_QWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 40) = 0i64;
    }
    if ( (_BYTE)v9 != *(_BYTE *)(a2 + v4) )
      break;
    if ( ++v4 >= a3 )
      return a4;
  }
  *(_QWORD *)(a1 + 112) = "invalid literal";
  return 14i64;
}
// 146190FF2: variable 'a3' is possibly undefined
// 14611C358: using guessed type __int64 __fastcall std::ios::clear(_QWORD, _QWORD, _QWORD);
// 14611C4B0: using guessed type _DWORD std::ios_base::rdstate(std::ios_base *__hidden this);
// 14611C4D0: using guessed type __int64 __fastcall std::streambuf::sbumpc(_QWORD);

//----- (0000000146191050) ----------------------------------------------------
__int64 __fastcall sub_146191050(__int64 a1, __int64 a2, __int64 a3)
{
  void **v4; // rsi
  _BYTE *v5; // rax
  __int64 v6; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  int v9; // r12d
  __int64 v10; // rdx
  __int64 v11; // rdx
  __int64 v12; // r8
  int v13; // eax
  int v14; // ebp
  std::ios_base *v15; // rbx
  int v16; // eax
  __int64 v17; // rdx
  __int64 v18; // r8
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rdx
  __int64 v22; // r8
  unsigned int v23; // eax
  __int64 v24; // rdx
  __int64 v25; // r8
  const char *v26; // rax
  __int64 v27; // r8
  __int64 v28; // r9
  _QWORD *v29; // rsi
  _QWORD *v30; // rbx
  int v31; // ebp
  std::ios_base *v32; // rbx
  int v33; // eax
  __int64 v34; // rdx
  __int64 v35; // rdx
  __int64 v36; // r8
  int v37; // ebp
  std::ios_base *v38; // rbx
  int v39; // eax
  __int64 v40; // rax
  __int64 v41; // rax
  const char *v42; // rcx
  unsigned __int64 v43; // rbx
  const char *v45; // rcx
  __int64 v46; // rbx
  const char *v47; // rcx
  char v48; // [rsp+70h] [rbp+8h] BYREF
  char *EndPtr; // [rsp+78h] [rbp+10h] BYREF

  v4 = (void **)(a1 + 80);
  *(_QWORD *)(a1 + 96) = 0i64;
  v5 = (_BYTE *)(a1 + 80);
  if ( *(_QWORD *)(a1 + 104) > 0xFui64 )
    v5 = *v4;
  *v5 = 0;
  v6 = *(_QWORD *)(a1 + 56);
  if ( v6 != *(_QWORD *)(a1 + 64) )
    *(_QWORD *)(a1 + 64) = v6;
  v48 = *(_BYTE *)(a1 + 20);
  sub_14617E120((_QWORD *)(a1 + 56), &v48, a3);
  v9 = 5;
  v10 = *(unsigned int *)(a1 + 20);
  switch ( (int)v10 )
  {
    case '-':
      sub_146190570(v4, v10, v7, v8);
      goto LABEL_7;
    case '0':
LABEL_9:
      sub_146190570(v4, v10, v7, v8);
      v13 = sub_14618E640(a1, v11, v12);
      if ( v13 == 46 )
      {
LABEL_23:
        sub_146190570(v4, *(unsigned __int8 *)(a1 + 144), v7, v8);
        v9 = 7;
        switch ( (unsigned int)sub_14618E640(a1, v17, v18) )
        {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            sub_146190570((void **)(a1 + 80), *(unsigned __int8 *)(a1 + 20), v19, v20);
            v23 = sub_14618E640(a1, v21, v22) - 48;
            while ( 2 )
            {
              switch ( v23 )
              {
                case 0u:
                case 1u:
                case 2u:
                case 3u:
                case 4u:
                case 5u:
                case 6u:
                case 7u:
                case 8u:
                case 9u:
                  sub_146190570((void **)(a1 + 80), *(unsigned __int8 *)(a1 + 20), v7, v8);
                  v23 = sub_14618E640(a1, v24, v25) - 48;
                  if ( v23 > 0x35 )
                    goto LABEL_56;
                  continue;
                case 0x15u:
                case 0x35u:
                  goto LABEL_29;
                default:
                  goto LABEL_56;
              }
            }
          default:
            v26 = "invalid number; expected digit after '.'";
            break;
        }
        goto LABEL_76;
      }
      if ( ((v13 - 69) & 0xFFFFFFDF) == 0 )
      {
LABEL_30:
        sub_146190570(v4, *(unsigned __int8 *)(a1 + 20), v7, v8);
        v9 = 7;
        ++*(_QWORD *)(a1 + 32);
        v29 = (_QWORD *)(a1 + 40);
        ++*(_QWORD *)(a1 + 40);
        if ( *(_BYTE *)(a1 + 24) )
        {
          *(_BYTE *)(a1 + 24) = 0;
          v30 = (_QWORD *)(a1 + 40);
        }
        else
        {
          v31 = std::streambuf::sbumpc(*(_QWORD *)(a1 + 8));
          v30 = (_QWORD *)(a1 + 40);
          if ( v31 == -1 )
          {
            v32 = (std::ios_base *)(*(_QWORD *)a1 + *(int *)(**(_QWORD **)a1 + 4i64));
            v33 = std::ios_base::rdstate(v32);
            std::ios::clear(v32, v33 | 1u, 0i64);
            v30 = (_QWORD *)(a1 + 40);
          }
          *(_DWORD *)(a1 + 20) = v31;
        }
        if ( *(_DWORD *)(a1 + 20) != -1 )
        {
          v48 = *(_DWORD *)(a1 + 20);
          sub_14617E120((_QWORD *)(a1 + 56), &v48, v27);
          v29 = v30;
        }
        v34 = *(unsigned int *)(a1 + 20);
        if ( (_DWORD)v34 == 10 )
        {
          ++*(_QWORD *)(a1 + 48);
          *v29 = 0i64;
LABEL_39:
          v26 = "invalid number; expected '+', '-', or digit after exponent";
LABEL_76:
          *(_QWORD *)(a1 + 112) = v26;
          return 14i64;
        }
        switch ( (int)v34 )
        {
          case '+':
          case '-':
            sub_146190570((void **)(a1 + 80), v34, v27, v28);
            switch ( (unsigned int)sub_14618E640(a1, v35, v36) )
            {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
                v34 = *(unsigned int *)(a1 + 20);
                v29 = (_QWORD *)(a1 + 40);
                goto LABEL_43;
              default:
                v26 = "invalid number; expected digit after exponent sign";
                goto LABEL_76;
            }
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
LABEL_43:
            while ( 2 )
            {
              sub_146190570((void **)(a1 + 80), v34, v27, v28);
              ++*(_QWORD *)(a1 + 32);
              ++*v29;
              if ( *(_BYTE *)(a1 + 24) )
              {
                *(_BYTE *)(a1 + 24) = 0;
              }
              else
              {
                v37 = std::streambuf::sbumpc(*(_QWORD *)(a1 + 8));
                if ( v37 == -1 )
                {
                  v38 = (std::ios_base *)(*(_QWORD *)a1 + *(int *)(**(_QWORD **)a1 + 4i64));
                  v39 = std::ios_base::rdstate(v38);
                  std::ios::clear(v38, v39 | 1u, 0i64);
                }
                *(_DWORD *)(a1 + 20) = v37;
              }
              if ( *(_DWORD *)(a1 + 20) != -1 )
              {
                v48 = *(_DWORD *)(a1 + 20);
                sub_14617E120((_QWORD *)(a1 + 56), &v48, v27);
              }
              v34 = *(unsigned int *)(a1 + 20);
              if ( (_DWORD)v34 == 10 )
              {
                *v29 = 0i64;
                goto LABEL_55;
              }
              switch ( (int)v34 )
              {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  continue;
                default:
                  goto LABEL_56;
              }
            }
          default:
            goto LABEL_39;
        }
      }
LABEL_56:
      *(_BYTE *)(a1 + 24) = 1;
      --*(_QWORD *)(a1 + 32);
      v40 = *(_QWORD *)(a1 + 40);
      if ( v40 )
      {
        *(_QWORD *)(a1 + 40) = v40 - 1;
      }
      else
      {
        v41 = *(_QWORD *)(a1 + 48);
        if ( v41 )
          *(_QWORD *)(a1 + 48) = v41 - 1;
      }
      if ( *(_DWORD *)(a1 + 20) != -1 )
        --*(_QWORD *)(a1 + 64);
      EndPtr = 0i64;
      *errno() = 0;
      if ( v9 == 5 )
      {
        v42 = (const char *)(a1 + 80);
        if ( *(_QWORD *)(a1 + 104) > 0xFui64 )
          v42 = *(const char **)v42;
        v43 = strtoull(v42, &EndPtr, 10);
        if ( !*errno() )
        {
          *(_QWORD *)(a1 + 128) = v43;
          return 5i64;
        }
      }
      else if ( v9 == 6 )
      {
        v45 = (const char *)(a1 + 80);
        if ( *(_QWORD *)(a1 + 104) > 0xFui64 )
          v45 = *(const char **)v45;
        v46 = strtoll(v45, &EndPtr, 10);
        if ( !*errno() )
        {
          *(_QWORD *)(a1 + 120) = v46;
          return 6i64;
        }
      }
      v47 = (const char *)(a1 + 80);
      if ( *(_QWORD *)(a1 + 104) > 0xFui64 )
        v47 = *(const char **)v47;
      *(double *)(a1 + 136) = strtod(v47, &EndPtr);
      return 7i64;
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
LABEL_13:
      while ( 2 )
      {
        sub_146190570(v4, v10, v7, v8);
        ++*(_QWORD *)(a1 + 32);
        ++*(_QWORD *)(a1 + 40);
        if ( *(_BYTE *)(a1 + 24) )
        {
          *(_BYTE *)(a1 + 24) = 0;
        }
        else
        {
          v14 = std::streambuf::sbumpc(*(_QWORD *)(a1 + 8));
          if ( v14 == -1 )
          {
            v15 = (std::ios_base *)(*(_QWORD *)a1 + *(int *)(**(_QWORD **)a1 + 4i64));
            v16 = std::ios_base::rdstate(v15);
            std::ios::clear(v15, v16 | 1u, 0i64);
          }
          *(_DWORD *)(a1 + 20) = v14;
        }
        if ( *(_DWORD *)(a1 + 20) != -1 )
        {
          v48 = *(_DWORD *)(a1 + 20);
          sub_14617E120((_QWORD *)(a1 + 56), &v48, v7);
        }
        v10 = *(unsigned int *)(a1 + 20);
        if ( (_DWORD)v10 != 10 )
        {
          switch ( (int)v10 )
          {
            case '.':
              v4 = (void **)(a1 + 80);
              goto LABEL_23;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              continue;
            case 'E':
            case 'e':
LABEL_29:
              v4 = (void **)(a1 + 80);
              goto LABEL_30;
            default:
              goto LABEL_56;
          }
        }
        break;
      }
      *(_QWORD *)(a1 + 40) = 0i64;
LABEL_55:
      ++*(_QWORD *)(a1 + 48);
      goto LABEL_56;
    default:
LABEL_7:
      v9 = 6;
      switch ( (unsigned int)sub_14618E640(a1, v10, v7) )
      {
        case '0':
          v10 = *(unsigned int *)(a1 + 20);
          goto LABEL_9;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          v10 = *(unsigned int *)(a1 + 20);
          goto LABEL_13;
        default:
          v26 = "invalid number; expected digit after '-'";
          goto LABEL_76;
      }
  }
}
// 1461910DF: variable 'v7' is possibly undefined
// 1461910DF: variable 'v8' is possibly undefined
// 1461910ED: variable 'v10' is possibly undefined
// 14619111B: variable 'v11' is possibly undefined
// 14619111B: variable 'v12' is possibly undefined
// 146191205: variable 'v17' is possibly undefined
// 146191205: variable 'v18' is possibly undefined
// 146191229: variable 'v19' is possibly undefined
// 146191229: variable 'v20' is possibly undefined
// 146191231: variable 'v21' is possibly undefined
// 146191231: variable 'v22' is possibly undefined
// 14619126A: variable 'v24' is possibly undefined
// 14619126A: variable 'v25' is possibly undefined
// 14619130F: variable 'v27' is possibly undefined
// 146191351: variable 'v28' is possibly undefined
// 146191359: variable 'v35' is possibly undefined
// 146191359: variable 'v36' is possibly undefined
// 14611C358: using guessed type __int64 __fastcall std::ios::clear(_QWORD, _QWORD, _QWORD);
// 14611C4B0: using guessed type _DWORD std::ios_base::rdstate(std::ios_base *__hidden this);
// 14611C4D0: using guessed type __int64 __fastcall std::streambuf::sbumpc(_QWORD);

//----- (00000001461916F0) ----------------------------------------------------
__int64 __fastcall sub_1461916F0(__int64 a1, __int64 a2, __int64 a3)
{
  _BYTE *v4; // rax
  __int64 v5; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  __m128i si128; // xmm7
  __m128i v9; // xmm6
  __m128i v10; // xmm8
  __m128i v11; // xmm9
  __m128i v12; // xmm10
  int v13; // esi
  std::ios_base *v14; // rdi
  int v15; // eax
  __int64 v16; // rdx
  __int64 v17; // rdx
  __int64 v18; // r8
  __int64 v19; // r9
  int v20; // eax
  __int64 v21; // rdx
  __int64 v22; // r8
  __int64 v23; // r9
  int v24; // edi
  __int64 v25; // rdx
  __int64 v26; // r8
  __int64 v27; // rdx
  __int64 v28; // r8
  int v29; // eax
  unsigned int v30; // esi
  unsigned __int8 v31; // si
  unsigned int v32; // r15d
  void **v33; // rcx
  unsigned __int8 v34; // r15
  __int64 *v35; // rsi
  int v36; // r14d
  std::ios_base *v37; // rdi
  int v38; // eax
  __int64 v39; // rdx
  __int64 *v40; // rdx
  const char *v41; // rax
  int v43; // [rsp+28h] [rbp-E0h] BYREF
  __int64 v44; // [rsp+30h] [rbp-D8h] BYREF
  __int64 v45[2]; // [rsp+38h] [rbp-D0h] BYREF
  __int64 v46[2]; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v47[2]; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v48[2]; // [rsp+68h] [rbp-A0h] BYREF
  __int64 v49[2]; // [rsp+78h] [rbp-90h] BYREF
  __int64 v50[3]; // [rsp+88h] [rbp-80h] BYREF
  __m128i v51; // [rsp+A0h] [rbp-68h] BYREF
  int v52; // [rsp+B0h] [rbp-58h] BYREF
  int v53; // [rsp+B4h] [rbp-54h]
  __int64 v54[12]; // [rsp+B8h] [rbp-50h] BYREF

  v50[2] = -2i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  v4 = (_BYTE *)(a1 + 80);
  if ( *(_QWORD *)(a1 + 104) > 0xFui64 )
    v4 = *(_BYTE **)(a1 + 80);
  *v4 = 0;
  v5 = *(_QWORD *)(a1 + 56);
  if ( v5 != *(_QWORD *)(a1 + 64) )
    *(_QWORD *)(a1 + 64) = v5;
  LOBYTE(v43) = *(_BYTE *)(a1 + 20);
  sub_14617E120((_QWORD *)(a1 + 56), &v43, a3);
  si128 = _mm_load_si128((const __m128i *)&xmmword_14612E130);
  v9 = _mm_load_si128((const __m128i *)&xmmword_14612E150);
  v10 = _mm_load_si128((const __m128i *)&xmmword_14612E160);
  v11 = _mm_load_si128((const __m128i *)&xmmword_14612E140);
  v12 = _mm_load_si128((const __m128i *)&xmmword_14612E170);
LABEL_6:
  while ( 2 )
  {
    ++*(_QWORD *)(a1 + 32);
    ++*(_QWORD *)(a1 + 40);
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_BYTE *)(a1 + 24) = 0;
    }
    else
    {
      v13 = std::streambuf::sbumpc(*(_QWORD *)(a1 + 8));
      if ( v13 == -1 )
      {
        v14 = (std::ios_base *)(*(_QWORD *)a1 + *(int *)(**(_QWORD **)a1 + 4i64));
        v15 = std::ios_base::rdstate(v14);
        std::ios::clear(v14, v15 | 1u, 0i64);
      }
      *(_DWORD *)(a1 + 20) = v13;
    }
    if ( *(_DWORD *)(a1 + 20) != -1 )
    {
      LOBYTE(v43) = *(_DWORD *)(a1 + 20);
      sub_14617E120((_QWORD *)(a1 + 56), &v43, v6);
    }
    v16 = *(unsigned int *)(a1 + 20);
    if ( (_DWORD)v16 == 10 )
    {
      ++*(_QWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 40) = 0i64;
    }
    switch ( (int)v16 )
    {
      case -1:
        v41 = "invalid string: missing closing quote";
        goto LABEL_104;
      case 0:
        v41 = "invalid string: control character U+0000 (NUL) must be escaped to \\u0000";
        goto LABEL_104;
      case 1:
        v41 = "invalid string: control character U+0001 (SOH) must be escaped to \\u0001";
        goto LABEL_104;
      case 2:
        v41 = "invalid string: control character U+0002 (STX) must be escaped to \\u0002";
        goto LABEL_104;
      case 3:
        v41 = "invalid string: control character U+0003 (ETX) must be escaped to \\u0003";
        goto LABEL_104;
      case 4:
        v41 = "invalid string: control character U+0004 (EOT) must be escaped to \\u0004";
        goto LABEL_104;
      case 5:
        v41 = "invalid string: control character U+0005 (ENQ) must be escaped to \\u0005";
        goto LABEL_104;
      case 6:
        v41 = "invalid string: control character U+0006 (ACK) must be escaped to \\u0006";
        goto LABEL_104;
      case 7:
        v41 = "invalid string: control character U+0007 (BEL) must be escaped to \\u0007";
        goto LABEL_104;
      case 8:
        v41 = "invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b";
        goto LABEL_104;
      case 9:
        v41 = "invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t";
        goto LABEL_104;
      case 10:
        v41 = "invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n";
        goto LABEL_104;
      case 11:
        v41 = "invalid string: control character U+000B (VT) must be escaped to \\u000B";
        goto LABEL_104;
      case 12:
        v41 = "invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f";
        goto LABEL_104;
      case 13:
        v41 = "invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r";
        goto LABEL_104;
      case 14:
        v41 = "invalid string: control character U+000E (SO) must be escaped to \\u000E";
        goto LABEL_104;
      case 15:
        v41 = "invalid string: control character U+000F (SI) must be escaped to \\u000F";
        goto LABEL_104;
      case 16:
        v41 = "invalid string: control character U+0010 (DLE) must be escaped to \\u0010";
        goto LABEL_104;
      case 17:
        v41 = "invalid string: control character U+0011 (DC1) must be escaped to \\u0011";
        goto LABEL_104;
      case 18:
        v41 = "invalid string: control character U+0012 (DC2) must be escaped to \\u0012";
        goto LABEL_104;
      case 19:
        v41 = "invalid string: control character U+0013 (DC3) must be escaped to \\u0013";
        goto LABEL_104;
      case 20:
        v41 = "invalid string: control character U+0014 (DC4) must be escaped to \\u0014";
        goto LABEL_104;
      case 21:
        v41 = "invalid string: control character U+0015 (NAK) must be escaped to \\u0015";
        goto LABEL_104;
      case 22:
        v41 = "invalid string: control character U+0016 (SYN) must be escaped to \\u0016";
        goto LABEL_104;
      case 23:
        v41 = "invalid string: control character U+0017 (ETB) must be escaped to \\u0017";
        goto LABEL_104;
      case 24:
        v41 = "invalid string: control character U+0018 (CAN) must be escaped to \\u0018";
        goto LABEL_104;
      case 25:
        v41 = "invalid string: control character U+0019 (EM) must be escaped to \\u0019";
        goto LABEL_104;
      case 26:
        v41 = "invalid string: control character U+001A (SUB) must be escaped to \\u001A";
        goto LABEL_104;
      case 27:
        v41 = "invalid string: control character U+001B (ESC) must be escaped to \\u001B";
        goto LABEL_104;
      case 28:
        v41 = "invalid string: control character U+001C (FS) must be escaped to \\u001C";
        goto LABEL_104;
      case 29:
        v41 = "invalid string: control character U+001D (GS) must be escaped to \\u001D";
        goto LABEL_104;
      case 30:
        v41 = "invalid string: control character U+001E (RS) must be escaped to \\u001E";
        goto LABEL_104;
      case 31:
        v41 = "invalid string: control character U+001F (US) must be escaped to \\u001F";
        goto LABEL_104;
      case 32:
      case 33:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
      case 75:
      case 76:
      case 77:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
      case 83:
      case 84:
      case 85:
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      case 91:
      case 93:
      case 94:
      case 95:
      case 96:
      case 97:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
      case 123:
      case 124:
      case 125:
      case 126:
      case 127:
        sub_146190570((void **)(a1 + 80), v16, v6, v7);
        continue;
      case 34:
        return 4i64;
      case 92:
        switch ( (unsigned int)sub_14618E640(a1, v16, v6) )
        {
          case '"':
            sub_146190570((void **)(a1 + 80), 34i64, v18, v19);
            continue;
          case '/':
            sub_146190570((void **)(a1 + 80), 47i64, v18, v19);
            continue;
          case '\\':
            sub_146190570((void **)(a1 + 80), 92i64, v18, v19);
            continue;
          case 'b':
            sub_146190570((void **)(a1 + 80), 8i64, v18, v19);
            continue;
          case 'f':
            sub_146190570((void **)(a1 + 80), 12i64, v18, v19);
            continue;
          case 'n':
            sub_146190570((void **)(a1 + 80), 10i64, v18, v19);
            continue;
          case 'r':
            sub_146190570((void **)(a1 + 80), 13i64, v18, v19);
            continue;
          case 't':
            sub_146190570((void **)(a1 + 80), 9i64, v18, v19);
            continue;
          case 'u':
            v20 = sub_14618E6E0(a1, v17, v18);
            v24 = v20;
            if ( v20 == -1 )
              goto LABEL_67;
            if ( (unsigned int)(v20 - 55296) > 0x3FF )
            {
              if ( (unsigned int)(v20 - 56320) <= 0x3FF )
              {
                v41 = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
                goto LABEL_104;
              }
LABEL_33:
              if ( v24 >= 128 )
              {
                v30 = (unsigned int)v24 >> 6;
                if ( v24 > 2047 )
                {
                  v32 = (unsigned int)v24 >> 12;
                  v31 = v30 & 0x3F | 0x80;
                  v33 = (void **)(a1 + 80);
                  if ( v24 > 0xFFFF )
                  {
                    sub_146190570(v33, (unsigned __int8)((unsigned int)v24 >> 18) | 0xF0u, v22, v23);
                    v34 = v32 & 0x3F | 0x80;
                    v33 = (void **)(a1 + 80);
                  }
                  else
                  {
                    v34 = v32 | 0xE0;
                  }
                  sub_146190570(v33, v34, v22, v23);
                }
                else
                {
                  v31 = v30 | 0xC0;
                }
                sub_146190570((void **)(a1 + 80), v31, v22, v23);
                LOBYTE(v24) = v24 & 0x3F | 0x80;
              }
              sub_146190570((void **)(a1 + 80), (unsigned __int8)v24, v22, v23);
              continue;
            }
            if ( (unsigned int)sub_14618E640(a1, v21, v22) == 92 && (unsigned int)sub_14618E640(a1, v25, v26) == 117 )
            {
              v29 = sub_14618E6E0(a1, v27, v28);
              if ( v29 == -1 )
              {
LABEL_67:
                v41 = "invalid string: '\\u' must be followed by 4 hex digits";
                goto LABEL_104;
              }
              if ( (unsigned int)(v29 - 56320) > 0x3FF )
                goto LABEL_65;
              v24 = v29 + (v24 << 10) - 56613888;
              goto LABEL_33;
            }
LABEL_65:
            v41 = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
LABEL_104:
            *(_QWORD *)(a1 + 112) = v41;
            return 14i64;
          default:
            v41 = "invalid string: forbidden character after backslash";
            goto LABEL_104;
        }
      case 194:
      case 195:
      case 196:
      case 197:
      case 198:
      case 199:
      case 200:
      case 201:
      case 202:
      case 203:
      case 204:
      case 205:
      case 206:
      case 207:
      case 208:
      case 209:
      case 210:
      case 211:
      case 212:
      case 213:
      case 214:
      case 215:
      case 216:
      case 217:
      case 218:
      case 219:
      case 220:
      case 221:
      case 222:
      case 223:
        v44 = 0xBF00000080i64;
        sub_146190570((void **)(a1 + 80), v16, v6, v7);
        v35 = &v44;
        while ( 1 )
        {
          ++*(_QWORD *)(a1 + 32);
          ++*(_QWORD *)(a1 + 40);
          if ( *(_BYTE *)(a1 + 24) )
          {
            *(_BYTE *)(a1 + 24) = 0;
          }
          else
          {
            v36 = std::streambuf::sbumpc(*(_QWORD *)(a1 + 8));
            if ( v36 == -1 )
            {
              v37 = (std::ios_base *)(*(_QWORD *)a1 + *(int *)(**(_QWORD **)a1 + 4i64));
              v38 = std::ios_base::rdstate(v37);
              std::ios::clear(v37, v38 | 1u, 0i64);
            }
            *(_DWORD *)(a1 + 20) = v36;
          }
          if ( *(_DWORD *)(a1 + 20) != -1 )
          {
            LOBYTE(v43) = *(_DWORD *)(a1 + 20);
            sub_14617E120((_QWORD *)(a1 + 56), &v43, v6);
          }
          v39 = *(unsigned int *)(a1 + 20);
          if ( (_DWORD)v39 == 10 )
          {
            ++*(_QWORD *)(a1 + 48);
            *(_QWORD *)(a1 + 40) = 0i64;
          }
          if ( *(_DWORD *)v35 > (int)v39 || (int)v39 > *((_DWORD *)v35 + 1) )
            break;
          sub_146190570((void **)(a1 + 80), v39, v6, v7);
          if ( ++v35 == v45 )
            goto LABEL_6;
        }
LABEL_103:
        v41 = "invalid string: ill-formed UTF-8 byte";
        goto LABEL_104;
      case 224:
        v51 = v12;
        v45[0] = (__int64)&v51;
        v45[1] = (__int64)&v52;
        v40 = v45;
        goto LABEL_58;
      case 225:
      case 226:
      case 227:
      case 228:
      case 229:
      case 230:
      case 231:
      case 232:
      case 233:
      case 234:
      case 235:
      case 236:
      case 238:
      case 239:
        v51 = v9;
        v46[0] = (__int64)&v51;
        v46[1] = (__int64)&v52;
        v40 = v46;
        goto LABEL_58;
      case 237:
        v51 = v11;
        v47[0] = (__int64)&v51;
        v47[1] = (__int64)&v52;
        v40 = v47;
        goto LABEL_58;
      case 240:
        v51 = v10;
        v52 = 128;
        v53 = 191;
        v48[0] = (__int64)&v51;
        v48[1] = (__int64)v54;
        v40 = v48;
        goto LABEL_58;
      case 241:
      case 242:
      case 243:
        v51 = v9;
        v52 = 128;
        v53 = 191;
        v49[0] = (__int64)&v51;
        v49[1] = (__int64)v54;
        v40 = v49;
        goto LABEL_58;
      case 244:
        v51 = si128;
        v52 = 128;
        v53 = 191;
        v50[0] = (__int64)&v51;
        v50[1] = (__int64)v54;
        v40 = v50;
LABEL_58:
        if ( !sub_14618F530(a1, (__int64)v40, v6, v7) )
          return 14i64;
        continue;
      default:
        goto LABEL_103;
    }
  }
}
// 14619182B: variable 'v6' is possibly undefined
// 14619189B: variable 'v18' is possibly undefined
// 14619189B: variable 'v19' is possibly undefined
// 14619193B: variable 'v17' is possibly undefined
// 14619195A: variable 'v21' is possibly undefined
// 14619195A: variable 'v22' is possibly undefined
// 14619196B: variable 'v25' is possibly undefined
// 14619196B: variable 'v26' is possibly undefined
// 14619197C: variable 'v27' is possibly undefined
// 14619197C: variable 'v28' is possibly undefined
// 146191A0D: variable 'v23' is possibly undefined
// 146191A51: variable 'v7' is possibly undefined
// 14611C358: using guessed type __int64 __fastcall std::ios::clear(_QWORD, _QWORD, _QWORD);
// 14611C4B0: using guessed type _DWORD std::ios_base::rdstate(std::ios_base *__hidden this);
// 14611C4D0: using guessed type __int64 __fastcall std::streambuf::sbumpc(_QWORD);
// 14612E130: using guessed type __int128 xmmword_14612E130;
// 14612E140: using guessed type __int128 xmmword_14612E140;
// 14612E150: using guessed type __int128 xmmword_14612E150;
// 14612E160: using guessed type __int128 xmmword_14612E160;
// 14612E170: using guessed type __int128 xmmword_14612E170;

//----- (0000000146192040) ----------------------------------------------------
fpos_t *__fastcall sub_146192040(__int64 a1, fpos_t *a2, __int64 a3, int a4)
{
  fpos_t v8; // rcx
  fpos_t Position; // [rsp+30h] [rbp+8h] BYREF

  if ( std::streambuf::gptr(a1) == a1 + 112 && a4 == 1 && !*(_QWORD *)(a1 + 104) )
    --a3;
  if ( !*(_QWORD *)(a1 + 128)
    || !sub_14618AF10(a1)
    || (a3 || a4 != 1) && fseeki64(*(FILE **)(a1 + 128), a3, a4)
    || fgetpos(*(FILE **)(a1 + 128), &Position) )
  {
    *a2 = -1i64;
    a2[1] = 0i64;
    a2[2] = 0i64;
  }
  else
  {
    sub_14618B6B0(a1);
    v8 = *(_QWORD *)(a1 + 116);
    *a2 = Position;
    a2[2] = v8;
    a2[1] = 0i64;
  }
  return a2;
}
// 14611C4E0: using guessed type __int64 __fastcall std::streambuf::gptr(_QWORD);

//----- (0000000146192120) ----------------------------------------------------
fpos_t *__fastcall sub_146192120(__int64 a1, fpos_t *a2, _QWORD *a3)
{
  bool v5; // zf
  fpos_t v7; // rcx
  fpos_t *result; // rax
  fpos_t Position; // [rsp+30h] [rbp+8h] BYREF

  v5 = *(_QWORD *)(a1 + 128) == 0i64;
  Position = *a3 + a3[1];
  if ( v5 || !sub_14618AF10(a1) || fsetpos(*(FILE **)(a1 + 128), &Position) )
  {
    *a2 = -1i64;
    a2[1] = 0i64;
    a2[2] = 0i64;
    return a2;
  }
  else
  {
    *(_QWORD *)(a1 + 116) = a3[2];
    sub_14618B6B0(a1);
    v7 = *(_QWORD *)(a1 + 116);
    *a2 = Position;
    result = a2;
    a2[1] = 0i64;
    a2[2] = v7;
  }
  return result;
}

//----- (00000001461921D0) ----------------------------------------------------
__int64 __fastcall sub_1461921D0(__int64 a1, char *a2, size_t a3)
{
  bool v5; // zf
  int v6; // r8d
  FILE *v7; // rcx
  FILE *v8; // rdi
  __int64 result; // rax
  int *Count; // [rsp+60h] [rbp+8h] BYREF
  char **Pointer; // [rsp+68h] [rbp+10h] BYREF
  char **Base; // [rsp+70h] [rbp+18h] BYREF

  if ( a2 || (v5 = a3 == 0, v6 = 4, !v5) )
    v6 = 0;
  v7 = *(FILE **)(a1 + 128);
  if ( !v7 || setvbuf(v7, a2, v6, a3) )
    return 0i64;
  v8 = *(FILE **)(a1 + 128);
  *(_BYTE *)(a1 + 124) = 1;
  *(_BYTE *)(a1 + 113) = 0;
  std::streambuf::_Init(a1);
  if ( v8 )
  {
    Base = 0i64;
    Pointer = 0i64;
    Count = 0i64;
    get_stream_buffer_pointers(v8, &Base, &Pointer, &Count);
    std::streambuf::_Init(a1);
  }
  *(_QWORD *)(a1 + 128) = v8;
  *(_QWORD *)(a1 + 116) = qword_14611AB90;
  result = a1;
  *(_QWORD *)(a1 + 104) = 0i64;
  return result;
}
// 14611AB90: using guessed type __int64 qword_14611AB90;
// 14611C330: using guessed type __int64 __fastcall std::streambuf::_Init(_QWORD);
// 14611C338: using guessed type __int64 __fastcall std::streambuf::_Init(_QWORD);

//----- (00000001461922B0) ----------------------------------------------------
__int64 __fastcall sub_1461922B0(__int64 a1)
{
  __int64 result; // rax

  switch ( *(_BYTE *)a1 )
  {
    case 0:
      result = 0i64;
      break;
    case 1:
      result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64);
      break;
    case 2:
      result = (__int64)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64) - **(_QWORD **)(a1 + 8)) >> 4;
      break;
    default:
      result = 1i64;
      break;
  }
  return result;
}

//----- (0000000146192320) ----------------------------------------------------
__int64 __fastcall sub_146192320(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // esi
  std::ios_base *v5; // rdi
  int v6; // eax
  __int64 result; // rax
  char v8; // [rsp+30h] [rbp+8h] BYREF

  v3 = *(_DWORD *)(a1 + 20);
  do
  {
    while ( 1 )
    {
      ++*(_QWORD *)(a1 + 32);
      ++*(_QWORD *)(a1 + 40);
      if ( *(_BYTE *)(a1 + 24) )
      {
        *(_BYTE *)(a1 + 24) = 0;
      }
      else
      {
        v3 = std::streambuf::sbumpc(*(_QWORD *)(a1 + 8));
        if ( v3 == -1 )
        {
          v5 = (std::ios_base *)(*(_QWORD *)a1 + *(int *)(**(_QWORD **)a1 + 4i64));
          v6 = std::ios_base::rdstate(v5);
          std::ios::clear(v5, v6 | 1u, 0i64);
        }
        *(_DWORD *)(a1 + 20) = v3;
      }
      if ( v3 != -1 )
      {
        v8 = v3;
        sub_14617E120((_QWORD *)(a1 + 56), &v8, a3);
      }
      v3 = *(_DWORD *)(a1 + 20);
      result = v3;
      if ( v3 != 10 )
        break;
      ++*(_QWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 40) = 0i64;
    }
  }
  while ( v3 == 32 || v3 == 9 || v3 == 13 );
  return result;
}
// 1461923A2: variable 'a3' is possibly undefined
// 14611C358: using guessed type __int64 __fastcall std::ios::clear(_QWORD, _QWORD, _QWORD);
// 14611C4B0: using guessed type _DWORD std::ios_base::rdstate(std::ios_base *__hidden this);
// 14611C4D0: using guessed type __int64 __fastcall std::streambuf::sbumpc(_QWORD);

//----- (00000001461923F0) ----------------------------------------------------
char __fastcall sub_1461923F0(__int64 a1, unsigned __int64 a2)
{
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v7; // rbx
  _QWORD *v8; // rax
  void **v9; // rax
  int v10; // [rsp+20h] [rbp-A8h] BYREF
  int v11; // [rsp+28h] [rbp-A0h] BYREF
  __int64 v12; // [rsp+30h] [rbp-98h]
  char pExceptionObject[56]; // [rsp+38h] [rbp-90h] BYREF
  __int64 v14; // [rsp+70h] [rbp-58h] BYREF
  __int64 v15[3]; // [rsp+78h] [rbp-50h] BYREF
  void *Src; // [rsp+90h] [rbp-38h] BYREF

  v12 = -2i64;
  LOBYTE(v10) = 2;
  v11 = (__int64)(*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3;
  v4 = *(_QWORD *)(a1 + 168);
  if ( !v4 )
  {
    std::_Xbad_function_call();
    JUMPOUT(0x14619253Ci64);
  }
  LOBYTE(v10) = (*(__int64 (__fastcall **)(__int64, int *, int *, __int64, int, int, __int64))(*(_QWORD *)v4 + 16i64))(
                  v4,
                  &v11,
                  &v10,
                  a1 + 184,
                  v10,
                  v11,
                  v12);
  sub_1461907F0((__int64 *)(a1 + 32), (char *)&v10);
  LOBYTE(v10) = 2;
  sub_146182980((__int64 *)a1, (__int64)&v14, (unsigned __int8 *)&v10, 1);
  sub_1461906D0((const void **)(a1 + 8), v15);
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 16) - 8i64);
  if ( v5 && a2 != -1i64 && a2 > sub_14618F120(v5) )
  {
    v7 = *(_QWORD *)sub_14618BBF0(a1 + 8);
    v8 = sub_1461928C0(&v14, a2);
    v9 = sub_14617F690(&Src, "excessive array size: ", v8);
    sub_14617FF70((__int64)pExceptionObject, 0x198u, v9, v7);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVout_of_range_detail_json_abi_v3_11_2_nlohmann__);
  }
  return 1;
}
// 146192537: control flows out of bounds to 14619253C
// 1461923F0: using guessed type __int64 var_50[3];

//----- (0000000146192540) ----------------------------------------------------
char __fastcall sub_146192540(__int64 a1, unsigned __int64 a2)
{
  __int64 v5; // rbx
  _QWORD *v6; // rax
  void **v7; // rax
  char v8[8]; // [rsp+20h] [rbp-A8h] BYREF
  __int64 v9[2]; // [rsp+28h] [rbp-A0h] BYREF
  char pExceptionObject[56]; // [rsp+38h] [rbp-90h] BYREF
  __int64 v11[4]; // [rsp+70h] [rbp-58h] BYREF
  void *Src; // [rsp+90h] [rbp-38h] BYREF

  v9[1] = -2i64;
  v8[0] = 2;
  v9[0] = sub_146182C10((unsigned __int8 **)a1, v8);
  sub_1461906D0((const void **)(a1 + 8), v9);
  if ( a2 != -1i64 && a2 > sub_14618F120(*(_QWORD *)(*(_QWORD *)(a1 + 16) - 8i64)) )
  {
    v5 = *(_QWORD *)sub_14618BBF0(a1 + 8);
    v6 = sub_1461928C0(v11, a2);
    v7 = sub_14617F690(&Src, "excessive array size: ", v6);
    sub_14617FF70((__int64)pExceptionObject, 0x198u, v7, v5);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVout_of_range_detail_json_abi_v3_11_2_nlohmann__);
  }
  return 1;
}
// 146192540: using guessed type char var_A8[8];
// 146192540: using guessed type __int64 var_58[4];

//----- (0000000146192630) ----------------------------------------------------
char __fastcall sub_146192630(__int64 a1, unsigned __int64 a2)
{
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v7; // rbx
  _QWORD *v8; // rax
  void **v9; // rax
  int v10; // [rsp+20h] [rbp-A8h] BYREF
  int v11; // [rsp+28h] [rbp-A0h] BYREF
  __int64 v12; // [rsp+30h] [rbp-98h]
  char pExceptionObject[56]; // [rsp+38h] [rbp-90h] BYREF
  __int64 v14; // [rsp+70h] [rbp-58h] BYREF
  __int64 v15[3]; // [rsp+78h] [rbp-50h] BYREF
  void *Src; // [rsp+90h] [rbp-38h] BYREF

  v12 = -2i64;
  LOBYTE(v10) = 0;
  v11 = (__int64)(*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3;
  v4 = *(_QWORD *)(a1 + 168);
  if ( !v4 )
  {
    std::_Xbad_function_call();
    JUMPOUT(0x14619277Ci64);
  }
  LOBYTE(v10) = (*(__int64 (__fastcall **)(__int64, int *, int *, __int64, int, int, __int64))(*(_QWORD *)v4 + 16i64))(
                  v4,
                  &v11,
                  &v10,
                  a1 + 184,
                  v10,
                  v11,
                  v12);
  sub_1461907F0((__int64 *)(a1 + 32), (char *)&v10);
  LOBYTE(v10) = 1;
  sub_146182980((__int64 *)a1, (__int64)&v14, (unsigned __int8 *)&v10, 1);
  sub_1461906D0((const void **)(a1 + 8), v15);
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 16) - 8i64);
  if ( v5 && a2 != -1i64 && a2 > sub_14618F120(v5) )
  {
    v7 = *(_QWORD *)sub_14618BBF0(a1 + 8);
    v8 = sub_1461928C0(&v14, a2);
    v9 = sub_14617F690(&Src, "excessive object size: ", v8);
    sub_14617FF70((__int64)pExceptionObject, 0x198u, v9, v7);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVout_of_range_detail_json_abi_v3_11_2_nlohmann__);
  }
  return 1;
}
// 146192777: control flows out of bounds to 14619277C
// 146192630: using guessed type __int64 var_50[3];

//----- (0000000146192780) ----------------------------------------------------
char __fastcall sub_146192780(__int64 a1, unsigned __int64 a2)
{
  __int64 v5; // rbx
  _QWORD *v6; // rax
  void **v7; // rax
  char v8[8]; // [rsp+20h] [rbp-A8h] BYREF
  __int64 v9[2]; // [rsp+28h] [rbp-A0h] BYREF
  char pExceptionObject[56]; // [rsp+38h] [rbp-90h] BYREF
  __int64 v11[4]; // [rsp+70h] [rbp-58h] BYREF
  void *Src; // [rsp+90h] [rbp-38h] BYREF

  v9[1] = -2i64;
  v8[0] = 1;
  v9[0] = sub_146182C10((unsigned __int8 **)a1, v8);
  sub_1461906D0((const void **)(a1 + 8), v9);
  if ( a2 != -1i64 && a2 > sub_14618F120(*(_QWORD *)(*(_QWORD *)(a1 + 16) - 8i64)) )
  {
    v5 = *(_QWORD *)sub_14618BBF0(a1 + 8);
    v6 = sub_1461928C0(v11, a2);
    v7 = sub_14617F690(&Src, "excessive object size: ", v6);
    sub_14617FF70((__int64)pExceptionObject, 0x198u, v7, v5);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVout_of_range_detail_json_abi_v3_11_2_nlohmann__);
  }
  return 1;
}
// 146192780: using guessed type char var_A8[8];
// 146192780: using guessed type __int64 var_58[4];

//----- (0000000146192870) ----------------------------------------------------
__int64 __fastcall sub_146192870(FILE **a1)
{
  if ( !a1[16] || (*(unsigned int (__fastcall **)(FILE **, __int64))&(*a1)->_flag)(a1, 0xFFFFFFFFi64) == -1 )
    return 0i64;
  else
    return (unsigned int)(fflush(a1[16]) >= 0) - 1;
}

//----- (00000001461928C0) ----------------------------------------------------
_QWORD *__fastcall sub_1461928C0(_QWORD *a1, unsigned __int64 a2)
{
  char *v4; // r10
  char v6[8]; // [rsp+20h] [rbp-38h] BYREF
  _QWORD *v7; // [rsp+28h] [rbp-30h]
  char v8[3]; // [rsp+45h] [rbp-13h] BYREF

  v7 = a1;
  v4 = v8;
  do
  {
    *--v4 = a2 % 0xA + 48;
    a2 /= 0xAui64;
  }
  while ( a2 );
  sub_14617D810(a1, v4, v8, (__int64)v6);
  return a1;
}
// 1461928C0: using guessed type char var_38[8];

//----- (0000000146192950) ----------------------------------------------------
const char *__fastcall sub_146192950(int a1)
{
  const char *result; // rax

  switch ( a1 )
  {
    case 0:
      result = "<uninitialized>";
      break;
    case 1:
      result = "true literal";
      break;
    case 2:
      result = "false literal";
      break;
    case 3:
      result = "null literal";
      break;
    case 4:
      result = "string literal";
      break;
    case 5:
    case 6:
    case 7:
      result = "number literal";
      break;
    case 8:
      result = "'['";
      break;
    case 9:
      result = "'{'";
      break;
    case 10:
      result = "']'";
      break;
    case 11:
      result = "'}'";
      break;
    case 12:
      result = "':'";
      break;
    case 13:
      result = "','";
      break;
    case 14:
      result = "<parse error>";
      break;
    case 15:
      result = "end of input";
      break;
    case 16:
      result = "'[', '{', or a literal";
      break;
    default:
      result = "unknown token";
      break;
  }
  return result;
}

//----- (0000000146192A40) ----------------------------------------------------
const char *__fastcall sub_146192A40(_BYTE *a1)
{
  const char *result; // rax

  switch ( *a1 )
  {
    case 0:
      result = "null";
      break;
    case 1:
      result = (const char *)&dword_14612CC4C;
      break;
    case 2:
      result = (const char *)&dword_14612CC44;
      break;
    case 3:
      result = "string";
      break;
    case 4:
      result = "boolean";
      break;
    case 8:
      result = "binary";
      break;
    case 9:
      result = "discarded";
      break;
    default:
      result = "number";
      break;
  }
  return result;
}
// 14612CC44: using guessed type int dword_14612CC44;
// 14612CC4C: using guessed type int dword_14612CC4C;

//----- (0000000146192AD0) ----------------------------------------------------
__int64 __fastcall sub_146192AD0(__int64 a1)
{
  unsigned __int64 v2; // rbx
  FILE *v4; // rcx
  int v5; // eax
  unsigned int v6; // ebx
  int v7; // eax
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  char v11; // r12
  size_t v12; // rsi
  size_t v13; // r14
  void **v14; // rax
  _QWORD *v15; // rdi
  size_t v16; // rbx
  unsigned __int64 v17; // rcx
  _QWORD *v18; // rbx
  void **v19; // rdx
  void **v20; // r8
  int v21; // eax
  int v22; // eax
  void **v23; // rax
  size_t v24; // r9
  void **v25; // rcx
  size_t v26; // rbx
  void **v27; // rax
  __int64 v28; // rcx
  __int64 v29; // rbx
  void *v30; // rcx
  unsigned __int8 v31; // [rsp+48h] [rbp-19h] BYREF
  char v32[7]; // [rsp+49h] [rbp-18h] BYREF
  __int64 v33; // [rsp+50h] [rbp-11h] BYREF
  __int64 v34[2]; // [rsp+58h] [rbp-9h] BYREF
  void *Src[2]; // [rsp+68h] [rbp+7h] BYREF
  size_t Size; // [rsp+78h] [rbp+17h]
  size_t v37; // [rsp+80h] [rbp+1Fh]

  v34[1] = -2i64;
  if ( std::streambuf::gptr(a1) )
  {
    v2 = std::streambuf::egptr(a1);
    if ( std::streambuf::gptr(a1) < v2 )
      return *(unsigned __int8 *)std::streambuf::_Gninc(a1);
  }
  if ( !*(_QWORD *)(a1 + 128) )
    return 0xFFFFFFFFi64;
  if ( std::streambuf::eback(a1) == a1 + 112 )
    std::streambuf::setg(a1, *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144));
  v4 = *(FILE **)(a1 + 128);
  if ( *(_QWORD *)(a1 + 104) )
  {
    *(_OWORD *)Src = 0i64;
    Size = 0i64;
    v37 = 15i64;
    LOBYTE(Src[0]) = 0;
    while ( 1 )
    {
      v7 = fgetc(v4);
      v11 = v7;
      if ( v7 == -1 )
        goto LABEL_56;
      v12 = Size;
      v13 = v37;
      if ( Size >= v37 )
      {
        if ( Size == 0x7FFFFFFFFFFFFFFFi64 )
          unknown_libname_4(v8, 0x7FFFFFFFFFFFFFFFi64, v9, v10);
        v16 = (Size + 1) | 0xF;
        if ( v16 <= 0x7FFFFFFFFFFFFFFFi64 )
        {
          v17 = v37 >> 1;
          if ( v37 <= 0x7FFFFFFFFFFFFFFFi64 - (v37 >> 1) )
          {
            if ( v16 < v37 + v17 )
              v16 = v37 + v17;
          }
          else
          {
            v16 = 0x7FFFFFFFFFFFFFFFi64;
          }
        }
        else
        {
          v16 = 0x7FFFFFFFFFFFFFFFi64;
        }
        v15 = sub_14615A5E0(v16 + 1);
        Size = v12 + 1;
        v37 = v16;
        if ( v13 <= 0xF )
        {
          memcpy(v15, Src, v12);
          *((_BYTE *)v15 + v12) = v11;
          *((_BYTE *)v15 + v12 + 1) = 0;
        }
        else
        {
          v18 = Src[0];
          memcpy(v15, Src[0], v12);
          *((_BYTE *)v15 + v12) = v11;
          *((_BYTE *)v15 + v12 + 1) = 0;
          if ( v13 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v18 - *(v18 - 1) - 8 > 0x1F )
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
            v18 = (_QWORD *)*(v18 - 1);
          }
          j_j_free(v18);
        }
        Src[0] = v15;
      }
      else
      {
        ++Size;
        v14 = Src;
        if ( v37 > 0xF )
          v14 = (void **)Src[0];
        *((_BYTE *)v14 + v12) = v11;
        *((_BYTE *)v14 + v12 + 1) = 0;
        v15 = Src[0];
      }
      v19 = Src;
      if ( v37 > 0xF )
        v19 = (void **)v15;
      v20 = Src;
      if ( v37 > 0xF )
        v20 = (void **)v15;
      v21 = std::codecvt<char,char,_Mbstatet>::in(
              *(_QWORD *)(a1 + 104),
              a1 + 116,
              v20,
              (char *)v19 + Size,
              &v33,
              &v31,
              v32,
              v34);
      if ( v21 )
      {
        v22 = v21 - 1;
        if ( v22 )
          break;
      }
      v23 = Src;
      if ( (unsigned __int8 *)v34[0] != &v31 )
      {
        if ( v37 > 0xF )
          v23 = (void **)Src[0];
        v28 = v33;
        v29 = (__int64)v23 + Size - v33;
        if ( v29 > 0 )
        {
          while ( 1 )
          {
            ungetc(*(char *)(--v29 + v28), *(FILE **)(a1 + 128));
            if ( v29 <= 0 )
              break;
            v28 = v33;
          }
        }
        v6 = v31;
        goto LABEL_57;
      }
      if ( v37 > 0xF )
        v23 = (void **)Src[0];
      v24 = v33 - (_QWORD)v23;
      if ( Size < v33 - (__int64)v23 )
        v24 = Size;
      v25 = Src;
      if ( v37 > 0xF )
        v25 = (void **)Src[0];
      v26 = Size - v24;
      memmove(v25, (char *)v25 + v24, Size - v24 + 1);
      Size = v26;
      v4 = *(FILE **)(a1 + 128);
    }
    if ( v22 != 2 )
    {
LABEL_56:
      v6 = -1;
      goto LABEL_57;
    }
    v27 = Src;
    if ( v37 > 0xF )
      v27 = (void **)Src[0];
    v6 = *(char *)v27;
LABEL_57:
    if ( v37 > 0xF )
    {
      v30 = Src[0];
      if ( v37 + 1 >= 0x1000 )
      {
        v30 = (void *)*((_QWORD *)Src[0] - 1);
        if ( (unsigned __int64)(Src[0] - v30 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v30);
    }
  }
  else
  {
    v5 = fgetc(v4);
    v6 = -1;
    if ( v5 != -1 )
      return (unsigned __int8)v5;
  }
  return v6;
}
// 146192E8A: variable 'v8' is possibly undefined
// 146192E8A: variable 'v9' is possibly undefined
// 146192E8A: variable 'v10' is possibly undefined
// 14611C428: using guessed type __int64 __fastcall std::streambuf::_Gninc(_QWORD);
// 14611C490: using guessed type __int64 __fastcall std::codecvt<char,char,_Mbstatet>::in(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 14611C4D8: using guessed type __int64 __fastcall std::streambuf::eback(_QWORD);
// 14611C4E0: using guessed type __int64 __fastcall std::streambuf::gptr(_QWORD);
// 14611C4F0: using guessed type __int64 __fastcall std::streambuf::egptr(_QWORD);
// 14611C500: using guessed type __int64 __fastcall std::streambuf::setg(_QWORD, _QWORD, _QWORD, _QWORD);
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);
// 146192AD0: using guessed type char var_6F[7];

//----- (0000000146192E90) ----------------------------------------------------
__int64 __fastcall sub_146192E90(__int64 a1)
{
  unsigned __int64 v2; // rbx
  __int64 result; // rax
  unsigned int v4; // ebx

  if ( std::streambuf::gptr(a1) )
  {
    v2 = std::streambuf::egptr(a1);
    if ( std::streambuf::gptr(a1) < v2 )
      return *(unsigned __int8 *)std::streambuf::gptr(a1);
  }
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 56i64))(a1);
  v4 = result;
  if ( (_DWORD)result != -1 )
  {
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 32i64))(a1, (unsigned int)result);
    return v4;
  }
  return result;
}
// 14611C4E0: using guessed type __int64 __fastcall std::streambuf::gptr(_QWORD);
// 14611C4F0: using guessed type __int64 __fastcall std::streambuf::egptr(_QWORD);

//----- (0000000146192F10) ----------------------------------------------------
__int64 __fastcall sub_146192F10(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 32) + 8i64))(a1 + 32);
}

//----- (0000000146192F30) ----------------------------------------------------
void __fastcall sub_146192F30(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  sub_146190570(*(void ***)(a1 + 8), a2, a3, a4);
}

//----- (0000000146192F40) ----------------------------------------------------
_QWORD *__fastcall sub_146192F40(__int64 a1, void *a2, size_t a3, __int64 a4)
{
  return sub_14618B8D0(*(_QWORD **)(a1 + 8), a2, a3, a4);
}

//----- (0000000146192F50) ----------------------------------------------------
__int64 __fastcall sub_146192F50(__int64 a1, char *a2, __int64 a3)
{
  size_t v7; // rbx
  unsigned __int64 v8; // rax
  size_t v9; // rdi
  const void *v10; // rax
  size_t v11; // rax

  if ( a3 <= 0 )
    return 0i64;
  if ( *(_QWORD *)(a1 + 104) )
    return std::streambuf::xsgetn();
  v7 = a3;
  v8 = std::streambuf::_Gnavail();
  if ( v8 )
  {
    v9 = a3;
    if ( v8 < a3 )
      v9 = v8;
    v10 = (const void *)std::streambuf::gptr(a1);
    memcpy(a2, v10, v9);
    a2 += v9;
    v7 = a3 - v9;
    std::streambuf::gbump(a1, (unsigned int)v9);
  }
  if ( *(_QWORD *)(a1 + 128) )
  {
    sub_14618B6B0(a1);
    if ( v7 <= 0xFFF )
    {
LABEL_13:
      if ( v7 )
        v7 -= fread(a2, 1ui64, v7, *(FILE **)(a1 + 128));
    }
    else
    {
      while ( 1 )
      {
        v11 = fread(a2, 1ui64, 0xFFFui64, *(FILE **)(a1 + 128));
        a2 += v11;
        v7 -= v11;
        if ( v11 != 4095 )
          break;
        if ( v7 <= 0xFFF )
          goto LABEL_13;
      }
    }
  }
  return a3 - v7;
}
// 14611C310: using guessed type __int64 std::streambuf::_Gnavail(void);
// 14611C340: using guessed type __int64 std::streambuf::xsgetn(void);
// 14611C4E0: using guessed type __int64 __fastcall std::streambuf::gptr(_QWORD);
// 14611C4F8: using guessed type __int64 __fastcall std::streambuf::gbump(_QWORD, _QWORD);

//----- (0000000146193080) ----------------------------------------------------
__int64 __fastcall sub_146193080(__int64 a1, char *a2, signed __int64 a3)
{
  signed __int64 v3; // rbx
  __int64 v8; // rax
  size_t v9; // rbp
  void *v10; // rax
  FILE *v11; // r9

  v3 = a3;
  if ( *(_QWORD *)(a1 + 104) )
    return std::streambuf::xsputn();
  v8 = std::streambuf::_Pnavail();
  v9 = v8;
  if ( v3 > 0 )
  {
    if ( v8 <= 0 )
      goto LABEL_8;
    if ( v3 < v8 )
      v9 = v3;
    v10 = (void *)std::streambuf::pptr(a1);
    memcpy(v10, a2, v9);
    v3 -= v9;
    std::streambuf::pbump(a1, (unsigned int)v9);
    a2 += v9;
    if ( v3 > 0 )
    {
LABEL_8:
      v11 = *(FILE **)(a1 + 128);
      if ( v11 )
        v3 -= fwrite(a2, 1ui64, v3, v11);
    }
  }
  return a3 - v3;
}
// 14611C318: using guessed type __int64 __fastcall std::streambuf::pbump(_QWORD, _QWORD);
// 14611C328: using guessed type __int64 std::streambuf::_Pnavail(void);
// 14611C348: using guessed type __int64 std::streambuf::xsputn(void);
// 14611C4E8: using guessed type __int64 __fastcall std::streambuf::pptr(_QWORD);

//----- (0000000146193140) ----------------------------------------------------
int sub_146193140(const char *a1, ...)
{
  FILE *v1; // rbx
  unsigned __int64 *v2; // rax
  va_list va; // [rsp+58h] [rbp+10h] BYREF

  va_start(va, a1);
  v1 = _acrt_iob_func(1u);
  v2 = (unsigned __int64 *)sub_146166290();
  return _stdio_common_vfprintf(*v2, v1, a1, 0i64, va);
}

//----- (0000000146193210) ----------------------------------------------------
__int64 __fastcall sub_146193210(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, unsigned __int8 a6)
{
  return a6;
}

//----- (0000000146193230) ----------------------------------------------------
FARPROC sub_146193230()
{
  HMODULE ModuleHandleW; // rax
  FARPROC result; // rax

  ModuleHandleW = GetModuleHandleW(L"CoreRT.dll");
  result = GetProcAddress(ModuleHandleW, "CoreSetExceptionOverride");
  if ( result )
    return (FARPROC)((__int64 (__fastcall *)(LONG (__stdcall *)(struct _EXCEPTION_POINTERS *)))result)(j_TopLevelExceptionFilter);
  return result;
}

//----- (0000000146193270) ----------------------------------------------------
__int64 __fastcall sub_146193270(char *a1, char *a2)
{
  void *v4; // rcx
  __int64 v5; // r9
  HMODULE ModuleHandleW; // rax
  __int64 v7; // rcx
  __m128i v8; // xmm6
  char *v9; // rax
  __int64 v10; // r8
  __int64 v11; // r9
  void **v12; // rax
  __int64 v13; // r8
  __int64 v14; // r9
  void *v15; // rcx
  const WCHAR *p_Block_8; // rcx
  const wchar_t *v17; // r8
  void *v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rax
  unsigned __int64 v22; // r13
  void *v23; // rcx
  const WCHAR *v24; // rcx
  __int64 v25; // r9
  const WCHAR *v26; // rcx
  __int64 v27; // r9
  const WCHAR *v28; // rcx
  __int64 v29; // r9
  const wchar_t *CommandLineW; // rax
  __int64 v31; // r9
  const wchar_t *v32; // rax
  __int64 v33; // r9
  unsigned __int64 v34; // rax
  char *v35; // r12
  const wchar_t *v36; // rdi
  int v37; // r15d
  char *v38; // rbx
  __int64 v39; // rax
  __int64 v40; // rcx
  const wchar_t *v41; // rax
  signed __int64 v42; // rsi
  wchar_t v43; // dx
  bool v44; // cf
  int v45; // eax
  __int64 v46; // rdx
  char *v47; // r8
  signed __int64 v48; // r8
  int v49; // eax
  __int64 v50; // r9
  __int128 *v51; // rdx
  void *v52; // rcx
  __int64 v53; // rcx
  unsigned __int64 v54; // rdx
  const WCHAR *v55; // rax
  __int64 v56; // r12
  unsigned __int64 v57; // rbx
  __int128 *v58; // rsi
  __int64 v59; // rcx
  __int64 v60; // rbx
  __int64 v61; // r9
  __int128 *v62; // rdx
  void *v63; // rcx
  const WCHAR *v64; // rcx
  const WCHAR *v65; // rcx
  __int64 v66; // rdx
  __int64 v67; // r8
  __int64 v68; // r9
  size_t v69; // rbx
  LPCWSTR *v70; // rax
  __int64 v71; // r12
  WCHAR *v72; // rsi
  __int64 v73; // rcx
  size_t v74; // rbx
  const WCHAR *v75; // rcx
  const WCHAR *v76; // rdx
  const WCHAR *v77; // rcx
  WCHAR *v78; // rcx
  const WCHAR *v79; // rdx
  const WCHAR *v80; // rcx
  __int64 v81; // rax
  signed __int64 v82; // r14
  wchar_t v83; // cx
  __int128 *v84; // rdx
  __int128 *v85; // rcx
  LPCWSTR *v86; // rax
  __int64 v87; // rbx
  void *v88; // rcx
  WCHAR *v89; // rcx
  char *v91; // [rsp+38h] [rbp-D0h]
  HANDLE hObject; // [rsp+40h] [rbp-C8h] BYREF
  LPCVOID lpBaseAddress; // [rsp+48h] [rbp-C0h]
  __int64 Block; // [rsp+50h] [rbp-B8h]
  __int128 Block_8; // [rsp+58h] [rbp-B0h] BYREF
  __m128i si128; // [rsp+68h] [rbp-A0h]
  __int128 v97; // [rsp+78h] [rbp-90h] BYREF
  LPCWSTR lpPathName[2]; // [rsp+88h] [rbp-80h] BYREF
  __m128i v99; // [rsp+98h] [rbp-70h]
  LPCWSTR lpFileName[2]; // [rsp+A8h] [rbp-60h] BYREF
  __m128i v101; // [rsp+B8h] [rbp-50h]
  __int128 v102; // [rsp+C8h] [rbp-40h] BYREF
  void *Src[2]; // [rsp+D8h] [rbp-30h] BYREF
  __m128i v104; // [rsp+E8h] [rbp-20h]
  void *v105[2]; // [rsp+F8h] [rbp-10h] BYREF
  __m128i v106; // [rsp+108h] [rbp+0h]
  _BYTE v107[36]; // [rsp+118h] [rbp+10h] BYREF
  _BYTE FileInformation[36]; // [rsp+140h] [rbp+38h] BYREF
  wchar_t Destination[264]; // [rsp+168h] [rbp+60h] BYREF

  Block = -2i64;
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611E150);
  strcpy((char *)&Block_8, "CfxInitState");
  BYTE13(Block_8) = 0;
  HIWORD(Block_8) = 0;
  sub_146166700((__int64)&hObject, (__int64 *)&Block_8);
  if ( si128.m128i_i64[1] > 0xFui64 )
  {
    v4 = (void *)Block_8;
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v4 = *(void **)(Block_8 - 8);
      if ( (unsigned __int64)(Block_8 - (_QWORD)v4 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v4);
  }
  si128 = _mm_load_si128((const __m128i *)&Size);
  LOBYTE(Block_8) = 0;
  if ( *((_WORD *)lpBaseAddress + 3080) )
  {
    wcscpy_s(Destination, 0x104ui64, (const wchar_t *)lpBaseAddress + 3080);
  }
  else
  {
    ModuleHandleW = GetModuleHandleW(0i64);
    GetModuleFileNameW(ModuleHandleW, Destination, 0x104u);
  }
  v7 = *((_QWORD *)a2 + 2);
  v8 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  if ( v7 )
  {
    v9 = a2;
    if ( *((_QWORD *)a2 + 3) > 7ui64 )
      v9 = *(char **)a2;
    *(_QWORD *)&v97 = v9;
    *((_QWORD *)&v97 + 1) = v7;
    *(_QWORD *)&v102 = L"CitizenFX_SubProcess_%s.bin";
    *((_QWORD *)&v102 + 1) = 27i64;
    lpFileName[0] = (LPCWSTR)13;
    lpFileName[1] = (LPCWSTR)&v97;
    sub_14616BE70(v105, &v102, (__int128 *)lpFileName);
    v12 = (void **)sub_146170F20((__int64)v107, (__int64)v105, v10, v11);
    sub_1461645B0((__int64)&Block_8, v12, v13, v14);
    if ( v106.m128i_i64[1] > 7ui64 )
    {
      v15 = v105[0];
      if ( (unsigned __int64)(2 * v106.m128i_i64[1] + 2) >= 0x1000 )
      {
        v15 = (void *)*((_QWORD *)v105[0] - 1);
        if ( (unsigned __int64)(v105[0] - v15 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v15);
    }
    v106 = v8;
    LOWORD(v105[0]) = 0;
    p_Block_8 = (const WCHAR *)&Block_8;
    if ( si128.m128i_i64[1] > 7ui64 )
      p_Block_8 = (const WCHAR *)Block_8;
    if ( GetFileAttributesW(p_Block_8) != -1 )
    {
      v17 = (const wchar_t *)&Block_8;
      if ( si128.m128i_i64[1] > 7ui64 )
        v17 = (const wchar_t *)Block_8;
      wcscpy_s(Destination, 0x104ui64, v17);
    }
    if ( si128.m128i_i64[1] > 7ui64 )
    {
      v18 = (void *)Block_8;
      if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
      {
        v18 = *(void **)(Block_8 - 8);
        if ( (unsigned __int64)(Block_8 - (_QWORD)v18 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v18);
    }
    si128 = v8;
    LOWORD(Block_8) = 0;
  }
  *(_OWORD *)v105 = 0i64;
  v106 = 0ui64;
  sub_146168F30(v105, L"data\\", 5ui64, v5);
  v21 = sub_1461645B0((__int64)&Block_8, v105, v19, v20);
  *(_OWORD *)lpPathName = 0i64;
  v99 = 0i64;
  *(_OWORD *)lpPathName = *(_OWORD *)v21;
  v99 = *(__m128i *)(v21 + 16);
  *(_QWORD *)(v21 + 16) = 0i64;
  v22 = 7i64;
  *(_QWORD *)(v21 + 24) = 7i64;
  *(_WORD *)v21 = 0;
  if ( si128.m128i_i64[1] > 7ui64 )
  {
    v23 = (void *)Block_8;
    if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
    {
      v23 = *(void **)(Block_8 - 8);
      if ( (unsigned __int64)(Block_8 - (_QWORD)v23 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v23);
  }
  si128 = v8;
  LOWORD(Block_8) = 0;
  v24 = (const WCHAR *)lpPathName;
  if ( v99.m128i_i64[1] > 7ui64 )
    v24 = lpPathName[0];
  CreateDirectoryW(v24, 0i64);
  sub_1461653F0(lpPathName, L"cache\\", 6ui64, v25);
  v26 = (const WCHAR *)lpPathName;
  if ( v99.m128i_i64[1] > 7ui64 )
    v26 = lpPathName[0];
  CreateDirectoryW(v26, 0i64);
  sub_1461653F0(lpPathName, L"subprocess\\", 0xBui64, v27);
  v28 = (const WCHAR *)lpPathName;
  if ( v99.m128i_i64[1] > 7ui64 )
    v28 = lpPathName[0];
  CreateDirectoryW(v28, 0i64);
  *(_OWORD *)Src = 0i64;
  v104 = v8;
  LOWORD(Src[0]) = 0;
  sub_14617D600(Src, L"ChanCity_", 9ui64, v29);
  CommandLineW = GetCommandLineW();
  if ( wcsstr(CommandLineW, L"cl2") )
    sub_1461653F0(Src, L"cl2_", 4ui64, v31);
  v32 = GetCommandLineW();
  if ( wcsstr(v32, L"fxdk") )
    sub_1461653F0(Src, L"fxdk_", 5ui64, v33);
  v34 = *((_QWORD *)a2 + 2);
  v35 = a2;
  if ( *((_QWORD *)a2 + 3) > 7ui64 )
    v35 = *(char **)a2;
  v36 = L"DumpServer";
  v37 = 1;
  if ( v34 < 4 )
    goto LABEL_61;
  v38 = &v35[2 * v34];
  v39 = sub_1461A7850(v35, v38, L"game", 4i64);
  if ( (char *)v39 == v38 || (unsigned __int64)(v39 - (_QWORD)v35) >= 2 )
    goto LABEL_61;
  v40 = *((_QWORD *)a2 + 2);
  if ( *((_QWORD *)a2 + 3) > 7ui64 )
    a2 = *(char **)a2;
  if ( v40 == 8 )
  {
    v41 = L"game_mtl";
    v42 = a2 - (char *)L"game_mtl";
    while ( 1 )
    {
      v43 = *(const wchar_t *)((char *)v41 + v42);
      v44 = v43 < *v41;
      if ( v43 != *v41 )
        break;
      ++v41;
      if ( !--v40 )
      {
        v45 = 0;
        goto LABEL_59;
      }
    }
    v45 = 1;
    v40 = 0xFFFFFFFFi64;
    if ( v44 )
      v45 = -1;
LABEL_59:
    LOBYTE(v40) = v45 != 0;
  }
  else
  {
    v40 = 1i64;
  }
  if ( (_BYTE)v40 )
  {
LABEL_67:
    v49 = dword_1461090C0;
    if ( dword_1461090C0 == -1 )
    {
      v49 = sub_1461A48B0(v40);
      dword_1461090C0 = v49;
    }
    if ( v49 != 2944 )
    {
      LODWORD(v97) = v49;
      v102 = v97;
      lpFileName[0] = L"b%d_";
      lpFileName[1] = (LPCWSTR)4;
      *(_QWORD *)&v97 = 1i64;
      *((_QWORD *)&v97 + 1) = &v102;
      sub_14616BE70(&Block_8, (__int128 *)lpFileName, &v97);
      v51 = &Block_8;
      if ( si128.m128i_i64[1] > 7ui64 )
        v51 = (__int128 *)Block_8;
      sub_1461653F0(Src, v51, si128.m128i_u64[0], v50);
      if ( si128.m128i_i64[1] > 7ui64 )
      {
        v52 = (void *)Block_8;
        if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
        {
          v52 = *(void **)(Block_8 - 8);
          if ( (unsigned __int64)(Block_8 - (_QWORD)v52 - 8) > 0x1F )
LABEL_91:
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v52);
      }
      si128 = v8;
      LOWORD(Block_8) = 0;
    }
  }
  else
  {
LABEL_61:
    v46 = *((_QWORD *)a1 + 2);
    v47 = a1;
    if ( *((_QWORD *)a1 + 3) > 7ui64 )
      v47 = *(char **)a1;
    if ( v46 == 10 )
    {
      v40 = (__int64)L"DumpServer";
      v48 = v47 - (char *)L"DumpServer";
      while ( *(_WORD *)(v40 + v48) == *(_WORD *)v40 )
      {
        v40 += 2i64;
        if ( !--v46 )
          goto LABEL_67;
      }
    }
  }
  v53 = v104.m128i_i64[0];
  *(_QWORD *)&v102 = v104.m128i_i64[0];
  v54 = *((_QWORD *)a1 + 2);
  *(_QWORD *)&v97 = v54;
  if ( 0x7FFFFFFFFFFFFFFEi64 - v104.m128i_i64[0] < v54 )
    unknown_libname_4(v104.m128i_i64[0], v54, 0x7FFFFFFFFFFFFFFEi64, v33);
  v55 = (const WCHAR *)Src;
  if ( v104.m128i_i64[1] > 7ui64 )
    v55 = (const WCHAR *)Src[0];
  lpFileName[0] = v55;
  v91 = a1;
  if ( *((_QWORD *)a1 + 3) > 7ui64 )
    v91 = *(char **)a1;
  Block_8 = 0i64;
  si128 = 0i64;
  v56 = v104.m128i_i64[0] + v54;
  v57 = 7i64;
  v58 = &Block_8;
  if ( v104.m128i_i64[0] + v54 > 7 )
  {
    v57 = v56 | 7;
    if ( (v56 | 7ui64) <= 0x7FFFFFFFFFFFFFFEi64 )
    {
      if ( v57 < 0xA )
        v57 = 10i64;
      v59 = v57 + 1;
      if ( v57 + 1 > 0x7FFFFFFFFFFFFFFFi64 )
        sub_146165390(v59, 0x7FFFFFFFFFFFFFFFi64, 0x7FFFFFFFFFFFFFFEi64);
    }
    else
    {
      v57 = 0x7FFFFFFFFFFFFFFEi64;
      v59 = 0x7FFFFFFFFFFFFFFFi64;
    }
    v58 = (__int128 *)sub_14615A5E0(2 * v59);
    *(_QWORD *)&Block_8 = v58;
    v53 = v102;
    v55 = lpFileName[0];
  }
  si128.m128i_i64[0] = v56;
  si128.m128i_i64[1] = v57;
  v60 = 2 * v53;
  memcpy(v58, v55, 2 * v53);
  memcpy((char *)v58 + v60, v91, 2 * v97);
  *((_WORD *)v58 + v56) = 0;
  v62 = &Block_8;
  if ( si128.m128i_i64[1] > 7ui64 )
    v62 = (__int128 *)Block_8;
  sub_1461653F0(lpPathName, v62, si128.m128i_u64[0], v61);
  if ( si128.m128i_i64[1] > 7ui64 )
  {
    v63 = (void *)Block_8;
    if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
    {
      v63 = *(void **)(Block_8 - 8);
      if ( (unsigned __int64)(Block_8 - (_QWORD)v63 - 8) > 0x1F )
        goto LABEL_91;
    }
    j_j_free(v63);
  }
  memset(FileInformation, 0, sizeof(FileInformation));
  v64 = (const WCHAR *)lpPathName;
  if ( v99.m128i_i64[1] > 7ui64 )
    v64 = lpPathName[0];
  if ( !GetFileAttributesExW(v64, GetFileExInfoStandard, FileInformation)
    || (memset(v107, 0, sizeof(v107)), !GetFileAttributesExW(Destination, GetFileExInfoStandard, v107))
    || *(_QWORD *)&v107[28] != *(_QWORD *)&FileInformation[28]
    || *(_QWORD *)&v107[20] > *(_QWORD *)&FileInformation[20] )
  {
    v65 = (const WCHAR *)lpPathName;
    if ( v99.m128i_i64[1] > 7ui64 )
      v65 = lpPathName[0];
    if ( !DeleteFileW(v65) )
    {
      v69 = v99.m128i_i64[0];
      if ( (unsigned __int64)(0x7FFFFFFFFFFFFFFEi64 - v99.m128i_i64[0]) < 4 )
        unknown_libname_4(0x7FFFFFFFFFFFFFFEi64, v66, v67, v68);
      v70 = lpPathName;
      if ( v99.m128i_i64[1] > 7ui64 )
        v70 = (LPCWSTR *)lpPathName[0];
      *(_QWORD *)&v97 = v70;
      *(_OWORD *)lpFileName = 0i64;
      v101 = 0i64;
      v71 = v99.m128i_i64[0] + 4;
      v72 = (WCHAR *)lpFileName;
      if ( (unsigned __int64)(v99.m128i_i64[0] + 4) > 7 )
      {
        v22 = v71 | 7;
        if ( (v71 | 7ui64) <= 0x7FFFFFFFFFFFFFFEi64 )
        {
          if ( v22 < 0xA )
            v22 = 10i64;
          v73 = v22 + 1;
          if ( v22 + 1 > 0x7FFFFFFFFFFFFFFFi64 )
            sub_146165390(v73, v66, v67);
        }
        else
        {
          v22 = 0x7FFFFFFFFFFFFFFEi64;
          v73 = 0x7FFFFFFFFFFFFFFFi64;
        }
        v72 = (WCHAR *)sub_14615A5E0(2 * v73);
        lpFileName[0] = v72;
        v70 = (LPCWSTR *)v97;
      }
      v101.m128i_i64[0] = v69 + 4;
      v101.m128i_i64[1] = v22;
      v74 = v69;
      memcpy(v72, v70, v74 * 2);
      *(_QWORD *)&v72[v74] = 0x64006C006F002Ei64;
      v72[v71] = 0;
      v75 = (const WCHAR *)lpFileName;
      if ( v101.m128i_i64[1] > 7ui64 )
        v75 = lpFileName[0];
      DeleteFileW(v75);
      v76 = (const WCHAR *)lpFileName;
      if ( v101.m128i_i64[1] > 7ui64 )
        v76 = lpFileName[0];
      v77 = (const WCHAR *)lpPathName;
      if ( v99.m128i_i64[1] > 7ui64 )
        v77 = lpPathName[0];
      MoveFileW(v77, v76);
      if ( v101.m128i_i64[1] > 7ui64 )
      {
        v78 = (WCHAR *)lpFileName[0];
        if ( (unsigned __int64)(2 * v101.m128i_i64[1] + 2) >= 0x1000 )
        {
          v78 = (WCHAR *)*((_QWORD *)lpFileName[0] - 1);
          if ( (unsigned __int64)((char *)lpFileName[0] - (char *)v78 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v78);
      }
      v101 = v8;
      LOWORD(lpFileName[0]) = 0;
    }
    v79 = (const WCHAR *)lpPathName;
    if ( v99.m128i_i64[1] > 7ui64 )
      v79 = lpPathName[0];
    CopyFileW(Destination, v79, 0);
  }
  v80 = (const WCHAR *)lpPathName;
  if ( v99.m128i_i64[1] > 7ui64 )
    v80 = lpPathName[0];
  if ( GetFileAttributesW(v80) == -1 )
  {
    v81 = *((_QWORD *)a1 + 2);
    if ( *((_QWORD *)a1 + 3) > 7ui64 )
      a1 = *(char **)a1;
    if ( v81 == 10 )
    {
      v82 = a1 - (char *)L"DumpServer";
      while ( 1 )
      {
        v83 = *(const wchar_t *)((char *)v36 + v82);
        if ( v83 != *v36 )
          break;
        ++v36;
        if ( !--v81 )
        {
          v37 = 0;
          goto LABEL_144;
        }
      }
      if ( v83 < *v36 )
        v37 = -1;
LABEL_144:
      LOBYTE(v37) = v37 != 0;
    }
    if ( (_BYTE)v37 )
      __debugbreak();
    *(_QWORD *)&v97 = Destination;
    v102 = v97;
    *(_QWORD *)&v97 = 12i64;
    *((_QWORD *)&v97 + 1) = &v102;
    lpFileName[0] = L"%s";
    lpFileName[1] = (LPCWSTR)2;
    v84 = &v97;
    v85 = (__int128 *)lpFileName;
  }
  else
  {
    v86 = lpPathName;
    if ( v99.m128i_i64[1] > 7ui64 )
      v86 = (LPCWSTR *)lpPathName[0];
    *(_QWORD *)&v97 = v86;
    *((_QWORD *)&v97 + 1) = v99.m128i_i64[0];
    lpFileName[0] = (LPCWSTR)13;
    lpFileName[1] = (LPCWSTR)&v97;
    *(_QWORD *)&v102 = L"%s";
    *((_QWORD *)&v102 + 1) = 2i64;
    v84 = (__int128 *)lpFileName;
    v85 = &v102;
  }
  v87 = sub_1461A30F0(v85, v84);
  if ( v104.m128i_i64[1] > 7ui64 )
  {
    v88 = Src[0];
    if ( (unsigned __int64)(2 * v104.m128i_i64[1] + 2) >= 0x1000 )
    {
      v88 = (void *)*((_QWORD *)Src[0] - 1);
      if ( (unsigned __int64)(Src[0] - v88 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v88);
  }
  v104 = v8;
  LOWORD(Src[0]) = 0;
  if ( v99.m128i_i64[1] > 7ui64 )
  {
    v89 = (WCHAR *)lpPathName[0];
    if ( (unsigned __int64)(2 * v99.m128i_i64[1] + 2) >= 0x1000 )
    {
      v89 = (WCHAR *)*((_QWORD *)lpPathName[0] - 1);
      if ( (unsigned __int64)((char *)lpPathName[0] - (char *)v89 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v89);
  }
  v99 = v8;
  LOWORD(lpPathName[0]) = 0;
  if ( lpBaseAddress && lpBaseAddress != &unk_146106050 )
    UnmapViewOfFile(lpBaseAddress);
  if ( hObject )
    CloseHandle(hObject);
  return v87;
}
// 146193403: variable 'v10' is possibly undefined
// 146193403: variable 'v11' is possibly undefined
// 146193410: variable 'v13' is possibly undefined
// 146193410: variable 'v14' is possibly undefined
// 14619352C: variable 'v5' is possibly undefined
// 14619353A: variable 'v19' is possibly undefined
// 14619353A: variable 'v20' is possibly undefined
// 1461935F3: variable 'v25' is possibly undefined
// 14619361F: variable 'v27' is possibly undefined
// 14619365B: variable 'v29' is possibly undefined
// 14619368B: variable 'v31' is possibly undefined
// 1461936BB: variable 'v33' is possibly undefined
// 146193825: variable 'v50' is possibly undefined
// 146193985: variable 'v61' is possibly undefined
// 146193E34: variable 'v66' is possibly undefined
// 146193E34: variable 'v67' is possibly undefined
// 146193E34: variable 'v68' is possibly undefined
// 1461090C0: using guessed type int dword_1461090C0;
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 14611E150: using guessed type __int128 xmmword_14611E150;
// 14612E1D0: using guessed type wchar_t aCitizenfxSubpr_0[28];
// 14612E208: using guessed type wchar_t aData[6];
// 14612E218: using guessed type wchar_t aCache[7];
// 14612E228: using guessed type wchar_t aSubprocess_0[12];
// 14612E240: using guessed type wchar_t aChancity_0[10];
// 14612E258: using guessed type wchar_t aCl2_2[5];
// 14612E268: using guessed type wchar_t aFxdk_1[6];
// 14612E278: using guessed type wchar_t aGame[5];
// 14612E288: using guessed type wchar_t aGameMtl[9];
// 14612E2A0: using guessed type wchar_t aDumpserver[11];
// 14612E2B8: using guessed type wchar_t aBD[5];
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);
// 1461A48B0: using guessed type __int64 __fastcall sub_1461A48B0(_QWORD);
// 1461A7850: using guessed type __int64 __fastcall sub_1461A7850(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146193E50) ----------------------------------------------------
__int64 sub_146193E50()
{
  return (unsigned __int8)byte_14611ABB1;
}
// 14611ABB1: using guessed type char byte_14611ABB1;
// 146193E50: using guessed type __int64 sub_146193E50();

//----- (0000000146193E60) ----------------------------------------------------
__int64 __fastcall BeforeTerminateHandler(__int64 a1)
{
  HMODULE ModuleHandleW; // rax
  FARPROC ProcAddress; // rax

  ModuleHandleW = GetModuleHandleW(L"CoreRT.dll");
  if ( ModuleHandleW )
  {
    ProcAddress = GetProcAddress(ModuleHandleW, "CoreOnProcessAbnormalTermination");
    if ( ProcAddress )
      ((void (__fastcall *)(__int64))ProcAddress)(a1);
  }
  return 0i64;
}

//----- (0000000146193EA0) ----------------------------------------------------
int EarlyInitializeExceptionHandler()
{
  int result; // eax

  if ( !byte_14611ABB0 )
  {
    sub_1461A81C0();
    dllmain_crt_dispatch((HINSTANCE)0x140000000i64, 1u, 0i64);
    return dllmain_crt_dispatch((HINSTANCE)0x140000000i64, 2u, 0i64);
  }
  return result;
}
// 14611ABB0: using guessed type char byte_14611ABB0;
// 1461A81C0: using guessed type __int64 sub_1461A81C0(void);

//----- (0000000146193EF0) ----------------------------------------------------
char InitializeExceptionHandler()
{
  char v0; // si
  const wchar_t *CommandLineW; // rax
  const wchar_t *v2; // rax
  HMODULE ModuleHandleW; // rax
  FARPROC ProcAddress; // rbx
  HANDLE CurrentProcess; // rax
  BOOL v7; // r12d
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rax
  HANDLE hProcess; // rcx
  const WCHAR *v13; // rcx
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // rax
  HANDLE v18; // rcx
  const WCHAR *v19; // rcx
  int v20; // ebx
  const WCHAR *v21; // r9
  int v22; // edi
  void *v23; // rbx
  _OWORD *v24; // rax
  __int64 v25; // rdi
  __int64 v26; // r9
  __int64 v27; // r9
  const WCHAR *v28; // r15
  void *v29; // rcx
  void *v30; // rcx
  HANDLE EventW; // r14
  void *v32; // rcx
  _DWORD *v33; // rbx
  DWORD CurrentProcessId; // eax
  struct _RTL_CRITICAL_SECTION *v35; // rbx
  __int64 v36; // r9
  struct _RTL_CRITICAL_SECTION *v37; // rax
  void *v38; // rcx
  HMODULE v39; // rax
  HMODULE v40; // rax
  LPVOID *v41; // rdi
  _BYTE *v42; // rbx
  WCHAR *v43; // rcx
  WCHAR *v44; // rcx
  uintptr_t Reserved; // [rsp+20h] [rbp-E0h]
  __int64 dwCreationFlags; // [rsp+28h] [rbp-D8h]
  DWORD flOldProtect[4]; // [rsp+50h] [rbp-B0h] BYREF
  __int128 v48; // [rsp+60h] [rbp-A0h] BYREF
  HANDLE hObject; // [rsp+70h] [rbp-90h] BYREF
  LPCVOID lpBaseAddress; // [rsp+78h] [rbp-88h]
  __int64 v51[2]; // [rsp+80h] [rbp-80h] BYREF
  struct _STARTUPINFOW StartupInfo; // [rsp+90h] [rbp-70h] BYREF
  __m256 EventAttributes; // [rsp+100h] [rbp+0h] BYREF
  void *v54[2]; // [rsp+120h] [rbp+20h] BYREF
  __m128i v55; // [rsp+130h] [rbp+30h]
  LPCWSTR lpFileName[2]; // [rsp+140h] [rbp+40h] BYREF
  __m128i v57; // [rsp+150h] [rbp+50h]
  struct _PROCESS_INFORMATION Block; // [rsp+160h] [rbp+60h] BYREF
  unsigned __int64 v59; // [rsp+178h] [rbp+78h]
  void *v60[2]; // [rsp+180h] [rbp+80h] BYREF
  __m128i si128; // [rsp+190h] [rbp+90h]
  LPCWSTR lpPathName[2]; // [rsp+1A0h] [rbp+A0h] BYREF
  __int128 v63; // [rsp+1B0h] [rbp+B0h]
  WCHAR CommandLine[2080]; // [rsp+1C0h] [rbp+C0h] BYREF

  v0 = 0;
  flOldProtect[0] = 0;
  if ( byte_14611ABB0 )
    return 0;
  byte_14611ABB0 = 1;
  CommandLineW = GetCommandLineW();
  if ( wcsstr(CommandLineW, L"-dumpserver") )
  {
    v2 = GetCommandLineW();
    wcsstr(v2, L"-parentpid:");
    return 1;
  }
  ModuleHandleW = GetModuleHandleW(L"ntdll.dll");
  ProcAddress = GetProcAddress(ModuleHandleW, "NtAllocateVirtualMemory");
  *(_QWORD *)&v48 = 0i64;
  hObject = (HANDLE)4096;
  CurrentProcess = GetCurrentProcess();
  if ( ((int (__fastcall *)(HANDLE, __int128 *, unsigned __int64, HANDLE *, int, int))ProcAddress)(
         CurrentProcess,
         &v48,
         0xFFFFFFFF80000000ui64,
         &hObject,
         12288,
         4) >= 0 )
    Destination = (char *)v48;
  v7 = IsDebuggerPresent();
  memset(&EventAttributes, 0, sizeof(EventAttributes));
  sub_146168F30(&EventAttributes, L"crashes", 7ui64, v8);
  v11 = sub_1461645B0((__int64)&Block, (void **)&EventAttributes, v9, v10);
  *(_OWORD *)lpPathName = 0i64;
  v63 = 0i64;
  *(_OWORD *)lpPathName = *(_OWORD *)v11;
  v63 = *(_OWORD *)(v11 + 16);
  *(_QWORD *)(v11 + 16) = 0i64;
  *(_QWORD *)(v11 + 24) = 7i64;
  *(_WORD *)v11 = 0;
  if ( v59 > 7 )
  {
    hProcess = Block.hProcess;
    if ( 2 * v59 + 2 >= 0x1000 )
    {
      hProcess = (HANDLE)*((_QWORD *)Block.hProcess - 1);
      if ( (unsigned __int64)(Block.hProcess - hProcess - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(hProcess);
  }
  v13 = (const WCHAR *)lpPathName;
  if ( *((_QWORD *)&v63 + 1) > 7ui64 )
    v13 = lpPathName[0];
  CreateDirectoryW(v13, 0i64);
  memset(&EventAttributes, 0, sizeof(EventAttributes));
  sub_146168F30(&EventAttributes, L"CitizenFX.ini", 0xDui64, v14);
  v17 = sub_1461645B0((__int64)&Block, (void **)&EventAttributes, v15, v16);
  *(_OWORD *)lpFileName = 0i64;
  v57 = 0i64;
  *(_OWORD *)lpFileName = *(_OWORD *)v17;
  v57 = *(__m128i *)(v17 + 16);
  *(_QWORD *)(v17 + 16) = 0i64;
  *(_QWORD *)(v17 + 24) = 7i64;
  *(_WORD *)v17 = 0;
  if ( v59 > 7 )
  {
    v18 = Block.hProcess;
    if ( 2 * v59 + 2 >= 0x1000 )
    {
      v18 = (HANDLE)*((_QWORD *)Block.hProcess - 1);
      if ( (unsigned __int64)(Block.hProcess - v18 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v18);
  }
  v19 = (const WCHAR *)lpFileName;
  v20 = 0;
  if ( v57.m128i_i64[1] > 7ui64 )
    v19 = lpFileName[0];
  if ( GetFileAttributesW(v19) != -1 )
  {
    v21 = (const WCHAR *)lpFileName;
    if ( v57.m128i_i64[1] > 7ui64 )
      v21 = lpFileName[0];
    LOBYTE(v20) = GetPrivateProfileIntW(L"Game", L"EnableFullMemoryDump", 0, v21) != 0;
  }
  v22 = 2 * v20 + 4384;
  v23 = operator new(0x370ui64);
  if ( v23 )
  {
    v24 = operator new(0x10ui64);
    if ( v24 )
      *v24 = 0i64;
    else
      v24 = 0i64;
    v25 = sub_1461A4CF0((__int64)v23, L"\\\\.\\pipe\\CitizenFX_Dump", v22, v24);
  }
  else
  {
    v25 = 0i64;
  }
  if ( sub_1461A4EE0(v25) )
    goto LABEL_63;
  *(_OWORD *)v60 = 0i64;
  si128 = 0i64;
  sub_146168F30(v60, &Default, 0i64, v26);
  *(_OWORD *)v54 = 0i64;
  v55 = 0i64;
  sub_146168F30(v54, L"DumpServer", 0xAui64, v27);
  v28 = (const WCHAR *)sub_146193270((char *)v54, (char *)v60);
  if ( v55.m128i_i64[1] > 7ui64 )
  {
    v29 = v54[0];
    if ( (unsigned __int64)(2 * v55.m128i_i64[1] + 2) >= 0x1000 )
    {
      v29 = (void *)*((_QWORD *)v54[0] - 1);
      if ( (unsigned __int64)(v54[0] - v29 - 8) > 0x1F )
LABEL_38:
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v29);
  }
  if ( si128.m128i_i64[1] > 7ui64 )
  {
    v30 = v60[0];
    if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
    {
      v30 = (void *)*((_QWORD *)v60[0] - 1);
      if ( (unsigned __int64)(v60[0] - v30 - 8) > 0x1F )
        goto LABEL_38;
    }
    j_j_free(v30);
  }
  LOWORD(v60[0]) = 0;
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  StartupInfo.cb = 104;
  *(_QWORD *)&EventAttributes.m256_f32[4] = 1i64;
  memset(&StartupInfo.cb + 1, 0, 100);
  memset(&Block, 0, sizeof(Block));
  *(_OWORD *)EventAttributes.m256_f32 = 0i64;
  EventW = CreateEventW((LPSECURITY_ATTRIBUTES)&EventAttributes, 1, 0, 0i64);
  BYTE5(v54[1]) = 0;
  HIWORD(v54[1]) = 0;
  strcpy((char *)v54, "CfxInitState");
  v55 = _mm_load_si128((const __m128i *)&xmmword_14611E150);
  sub_146166700((__int64)&hObject, (__int64 *)v54);
  if ( v55.m128i_i64[1] > 0xFui64 )
  {
    v32 = v54[0];
    if ( (unsigned __int64)(v55.m128i_i64[1] + 1) >= 0x1000 )
    {
      v32 = (void *)*((_QWORD *)v54[0] - 1);
      if ( (unsigned __int64)(v54[0] - v32 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v32);
  }
  v33 = lpBaseAddress;
  CurrentProcessId = *((_DWORD *)lpBaseAddress + 1);
  if ( !CurrentProcessId )
  {
    CurrentProcessId = GetCurrentProcessId();
    v33[1] = CurrentProcessId;
  }
  LODWORD(dwCreationFlags) = CurrentProcessId;
  LODWORD(Reserved) = (_DWORD)EventW;
  if ( (unsigned int)swprintf_0(
                       CommandLine,
                       (const wchar_t *)0x820,
                       L"\"%s\" -dumpserver:%i -parentpid:%i",
                       v28,
                       Reserved,
                       dwCreationFlags) < 0x820 )
  {
    if ( CreateProcessW(v28, CommandLine, 0i64, 0i64, 1, 0x1000000u, 0i64, 0i64, &StartupInfo, &Block) )
    {
      CloseHandle(Block.hProcess);
      CloseHandle(Block.hThread);
    }
    WaitForSingleObject(EventW, 0x1D4Cu);
    if ( !v7 && !sub_1461A4EE0(v25) )
    {
      *(_QWORD *)&v48 = 0i64;
      *((_QWORD *)&v48 + 1) = v60;
      v54[1] = (void *)41;
      v54[0] = "Could not register with breakpad server.\n";
      sub_1461A2D50(
        (__int64)"Launcher",
        (__int64)"InitializeExceptionHandler",
        (__int64)"F:\\NewBuildFivem\\LauncherGTA\\code\\client\\launcher\\MiniDump.Shared.cpp",
        0x11Fu,
        (__int128 *)v54,
        &v48);
    }
    if ( v33 && v33 != (_DWORD *)&unk_146106050 )
      UnmapViewOfFile(v33);
    if ( hObject )
      CloseHandle(hObject);
LABEL_63:
    if ( !v7 )
    {
      v35 = (struct _RTL_CRITICAL_SECTION *)operator new(0x158ui64);
      if ( v35 )
      {
        memset(&EventAttributes, 0, sizeof(EventAttributes));
        sub_146168F30(&EventAttributes, &Default, 0i64, v36);
        v37 = sub_1461A53B0(
                v35,
                (char *)&EventAttributes,
                (struct _RTL_CRITICAL_SECTION_DEBUG *)sub_1461689D0,
                (__int64)sub_146193210,
                0i64,
                7,
                v25);
        v0 = 1;
      }
      else
      {
        v37 = 0i64;
      }
      *(_QWORD *)&qword_14611ABA8 = v37;
      if ( (v0 & 1) != 0 && *(_QWORD *)&EventAttributes.m256_f32[6] > 7ui64 )
      {
        v38 = *(void **)EventAttributes.m256_f32;
        if ( (unsigned __int64)(2i64 * *(_QWORD *)&EventAttributes.m256_f32[6] + 2) >= 0x1000 )
        {
          v38 = *(void **)(*(_QWORD *)EventAttributes.m256_f32 - 8i64);
          if ( (unsigned __int64)(*(_QWORD *)EventAttributes.m256_f32 - (_QWORD)v38 - 8i64) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v38);
        v37 = *(struct _RTL_CRITICAL_SECTION **)&qword_14611ABA8;
      }
      BYTE1(v37[8].DebugInfo) = 1;
      byte_14611ABB1 = 1;
      v39 = GetModuleHandleW(L"kernelbase.dll");
      v51[0] = (__int64)GetProcAddress(v39, "SetUnhandledExceptionFilter");
      v40 = GetModuleHandleW(L"kernel32.dll");
      v51[1] = (__int64)GetProcAddress(v40, "SetUnhandledExceptionFilter");
      v41 = (LPVOID *)v51;
      do
      {
        v42 = *v41;
        if ( *v41 )
        {
          VirtualProtect(*v41, 4ui64, 0x40u, flOldProtect);
          *v42 = -61;
          VirtualProtect(v42, 4ui64, flOldProtect[0], flOldProtect);
        }
        ++v41;
      }
      while ( v41 != (LPVOID *)&StartupInfo );
    }
    goto LABEL_77;
  }
  if ( v33 && v33 != (_DWORD *)&unk_146106050 )
    UnmapViewOfFile(v33);
  if ( hObject )
    CloseHandle(hObject);
LABEL_77:
  if ( v57.m128i_i64[1] > 7ui64 )
  {
    v43 = (WCHAR *)lpFileName[0];
    if ( (unsigned __int64)(2 * v57.m128i_i64[1] + 2) >= 0x1000 )
    {
      v43 = (WCHAR *)*((_QWORD *)lpFileName[0] - 1);
      if ( (unsigned __int64)((char *)lpFileName[0] - (char *)v43 - 8) > 0x1F )
LABEL_84:
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v43);
  }
  LOWORD(lpFileName[0]) = 0;
  v57 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  if ( *((_QWORD *)&v63 + 1) > 7ui64 )
  {
    v44 = (WCHAR *)lpPathName[0];
    if ( (unsigned __int64)(2i64 * *((_QWORD *)&v63 + 1) + 2) >= 0x1000 )
    {
      v44 = (WCHAR *)*((_QWORD *)lpPathName[0] - 1);
      if ( (unsigned __int64)((char *)lpPathName[0] - (char *)v44 - 8) > 0x1F )
        goto LABEL_84;
    }
    j_j_free(v44);
  }
  return 0;
}
// 146194016: variable 'v8' is possibly undefined
// 146194023: variable 'v9' is possibly undefined
// 146194023: variable 'v10' is possibly undefined
// 1461940F3: variable 'v14' is possibly undefined
// 146194100: variable 'v15' is possibly undefined
// 146194100: variable 'v16' is possibly undefined
// 146194251: variable 'v26' is possibly undefined
// 146194276: variable 'v27' is possibly undefined
// 146194450: variable 'Reserved' is possibly undefined
// 146194450: variable 'dwCreationFlags' is possibly undefined
// 1461945C1: variable 'v36' is possibly undefined
// 14611ABB0: using guessed type char byte_14611ABB0;
// 14611ABB1: using guessed type char byte_14611ABB1;
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 14611E150: using guessed type __int128 xmmword_14611E150;
// 14612E2A0: using guessed type wchar_t aDumpserver[11];
// 14612E378: using guessed type wchar_t aCrashes[8];
// 14612E388: using guessed type wchar_t aCitizenfxIni[14];
// 14612E3E8: using guessed type wchar_t aPipeCitizenfxD[24];
// 14612E420: using guessed type wchar_t aSDumpserverIPa[34];

//----- (00000001461947E0) ----------------------------------------------------
char *__fastcall RemoteExceptionFunc(__int64 a1)
{
  const char *v1; // rax
  char *result; // rax

  if ( !Destination )
    return 0i64;
  v1 = (const char *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8i64))(a1);
  strncpy(Destination, v1, 0x1000ui64);
  result = Destination;
  Destination[4095] = 0;
  return result;
}

//----- (0000000146194830) ----------------------------------------------------
char __fastcall TerminateForException(__int64 a1)
{
  if ( *(_QWORD *)&qword_14611ABA8 )
    return sub_1461A6400(*(_QWORD **)&qword_14611ABA8, a1);
  else
    return 0;
}

//----- (0000000146194850) ----------------------------------------------------
__int64 __fastcall TryCollectCrashLog(__int64 a1)
{
  HMODULE ModuleHandleW; // rax
  FARPROC ProcAddress; // rax

  if ( a1 )
  {
    ModuleHandleW = GetModuleHandleW(L"CoreRT.dll");
    if ( ModuleHandleW )
    {
      ProcAddress = GetProcAddress(ModuleHandleW, "CoreCollectCrashLog");
      if ( ProcAddress )
        ((void (__fastcall *)(__int64))ProcAddress)(a1);
    }
  }
  return 0i64;
}

//----- (0000000146194910) ----------------------------------------------------
_QWORD *__fastcall sub_146194910(_QWORD *a1, _QWORD *Src, wchar_t *String)
{
  __int64 v3; // r15
  _QWORD *v6; // rdi
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  size_t v10; // r12
  size_t v11; // rbp
  _QWORD *v12; // r14
  unsigned __int64 v13; // rbx
  __int64 v14; // rcx

  v3 = Src[2];
  v6 = Src;
  v10 = wcslen(String);
  if ( 0x7FFFFFFFFFFFFFFEi64 - v3 < v10 )
    unknown_libname_4(v7, 0x7FFFFFFFFFFFFFFEi64 - v3, v8, v9);
  if ( v6[3] > 7ui64 )
    v6 = (_QWORD *)*v6;
  v11 = v10 + v3;
  *(_OWORD *)a1 = 0i64;
  a1[2] = 0i64;
  v12 = a1;
  a1[3] = 0i64;
  v13 = 7i64;
  if ( v10 + v3 > 7 )
  {
    v13 = v11 | 7;
    if ( (v11 | 7) <= 0x7FFFFFFFFFFFFFFEi64 )
    {
      if ( v13 < 0xA )
        v13 = 10i64;
      v14 = v13 + 1;
      if ( v13 + 1 > 0x7FFFFFFFFFFFFFFFi64 )
        sub_146165390();
    }
    else
    {
      v13 = 0x7FFFFFFFFFFFFFFEi64;
      v14 = 0x7FFFFFFFFFFFFFFFi64;
    }
    v12 = sub_14615A5E0(2 * v14);
    *a1 = v12;
  }
  a1[3] = v13;
  a1[2] = v11;
  memcpy(v12, v6, 2 * v3);
  memcpy((char *)v12 + 2 * v3, String, 2 * v10);
  *((_WORD *)v12 + v11) = 0;
  return a1;
}
// 146194A1F: variable 'v7' is possibly undefined
// 146194A1F: variable 'v8' is possibly undefined
// 146194A1F: variable 'v9' is possibly undefined
// 146165390: using guessed type void __noreturn sub_146165390(void);
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000146194A40) ----------------------------------------------------
void __fastcall sub_146194A40(__int64 *a1)
{
  __int64 v1; // rdi
  __int64 i; // rbx

  v1 = a1[1];
  for ( i = *a1; i != v1; i += 64i64 )
  {
    sub_1461626B0(i + 32);
    sub_1461626B0(i);
  }
}

//----- (0000000146194A90) ----------------------------------------------------
FARPROC sub_146194A90()
{
  HMODULE ModuleHandleW; // rax
  FARPROC result; // rax
  int v2; // [rsp+30h] [rbp+8h] BYREF

  ModuleHandleW = GetModuleHandleW(L"kernel32.dll");
  result = GetProcAddress(ModuleHandleW, "SetProcessMitigationPolicy");
  if ( result )
  {
    v2 |= 1u;
    return (FARPROC)((__int64 (__fastcall *)(__int64, int *, __int64))result)(6i64, &v2, 4i64);
  }
  return result;
}

//----- (0000000146194AE0) ----------------------------------------------------
void sub_146194AE0()
{
  void **v0; // rax
  __int64 v1; // r8
  __int64 v2; // r9
  __int64 v3; // rax
  void *v4; // rcx
  void **v5; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rax
  void *v9; // rcx
  _QWORD *v10; // rbx
  __int64 v11; // r8
  __int64 v12; // r9
  struct _WIN32_FIND_DATAW *v13; // rdi
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r15
  __m128i v17; // xmm6
  void **v18; // rdi
  void *v19; // rax
  __int64 v20; // rax
  __int64 v21; // rdx
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  _OWORD *v25; // r14
  unsigned __int64 v26; // rsi
  unsigned __int64 v27; // rbx
  __int64 v28; // rcx
  _QWORD *v29; // rax
  __int64 v30; // r9
  void **v31; // rdx
  __m128i *v32; // rax
  __int64 v33; // r8
  __int64 v34; // r9
  WCHAR *v35; // rcx
  void *v36; // rcx
  void *v37; // rcx
  void **v38; // rax
  __int64 v39; // rax
  __int64 v40; // rdx
  __int64 v41; // rcx
  __int64 v42; // r8
  __int64 v43; // r9
  _OWORD *v44; // r14
  unsigned __int64 v45; // rsi
  unsigned __int64 v46; // rbx
  __int64 v47; // rcx
  _QWORD *v48; // rax
  __int64 v49; // r9
  LPCWSTR *v50; // rdx
  __m128i *v51; // rax
  __int64 v52; // r8
  __int64 v53; // r9
  void *v54; // rcx
  void *v55; // rcx
  void *v56; // rcx
  const WCHAR *v57; // rcx
  const WCHAR *v58; // rcx
  const WCHAR *v59; // rdx
  const WCHAR *v60; // rcx
  WCHAR *v61; // rcx
  WCHAR *v62; // rcx
  void **v63; // rax
  __int64 v64; // r8
  __int64 v65; // r9
  void **v66; // rax
  __int64 v67; // r8
  __int64 v68; // r9
  const WCHAR *v69; // rax
  HANDLE FirstFileW; // rsi
  void *v71; // r8
  char *v72; // rbx
  WCHAR *v73; // rdi
  __int64 v74; // r12
  size_t v75; // rbx
  unsigned __int64 v76; // r13
  size_t v77; // rax
  __int64 v78; // rdx
  __int64 v79; // rcx
  __int64 v80; // r8
  __int64 v81; // r9
  size_t v82; // r14
  LPCWSTR *v83; // r15
  size_t v84; // rsi
  unsigned __int64 v85; // rbx
  WCHAR *v86; // rdi
  __int64 v87; // rcx
  const WCHAR *v88; // r12
  __int64 v89; // rdx
  __int64 v90; // r8
  __int64 v91; // r9
  size_t v92; // r15
  void **v93; // r14
  size_t v94; // rsi
  unsigned __int64 v95; // rbx
  WCHAR *v96; // rdi
  __int64 v97; // rcx
  const WCHAR *v98; // rcx
  WCHAR *v99; // rcx
  WCHAR *v100; // rcx
  HANDLE v101; // rsi
  WCHAR *v102; // rax
  char *v103; // rax
  size_t v104; // [rsp+38h] [rbp-D0h]
  _QWORD *v105; // [rsp+40h] [rbp-C8h] BYREF
  _QWORD *v106; // [rsp+48h] [rbp-C0h]
  _QWORD *v107; // [rsp+50h] [rbp-B8h]
  HANDLE hFindFile[2]; // [rsp+58h] [rbp-B0h] BYREF
  void **v109; // [rsp+68h] [rbp-A0h] BYREF
  _QWORD *v110; // [rsp+70h] [rbp-98h]
  __int64 *v111; // [rsp+78h] [rbp-90h]
  __int64 v112; // [rsp+88h] [rbp-80h]
  LPCWSTR lpExistingFileName[2]; // [rsp+90h] [rbp-78h] BYREF
  __m128i v114; // [rsp+A0h] [rbp-68h]
  void *Src[2]; // [rsp+B0h] [rbp-58h] BYREF
  unsigned __int64 v116; // [rsp+C0h] [rbp-48h]
  unsigned __int64 v117; // [rsp+C8h] [rbp-40h]
  LPCWSTR lpNewFileName[2]; // [rsp+D0h] [rbp-38h] BYREF
  __m128i v119; // [rsp+E0h] [rbp-28h]
  void *Block[2]; // [rsp+F0h] [rbp-18h] BYREF
  __m128i v121; // [rsp+100h] [rbp-8h]
  LPCWSTR lpFileName[2]; // [rsp+110h] [rbp+8h] BYREF
  __int64 v123; // [rsp+120h] [rbp+18h]
  unsigned __int64 v124; // [rsp+128h] [rbp+20h]
  __int64 v125[2]; // [rsp+130h] [rbp+28h] BYREF
  __m128i v126; // [rsp+140h] [rbp+38h]
  __int64 v127[3]; // [rsp+150h] [rbp+48h] BYREF
  unsigned __int64 v128; // [rsp+168h] [rbp+60h]
  __int128 v129; // [rsp+178h] [rbp+70h] BYREF
  __m128i si128; // [rsp+188h] [rbp+80h]
  __int64 v131[4]; // [rsp+198h] [rbp+90h] BYREF
  __int64 v132[4]; // [rsp+1B8h] [rbp+B0h] BYREF
  __int64 v133[4]; // [rsp+1D8h] [rbp+D0h] BYREF
  __int64 v134[4]; // [rsp+1F8h] [rbp+F0h] BYREF
  __int64 v135[4]; // [rsp+218h] [rbp+110h] BYREF
  __int64 v136[4]; // [rsp+238h] [rbp+130h] BYREF
  __int64 v137[4]; // [rsp+258h] [rbp+150h] BYREF
  __int64 v138[4]; // [rsp+278h] [rbp+170h] BYREF
  __int64 v139[4]; // [rsp+298h] [rbp+190h] BYREF
  __int64 v140[4]; // [rsp+2B8h] [rbp+1B0h] BYREF
  __int64 v141[4]; // [rsp+2D8h] [rbp+1D0h] BYREF
  __int64 v142[4]; // [rsp+2F8h] [rbp+1F0h] BYREF
  __int64 v143[4]; // [rsp+318h] [rbp+210h] BYREF
  __int64 v144[4]; // [rsp+338h] [rbp+230h] BYREF
  __int64 v145[4]; // [rsp+358h] [rbp+250h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+378h] [rbp+270h] BYREF

  v112 = -2i64;
  v0 = (void **)sub_146186230(v127, L"data/");
  v3 = sub_1461645B0((__int64)Block, v0, v1, v2);
  if ( *(_QWORD *)(v3 + 24) > 7ui64 )
    v3 = *(_QWORD *)v3;
  CreateDirectoryW((LPCWSTR)v3, 0i64);
  if ( v121.m128i_i64[1] > 7ui64 )
  {
    v4 = Block[0];
    if ( (unsigned __int64)(2 * v121.m128i_i64[1] + 2) >= 0x1000 )
    {
      v4 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v4 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v4);
  }
  v5 = (void **)sub_146186230(v127, L"data/server-cache/");
  v8 = sub_1461645B0((__int64)Block, v5, v6, v7);
  if ( *(_QWORD *)(v8 + 24) > 7ui64 )
    v8 = *(_QWORD *)v8;
  CreateDirectoryW((LPCWSTR)v8, 0i64);
  if ( v121.m128i_i64[1] > 7ui64 )
  {
    v9 = Block[0];
    if ( (unsigned __int64)(2 * v121.m128i_i64[1] + 2) >= 0x1000 )
    {
      v9 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v9 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v9);
  }
  v129 = 0i64;
  si128 = 0i64;
  *(_QWORD *)&v129 = sub_14615A5E0(0x20ui64);
  si128 = _mm_load_si128((const __m128i *)&xmmword_14612E730);
  strcpy((char *)v129, "data/game-storage/");
  sub_146178620(v131, "cache/game/");
  sub_146178620(v132, "data/server-cache-priv/");
  sub_146178620(v133, "cache/priv/");
  sub_146178620(v134, "data/server-cache-fxdk/");
  sub_146178620(v135, "cache/fxdk/");
  sub_146178620(v136, "data/nui-storage-fxdk/");
  sub_146178620(v137, "cache/browser-fxdk/");
  sub_146178620(v138, "data/nui-storage/");
  sub_146178620(v139, "cache/browser/");
  sub_146178620(v140, "data/server-cache/db/");
  sub_146178620(v141, "cache/db/");
  sub_146178620(v142, "data/ipfs/");
  sub_146178620(v143, "cache/ipfs_data/");
  sub_146178620(v144, "data/cache/");
  sub_146178620(v145, "cache/");
  v10 = sub_14615A5E0(0x200ui64);
  v105 = v10;
  v106 = v10;
  v107 = v10 + 64;
  v13 = (struct _WIN32_FIND_DATAW *)&v129;
  v109 = (void **)v10;
  v110 = v10;
  v111 = (__int64 *)&v105;
  do
  {
    hFindFile[0] = v10;
    sub_146170E60((__int64)v10, (__int64)v13, v11, v12);
    sub_146170E60((__int64)(v10 + 4), (__int64)&v13->nFileSizeLow, v14, v15);
    v10 += 8;
    v110 = v10;
    v13 = (struct _WIN32_FIND_DATAW *)((char *)v13 + 64);
  }
  while ( v13 != &FindFileData );
  v106 = v10;
  `eh vector destructor iterator'(&v129, 0x40ui64, 8ui64, (void (__fastcall *)(void *))sub_146171080);
  v16 = (__int64)v106;
  v17 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  if ( v105 != v106 )
  {
    v18 = (void **)(v105 + 4);
    do
    {
      v19 = v18;
      if ( (unsigned __int64)v18[3] > 0xF )
        v19 = *v18;
      hFindFile[0] = v19;
      hFindFile[1] = v18[2];
      v20 = sub_1461A2C60((__int64)Block, (__int64)hFindFile);
      v25 = (_OWORD *)v20;
      *(_OWORD *)Src = 0i64;
      v116 = 0i64;
      v117 = 0i64;
      v26 = *(_QWORD *)(v20 + 16);
      if ( *(_QWORD *)(v20 + 24) > 7ui64 )
        v25 = *(_OWORD **)v20;
      if ( v26 > 0x7FFFFFFFFFFFFFFEi64 )
        unknown_libname_4(v22, v21, v23, v24);
      if ( v26 > 7 )
      {
        v27 = v26 | 7;
        if ( (v26 | 7) <= 0x7FFFFFFFFFFFFFFEi64 )
        {
          if ( v27 < 0xA )
            v27 = 10i64;
          v28 = v27 + 1;
          if ( v27 + 1 > 0x7FFFFFFFFFFFFFFFi64 )
            sub_146165390(v28, v21, v23);
        }
        else
        {
          v27 = 0x7FFFFFFFFFFFFFFEi64;
          v28 = 0x7FFFFFFFFFFFFFFFi64;
        }
        Src[0] = sub_14615A5E0(2 * v28);
        v116 = v26;
        v117 = v27;
        memcpy(Src[0], v25, 2 * v26 + 2);
      }
      else
      {
        v116 = *(_QWORD *)(v20 + 16);
        v117 = 7i64;
        *(_OWORD *)Src = *v25;
      }
      v29 = (_QWORD *)sub_1461A1350((__int64)v125, v21, v23, v24);
      v31 = Src;
      if ( v117 > 7 )
        v31 = (void **)Src[0];
      v32 = (__m128i *)sub_1461653F0(v29, v31, v116, v30);
      *(__m128i *)lpExistingFileName = *v32;
      v114 = v32[1];
      v32[1].m128i_i64[0] = 0i64;
      v32[1].m128i_i64[1] = 7i64;
      v32->m128i_i16[0] = 0;
      sub_146170F20((__int64)lpFileName, (__int64)lpExistingFileName, v33, v34);
      if ( v114.m128i_i64[1] > 7ui64 )
      {
        v35 = (WCHAR *)lpExistingFileName[0];
        if ( (unsigned __int64)(2 * v114.m128i_i64[1] + 2) >= 0x1000 )
        {
          v35 = (WCHAR *)*((_QWORD *)lpExistingFileName[0] - 1);
          if ( (unsigned __int64)((char *)lpExistingFileName[0] - (char *)v35 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v35);
      }
      if ( v126.m128i_i64[1] > 7ui64 )
      {
        v36 = (void *)v125[0];
        if ( (unsigned __int64)(2 * v126.m128i_i64[1] + 2) >= 0x1000 )
        {
          v36 = *(void **)(v125[0] - 8);
          if ( (unsigned __int64)(v125[0] - (_QWORD)v36 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v36);
      }
      v126 = v17;
      LOWORD(v125[0]) = 0;
      sub_146162730((__int64)Src);
      if ( v121.m128i_i64[1] > 7ui64 )
      {
        v37 = Block[0];
        if ( (unsigned __int64)(2 * v121.m128i_i64[1] + 2) >= 0x1000 )
        {
          v37 = (void *)*((_QWORD *)Block[0] - 1);
          if ( (unsigned __int64)(Block[0] - v37 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v37);
      }
      v121 = v17;
      LOWORD(Block[0]) = 0;
      v38 = v18 - 4;
      if ( (unsigned __int64)*(v18 - 1) > 0xF )
        v38 = (void **)*v38;
      v109 = v38;
      v110 = *(v18 - 2);
      v39 = sub_1461A2C60((__int64)v127, (__int64)&v109);
      v44 = (_OWORD *)v39;
      *(_OWORD *)lpExistingFileName = 0i64;
      v114 = 0ui64;
      v45 = *(_QWORD *)(v39 + 16);
      if ( *(_QWORD *)(v39 + 24) > 7ui64 )
        v44 = *(_OWORD **)v39;
      if ( v45 > 0x7FFFFFFFFFFFFFFEi64 )
        unknown_libname_4(v41, v40, v42, v43);
      if ( v45 > 7 )
      {
        v46 = v45 | 7;
        if ( (v45 | 7) <= 0x7FFFFFFFFFFFFFFEi64 )
        {
          if ( v46 < 0xA )
            v46 = 10i64;
          v47 = v46 + 1;
          if ( v46 + 1 > 0x7FFFFFFFFFFFFFFFi64 )
            sub_146165390(v47, v40, v42);
        }
        else
        {
          v46 = 0x7FFFFFFFFFFFFFFEi64;
          v47 = 0x7FFFFFFFFFFFFFFFi64;
        }
        lpExistingFileName[0] = (LPCWSTR)sub_14615A5E0(2 * v47);
        v114.m128i_i64[0] = v45;
        v114.m128i_i64[1] = v46;
        memcpy((void *)lpExistingFileName[0], v44, 2 * v45 + 2);
      }
      else
      {
        v114.m128i_i64[0] = *(_QWORD *)(v39 + 16);
        v114.m128i_i64[1] = 7i64;
        *(_OWORD *)lpExistingFileName = *v44;
      }
      v48 = (_QWORD *)sub_1461A1350((__int64)v125, v40, v42, v43);
      v50 = lpExistingFileName;
      if ( v114.m128i_i64[1] > 7ui64 )
        v50 = (LPCWSTR *)lpExistingFileName[0];
      v51 = (__m128i *)sub_1461653F0(v48, v50, v114.m128i_u64[0], v49);
      *(__m128i *)Block = *v51;
      v121 = v51[1];
      v51[1].m128i_i64[0] = 0i64;
      v51[1].m128i_i64[1] = 7i64;
      v51->m128i_i16[0] = 0;
      sub_146170F20((__int64)lpNewFileName, (__int64)Block, v52, v53);
      if ( v121.m128i_i64[1] > 7ui64 )
      {
        v54 = Block[0];
        if ( (unsigned __int64)(2 * v121.m128i_i64[1] + 2) >= 0x1000 )
        {
          v54 = (void *)*((_QWORD *)Block[0] - 1);
          if ( (unsigned __int64)(Block[0] - v54 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v54);
      }
      if ( v126.m128i_i64[1] > 7ui64 )
      {
        v55 = (void *)v125[0];
        if ( (unsigned __int64)(2 * v126.m128i_i64[1] + 2) >= 0x1000 )
        {
          v55 = *(void **)(v125[0] - 8);
          if ( (unsigned __int64)(v125[0] - (_QWORD)v55 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v55);
      }
      v126 = v17;
      LOWORD(v125[0]) = 0;
      sub_146162730((__int64)lpExistingFileName);
      if ( v128 > 7 )
      {
        v56 = (void *)v127[0];
        if ( 2 * v128 + 2 >= 0x1000 )
        {
          v56 = *(void **)(v127[0] - 8);
          if ( (unsigned __int64)(v127[0] - (_QWORD)v56 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v56);
      }
      v57 = (const WCHAR *)lpFileName;
      if ( v124 > 7 )
        v57 = lpFileName[0];
      if ( GetFileAttributesW(v57) != -1 )
      {
        v58 = (const WCHAR *)lpNewFileName;
        if ( v119.m128i_i64[1] > 7ui64 )
          v58 = lpNewFileName[0];
        if ( GetFileAttributesW(v58) == -1 )
        {
          v59 = (const WCHAR *)lpNewFileName;
          if ( v119.m128i_i64[1] > 7ui64 )
            v59 = lpNewFileName[0];
          v60 = (const WCHAR *)lpFileName;
          if ( v124 > 7 )
            v60 = lpFileName[0];
          MoveFileW(v60, v59);
        }
      }
      if ( v119.m128i_i64[1] > 7ui64 )
      {
        v61 = (WCHAR *)lpNewFileName[0];
        if ( (unsigned __int64)(2 * v119.m128i_i64[1] + 2) >= 0x1000 )
        {
          v61 = (WCHAR *)*((_QWORD *)lpNewFileName[0] - 1);
          if ( (unsigned __int64)((char *)lpNewFileName[0] - (char *)v61 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v61);
      }
      v119 = v17;
      LOWORD(lpNewFileName[0]) = 0;
      if ( v124 > 7 )
      {
        v62 = (WCHAR *)lpFileName[0];
        if ( 2 * v124 + 2 >= 0x1000 )
        {
          v62 = (WCHAR *)*((_QWORD *)lpFileName[0] - 1);
          if ( (unsigned __int64)((char *)lpFileName[0] - (char *)v62 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v62);
      }
      v18 += 8;
    }
    while ( v18 - 4 != (void **)v16 );
  }
  v63 = (void **)sub_146186230(v127, L"data/cache/");
  sub_1461645B0((__int64)Src, v63, v64, v65);
  v66 = (void **)sub_146186230(v125, L"data/server-cache/");
  sub_1461645B0((__int64)lpFileName, v66, v67, v68);
  v69 = (const WCHAR *)sub_146194910(Block, Src, (wchar_t *)L"cache_*");
  if ( *((_QWORD *)v69 + 3) > 7ui64 )
    v69 = *(const WCHAR **)v69;
  FirstFileW = FindFirstFileW(v69, &FindFileData);
  hFindFile[0] = FirstFileW;
  if ( v121.m128i_i64[1] > 7ui64 )
  {
    v71 = Block[0];
    if ( (unsigned __int64)(2 * v121.m128i_i64[1] + 2) >= 0x1000 )
    {
      v71 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v71 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v71);
  }
  v121 = v17;
  LOWORD(Block[0]) = 0;
  v72 = (char *)Src[0];
  v73 = (WCHAR *)lpFileName[0];
  if ( FirstFileW != (HANDLE)-1i64 )
  {
    v74 = v123;
    v75 = 0x7FFFFFFFFFFFFFFEi64 - v123;
    v104 = 0x7FFFFFFFFFFFFFFEi64 - v123;
    v76 = v116;
    while ( 1 )
    {
      v77 = wcslen(FindFileData.cFileName);
      v82 = v77;
      if ( v75 < v77 )
        unknown_libname_4(v79, v78, v80, v81);
      v83 = lpFileName;
      if ( v124 > 7 )
        v83 = (LPCWSTR *)v73;
      *(_OWORD *)lpNewFileName = 0i64;
      v119 = 0i64;
      v84 = v77 + v74;
      v85 = 7i64;
      v86 = (WCHAR *)lpNewFileName;
      if ( v77 + v74 > 7 )
      {
        v85 = v84 | 7;
        if ( (v84 | 7) <= 0x7FFFFFFFFFFFFFFEi64 )
        {
          if ( v85 < 0xA )
            v85 = 10i64;
          v87 = v85 + 1;
          if ( v85 + 1 > 0x7FFFFFFFFFFFFFFFi64 )
            sub_146165390(v87, v78, v80);
        }
        else
        {
          v85 = 0x7FFFFFFFFFFFFFFEi64;
          v87 = 0x7FFFFFFFFFFFFFFFi64;
        }
        v86 = (WCHAR *)sub_14615A5E0(2 * v87);
        lpNewFileName[0] = v86;
      }
      v119.m128i_i64[0] = v84;
      v119.m128i_i64[1] = v85;
      memcpy(v86, v83, 2 * v74);
      memcpy(&v86[v74], FindFileData.cFileName, 2 * v82);
      v86[v84] = 0;
      v88 = (const WCHAR *)lpNewFileName;
      if ( v119.m128i_i64[1] > 7ui64 )
        v88 = lpNewFileName[0];
      v92 = wcslen(FindFileData.cFileName);
      if ( 0x7FFFFFFFFFFFFFFEi64 - v76 < v92 )
        unknown_libname_4(0x7FFFFFFFFFFFFFFEi64 - v76, v89, v90, v91);
      v93 = Src;
      if ( v117 > 7 )
        v93 = (void **)Src[0];
      *(_OWORD *)lpExistingFileName = 0i64;
      v114 = 0i64;
      v94 = v92 + v76;
      v95 = 7i64;
      v96 = (WCHAR *)lpExistingFileName;
      if ( v92 + v76 > 7 )
      {
        v95 = v94 | 7;
        if ( (v94 | 7) <= 0x7FFFFFFFFFFFFFFEi64 )
        {
          if ( v95 < 0xA )
            v95 = 10i64;
          v97 = v95 + 1;
          if ( v95 + 1 > 0x7FFFFFFFFFFFFFFFi64 )
            sub_146165390(v97, v89, v90);
        }
        else
        {
          v95 = 0x7FFFFFFFFFFFFFFEi64;
          v97 = 0x7FFFFFFFFFFFFFFFi64;
        }
        v96 = (WCHAR *)sub_14615A5E0(2 * v97);
        lpExistingFileName[0] = v96;
      }
      v114.m128i_i64[0] = v92 + v76;
      v114.m128i_i64[1] = v95;
      memcpy(v96, v93, 2 * v76);
      memcpy(&v96[v76], FindFileData.cFileName, 2 * v92);
      v96[v94] = 0;
      v98 = (const WCHAR *)lpExistingFileName;
      if ( v114.m128i_i64[1] > 7ui64 )
        v98 = lpExistingFileName[0];
      MoveFileW(v98, v88);
      if ( v114.m128i_i64[1] > 7ui64 )
      {
        v99 = (WCHAR *)lpExistingFileName[0];
        if ( (unsigned __int64)(2 * v114.m128i_i64[1] + 2) >= 0x1000 )
        {
          v99 = (WCHAR *)*((_QWORD *)lpExistingFileName[0] - 1);
          if ( (unsigned __int64)((char *)lpExistingFileName[0] - (char *)v99 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v99);
      }
      v114 = v17;
      LOWORD(lpExistingFileName[0]) = 0;
      if ( v119.m128i_i64[1] > 7ui64 )
      {
        v100 = (WCHAR *)lpNewFileName[0];
        if ( (unsigned __int64)(2 * v119.m128i_i64[1] + 2) >= 0x1000 )
        {
          v100 = (WCHAR *)*((_QWORD *)lpNewFileName[0] - 1);
          if ( (unsigned __int64)((char *)lpNewFileName[0] - (char *)v100 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v100);
      }
      v101 = hFindFile[0];
      if ( !FindNextFileW(hFindFile[0], &FindFileData) )
        break;
      v73 = (WCHAR *)lpFileName[0];
      v74 = v123;
      v75 = v104;
    }
    FindClose(v101);
    v72 = (char *)Src[0];
    v73 = (WCHAR *)lpFileName[0];
  }
  if ( v124 > 7 )
  {
    v102 = v73;
    if ( 2 * v124 + 2 >= 0x1000 )
    {
      v73 = (WCHAR *)*((_QWORD *)v73 - 1);
      if ( (unsigned __int64)((char *)v102 - (char *)v73 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v73);
  }
  if ( v117 > 7 )
  {
    v103 = v72;
    if ( 2 * v117 + 2 >= 0x1000 )
    {
      v72 = (char *)*((_QWORD *)v72 - 1);
      if ( (unsigned __int64)(v103 - v72 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v72);
  }
  sub_146195910((__int64 *)&v105);
}
// 146194B3D: variable 'v1' is possibly undefined
// 146194B3D: variable 'v2' is possibly undefined
// 146194BC0: variable 'v6' is possibly undefined
// 146194BC0: variable 'v7' is possibly undefined
// 146194E0B: variable 'v11' is possibly undefined
// 146194E0B: variable 'v12' is possibly undefined
// 146194E19: variable 'v14' is possibly undefined
// 146194E19: variable 'v15' is possibly undefined
// 146194F62: variable 'v21' is possibly undefined
// 146194F62: variable 'v23' is possibly undefined
// 146194F62: variable 'v24' is possibly undefined
// 146194F7D: variable 'v30' is possibly undefined
// 146194FA9: variable 'v33' is possibly undefined
// 146194FA9: variable 'v34' is possibly undefined
// 146195170: variable 'v40' is possibly undefined
// 146195170: variable 'v42' is possibly undefined
// 146195170: variable 'v43' is possibly undefined
// 14619518B: variable 'v49' is possibly undefined
// 1461951B7: variable 'v52' is possibly undefined
// 1461951B7: variable 'v53' is possibly undefined
// 146195398: variable 'v64' is possibly undefined
// 146195398: variable 'v65' is possibly undefined
// 1461953B5: variable 'v67' is possibly undefined
// 1461953B5: variable 'v68' is possibly undefined
// 1461958D5: variable 'v79' is possibly undefined
// 1461958D5: variable 'v78' is possibly undefined
// 1461958D5: variable 'v80' is possibly undefined
// 1461958D5: variable 'v81' is possibly undefined
// 1461958E1: variable 'v41' is possibly undefined
// 1461958ED: variable 'v22' is possibly undefined
// 1461958F9: variable 'v89' is possibly undefined
// 1461958F9: variable 'v90' is possibly undefined
// 1461958FF: variable 'v91' is possibly undefined
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 14612E590: using guessed type wchar_t aData_0[6];
// 14612E5A0: using guessed type wchar_t aDataServerCach[19];
// 14612E700: using guessed type wchar_t aDataCache_0[12];
// 14612E730: using guessed type __int128 xmmword_14612E730;
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);
// 146194AE0: using guessed type __int64 var_470[4];
// 146194AE0: using guessed type __int64 var_450[4];
// 146194AE0: using guessed type __int64 var_430[4];
// 146194AE0: using guessed type __int64 var_410[4];
// 146194AE0: using guessed type __int64 var_3F0[4];
// 146194AE0: using guessed type __int64 var_3D0[4];
// 146194AE0: using guessed type __int64 var_3B0[4];
// 146194AE0: using guessed type __int64 var_390[4];
// 146194AE0: using guessed type __int64 var_370[4];
// 146194AE0: using guessed type __int64 var_350[4];
// 146194AE0: using guessed type __int64 var_330[4];
// 146194AE0: using guessed type __int64 var_310[4];
// 146194AE0: using guessed type __int64 var_2F0[4];
// 146194AE0: using guessed type __int64 var_2D0[4];
// 146194AE0: using guessed type __int64 var_2B0[4];

//----- (0000000146195910) ----------------------------------------------------
void __fastcall sub_146195910(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 i; // rsi
  _QWORD *v4; // rcx

  v1 = *a1;
  if ( *a1 )
  {
    for ( i = a1[1]; v1 != i; v1 += 64i64 )
    {
      sub_1461626B0(v1 + 32);
      sub_1461626B0(v1);
    }
    v4 = (_QWORD *)*a1;
    if ( ((a1[2] - *a1) & 0xFFFFFFFFFFFFFFC0ui64) >= 0x1000 )
    {
      if ( (unsigned __int64)v4 - *(v4 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v4 = (_QWORD *)*(v4 - 1);
    }
    j_j_free(v4);
    *a1 = 0i64;
    a1[1] = 0i64;
    a1[2] = 0i64;
  }
}

//----- (00000001461959C0) ----------------------------------------------------
__int64 __fastcall sub_1461959C0(_BYTE *a1, int *a2)
{
  __int64 v2; // rax
  int *v3; // r14
  unsigned int v4; // ebp
  __int64 v7; // rdi
  unsigned int v8; // eax
  __int64 v10; // rax
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // ecx
  int v25; // ecx
  int v26; // edx

  v2 = (unsigned int)a2[26];
  v3 = a2 + 10;
  v4 = 0;
  v7 = v2 + 1;
  *((_BYTE *)a2 + v2 + 40) = 0x80;
  if ( (unsigned __int64)(v2 + 1) > 0x38 )
  {
    memset((char *)v3 + v7, 0, 64 - v7);
    v7 = 0i64;
    sub_146147500(a2, (unsigned int *)v3, 1i64);
  }
  memset((char *)v3 + v7, 0, 56 - v7);
  *((_BYTE *)v3 + 56) = *((_BYTE *)a2 + 39);
  *((_BYTE *)v3 + 57) = *((_BYTE *)a2 + 38);
  *((_BYTE *)v3 + 58) = *((_BYTE *)a2 + 37);
  *((_BYTE *)v3 + 59) = *((_BYTE *)a2 + 36);
  *((_BYTE *)v3 + 60) = *((_BYTE *)a2 + 35);
  *((_BYTE *)v3 + 61) = *((_BYTE *)a2 + 34);
  *((_BYTE *)v3 + 62) = *((_BYTE *)a2 + 33);
  *((_BYTE *)v3 + 63) = *((_BYTE *)a2 + 32);
  sub_146147500(a2, (unsigned int *)v3, 1i64);
  a2[26] = 0;
  sub_146147240(v3, 0x40ui64);
  v8 = a2[27];
  if ( v8 == 28 )
  {
    v20 = *a2;
    *a1 = HIBYTE(*a2);
    a1[3] = v20;
    a1[1] = BYTE2(v20);
    a1[2] = BYTE1(v20);
    v21 = a2[1];
    a1[4] = HIBYTE(v21);
    a1[5] = BYTE2(v21);
    a1[6] = BYTE1(v21);
    a1[7] = v21;
    v22 = a2[2];
    a1[8] = HIBYTE(v22);
    a1[9] = BYTE2(v22);
    a1[10] = BYTE1(v22);
    a1[11] = v22;
    v23 = a2[3];
    a1[12] = HIBYTE(v23);
    a1[13] = BYTE2(v23);
    a1[14] = BYTE1(v23);
    a1[15] = v23;
    v24 = a2[4];
    a1[16] = HIBYTE(v24);
    a1[17] = BYTE2(v24);
    a1[18] = BYTE1(v24);
    a1[19] = v24;
    v25 = a2[5];
    a1[20] = HIBYTE(v25);
    a1[21] = BYTE2(v25);
    a1[22] = BYTE1(v25);
    a1[23] = v25;
    v26 = a2[6];
    a1[24] = HIBYTE(v26);
    a1[25] = BYTE2(v26);
    a1[26] = BYTE1(v26);
    a1[27] = v26;
  }
  else if ( v8 == 32 )
  {
    v12 = *a2;
    *a1 = HIBYTE(*a2);
    a1[1] = BYTE2(v12);
    a1[2] = BYTE1(v12);
    a1[3] = v12;
    v13 = a2[1];
    a1[4] = HIBYTE(v13);
    a1[5] = BYTE2(v13);
    a1[6] = BYTE1(v13);
    a1[7] = v13;
    v14 = a2[2];
    a1[8] = HIBYTE(v14);
    a1[9] = BYTE2(v14);
    a1[10] = BYTE1(v14);
    a1[11] = v14;
    v15 = a2[3];
    a1[12] = HIBYTE(v15);
    a1[13] = BYTE2(v15);
    a1[14] = BYTE1(v15);
    a1[15] = v15;
    v16 = a2[4];
    a1[16] = HIBYTE(v16);
    a1[17] = BYTE2(v16);
    a1[18] = BYTE1(v16);
    a1[19] = v16;
    v17 = a2[5];
    a1[20] = HIBYTE(v17);
    a1[21] = BYTE2(v17);
    a1[22] = BYTE1(v17);
    a1[23] = v17;
    v18 = a2[6];
    a1[24] = HIBYTE(v18);
    a1[25] = BYTE2(v18);
    a1[26] = BYTE1(v18);
    a1[27] = v18;
    v19 = a2[7];
    a1[28] = HIBYTE(v19);
    a1[29] = BYTE2(v19);
    a1[30] = BYTE1(v19);
    a1[31] = v19;
  }
  else
  {
    if ( v8 > 0x20 )
      return 0i64;
    if ( (v8 & 0xFFFFFFFC) != 0 )
    {
      do
      {
        v10 = v4;
        a1 += 4;
        ++v4;
        v11 = a2[v10];
        *(a1 - 4) = HIBYTE(v11);
        *(a1 - 3) = BYTE2(v11);
        *(a1 - 2) = BYTE1(v11);
        *(a1 - 1) = v11;
      }
      while ( v4 < (unsigned int)a2[27] >> 2 );
    }
  }
  return 1i64;
}

//----- (0000000146195CE0) ----------------------------------------------------
__int64 __fastcall sub_146195CE0(__int64 a1)
{
  __int64 result; // rax

  *(_OWORD *)(a1 + 32) = 0i64;
  *(_OWORD *)(a1 + 48) = 0i64;
  *(_OWORD *)(a1 + 64) = 0i64;
  *(_OWORD *)(a1 + 80) = 0i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  *(_DWORD *)(a1 + 104) = 0;
  result = 1i64;
  *(_DWORD *)a1 = 1779033703;
  *(_DWORD *)(a1 + 4) = -1150833019;
  *(_DWORD *)(a1 + 8) = 1013904242;
  *(_DWORD *)(a1 + 12) = -1521486534;
  *(_DWORD *)(a1 + 16) = 1359893119;
  *(_DWORD *)(a1 + 20) = -1694144372;
  *(_DWORD *)(a1 + 24) = 528734635;
  *(_DWORD *)(a1 + 28) = 1541459225;
  *(_DWORD *)(a1 + 108) = 32;
  return result;
}

//----- (0000000146195D40) ----------------------------------------------------
__int64 __fastcall sub_146195D40(_DWORD *a1, char *a2, size_t a3)
{
  size_t v3; // rdi
  unsigned int v6; // eax
  unsigned int v7; // edx
  _DWORD *v8; // rsi
  __int64 v9; // rdx
  unsigned int *v10; // r15
  _DWORD *v11; // r12
  __int64 v12; // rbx
  size_t v13; // rbx

  v3 = a3;
  if ( a3 )
  {
    v6 = a1[8];
    v7 = v6 + 8 * a3;
    if ( v7 < v6 )
      ++a1[9];
    v8 = a1 + 26;
    a1[8] = v7;
    v9 = (unsigned int)a1[26];
    v10 = a1 + 10;
    v11 = a1 + 26;
    a1[9] += a3 >> 29;
    if ( v9 )
    {
      if ( a3 < 0x40 )
      {
        if ( v9 + a3 < 0x40 )
        {
          memcpy((char *)v10 + v9, a2, a3);
          *v8 += v3;
          return 1i64;
        }
        v11 = a1 + 26;
      }
      v12 = 64 - v9;
      memcpy((char *)v10 + v9, a2, 64 - v9);
      sub_146147500(a1, v10, 1i64);
      *v8 = 0;
      *(_OWORD *)v10 = 0i64;
      a2 += v12;
      *((_OWORD *)v10 + 1) = 0i64;
      v3 -= v12;
      *((_OWORD *)v10 + 2) = 0i64;
      *((_OWORD *)v10 + 3) = 0i64;
    }
    if ( v3 >> 6 )
    {
      sub_146147500(a1, (unsigned int *)a2, v3 >> 6);
      v13 = v3 >> 6 << 6;
      v8 = v11;
      a2 += v13;
      v3 -= v13;
    }
    if ( v3 )
    {
      *v8 = v3;
      memcpy(v10, a2, v3);
    }
  }
  return 1i64;
}

//----- (0000000146195E70) ----------------------------------------------------
void sub_146195E70()
{
  WCHAR *v0; // rdi
  WCHAR v1; // bx
  __int64 v2; // rbp
  __int64 v3; // rcx
  unsigned __int64 v4; // rsi
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  WCHAR v7; // ax
  WCHAR v8; // bx
  __int64 v9; // rax

  if ( !dword_14611AC70 )
  {
    v0 = &Buffer;
    dword_14611AC70 = 1;
    if ( GetEnvironmentVariableW(L"OPENSSL_ia32cap", &Buffer, 0x30u) - 1 > 0x2E )
    {
      v4 = sub_146147030((__int64)&qword_14611B450);
    }
    else
    {
      v1 = Buffer;
      v2 = 0i64;
      v3 = 0i64;
      if ( Buffer == 126 )
        v3 = 2i64;
      v4 = sub_146196000((WCHAR *)((char *)&Buffer + v3));
      if ( v1 == 126 )
      {
        v5 = ~v4 & sub_146147030((__int64)&qword_14611B450);
        v6 = v4 & 0x1000000;
        v4 = v5 & 0xEDFFF7FDFFFFFFFFui64;
        if ( !v6 )
          v4 = v5;
      }
      else if ( Buffer == 58 )
      {
        v4 = sub_146147030((__int64)&qword_14611B450);
      }
      v7 = Buffer;
      if ( Buffer )
      {
        while ( 1 )
        {
          ++v0;
          if ( v7 == 58 )
            break;
          v7 = *v0;
          if ( !*v0 )
            goto LABEL_14;
        }
        v8 = *v0;
        if ( *v0 == 126 )
          v2 = 1i64;
        v9 = sub_146196000(&v0[v2]);
        if ( v8 == 126 )
          qword_14611B458 &= ~v9;
        else
          qword_14611B458 = v9;
      }
      else
      {
LABEL_14:
        qword_14611B458 = 0i64;
      }
    }
    qword_14611B450 = v4 | 0x400;
  }
}
// 14611AC70: using guessed type int dword_14611AC70;
// 14611B450: using guessed type __int64 qword_14611B450;
// 14611B458: using guessed type __int64 qword_14611B458;

//----- (0000000146196000) ----------------------------------------------------
__int64 __fastcall sub_146196000(unsigned __int16 *a1)
{
  __int64 v1; // rsi
  unsigned __int16 *v2; // rbx
  unsigned int v3; // ebp
  unsigned int v4; // edi
  unsigned int v5; // eax

  v1 = 0i64;
  v2 = a1;
  v3 = 10;
  if ( *a1 == 48 )
  {
    v2 = a1 + 1;
    v3 = 8;
    if ( (unsigned int)sub_1461960E0(a1[1]) == 120 )
    {
      v3 = 16;
      ++v2;
    }
  }
  while ( 1 )
  {
    v4 = *v2;
    if ( sub_1461960C0(v4, 4u) )
      v5 = v4 - 48;
    else
      v5 = sub_1461960C0(v4, 0x10u) ? sub_1461960E0(v4) - 87 : 16;
    ++v2;
    if ( v5 >= v3 )
      break;
    v1 = v1 * v3 + v5;
  }
  return v1;
}

//----- (00000001461960C0) ----------------------------------------------------
_BOOL8 __fastcall sub_1461960C0(unsigned int a1, unsigned __int16 a2)
{
  return a1 <= 0x7F && (aHhhhh[a1] & a2) != 0;
}
// 14612E760: using guessed type wchar_t aHhhhh[32];

//----- (00000001461960E0) ----------------------------------------------------
__int64 __fastcall sub_1461960E0(unsigned int a1)
{
  if ( a1 <= 0x7F && (aHhhhh[2 * a1] & 2) != 0 )
    return a1 ^ 0x20;
  else
    return a1;
}
// 14612E760: using guessed type _BYTE aHhhhh[256];

//----- (0000000146196120) ----------------------------------------------------
__int64 __fastcall sub_146196120(double a1, int a2, __int64 a3, _QWORD *a4)
{
  char v4; // r12
  size_t v6; // r14
  __int64 v8; // rbx
  void *v9; // rcx
  char v11; // r15
  double v12; // xmm0_8
  unsigned __int64 v13; // rbx
  __int64 v14; // rbx
  __m128i v15; // xmm6
  __int64 v16; // rcx
  int v17; // edi
  __int64 v18; // r8
  int i; // edi
  unsigned __int64 v20; // r8
  int v21; // edi
  unsigned __int64 v22; // r10
  __int64 v23; // rcx
  int v24; // kr00_4
  __int64 v25; // rbx
  unsigned __int64 v26; // rdx
  unsigned __int64 v27; // r8
  unsigned __int64 v28; // r11
  unsigned __int64 v29; // rdx
  unsigned __int64 v30; // rdx
  unsigned int v31; // eax
  unsigned __int64 v32; // rdx
  _BYTE *v33; // rcx
  __int128 v34; // [rsp+30h] [rbp-50h] BYREF
  __int64 v35; // [rsp+40h] [rbp-40h] BYREF
  unsigned int v36; // [rsp+48h] [rbp-38h]
  unsigned int v37; // [rsp+4Ch] [rbp-34h]
  int v38; // [rsp+50h] [rbp-30h]
  char v39; // [rsp+54h] [rbp-2Ch]
  __int64 v40; // [rsp+B0h] [rbp+30h] BYREF
  unsigned int v41; // [rsp+C0h] [rbp+40h] BYREF

  v4 = *(_BYTE *)(a3 + 4);
  v6 = a2;
  LOBYTE(v40) = v4 == 2;
  if ( a1 > 0.0 )
  {
    v11 = *(_BYTE *)(a3 + 12);
    if ( (v11 & 8) == 0 )
    {
      v34 = *(_OWORD *)a3;
      return sub_146199D60(a1, a2, (__int64)&v34, (__int64)a4);
    }
    if ( a2 >= 0 )
    {
      v41 = 0;
      v16 = (*(_QWORD *)&a1 >> 52) & 0x7FFi64;
      v17 = v16;
      if ( ((*(_QWORD *)&a1 >> 52) & 0x7FF) == 0 )
        v17 = 1;
      v18 = (*(_QWORD *)&a1 & 0xFFFFFFFFFFFFFi64) + 0x10000000000000i64;
      if ( !(_DWORD)v16 )
        v18 = *(_QWORD *)&a1 & 0xFFFFFFFFFFFFFi64;
      for ( i = v17 - 1075; (v18 & 0x10000000000000i64) == 0; --i )
        v18 *= 2i64;
      v20 = v18 << 11;
      v21 = i - 11;
      v36 = 0;
      v22 = HIDWORD(v20);
      v23 = (unsigned int)v20;
      v24 = ((unsigned __int64)(1292913986i64 * (-61 - v21) + 0xFFFFFFFFi64) >> 32) + 347;
      v25 = v24 / 8;
      v26 = (unsigned int)v20 * (unsigned __int64)(unsigned int)qword_14612EEE8[v25];
      v27 = HIDWORD(v20) * (unsigned int)qword_14612EEE8[v25];
      v28 = (unsigned __int64)(v23 * HIDWORD(qword_14612EEE8[v25])) >> 32;
      v29 = (unsigned int)(v23 * HIDWORD(qword_14612EEE8[v25])) + (unsigned int)v27 + HIDWORD(v26) + 0x80000000;
      LODWORD(v23) = v21 + word_14612F1A2[v25] + 64;
      v30 = v22 * HIDWORD(qword_14612EEE8[v25]) + HIDWORD(v29);
      v35 = a4[1];
      DWORD2(v34) = v23;
      *(_QWORD *)&v34 = v28 + HIDWORD(v27) + v30;
      v31 = 767;
      if ( (int)v6 <= 767 )
        v31 = v6;
      v37 = v31;
      v38 = 340 - 8 * (v24 / 8);
      v39 = v40;
      if ( (unsigned int)sub_146198880((unsigned __int64 *)&v34, 1ui64, (int *)&v41, (__int64)&v35) == 2 )
      {
        v41 = v41 - 1 + v36 - (8 * (v24 / 8) - 340);
        sub_146197040(a1, v37, (v11 & 4) != 0, (__int64)a4, &v41);
        LODWORD(v14) = v41;
      }
      else
      {
        LODWORD(v14) = v38 + v41;
        sub_1461A0990((__int64)a4, v36);
      }
      if ( v4 != 2 && (v11 & 0x10) == 0 )
      {
        v32 = a4[2];
        if ( v32 )
        {
          v33 = (_BYTE *)(v32 + a4[1] - 1i64);
          do
          {
            if ( *v33 != 48 )
              break;
            --v33;
            LODWORD(v14) = v14 + 1;
            --v32;
          }
          while ( v32 );
        }
        sub_1461A0990((__int64)a4, v32);
      }
    }
    else
    {
      if ( (v11 & 4) == 0 )
      {
        v15 = *(__m128i *)sub_14619A920((__int64)&v34, a1);
        sub_14619CAB0(&v40, a4, v15.m128i_u64[0]);
        return (unsigned int)_mm_cvtsi128_si32(_mm_srli_si128(v15, 8));
      }
      HIDWORD(v12) = 0;
      *(float *)&v12 = a1;
      v13 = sub_14619A530(v12);
      sub_14619C9B0(&v40, a4, v13);
      return HIDWORD(v13);
    }
    return (unsigned int)v14;
  }
  else if ( a2 > 0 && v4 == 2 )
  {
    v8 = (unsigned int)a2;
    if ( (unsigned __int64)(unsigned int)a2 > a4[3] )
      (*(void (__fastcall **)(_QWORD *, _QWORD))*a4)(a4, (unsigned int)a2);
    v9 = (void *)a4[1];
    if ( (unsigned __int64)(unsigned int)v6 > a4[3] )
      v8 = a4[3];
    a4[2] = v8;
    memset(v9, 48, v6);
    return (unsigned int)-(int)v6;
  }
  else
  {
    if ( (unsigned __int64)(a4[2] + 1i64) > a4[3] )
      (*(void (__fastcall **)(_QWORD *))*a4)(a4);
    *(_BYTE *)(a4[1] + a4[2]++) = 48;
    return 0i64;
  }
}
// 14612EEE8: using guessed type __int64 qword_14612EEE8[87];
// 14612F1A2: using guessed type __int16 word_14612F1A2[87];

//----- (0000000146196480) ----------------------------------------------------
void __noreturn sub_146196480()
{
  const char *pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v1; // [rsp+30h] [rbp-38h]
  void **v2; // [rsp+40h] [rbp-28h] BYREF
  __int128 v3; // [rsp+48h] [rbp-20h]

  v2 = &std::exception::`vftable';
  v3 = 0i64;
  pExceptionObject = "precision is not integer";
  v1 = 1;
  _std_exception_copy(&pExceptionObject);
  v2 = &fmt::v8::format_error::`vftable';
  sub_146162440((__int64)&pExceptionObject, (__int64)&v2);
  CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 146196480: using guessed type void __noreturn sub_146196480();
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146196500) ----------------------------------------------------
void __noreturn sub_146196500()
{
  const char *pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v1; // [rsp+30h] [rbp-38h]
  void **v2; // [rsp+40h] [rbp-28h] BYREF
  __int128 v3; // [rsp+48h] [rbp-20h]

  v2 = &std::exception::`vftable';
  v3 = 0i64;
  pExceptionObject = "width is not integer";
  v1 = 1;
  _std_exception_copy(&pExceptionObject);
  v2 = &fmt::v8::format_error::`vftable';
  sub_146162440((__int64)&pExceptionObject, (__int64)&v2);
  CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 146196500: using guessed type void __noreturn sub_146196500();
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146196580) ----------------------------------------------------
__int64 __fastcall sub_146196580(__int64 a1, unsigned int a2)
{
  unsigned __int64 v2; // r10
  unsigned int v3; // edi
  __int64 v4; // r11
  unsigned __int64 v6; // r9
  _DWORD *v7; // r8
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rdx

  v2 = *(_QWORD *)(a1 + 16);
  v3 = 0;
  v4 = a2;
  v6 = 0i64;
  if ( v2 )
  {
    do
    {
      v7 = (_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v6++);
      v8 = v3 + v4 * (unsigned int)*v7;
      *v7 = v8;
      v9 = HIDWORD(v8);
      v3 = v9;
    }
    while ( v6 < v2 );
    if ( (_DWORD)v9 )
    {
      if ( (unsigned __int64)(*(_QWORD *)(a1 + 16) + 1i64) > *(_QWORD *)(a1 + 24) )
        (**(void (__fastcall ***)(__int64))a1)(a1);
      *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4i64 * (*(_QWORD *)(a1 + 16))++) = v3;
    }
  }
  return a1;
}

//----- (0000000146196600) ----------------------------------------------------
__int64 __fastcall sub_146196600(char *a1, __int64 a2, const _Cvtvec *a3)
{
  const char *v4; // rbp
  size_t v5; // rax
  __int64 v6; // rbx
  const char *v7; // rsi
  size_t v8; // r15
  size_t v9; // rdi
  int v10; // eax
  size_t v11; // rbx
  wchar_t *v12; // rax
  __int64 v13; // rsi
  wchar_t *i; // rdi
  int v15; // eax
  __int64 result; // rax
  mbstate_t v17; // [rsp+30h] [rbp-38h] BYREF
  wchar_t v18; // [rsp+70h] [rbp+8h] BYREF
  mbstate_t v19; // [rsp+88h] [rbp+20h] BYREF

  v19 = 0i64;
  v4 = a1;
  v5 = strlen(a1);
  v6 = 0i64;
  v7 = v4;
  v8 = v5 + 1;
  v9 = v5 + 1;
  if ( v5 != -1i64 )
  {
    do
    {
      v10 = Mbrtowc(&v18, v7, v9, &v19, a3);
      if ( v10 <= 0 )
        break;
      ++v6;
      v7 += v10;
      v9 -= v10;
    }
    while ( v9 );
  }
  v11 = v6 + 1;
  v12 = (wchar_t *)calloc(v11, 2ui64);
  v13 = (__int64)v12;
  if ( !v12 )
  {
    std::_Xbad_alloc();
    JUMPOUT(0x1461966F1i64);
  }
  v17 = 0i64;
  for ( i = v12; v11; --v11 )
  {
    v15 = Mbrtowc(i, v4, v8, &v17, a3);
    if ( v15 <= 0 )
      break;
    ++i;
    v4 += v15;
  }
  result = v13;
  *i = 0;
  return result;
}
// 1461966EC: control flows out of bounds to 1461966F1

//----- (0000000146196700) ----------------------------------------------------
__int64 __fastcall sub_146196700(__int64 a1)
{
  __int64 v1; // rdi
  struct std::locale::_Locimp *v2; // rbx
  char v3; // si
  void (__fastcall ***v4)(_QWORD, __int64); // rax
  void (__fastcall ***v5)(_QWORD, __int64); // rax
  std::locale::facet *v6; // rax
  unsigned __int8 v7; // di
  void (__fastcall ***v8)(_QWORD, __int64); // rax
  char v10[8]; // [rsp+28h] [rbp-20h] BYREF
  __int64 v11; // [rsp+30h] [rbp-18h]

  if ( a1 )
  {
    v1 = *(_QWORD *)(a1 + 8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v1 + 8i64))(v1);
    v2 = (struct std::locale::_Locimp *)v1;
    v11 = v1;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v1 + 8i64))(v1);
    v3 = 5;
  }
  else
  {
    v2 = std::locale::_Init(1);
    v11 = (__int64)v2;
    (*(void (__fastcall **)(struct std::locale::_Locimp *))(*(_QWORD *)v2 + 8i64))(v2);
    v3 = 4;
    if ( v2 )
    {
      v4 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(struct std::locale::_Locimp *))(*(_QWORD *)v2 + 16i64))(v2);
      if ( v4 )
        (**v4)(v4, 1i64);
    }
    v1 = v11;
  }
  if ( (v3 & 1) != 0 )
  {
    if ( v1 )
    {
      v5 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 16i64))(v1);
      if ( v5 )
        (**v5)(v5, 1i64);
    }
  }
  v6 = sub_14619AD00((__int64)v10);
  v7 = (*(__int64 (__fastcall **)(std::locale::facet *))(*(_QWORD *)v6 + 24i64))(v6);
  v8 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(struct std::locale::_Locimp *))(*(_QWORD *)v2 + 16i64))(v2);
  if ( v8 )
    (**v8)(v8, 1i64);
  return v7;
}
// 146196700: using guessed type char var_20[8];

//----- (0000000146196810) ----------------------------------------------------
__int64 __fastcall sub_146196810(__int64 a1)
{
  __int64 v1; // rdi
  struct std::locale::_Locimp *v2; // rbx
  char v3; // si
  void (__fastcall ***v4)(_QWORD, __int64); // rax
  void (__fastcall ***v5)(_QWORD, __int64); // rax
  __int64 v6; // rax
  unsigned __int16 v7; // di
  void (__fastcall ***v8)(_QWORD, __int64); // rax
  char v10[8]; // [rsp+28h] [rbp-20h] BYREF
  __int64 v11; // [rsp+30h] [rbp-18h]

  if ( a1 )
  {
    v1 = *(_QWORD *)(a1 + 8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v1 + 8i64))(v1);
    v2 = (struct std::locale::_Locimp *)v1;
    v11 = v1;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v1 + 8i64))(v1);
    v3 = 5;
  }
  else
  {
    v2 = std::locale::_Init(1);
    v11 = (__int64)v2;
    (*(void (__fastcall **)(struct std::locale::_Locimp *))(*(_QWORD *)v2 + 8i64))(v2);
    v3 = 4;
    if ( v2 )
    {
      v4 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(struct std::locale::_Locimp *))(*(_QWORD *)v2 + 16i64))(v2);
      if ( v4 )
        (**v4)(v4, 1i64);
    }
    v1 = v11;
  }
  if ( (v3 & 1) != 0 )
  {
    if ( v1 )
    {
      v5 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 16i64))(v1);
      if ( v5 )
        (**v5)(v5, 1i64);
    }
  }
  v6 = sub_14619AEC0((__int64)v10);
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 24i64))(v6);
  v8 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(struct std::locale::_Locimp *))(*(_QWORD *)v2 + 16i64))(v2);
  if ( v8 )
    (**v8)(v8, 1i64);
  return v7;
}
// 146196810: using guessed type char var_20[8];

//----- (0000000146196920) ----------------------------------------------------
char *__fastcall sub_146196920(const char *a1, char *a2, __int64 a3)
{
  unsigned __int64 v6; // r9
  unsigned int v7; // ebx
  const char *v8; // rdx
  const char *v9; // r8
  __int64 v10; // r11
  const char *v11; // rdi
  __int64 v12; // rcx
  __int64 v13; // rcx
  char *v14; // rbx
  char v15; // al
  int v16; // eax
  const char *pExceptionObject; // [rsp+30h] [rbp-48h] BYREF
  __int64 v19; // [rsp+38h] [rbp-40h]
  void **v20; // [rsp+50h] [rbp-28h] BYREF
  __int128 v21; // [rsp+58h] [rbp-20h]

  v6 = *(unsigned __int8 *)a1;
  if ( (unsigned __int8)(v6 - 48) <= 9u )
  {
    v7 = 0;
    if ( (_BYTE)v6 == 48 )
    {
      v11 = a1 + 1;
    }
    else
    {
      v8 = a1;
      do
      {
        v9 = v8;
        v10 = v7;
        v7 = (char)v6 + 2 * (5 * v7 - 24);
        if ( ++v8 == a2 )
          break;
        LOBYTE(v6) = *v8;
        if ( *v8 < 48 )
          break;
      }
      while ( (char)v6 <= 57 );
      v11 = v8;
      if ( v8 - a1 > 9 && (v8 - a1 != 10 || (unsigned __int64)(unsigned int)(*v9 - 48) + 10 * v10 > 0x7FFFFFFF) )
        v7 = 0x7FFFFFFF;
    }
    if ( v11 != a2 && (*v11 == 125 || *v11 == 58) )
    {
      sub_14619F410(*(_QWORD *)a3);
      *(_DWORD *)(a3 + 8) = v7;
      return (char *)v11;
    }
    v12 = *(_QWORD *)a3;
LABEL_31:
    sub_14619FE20(v12, (__int64)"invalid format string");
  }
  LOBYTE(v6) = v6 - 65;
  if ( (unsigned __int8)v6 > 0x39u || (v13 = 0x3FFFFFF43FFFFFFi64, !_bittest64(&v13, v6)) )
  {
    v12 = *(_QWORD *)a3;
    goto LABEL_31;
  }
  v14 = (char *)a1;
  do
  {
    if ( ++v14 == a2 )
      break;
    v15 = *v14;
  }
  while ( *v14 >= 97 && v15 <= 122 || v15 >= 65 && v15 <= 90 || v15 == 95 || v15 >= 48 && v15 <= 57 );
  pExceptionObject = a1;
  v19 = v14 - a1;
  v16 = sub_1461987B0((_QWORD *)(*(_QWORD *)a3 + 32i64), (__int64)&pExceptionObject);
  if ( v16 < 0 )
  {
    v20 = &std::exception::`vftable';
    v21 = 0i64;
    pExceptionObject = "argument not found";
    LOBYTE(v19) = 1;
    _std_exception_copy(&pExceptionObject);
    v20 = &fmt::v8::format_error::`vftable';
    sub_146162440((__int64)&pExceptionObject, (__int64)&v20);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  *(_DWORD *)(a3 + 8) = v16;
  return v14;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146196B00) ----------------------------------------------------
char *__fastcall sub_146196B00(char *a1, char *a2, __int64 *a3)
{
  unsigned __int64 v6; // r9
  int v7; // ebx
  char *v8; // rdx
  char *v9; // r8
  __int64 v10; // r11
  char *v11; // rsi
  _QWORD *v12; // rdi
  __int64 v13; // r8
  __int64 v14; // rdx
  __int64 v15; // rax
  int v16; // edx
  __int64 v17; // rcx
  char *v18; // rdi
  char v19; // al
  __int64 v20; // rbx
  __int64 v21; // rax
  __int128 v23; // [rsp+30h] [rbp-21h]
  __int128 v24; // [rsp+48h] [rbp-9h] BYREF
  _BYTE v25[24]; // [rsp+58h] [rbp+7h] BYREF
  __int128 pExceptionObject; // [rsp+78h] [rbp+27h] BYREF
  __int64 v27; // [rsp+88h] [rbp+37h]
  char v28; // [rsp+B8h] [rbp+67h] BYREF

  v6 = (unsigned __int8)*a1;
  if ( (unsigned __int8)(v6 - 48) <= 9u )
  {
    v7 = 0;
    if ( (_BYTE)v6 == 48 )
    {
      v11 = a1 + 1;
    }
    else
    {
      v8 = a1;
      do
      {
        v9 = v8;
        v10 = (unsigned int)v7;
        v7 = (char)v6 + 2 * (5 * v7 - 24);
        if ( ++v8 == a2 )
          break;
        LOBYTE(v6) = *v8;
        if ( *v8 < 48 )
          break;
      }
      while ( (char)v6 <= 57 );
      v11 = v8;
      if ( v8 - a1 > 9 && (v8 - a1 != 10 || (unsigned __int64)(unsigned int)(*v9 - 48) + 10 * v10 > 0x7FFFFFFF) )
        v7 = 0x7FFFFFFF;
    }
    if ( v11 != a2 && (*v11 == 125 || *v11 == 58) )
    {
      v12 = (_QWORD *)*a3;
      sub_14619F410(*(_QWORD *)(*a3 + 8));
      v13 = v12[2];
      LODWORD(v27) = 0;
      v14 = *(_QWORD *)(v13 + 8);
      if ( v14 >= 0 )
      {
        if ( v7 >= 15 )
          goto LABEL_36;
        v16 = ((unsigned __int64)v14 >> (4 * (unsigned __int8)v7)) & 0xF;
        LODWORD(v27) = v16;
        if ( !v16 )
          goto LABEL_36;
        v23 = *(_OWORD *)(*(_QWORD *)(v13 + 16) + 16i64 * v7);
      }
      else
      {
        if ( v7 >= (int)v14 )
          goto LABEL_36;
        v15 = *(_QWORD *)(v13 + 16);
        v23 = *(_OWORD *)(v15 + 24i64 * v7);
        v27 = *(_QWORD *)(v15 + 24i64 * v7 + 16);
        v16 = v27;
      }
      if ( v16 )
      {
        *(_OWORD *)v25 = v23;
        *(_QWORD *)&v25[16] = v27;
        *(_DWORD *)(*v12 + 4i64) = sub_146198650((unsigned int *)v25, 0);
        return v11;
      }
LABEL_36:
      *(_QWORD *)v25 = &std::exception::`vftable';
      *(_OWORD *)&v25[8] = 0i64;
      *(_QWORD *)&v24 = "argument not found";
      BYTE8(v24) = 1;
      _std_exception_copy(&v24);
      *(_QWORD *)v25 = &fmt::v8::format_error::`vftable';
      v28 = 1;
      sub_146162440((__int64)&pExceptionObject, (__int64)v25);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    }
LABEL_35:
    sub_14619FE20((__int64)&v28, (__int64)"invalid format string");
  }
  LOBYTE(v6) = v6 - 65;
  if ( (unsigned __int8)v6 > 0x39u )
    goto LABEL_35;
  v17 = 0x3FFFFFF43FFFFFFi64;
  if ( !_bittest64(&v17, v6) )
    goto LABEL_35;
  v18 = a1;
  do
  {
    if ( ++v18 == a2 )
      break;
    v19 = *v18;
  }
  while ( *v18 >= 97 && v19 <= 122 || v19 >= 65 && v19 <= 90 || v19 == 95 || v19 >= 48 && v19 <= 57 );
  v20 = *a3;
  *(_QWORD *)&v24 = a1;
  *((_QWORD *)&v24 + 1) = v18 - a1;
  v21 = sub_14619FA10(v20, (__int64)v25, &v24);
  pExceptionObject = *(_OWORD *)v21;
  v27 = *(_QWORD *)(v21 + 16);
  *(_DWORD *)(*(_QWORD *)v20 + 4i64) = sub_146198650((unsigned int *)&pExceptionObject, 0);
  return v18;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146196DA0) ----------------------------------------------------
char *__fastcall sub_146196DA0(char *a1, char *a2, __int64 *a3)
{
  unsigned __int64 v6; // r9
  int v7; // ebx
  char *v8; // rdx
  char *v9; // r8
  __int64 v10; // r11
  char *v11; // rsi
  __int64 v12; // rdi
  __int64 v13; // r8
  __int64 v14; // rdx
  __int64 v15; // rax
  int v16; // edx
  __int64 v17; // rcx
  char *v18; // rdi
  char v19; // al
  _DWORD **v20; // rbx
  __int64 v21; // rax
  __int128 v23; // [rsp+30h] [rbp-21h]
  __int128 v24; // [rsp+48h] [rbp-9h] BYREF
  _BYTE v25[24]; // [rsp+58h] [rbp+7h] BYREF
  __int128 pExceptionObject; // [rsp+78h] [rbp+27h] BYREF
  __int64 v27; // [rsp+88h] [rbp+37h]
  char v28; // [rsp+B8h] [rbp+67h] BYREF

  v6 = (unsigned __int8)*a1;
  if ( (unsigned __int8)(v6 - 48) <= 9u )
  {
    v7 = 0;
    if ( (_BYTE)v6 == 48 )
    {
      v11 = a1 + 1;
    }
    else
    {
      v8 = a1;
      do
      {
        v9 = v8;
        v10 = (unsigned int)v7;
        v7 = (char)v6 + 2 * (5 * v7 - 24);
        if ( ++v8 == a2 )
          break;
        LOBYTE(v6) = *v8;
        if ( *v8 < 48 )
          break;
      }
      while ( (char)v6 <= 57 );
      v11 = v8;
      if ( v8 - a1 > 9 && (v8 - a1 != 10 || (unsigned __int64)(unsigned int)(*v9 - 48) + 10 * v10 > 0x7FFFFFFF) )
        v7 = 0x7FFFFFFF;
    }
    if ( v11 != a2 && (*v11 == 125 || *v11 == 58) )
    {
      v12 = *a3;
      sub_14619F410(*(_QWORD *)(*a3 + 8));
      v13 = *(_QWORD *)(v12 + 16);
      LODWORD(v27) = 0;
      v14 = *(_QWORD *)(v13 + 8);
      if ( v14 >= 0 )
      {
        if ( v7 >= 15 )
          goto LABEL_36;
        v16 = ((unsigned __int64)v14 >> (4 * (unsigned __int8)v7)) & 0xF;
        LODWORD(v27) = v16;
        if ( !v16 )
          goto LABEL_36;
        v23 = *(_OWORD *)(*(_QWORD *)(v13 + 16) + 16i64 * v7);
      }
      else
      {
        if ( v7 >= (int)v14 )
          goto LABEL_36;
        v15 = *(_QWORD *)(v13 + 16);
        v23 = *(_OWORD *)(v15 + 24i64 * v7);
        v27 = *(_QWORD *)(v15 + 24i64 * v7 + 16);
        v16 = v27;
      }
      if ( v16 )
      {
        *(_OWORD *)v25 = v23;
        *(_QWORD *)&v25[16] = v27;
        **(_DWORD **)v12 = sub_146198700((unsigned int *)v25, 0);
        return v11;
      }
LABEL_36:
      *(_QWORD *)v25 = &std::exception::`vftable';
      *(_OWORD *)&v25[8] = 0i64;
      *(_QWORD *)&v24 = "argument not found";
      BYTE8(v24) = 1;
      _std_exception_copy(&v24);
      *(_QWORD *)v25 = &fmt::v8::format_error::`vftable';
      v28 = 1;
      sub_146162440((__int64)&pExceptionObject, (__int64)v25);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    }
LABEL_35:
    sub_14619FE20((__int64)&v28, (__int64)"invalid format string");
  }
  LOBYTE(v6) = v6 - 65;
  if ( (unsigned __int8)v6 > 0x39u )
    goto LABEL_35;
  v17 = 0x3FFFFFF43FFFFFFi64;
  if ( !_bittest64(&v17, v6) )
    goto LABEL_35;
  v18 = a1;
  do
  {
    if ( ++v18 == a2 )
      break;
    v19 = *v18;
  }
  while ( *v18 >= 97 && v19 <= 122 || v19 >= 65 && v19 <= 90 || v19 == 95 || v19 >= 48 && v19 <= 57 );
  v20 = (_DWORD **)*a3;
  *(_QWORD *)&v24 = a1;
  *((_QWORD *)&v24 + 1) = v18 - a1;
  v21 = sub_14619FA10((__int64)v20, (__int64)v25, &v24);
  pExceptionObject = *(_OWORD *)v21;
  v27 = *(_QWORD *)(v21 + 16);
  **v20 = sub_146198700((unsigned int *)&pExceptionObject, 0);
  return v18;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146197040) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_146197040(double a1, unsigned int a2, char a3, __int64 a4, _DWORD *a5)
{
  unsigned int v5; // r14d
  char *v6; // rax
  unsigned int v7; // ecx
  unsigned __int64 v8; // r8
  __int64 v9; // rcx
  int v10; // r9d
  int v11; // edx
  int v12; // r15d
  __int64 v13; // r9
  int v14; // r9d
  int v15; // r13d
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // rdi
  unsigned __int64 v18; // rax
  bool v19; // cc
  int v20; // r13d
  int v21; // r15d
  int v22; // r10d
  int v23; // ebx
  unsigned __int64 v24; // rax
  int v25; // r11d
  int v26; // ebx
  unsigned __int64 v27; // rax
  unsigned __int64 v28; // r9
  int v29; // eax
  int v30; // r11d
  int v31; // ebx
  _DWORD *v32; // r13
  unsigned __int64 v33; // r9
  unsigned __int64 v34; // r10
  unsigned __int64 v35; // r8
  unsigned int v36; // ebx
  unsigned __int64 v37; // rdx
  unsigned __int64 v38; // rdi
  unsigned __int64 v39; // rcx
  __int64 v40; // rax
  unsigned __int64 v41; // rdi
  unsigned __int64 v42; // rcx
  __int64 v43; // rax
  __int64 v44; // r15
  unsigned __int64 v45; // rbx
  unsigned __int64 v46; // rdi
  unsigned __int64 v47; // r11
  unsigned __int64 v48; // r10
  __int64 v49; // rdx
  unsigned __int64 v50; // rax
  int v51; // r13d
  int v52; // r10d
  int v53; // ebx
  void ***v54; // rax
  void ***v55; // rcx
  unsigned int v56; // esi
  int *v57; // r13
  int v58; // edi
  int v59; // r11d
  unsigned __int64 v60; // rdi
  unsigned __int64 v61; // rax
  bool v62; // cc
  int v63; // r10d
  unsigned __int64 v64; // r11
  int v65; // ebx
  unsigned __int64 v66; // rcx
  unsigned __int64 v67; // rcx
  __int64 v68; // rcx
  __int64 v69; // rdx
  int v70; // r10d
  unsigned int v71; // r8d
  unsigned int v72; // r11d
  int v73; // ebx
  __int64 v74; // r8
  int v75; // r13d
  int v76; // ecx
  int v77; // esi
  int v78; // eax
  unsigned __int64 v79; // r10
  int *v80; // rcx
  int *v81; // rax
  int v82; // edx
  __int64 v83; // r9
  unsigned int v84; // r8d
  unsigned __int64 v85; // r9
  __int64 v86; // rcx
  unsigned __int64 v87; // r10
  int v88; // ecx
  unsigned __int64 v89; // rbx
  unsigned __int64 v90; // r9
  unsigned __int64 v91; // r8
  unsigned __int64 v92; // rbx
  unsigned __int64 v93; // rcx
  unsigned __int64 v94; // rbx
  unsigned __int64 v95; // r9
  unsigned __int64 v96; // r8
  unsigned __int64 v97; // rbx
  __int64 v98; // rcx
  int v99; // eax
  __int64 v100; // rbx
  bool v101; // cc
  unsigned __int64 v102; // rax
  unsigned __int64 v103; // r10
  unsigned __int64 v104; // r9
  unsigned __int64 v105; // rdx
  unsigned __int64 v106; // rdx
  __int64 v107; // rbx
  __int64 v108; // rdi
  __int64 i; // rsi
  unsigned __int64 v110; // rbx
  unsigned __int64 v111; // r9
  unsigned __int64 v112; // r8
  unsigned __int64 v113; // rbx
  unsigned __int64 v114; // rcx
  int v115; // ebx
  int v116; // eax
  __int64 v117; // rax
  _BYTE *v118; // rax
  int v119; // [rsp+20h] [rbp-E0h]
  int v120; // [rsp+20h] [rbp-E0h]
  void ***v121; // [rsp+28h] [rbp-D8h]
  char v122; // [rsp+28h] [rbp-D8h]
  int v123; // [rsp+30h] [rbp-D0h]
  unsigned int v124; // [rsp+30h] [rbp-D0h]
  char v126; // [rsp+48h] [rbp-B8h]
  BOOL v127; // [rsp+48h] [rbp-B8h]
  __int64 v128; // [rsp+50h] [rbp-B0h]
  _BYTE *v130; // [rsp+60h] [rbp-A0h]
  _BYTE *v131; // [rsp+68h] [rbp-98h]
  void ***v132; // [rsp+70h] [rbp-90h]
  void **v133; // [rsp+80h] [rbp-80h] BYREF
  void *Src; // [rsp+88h] [rbp-78h]
  unsigned __int64 v135; // [rsp+90h] [rbp-70h]
  unsigned __int64 v136; // [rsp+98h] [rbp-68h]
  char v137[136]; // [rsp+A0h] [rbp-60h] BYREF
  int v138; // [rsp+128h] [rbp+28h] BYREF
  void **v139; // [rsp+130h] [rbp+30h] BYREF
  char *v140; // [rsp+138h] [rbp+38h]
  unsigned __int64 v141; // [rsp+140h] [rbp+40h]
  unsigned __int64 v142; // [rsp+148h] [rbp+48h]
  char v143; // [rsp+150h] [rbp+50h] BYREF
  int v144; // [rsp+1D8h] [rbp+D8h] BYREF
  void **v145; // [rsp+1E0h] [rbp+E0h] BYREF
  void *v146; // [rsp+1E8h] [rbp+E8h]
  __int64 v147; // [rsp+1F0h] [rbp+F0h]
  unsigned __int64 v148; // [rsp+1F8h] [rbp+F8h]
  char v149; // [rsp+200h] [rbp+100h] BYREF
  int v150; // [rsp+288h] [rbp+188h]
  void **v151; // [rsp+290h] [rbp+190h] BYREF
  void *v152; // [rsp+298h] [rbp+198h]
  unsigned __int64 v153; // [rsp+2A0h] [rbp+1A0h]
  unsigned __int64 v154; // [rsp+2A8h] [rbp+1A8h]
  char v155; // [rsp+2B0h] [rbp+1B0h] BYREF
  int v156; // [rsp+338h] [rbp+238h]

  v5 = 0;
  v135 = 0i64;
  v133 = &fmt::v8::basic_memory_buffer<unsigned int,32,std::allocator<unsigned int>>::`vftable';
  v6 = v137;
  Src = v137;
  v136 = 32i64;
  v138 = 0;
  v141 = 0i64;
  v139 = &fmt::v8::basic_memory_buffer<unsigned int,32,std::allocator<unsigned int>>::`vftable';
  v140 = &v143;
  v142 = 32i64;
  v144 = 0;
  v147 = 0i64;
  v145 = &fmt::v8::basic_memory_buffer<unsigned int,32,std::allocator<unsigned int>>::`vftable';
  v146 = &v149;
  v148 = 32i64;
  v150 = 0;
  v153 = 0i64;
  v151 = &fmt::v8::basic_memory_buffer<unsigned int,32,std::allocator<unsigned int>>::`vftable';
  v152 = &v155;
  v154 = 32i64;
  v156 = 0;
  v121 = 0i64;
  if ( a3 )
  {
    *(float *)&a1 = a1;
    v7 = _mm_cvtsi128_si32(*(__m128i *)&a1);
    v8 = v7 & 0x7FFFFF;
    LODWORD(v9) = v7 >> 23;
    v10 = v9;
    if ( v8 || (unsigned int)v9 <= 1 )
    {
      v11 = 0;
      if ( !(_DWORD)v9 )
        v10 = 1;
      v12 = v10 - 150;
      v13 = v8 + 0x800000;
    }
    else
    {
      v11 = 1;
      v12 = v9 - 150;
      v13 = 0x800000i64;
    }
  }
  else
  {
    v9 = (*(_QWORD *)&a1 >> 52) & 0x7FFi64;
    v8 = *(_QWORD *)&a1 & 0xFFFFFFFFFFFFFi64;
    if ( (*(_QWORD *)&a1 & 0xFFFFFFFFFFFFFi64) != 0 || (unsigned int)v9 <= 1 )
    {
      v11 = 0;
      if ( (_DWORD)v9 )
      {
        v14 = (*(_QWORD *)&a1 >> 52) & 0x7FF;
      }
      else
      {
        v14 = 1;
        v11 = 0;
      }
    }
    else
    {
      v11 = 1;
      v14 = (*(_QWORD *)&a1 >> 52) & 0x7FF;
    }
    v12 = v14 - 1075;
    v13 = v8 + 0x10000000000000i64;
  }
  if ( !(_DWORD)v9 )
    v13 = v8;
  v126 = v13;
  v119 = v12;
  v15 = v11 + 1;
  v123 = v11 + 1;
  v16 = v13 << ((unsigned __int8)v11 + 1);
  if ( v12 >= 0 )
  {
    v17 = 0i64;
    while ( 1 )
    {
      *(_DWORD *)&v6[4 * v17++] = v16;
      v16 >>= 32;
      if ( !v16 )
        break;
      v6 = (char *)Src;
    }
    v18 = v136;
    v19 = v17 <= v136;
    if ( v17 > v136 )
    {
      if ( *v133 == sub_14619FC90 )
        sub_14619FC90(&v133, v17);
      else
        ((void (__fastcall *)(void ***, unsigned __int64))*v133)(&v133, v17);
      v18 = v136;
      v19 = v17 <= v136;
    }
    if ( !v19 )
      v17 = v18;
    v135 = v17;
    v20 = v12 / 32;
    v21 = v12 % 32;
    v138 = v20;
    if ( v21 )
    {
      v22 = 0;
      v8 = 0i64;
      if ( v17 )
      {
        do
        {
          v23 = *((_DWORD *)Src + v8) >> (32 - v21);
          *((_DWORD *)Src + v8) = v22 + (*((_DWORD *)Src + v8) << v21);
          v22 = v23;
          ++v8;
        }
        while ( v8 < v17 );
        if ( v23 )
        {
          if ( v135 + 1 > v136 )
          {
            if ( *v133 == sub_14619FC90 )
              sub_14619FC90(&v133, v135 + 1);
            else
              ((void (__fastcall *)(void ***))*v133)(&v133);
          }
          *((_DWORD *)Src + v135++) = v23;
        }
      }
    }
    *(_DWORD *)v146 = 1;
    v24 = v148;
    if ( !v148 )
    {
      if ( *v145 == sub_14619FC90 )
        sub_14619FC90(&v145, 1ui64);
      else
        ((void (__fastcall *)(void ***, __int64))*v145)(&v145, 1i64);
      v24 = v148;
    }
    v147 = v24 != 0;
    v150 = v20;
    if ( v21 )
    {
      v25 = 0;
      v8 = 0i64;
      if ( v24 )
      {
        do
        {
          v26 = *((_DWORD *)v146 + v8) >> (32 - v21);
          *((_DWORD *)v146 + v8) = v25 + (*((_DWORD *)v146 + v8) << v21);
          v25 = v26;
          ++v8;
        }
        while ( v8 < (v24 != 0) );
        if ( v26 )
        {
          if ( v147 + 1 > v148 )
          {
            if ( *v145 == sub_14619FC90 )
              sub_14619FC90(&v145, v147 + 1);
            else
              ((void (__fastcall *)(void ***))*v145)(&v145);
          }
          *((_DWORD *)v146 + v147++) = v26;
        }
      }
    }
    if ( v123 != 1 )
    {
      *(_DWORD *)v152 = 1;
      v27 = v154;
      if ( !v154 )
      {
        if ( *v151 == sub_14619FC90 )
          sub_14619FC90(&v151, 1ui64);
        else
          ((void (__fastcall *)(void ***, __int64))*v151)(&v151, 1i64);
        v27 = v154;
      }
      v28 = v27 != 0;
      v153 = v28;
      v29 = (v119 + 1) % 32;
      v156 = (v119 + 1) / 32;
      if ( v29 )
      {
        v30 = 0;
        v8 = 0i64;
        if ( v28 )
        {
          do
          {
            v31 = *((_DWORD *)v152 + v8) >> (32 - v29);
            *((_DWORD *)v152 + v8) = v30 + (*((_DWORD *)v152 + v8) << ((v119 + 1) % 32));
            v30 = v31;
            ++v8;
          }
          while ( v8 < v28 );
          if ( v31 )
          {
            if ( v153 + 1 > v154 )
            {
              if ( *v151 == sub_14619FC90 )
                sub_14619FC90(&v151, v153 + 1);
              else
                ((void (__fastcall *)(void ***))*v151)(&v151);
            }
            *((_DWORD *)v152 + v153++) = v31;
          }
        }
      }
      v121 = &v151;
    }
    v32 = a5;
    sub_14619F2E0((__int64)&v139, (_DWORD *)(unsigned int)*a5, v8);
    v33 = 0i64;
    v34 = v141;
    v35 = 0i64;
    if ( v141 )
    {
      do
      {
        v36 = *(_DWORD *)&v140[4 * v35] >> (32 - v123);
        *(_DWORD *)&v140[4 * v35] = v33 + (*(_DWORD *)&v140[4 * v35] << v123);
        v33 = v36;
        ++v35;
      }
      while ( v35 < v34 );
      if ( v36 )
      {
        v37 = v141 + 1;
        if ( v141 + 1 > v142 )
        {
          if ( *v139 == sub_14619FC90 )
            sub_14619FC90(&v139, v37);
          else
            ((void (__fastcall *)(void ***, unsigned __int64, void *, _QWORD))*v139)(&v139, v37, *v139, v36);
        }
        *(_DWORD *)&v140[4 * v141++] = v36;
      }
    }
LABEL_116:
    v54 = v121;
    goto LABEL_117;
  }
  if ( (int)*a5 < 0 )
  {
    sub_14619F2E0((__int64)&v133, (_DWORD *)(unsigned int)-*a5, v8);
    v38 = v135;
    v39 = v148;
    if ( v135 > v148 )
    {
      if ( *v145 == sub_14619FC90 )
        sub_14619FC90(&v145, v135);
      else
        ((void (__fastcall *)(void ***, unsigned __int64))*v145)(&v145, v135);
      v39 = v148;
    }
    v40 = v38;
    if ( v38 > v39 )
      v40 = v39;
    v147 = v40;
    memmove(v146, Src, 4 * v38);
    v150 = v138;
    if ( v15 != 1 )
    {
      v41 = v135;
      v42 = v154;
      if ( v135 > v154 )
      {
        if ( *v151 == sub_14619FC90 )
          sub_14619FC90(&v151, v135);
        else
          ((void (__fastcall *)(void ***, unsigned __int64))*v151)(&v151, v135);
        v42 = v154;
      }
      v43 = v41;
      if ( v41 > v42 )
        v43 = v42;
      v153 = v43;
      memmove(v152, Src, 4 * v41);
      v156 = v138;
      sub_14619EE30((__int64)&v151, 1);
      v121 = &v151;
    }
    v44 = (unsigned int)v16;
    v45 = HIDWORD(v16);
    v46 = 0i64;
    v47 = v135;
    v48 = 0i64;
    if ( v135 )
    {
      do
      {
        v49 = *((unsigned int *)Src + v48);
        v35 = (unsigned int)v46 + v49 * v44;
        v46 = HIDWORD(v35) + v49 * v45 + HIDWORD(v46);
        *((_DWORD *)Src + v48++) = v35;
      }
      while ( v48 < v47 );
      for ( ; v46; v46 >>= 32 )
      {
        if ( v135 + 1 > v136 )
        {
          if ( *v133 == sub_14619FC90 )
            sub_14619FC90(&v133, v135 + 1);
          else
            ((void (__fastcall *)(void ***))*v133)(&v133);
        }
        *((_DWORD *)Src + v135++) = v46;
      }
    }
    *(_DWORD *)v140 = 1;
    v50 = v142;
    if ( !v142 )
    {
      if ( *v139 == sub_14619FC90 )
        sub_14619FC90(&v139, 1ui64);
      else
        ((void (__fastcall *)(void ***, __int64))*v139)(&v139, 1i64);
      v50 = v142;
    }
    v33 = v50 != 0;
    v141 = v33;
    v51 = v15 - v119;
    v144 = v51 / 32;
    if ( v51 % 32 )
    {
      v52 = 0;
      v35 = 0i64;
      if ( v33 )
      {
        do
        {
          v53 = *(_DWORD *)&v140[4 * v35] >> (32 - v51 % 32);
          *(_DWORD *)&v140[4 * v35] = v52 + (*(_DWORD *)&v140[4 * v35] << (v51 % 32));
          v52 = v53;
          ++v35;
        }
        while ( v35 < v33 );
        if ( v53 )
        {
          if ( v141 + 1 > v142 )
          {
            if ( *v139 == sub_14619FC90 )
              sub_14619FC90(&v139, v141 + 1);
            else
              ((void (__fastcall *)(void ***))*v139)(&v139);
          }
          *(_DWORD *)&v140[4 * v141++] = v53;
        }
      }
    }
    v32 = a5;
    goto LABEL_116;
  }
  v60 = 0i64;
  while ( 1 )
  {
    *(_DWORD *)&v6[4 * v60++] = v16;
    v16 >>= 32;
    if ( !v16 )
      break;
    v6 = (char *)Src;
  }
  v61 = v136;
  v62 = v60 <= v136;
  if ( v60 > v136 )
  {
    if ( *v133 == sub_14619FC90 )
      sub_14619FC90(&v133, v60);
    else
      ((void (__fastcall *)(void ***, unsigned __int64))*v133)(&v133, v60);
    v61 = v136;
    v62 = v60 <= v136;
  }
  if ( !v62 )
    v60 = v61;
  v135 = v60;
  v138 = 0;
  sub_14619F2E0((__int64)&v139, (_DWORD *)(unsigned int)*a5, v8);
  v144 += (v15 - v12) / 32;
  v35 = (v15 - v12) & 0x8000001F;
  if ( v15 - v12 < 0 )
    v35 = ((unsigned __int8)(((v15 - v12) & 0x1F) - 1) | 0xFFFFFFE0) + 1;
  if ( (_DWORD)v35 )
  {
    v63 = 0;
    v64 = v141;
    v33 = 0i64;
    if ( v141 )
    {
      do
      {
        v65 = *(_DWORD *)&v140[4 * v33] >> (32 - v35);
        *(_DWORD *)&v140[4 * v33] = v63 + (*(_DWORD *)&v140[4 * v33] << v35);
        v63 = v65;
        ++v33;
      }
      while ( v33 < v64 );
      if ( v65 )
      {
        if ( v141 + 1 > v142 )
        {
          if ( *v139 == sub_14619FC90 )
            sub_14619FC90(&v139, v141 + 1);
          else
            ((void (__fastcall *)(void ***))*v139)(&v139);
        }
        *(_DWORD *)&v140[4 * v141++] = v65;
      }
    }
  }
  *(_DWORD *)v146 = 1;
  v66 = v148;
  if ( !v148 )
  {
    if ( *v145 == sub_14619FC90 )
      sub_14619FC90(&v145, 1ui64);
    else
      ((void (__fastcall *)(void ***, __int64, void *, unsigned __int64))*v145)(&v145, 1i64, *v145, v33);
    v66 = v148;
  }
  v147 = v66 != 0;
  v150 = 0;
  if ( v15 == 1 )
  {
    v54 = 0i64;
    v32 = a5;
  }
  else
  {
    *(_DWORD *)v152 = 2;
    v67 = v154;
    if ( !v154 )
    {
      if ( *v151 == sub_14619FC90 )
        sub_14619FC90(&v151, 1ui64);
      else
        ((void (__fastcall *)(void ***, __int64, void *, unsigned __int64))*v151)(&v151, 1i64, *v151, v33);
      v67 = v154;
    }
    v153 = v67 != 0;
    v156 = 0;
    v54 = &v151;
    v32 = a5;
  }
LABEL_117:
  if ( (a2 & 0x80000000) == 0 )
  {
    *v32 += 1 - a2;
    v102 = *(_QWORD *)(a4 + 24);
    if ( !a2 )
    {
      if ( !v102 )
        (**(void (__fastcall ***)(__int64, __int64, unsigned __int64, unsigned __int64))a4)(a4, 1i64, v35, v33);
      *(_QWORD *)(a4 + 16) = *(_QWORD *)(a4 + 24) != 0i64;
      v103 = v141;
      v104 = 0i64;
      if ( v141 )
      {
        do
        {
          v105 = v5 + 10i64 * *(unsigned int *)&v140[4 * v104];
          *(_DWORD *)&v140[4 * v104] = v105;
          v106 = HIDWORD(v105);
          v5 = v106;
          ++v104;
        }
        while ( v104 < v103 );
        if ( (_DWORD)v106 )
        {
          if ( v141 + 1 > v142 )
          {
            if ( *v139 == sub_14619FC90 )
              sub_14619FC90(&v139, v141 + 1);
            else
              ((void (__fastcall *)(void ***))*v139)(&v139);
          }
          *(_DWORD *)&v140[4 * v141++] = v5;
        }
      }
      **(_BYTE **)(a4 + 8) = ((int)sub_14619F150((__int64)&v133, (__int64)&v133, (__int64)&v139) > 0) + 48;
      goto LABEL_263;
    }
    v107 = a2;
    if ( a2 > v102 )
      (**(void (__fastcall ***)(__int64, _QWORD, unsigned __int64, unsigned __int64))a4)(a4, a2, v35, v33);
    if ( (unsigned __int64)a2 > *(_QWORD *)(a4 + 24) )
      v107 = *(_QWORD *)(a4 + 24);
    *(_QWORD *)(a4 + 16) = v107;
    v108 = (int)a2 - 1i64;
    if ( v108 > 0 )
    {
      for ( i = 0i64; i < v108; ++i )
      {
        *(_BYTE *)(i + *(_QWORD *)(a4 + 8)) = sub_14619F540((__int64)&v133, (__int64)&v139) + 48;
        LODWORD(v110) = 0;
        v111 = v135;
        v112 = 0i64;
        if ( v135 )
        {
          do
          {
            v113 = (unsigned int)v110 + 10i64 * *((unsigned int *)Src + v112);
            *((_DWORD *)Src + v112) = v113;
            v110 = HIDWORD(v113);
            ++v112;
          }
          while ( v112 < v111 );
          if ( (_DWORD)v110 )
          {
            v114 = v135;
            if ( v135 + 1 > v136 )
            {
              ((void (__fastcall *)(void ***))*v133)(&v133);
              v114 = v135;
            }
            *((_DWORD *)Src + v114) = v110;
            ++v135;
          }
        }
      }
    }
    v115 = sub_14619F540((__int64)&v133, (__int64)&v139);
    v116 = sub_14619F150((__int64)&v133, (__int64)&v133, (__int64)&v139);
    if ( v116 > 0 || !v116 && (v115 & 1) != 0 )
    {
      if ( v115 == 9 )
      {
        for ( *(_BYTE *)(v108 + *(_QWORD *)(a4 + 8)) = 58; v108 > 0; --v108 )
        {
          v117 = *(_QWORD *)(a4 + 8);
          if ( *(_BYTE *)(v108 + v117) != 58 )
            break;
          *(_BYTE *)(v108 + v117) = 48;
          ++*(_BYTE *)(v108 + *(_QWORD *)(a4 + 8) - 1);
        }
        v118 = *(_BYTE **)(a4 + 8);
        if ( *v118 == 58 )
        {
          *v118 = 49;
          ++*v32;
        }
        goto LABEL_263;
      }
      LOBYTE(v115) = v115 + 1;
    }
    *(_BYTE *)(v108 + *(_QWORD *)(a4 + 8)) = v115 + 48;
    goto LABEL_263;
  }
  v55 = &v145;
  if ( v54 )
    v55 = v54;
  v128 = (__int64)v55;
  v56 = 0;
  v120 = 0;
  v131 = *(_BYTE **)(a4 + 8);
  v127 = (v126 & 1) == 0;
  v57 = (int *)(v55 + 21);
  v132 = v55 + 21;
  v130 = v131;
  while ( 1 )
  {
    v124 = v56;
    v122 = sub_14619F540((__int64)&v133, (__int64)&v139);
    v58 = v135 + v138;
    if ( (_DWORD)v135 + v138 == (_DWORD)v147 + v150 )
    {
      v68 = (unsigned int)(v135 - 1);
      v69 = (unsigned int)(v147 - 1);
      v70 = 0;
      if ( (int)v135 - (int)v147 >= 0 )
        v70 = v135 - v147;
      if ( (int)v68 < v70 )
      {
LABEL_164:
        if ( (_DWORD)v68 == (_DWORD)v69 )
        {
          v59 = 0;
        }
        else
        {
          v59 = -1;
          if ( (int)v68 > (int)v69 )
            v59 = 1;
        }
      }
      else
      {
        while ( 1 )
        {
          v71 = *((_DWORD *)Src + v68);
          if ( v71 != *((_DWORD *)v146 + v69) )
            break;
          v68 = (unsigned int)(v68 - 1);
          v69 = (unsigned int)(v69 - 1);
          if ( (int)v68 < v70 )
            goto LABEL_164;
        }
        v59 = -1;
        if ( v71 > *((_DWORD *)v146 + v69) )
          v59 = 1;
      }
    }
    else
    {
      v59 = -1;
      if ( v58 > (int)v147 + v150 )
        v59 = 1;
    }
    v72 = (unsigned int)(v59 - v127) >> 31;
    v73 = *v57;
    v74 = v128;
    v75 = *v57 + *(_DWORD *)(v128 + 16);
    v76 = v135 + v138;
    if ( v58 < v75 )
      v76 = v75;
    v77 = v144 + v141;
    if ( v76 + 1 >= v144 + (int)v141 )
    {
      if ( v76 <= v77 )
      {
        v79 = 0i64;
        v80 = &v138;
        if ( v73 < v138 )
          v80 = (int *)(v128 + 168);
        v81 = &v144;
        if ( v144 >= *v80 )
          v81 = v80;
        v82 = v77 - 1;
        if ( v77 - 1 < *v81 )
        {
LABEL_198:
          v78 = -(v79 != 0);
        }
        else
        {
          while ( 1 )
          {
            v83 = v82 < v138 || v82 >= (int)v135 + v138 ? 0i64 : *((unsigned int *)Src + (unsigned int)(v82 - v138));
            v84 = v82 < v73 || v82 >= v75 ? 0 : *(_DWORD *)(*(_QWORD *)(v74 + 8) + 4i64 * (unsigned int)(v82 - v73));
            v85 = v84 + v83;
            if ( v82 < v144 || v82 >= v77 )
              v86 = 0i64;
            else
              v86 = *(unsigned int *)&v140[4 * (v82 - v144)];
            if ( v85 > v86 + v79 )
              break;
            v87 = v86 - v85 + v79;
            if ( v87 > 1 )
            {
              v78 = -1;
              goto LABEL_199;
            }
            v79 = v87 << 32;
            --v82;
            v74 = v128;
            if ( v82 < *v81 )
              goto LABEL_198;
          }
          v78 = 1;
        }
      }
      else
      {
        v78 = 1;
      }
    }
    else
    {
      v78 = -1;
    }
LABEL_199:
    v88 = v78 + v127;
    *v130 = v122 + 48;
    v56 = ++v120;
    ++v130;
    if ( (_BYTE)v72 )
      break;
    if ( v88 > 0 )
      goto LABEL_221;
    LODWORD(v89) = 0;
    v90 = v135;
    v91 = 0i64;
    if ( v135 )
    {
      do
      {
        v92 = (unsigned int)v89 + 10i64 * *((unsigned int *)Src + v91);
        *((_DWORD *)Src + v91) = v92;
        v89 = HIDWORD(v92);
        ++v91;
      }
      while ( v91 < v90 );
      if ( (_DWORD)v89 )
      {
        v93 = v135;
        if ( v135 + 1 > v136 )
        {
          ((void (__fastcall *)(void ***))*v133)(&v133);
          v93 = v135;
        }
        *((_DWORD *)Src + v93) = v89;
        ++v135;
      }
    }
    LODWORD(v94) = 0;
    v95 = v147;
    v96 = 0i64;
    if ( v147 )
    {
      do
      {
        v97 = (unsigned int)v94 + 10i64 * *((unsigned int *)v146 + v96);
        *((_DWORD *)v146 + v96) = v97;
        v94 = HIDWORD(v97);
        ++v96;
      }
      while ( v96 < v95 );
      if ( (_DWORD)v94 )
      {
        v98 = v147;
        if ( v147 + 1 > v148 )
        {
          ((void (__fastcall *)(void ***))*v145)(&v145);
          v98 = v147;
        }
        *((_DWORD *)v146 + v98) = v94;
        ++v147;
      }
    }
    v57 = (int *)(v128 + 168);
    if ( (void ***)v128 != &v145 )
    {
      sub_146196580(v128, 0xAu);
      v57 = (int *)v132;
    }
  }
  if ( v88 > 0 )
  {
    v99 = sub_14619F150((__int64)&v133, (__int64)&v133, (__int64)&v139);
    if ( v99 > 0 || !v99 && (v122 & 1) != 0 )
LABEL_221:
      ++v131[v124];
  }
  v100 = v56;
  v101 = (unsigned __int64)v56 <= *(_QWORD *)(a4 + 24);
  if ( (unsigned __int64)v56 > *(_QWORD *)(a4 + 24) )
  {
    (**(void (__fastcall ***)(__int64, _QWORD))a4)(a4, v56);
    v101 = (unsigned __int64)v56 <= *(_QWORD *)(a4 + 24);
  }
  if ( !v101 )
    v100 = *(_QWORD *)(a4 + 24);
  *(_QWORD *)(a4 + 16) = v100;
  *a5 += 1 - v56;
LABEL_263:
  sub_14619E4D0(&v151);
  sub_14619E4D0(&v145);
  sub_14619E4D0(&v139);
  sub_14619E4D0(&v133);
}
// 146197040: inconsistent variable size for 'xmm0_8.8'
// 14612F258: using guessed type void *fmt::v8::basic_memory_buffer<unsigned int,32,std::allocator<unsigned int>>::`vftable';

//----- (0000000146198090) ----------------------------------------------------
_QWORD *__fastcall sub_146198090(_QWORD *a1, __int64 a2, unsigned int a3, int a4)
{
  char *v6; // r9
  char *i; // r14
  __int16 v8; // ax
  char *j; // rsi
  __int64 v10; // rcx
  size_t v11; // rdi
  _QWORD *result; // rax
  char Src[16]; // [rsp+28h] [rbp-40h] BYREF

  v6 = &Src[a4];
  for ( i = v6; a3 >= 0x64; *(_WORD *)v6 = v8 )
  {
    v6 -= 2;
    v8 = *(_WORD *)&a00010203040506[2 * (a3 % 0x64)];
    a3 /= 0x64u;
  }
  if ( a3 >= 0xA )
    *((_WORD *)v6 - 1) = *(_WORD *)&a00010203040506[2 * a3];
  else
    *(v6 - 1) = a3 + 48;
  *a1 = a2;
  for ( j = Src; j != i; j += v11 )
  {
    if ( (unsigned __int64)(i - j + *(_QWORD *)(a2 + 16)) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    v10 = *(_QWORD *)(a2 + 16);
    v11 = *(_QWORD *)(a2 + 24) - v10;
    if ( v11 >= i - j )
      v11 = i - j;
    if ( v11 )
      memmove((void *)(*(_QWORD *)(a2 + 8) + v10), j, v11);
    *(_QWORD *)(a2 + 16) += v11;
  }
  result = a1;
  a1[1] = a2;
  return result;
}

//----- (00000001461981B0) ----------------------------------------------------
_QWORD *__fastcall sub_1461981B0(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4)
{
  __int64 v5; // rdi
  unsigned __int64 v6; // rsi
  char *v8; // r8
  const char *v9; // r9
  char *i; // rbp
  __int16 v11; // ax
  char *j; // rsi
  unsigned __int64 v13; // rdx
  __int64 v14; // rcx
  size_t v15; // rdi
  _QWORD *result; // rax
  char Src[24]; // [rsp+20h] [rbp-48h] BYREF

  v5 = a4;
  v6 = a3;
  sub_146165560(a3);
  v8 = &Src[v5];
  v9 = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555"
       "6575859606162636465666768697071727374757677787980818283848586878889909192939495969798990123456789abcdef";
  for ( i = &Src[v5]; v6 >= 0x64; *(_WORD *)v8 = v11 )
  {
    v8 -= 2;
    v11 = *(_WORD *)&a00010203040506[2 * (v6 % 0x64)];
    v6 /= 0x64ui64;
  }
  if ( v6 >= 0xA )
    *((_WORD *)v8 - 1) = *(_WORD *)&a00010203040506[2 * v6];
  else
    *(v8 - 1) = v6 + 48;
  *a1 = a2;
  for ( j = Src; j != i; j += v15 )
  {
    v13 = i - j + *(_QWORD *)(a2 + 16);
    if ( v13 > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64, unsigned __int64, char *, const char *))a2)(a2, v13, v8, v9);
    v14 = *(_QWORD *)(a2 + 16);
    v15 = *(_QWORD *)(a2 + 24) - v14;
    if ( v15 >= i - j )
      v15 = i - j;
    if ( v15 )
      memmove((void *)(*(_QWORD *)(a2 + 8) + v14), j, v15);
    *(_QWORD *)(a2 + 16) += v15;
  }
  result = a1;
  a1[1] = a2;
  return result;
}
// 146198289: variable 'v8' is possibly undefined
// 146198289: variable 'v9' is possibly undefined

//----- (00000001461982F0) ----------------------------------------------------
__int64 __fastcall sub_1461982F0(double a1, int a2, __int64 a3, _QWORD *a4)
{
  char v4; // r12
  size_t v6; // r14
  __int64 v8; // rbx
  void *v9; // rcx
  char v11; // r15
  double v12; // xmm0_8
  unsigned __int64 v13; // rbx
  __int64 v14; // rbx
  __m128i v15; // xmm6
  __int64 v16; // rcx
  int v17; // edi
  __int64 v18; // r8
  int i; // edi
  unsigned __int64 v20; // r8
  int v21; // edi
  unsigned __int64 v22; // r10
  __int64 v23; // rcx
  int v24; // kr00_4
  __int64 v25; // rbx
  unsigned __int64 v26; // rdx
  unsigned __int64 v27; // r8
  unsigned __int64 v28; // r11
  unsigned __int64 v29; // rdx
  unsigned __int64 v30; // rdx
  unsigned int v31; // eax
  unsigned __int64 v32; // rdx
  _BYTE *v33; // rcx
  __int128 v34; // [rsp+30h] [rbp-50h] BYREF
  __int64 v35; // [rsp+40h] [rbp-40h] BYREF
  unsigned int v36; // [rsp+48h] [rbp-38h]
  unsigned int v37; // [rsp+4Ch] [rbp-34h]
  int v38; // [rsp+50h] [rbp-30h]
  char v39; // [rsp+54h] [rbp-2Ch]
  __int64 v40; // [rsp+B0h] [rbp+30h] BYREF
  unsigned int v41; // [rsp+C0h] [rbp+40h] BYREF

  v4 = *(_BYTE *)(a3 + 4);
  v6 = a2;
  LOBYTE(v40) = v4 == 2;
  if ( a1 > 0.0 )
  {
    v11 = *(_BYTE *)(a3 + 12);
    if ( (v11 & 8) == 0 )
    {
      v34 = *(_OWORD *)a3;
      return sub_146199FE0(a1, a2, (__int64)&v34, (__int64)a4);
    }
    if ( a2 >= 0 )
    {
      v41 = 0;
      v16 = (*(_QWORD *)&a1 >> 52) & 0x7FFi64;
      v17 = v16;
      if ( ((*(_QWORD *)&a1 >> 52) & 0x7FF) == 0 )
        v17 = 1;
      v18 = (*(_QWORD *)&a1 & 0xFFFFFFFFFFFFFi64) + 0x10000000000000i64;
      if ( !(_DWORD)v16 )
        v18 = *(_QWORD *)&a1 & 0xFFFFFFFFFFFFFi64;
      for ( i = v17 - 1075; (v18 & 0x10000000000000i64) == 0; --i )
        v18 *= 2i64;
      v20 = v18 << 11;
      v21 = i - 11;
      v36 = 0;
      v22 = HIDWORD(v20);
      v23 = (unsigned int)v20;
      v24 = ((unsigned __int64)(1292913986i64 * (-61 - v21) + 0xFFFFFFFFi64) >> 32) + 347;
      v25 = v24 / 8;
      v26 = (unsigned int)v20 * (unsigned __int64)(unsigned int)qword_14612EEE8[v25];
      v27 = HIDWORD(v20) * (unsigned int)qword_14612EEE8[v25];
      v28 = (unsigned __int64)(v23 * HIDWORD(qword_14612EEE8[v25])) >> 32;
      v29 = (unsigned int)(v23 * HIDWORD(qword_14612EEE8[v25])) + (unsigned int)v27 + HIDWORD(v26) + 0x80000000;
      LODWORD(v23) = v21 + word_14612F1A2[v25] + 64;
      v30 = v22 * HIDWORD(qword_14612EEE8[v25]) + HIDWORD(v29);
      v35 = a4[1];
      DWORD2(v34) = v23;
      *(_QWORD *)&v34 = v28 + HIDWORD(v27) + v30;
      v31 = 767;
      if ( (int)v6 <= 767 )
        v31 = v6;
      v37 = v31;
      v38 = 340 - 8 * (v24 / 8);
      v39 = v40;
      if ( (unsigned int)sub_146198880((unsigned __int64 *)&v34, 1ui64, (int *)&v41, (__int64)&v35) == 2 )
      {
        v41 = v41 - 1 + v36 - (8 * (v24 / 8) - 340);
        sub_146197040(a1, v37, (v11 & 4) != 0, (__int64)a4, &v41);
        LODWORD(v14) = v41;
      }
      else
      {
        LODWORD(v14) = v38 + v41;
        sub_1461A0990((__int64)a4, v36);
      }
      if ( v4 != 2 && (v11 & 0x10) == 0 )
      {
        v32 = a4[2];
        if ( v32 )
        {
          v33 = (_BYTE *)(v32 + a4[1] - 1i64);
          do
          {
            if ( *v33 != 48 )
              break;
            --v33;
            LODWORD(v14) = v14 + 1;
            --v32;
          }
          while ( v32 );
        }
        sub_1461A0990((__int64)a4, v32);
      }
    }
    else
    {
      if ( (v11 & 4) == 0 )
      {
        v15 = *(__m128i *)sub_14619A920((__int64)&v34, a1);
        sub_14619CAB0(&v40, a4, v15.m128i_u64[0]);
        return (unsigned int)_mm_cvtsi128_si32(_mm_srli_si128(v15, 8));
      }
      HIDWORD(v12) = 0;
      *(float *)&v12 = a1;
      v13 = sub_14619A530(v12);
      sub_14619C9B0(&v40, a4, v13);
      return HIDWORD(v13);
    }
    return (unsigned int)v14;
  }
  else if ( a2 > 0 && v4 == 2 )
  {
    v8 = (unsigned int)a2;
    if ( (unsigned __int64)(unsigned int)a2 > a4[3] )
      (*(void (__fastcall **)(_QWORD *, _QWORD))*a4)(a4, (unsigned int)a2);
    v9 = (void *)a4[1];
    if ( (unsigned __int64)(unsigned int)v6 > a4[3] )
      v8 = a4[3];
    a4[2] = v8;
    memset(v9, 48, v6);
    return (unsigned int)-(int)v6;
  }
  else
  {
    if ( (unsigned __int64)(a4[2] + 1i64) > a4[3] )
      (*(void (__fastcall **)(_QWORD *))*a4)(a4);
    *(_BYTE *)(a4[1] + a4[2]++) = 48;
    return 0i64;
  }
}
// 14612EEE8: using guessed type __int64 qword_14612EEE8[87];
// 14612F1A2: using guessed type __int16 word_14612F1A2[87];

//----- (0000000146198650) ----------------------------------------------------
unsigned __int64 __fastcall sub_146198650(unsigned int *a1, char a2)
{
  unsigned __int64 result; // rax
  const char *pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v4; // [rsp+30h] [rbp-38h]
  void **v5; // [rsp+40h] [rbp-28h] BYREF
  __int128 v6; // [rsp+48h] [rbp-20h]
  char *v7; // [rsp+70h] [rbp+8h] BYREF
  char v8; // [rsp+78h] [rbp+10h] BYREF

  v8 = a2;
  v7 = &v8;
  result = sub_14619BE40((__int64)&v7, a1);
  if ( result > 0x7FFFFFFF )
  {
    v5 = &std::exception::`vftable';
    v6 = 0i64;
    pExceptionObject = "number is too big";
    v4 = 1;
    _std_exception_copy(&pExceptionObject);
    v5 = &fmt::v8::format_error::`vftable';
    LOBYTE(v7) = 1;
    sub_146162440((__int64)&pExceptionObject, (__int64)&v5);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  return result;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146198700) ----------------------------------------------------
unsigned __int64 __fastcall sub_146198700(unsigned int *a1, char a2)
{
  unsigned __int64 result; // rax
  const char *pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v4; // [rsp+30h] [rbp-38h]
  void **v5; // [rsp+40h] [rbp-28h] BYREF
  __int128 v6; // [rsp+48h] [rbp-20h]
  char *v7; // [rsp+70h] [rbp+8h] BYREF
  char v8; // [rsp+78h] [rbp+10h] BYREF

  v8 = a2;
  v7 = &v8;
  result = sub_14619C350((__int64)&v7, a1);
  if ( result > 0x7FFFFFFF )
  {
    v5 = &std::exception::`vftable';
    v6 = 0i64;
    pExceptionObject = "number is too big";
    v4 = 1;
    _std_exception_copy(&pExceptionObject);
    v5 = &fmt::v8::format_error::`vftable';
    LOBYTE(v7) = 1;
    sub_146162440((__int64)&pExceptionObject, (__int64)&v5);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  return result;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (00000001461987B0) ----------------------------------------------------
__int64 __fastcall sub_1461987B0(_QWORD *a1, __int64 a2)
{
  unsigned __int64 v2; // rbx
  const char ***v3; // rcx
  const char **v4; // r15
  const char **v5; // r12
  const char **v6; // rsi
  size_t v7; // r14
  const void *v8; // r13
  size_t v9; // rax
  size_t v10; // r8
  size_t v11; // rbp

  if ( (*a1 & 0x4000000000000000i64) == 0 )
    return 0xFFFFFFFFi64;
  v2 = 0i64;
  v3 = (const char ***)(a1[1] - (8i64 * (*a1 >> 63) + 16));
  v4 = v3[1];
  if ( !v4 )
    return 0xFFFFFFFFi64;
  v5 = *v3;
  v6 = *v3;
  v7 = *(_QWORD *)(a2 + 8);
  v8 = *(const void **)a2;
  while ( 1 )
  {
    v9 = strlen(*v6);
    v10 = v7;
    if ( v9 < v7 )
      v10 = v9;
    v11 = v9;
    if ( !memcmp(*v6, v8, v10) && v11 == v7 )
      break;
    ++v2;
    v6 += 2;
    if ( v2 >= (unsigned __int64)v4 )
      return 0xFFFFFFFFi64;
  }
  return LODWORD(v5[2 * v2 + 1]);
}

//----- (0000000146198880) ----------------------------------------------------
__int64 __fastcall sub_146198880(unsigned __int64 *a1, unsigned __int64 a2, int *a3, __int64 a4)
{
  unsigned __int64 v4; // r10
  unsigned __int64 v5; // rax
  int v6; // r12d
  unsigned __int64 v7; // r11
  char v8; // cl
  unsigned int v9; // edi
  __int64 v11; // rbx
  int v12; // r15d
  unsigned __int64 v13; // r14
  unsigned __int64 v14; // r8
  unsigned __int64 v15; // kr00_8
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // r10
  unsigned __int64 v18; // rdx
  __int64 v19; // rbp
  int v20; // ecx
  unsigned int v21; // r10d
  int v22; // ebp
  unsigned __int64 v23; // rdx
  __int64 v24; // rbp
  __int64 v25; // r10
  unsigned __int64 v26; // rdx
  __int64 v27; // rcx
  __int64 i; // rcx
  __int64 j; // rcx
  int v30; // eax

  v4 = *a1;
  v5 = *a1;
  v6 = -*((_DWORD *)a1 + 2);
  v7 = a2;
  v8 = -*((_BYTE *)a1 + 8);
  v9 = 1;
  v11 = (unsigned int)(v5 >> v8);
  v12 = 0;
  _BitScanReverse((unsigned int *)&v5, v11 | 1);
  v13 = 1i64 << v8;
  v14 = v4 & ((1i64 << v8) - 1);
  v15 = v4;
  v16 = (unsigned __int64)(v11 + qword_14611CFD0[(int)v5]) >> 32;
  *a3 = v16;
  v17 = 10 * a2;
  v18 = v15 / 0xA;
  v19 = (_QWORD)*(&fmt::v8::basic_memory_buffer<unsigned int,32,std::allocator<unsigned int>>::`vftable' + (int)v16) << v6;
  if ( *(_BYTE *)(a4 + 20)
    && (v20 = *(_DWORD *)(a4 + 12) + *(_DWORD *)(a4 + 16) + v16, *(_DWORD *)(a4 + 12) = v20, v20 <= 0) )
  {
    if ( v20 >= 0 )
    {
      if ( v18 > v19 - v18 || 2 * v17 > v19 - 2 * v18 )
      {
        if ( v18 < v17 || v18 - v17 < v19 + v17 - v18 )
          return 2;
        v30 = 1;
      }
      else
      {
        v30 = 2;
      }
      *(_BYTE *)((int)(*(_DWORD *)(a4 + 8))++ + *(_QWORD *)a4) = (v30 == 1) + 48;
    }
  }
  else
  {
    while ( 1 )
    {
      LOBYTE(v21) = 0;
      v22 = *a3 - 1;
      switch ( *a3 )
      {
        case 1:
          LOBYTE(v21) = v11;
          LODWORD(v11) = 0;
          break;
        case 2:
          LOBYTE(v21) = (unsigned int)v11 / 0xA;
          LODWORD(v11) = (unsigned int)v11 % 0xA;
          break;
        case 3:
          LOBYTE(v21) = (unsigned int)v11 / 0x64;
          LODWORD(v11) = (unsigned int)v11 % 0x64;
          break;
        case 4:
          LOBYTE(v21) = (unsigned int)v11 / 0x3E8;
          LODWORD(v11) = (unsigned int)v11 % 0x3E8;
          break;
        case 5:
          LOBYTE(v21) = (unsigned int)v11 / 0x2710;
          LODWORD(v11) = (unsigned int)v11 % 0x2710;
          break;
        case 6:
          LOBYTE(v21) = (unsigned int)v11 / 0x186A0;
          LODWORD(v11) = (unsigned int)v11 % 0x186A0;
          break;
        case 7:
          LOBYTE(v21) = (unsigned int)v11 / 0xF4240;
          LODWORD(v11) = (unsigned int)v11 % 0xF4240;
          break;
        case 8:
          LOBYTE(v21) = (unsigned int)v11 / 0x989680;
          LODWORD(v11) = (unsigned int)v11 % 0x989680;
          break;
        case 9:
          LOBYTE(v21) = (unsigned int)v11 / 0x5F5E100;
          LODWORD(v11) = (unsigned int)v11 % 0x5F5E100;
          break;
        case 10:
          v21 = (unsigned int)v11 / 0x3B9ACA00;
          LODWORD(v11) = (unsigned int)v11 % 0x3B9ACA00;
          break;
        default:
          break;
      }
      *a3 = v22;
      v23 = v14 + ((unsigned __int64)(unsigned int)v11 << v6);
      v24 = qword_14612F260[v22] << v6;
      *(_BYTE *)(*(int *)(a4 + 8) + *(_QWORD *)a4) = v21 + 48;
      v25 = *(int *)(a4 + 8);
      *(_DWORD *)(a4 + 8) = v25 + 1;
      if ( (int)v25 + 1 >= *(_DWORD *)(a4 + 12) )
        break;
      if ( *a3 <= 0 )
      {
        while ( 1 )
        {
          --*a3;
          v26 = 10 * v14;
          v7 *= 10i64;
          v14 = (10 * v14) & (v13 - 1);
          *(_BYTE *)(*(int *)(a4 + 8) + *(_QWORD *)a4) = (v26 >> v6) + 48;
          v27 = *(int *)(a4 + 8);
          *(_DWORD *)(a4 + 8) = v27 + 1;
          if ( v7 >= v14 )
            return 2;
          if ( (int)v27 + 1 >= *(_DWORD *)(a4 + 12) )
          {
            if ( v7 >= v13 || v7 >= v13 - v7 )
              return 2;
            if ( v14 <= v13 - v14 && 2 * v7 <= v13 - 2 * v14 )
              return v9;
            if ( v14 - v7 < v13 - v14 + v7 )
              return 2;
            ++*(_BYTE *)(v27 + *(_QWORD *)a4);
            for ( i = *(_DWORD *)(a4 + 8) - 1; i > 0; --i )
            {
              if ( *(char *)(i + *(_QWORD *)a4) <= 57 )
                break;
              *(_BYTE *)(i + *(_QWORD *)a4) = 48;
              ++*(_BYTE *)(i + *(_QWORD *)a4 - 1);
            }
            goto LABEL_26;
          }
        }
      }
    }
    if ( v23 > v24 - v23 || 2 * v7 > v24 - 2 * v23 )
    {
      if ( v23 < v7 || v23 - v7 < v24 - v23 + v7 )
      {
        LOBYTE(v12) = 1;
        return (unsigned int)(v12 + 1);
      }
      else
      {
        ++*(_BYTE *)(v25 + *(_QWORD *)a4);
        for ( j = *(_DWORD *)(a4 + 8) - 1; j > 0; --j )
        {
          if ( *(char *)(j + *(_QWORD *)a4) <= 57 )
            break;
          *(_BYTE *)(j + *(_QWORD *)a4) = 48;
          ++*(_BYTE *)(j + *(_QWORD *)a4 - 1);
        }
LABEL_26:
        if ( **(char **)a4 > 57 )
        {
          **(_BYTE **)a4 = 49;
          if ( *(_BYTE *)(a4 + 20) )
            *(_BYTE *)((int)(*(_DWORD *)(a4 + 8))++ + *(_QWORD *)a4) = 48;
          else
            ++*(_DWORD *)(a4 + 16);
        }
      }
    }
    else
    {
      LOBYTE(v12) = 0;
      return (unsigned int)(v12 + 1);
    }
  }
  return v9;
}
// 14611CFD0: using guessed type __int64 qword_14611CFD0[32];
// 14612F258: using guessed type void *fmt::v8::basic_memory_buffer<unsigned int,32,std::allocator<unsigned int>>::`vftable';
// 14612F260: using guessed type __int64 qword_14612F260[20];

//----- (0000000146198CE0) ----------------------------------------------------
bool __fastcall sub_146198CE0(__int64 a1, int a2, int a3)
{
  if ( a2 < -2 )
    return 0;
  if ( a2 <= 9 )
    return 1;
  return a2 <= 86 && (unsigned __int64)(qword_14612F360[2 * a3] * a1) <= qword_14612F360[2 * a3 + 1];
}
// 14612F360: using guessed type _QWORD qword_14612F360[48];

//----- (0000000146198D20) ----------------------------------------------------
const char *__fastcall sub_146198D20(const char *a1, unsigned __int64 a2, _QWORD *a3)
{
  const char *v4; // rdi
  char v5; // r8
  int v6; // ecx
  const char *v7; // rcx
  const char *v8; // rbx
  char v9; // al
  int v10; // esi
  const char *pExceptionObject; // [rsp+30h] [rbp-48h] BYREF
  __int64 v13; // [rsp+38h] [rbp-40h]
  __m256i v14; // [rsp+50h] [rbp-28h] BYREF

  v4 = a1;
  *(__m128i *)v14.m256i_i8 = _mm_load_si128((const __m128i *)&xmmword_14611DA90);
  *(__m128i *)&v14.m256i_u64[2] = _mm_load_si128((const __m128i *)&xmmword_14611DA80);
  v5 = *a1;
  v6 = v14.m256i_i8[(unsigned __int64)*(unsigned __int8 *)a1 >> 3];
  v7 = &v4[v6 + ((_BYTE)v6 == 0)];
  v8 = v4;
  if ( (unsigned __int64)v7 < a2 )
    v8 = v7;
  while ( 1 )
  {
    v9 = *v8;
    if ( *v8 == 60 )
      break;
    if ( v9 == 62 )
    {
      v10 = 2;
      goto LABEL_11;
    }
    if ( v9 == 94 )
    {
      v10 = 3;
      goto LABEL_11;
    }
    if ( v8 == v4 )
      return v4;
    v8 = v4;
  }
  v10 = 1;
LABEL_11:
  if ( v8 == v4 )
  {
    v8 = v4;
  }
  else
  {
    if ( v5 == 123 )
    {
      v14.m256i_i64[0] = (__int64)&std::exception::`vftable';
      *(_OWORD *)&v14.m256i_u64[1] = 0i64;
      pExceptionObject = "invalid fill character '{'";
      LOBYTE(v13) = 1;
      _std_exception_copy(&pExceptionObject);
      v14.m256i_i64[0] = (__int64)&fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v14);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    }
    pExceptionObject = v4;
    v13 = v8 - v4;
    sub_14619FE90(a3, (__int64)&pExceptionObject);
  }
  *(_DWORD *)(*a3 + 12i64) = v10 ^ (*(_DWORD *)(*a3 + 12i64) ^ v10) & 0xFFFFFFF0;
  return v8 + 1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 14611DA80: using guessed type __int128 xmmword_14611DA80;
// 14611DA90: using guessed type __int128 xmmword_14611DA90;
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146198E90) ----------------------------------------------------
char *__fastcall sub_146198E90(const char *a1, char *a2, _QWORD *a3)
{
  char *result; // rax
  char v6; // dl
  char *v7; // rbx
  char v8; // al
  int v9; // edx
  int v10; // eax
  char v11; // cl

  result = (char *)(a1 + 1);
  if ( a1 + 1 < a2 && *result == 125 )
  {
    if ( (v6 = *a1, *a1 >= 97) && v6 <= 122 || (unsigned __int8)(v6 - 65) <= 0x19u && v6 != 76 )
    {
      *(_BYTE *)(*a3 + 8i64) = v6;
      return result;
    }
  }
  if ( a1 == a2 )
    return (char *)a1;
  result = (char *)sub_146198D20(a1, (unsigned __int64)a2, a3);
  v7 = result;
  if ( result == a2 )
    return result;
  v8 = *result;
  switch ( v8 )
  {
    case ' ':
      v9 = 3;
LABEL_17:
      sub_1461A0330(a3, v9);
      if ( ++v7 == a2 )
        return v7;
      break;
    case '+':
      v9 = 2;
      goto LABEL_17;
    case '-':
      v9 = 1;
      goto LABEL_17;
  }
  if ( *v7 == 35 )
  {
    sub_1461A0620((__int64)a3);
    ++v7;
    *(_BYTE *)(*a3 + 16i64) |= 1u;
    if ( v7 == a2 )
      return v7;
  }
  if ( *v7 == 48 )
  {
    sub_1461A0620((__int64)a3);
    v10 = *(_DWORD *)(*a3 + 12i64);
    if ( (v10 & 0xF) == 0 )
      *(_DWORD *)(*a3 + 12i64) = v10 & 0xFFFFFFF0 | 4;
    ++v7;
    *(_BYTE *)(*a3 + 17i64) = 48;
    if ( v7 == a2 )
      return v7;
  }
  result = sub_146199890(v7, a2, (__int64)a3);
  v7 = result;
  if ( result != a2 )
  {
    if ( *result != 46 || (result = sub_146199530((__int64)result, a2, (__int64)a3), v7 = result, result != a2) )
    {
      if ( *v7 != 76 || (sub_1461A0620((__int64)a3), *(_BYTE *)(*a3 + 16i64) |= 2u, ++v7, v7 != a2) )
      {
        v11 = *v7;
        if ( *v7 != 125 )
        {
          ++v7;
          *(_BYTE *)(*a3 + 8i64) = v11;
        }
      }
      return v7;
    }
  }
  return result;
}

//----- (0000000146199020) ----------------------------------------------------
void __fastcall sub_146199020(__int64 a1, void ***a2)
{
  char *v3; // r14
  __int64 v4; // rax
  char *v5; // r15
  char *v6; // rdi
  char *v7; // r8
  char v8; // al
  __int64 v9; // rbx
  char v10; // al
  int v11; // eax
  char *v12; // r8
  int v13; // eax
  char *v14; // rax
  __int64 v15; // rbx
  __int64 v16; // rbx
  char *v17; // r13
  char *i; // rdi
  char *v19; // rdi
  __int64 v20; // rbx
  __int64 v21; // rbx
  char *v22; // r14
  char v23; // al
  int v24; // eax
  __int64 v25; // rbx
  char *v26; // rax
  int v27; // edx
  char *v28; // rax
  const char *v29; // rdx
  void ***v30; // [rsp+28h] [rbp-48h] BYREF
  int v31; // [rsp+30h] [rbp-40h]
  const char *pExceptionObject; // [rsp+38h] [rbp-38h] BYREF
  char v33; // [rsp+40h] [rbp-30h]
  void **v34; // [rsp+50h] [rbp-20h] BYREF
  __int128 v35; // [rsp+58h] [rbp-18h]
  void ***v36; // [rsp+C0h] [rbp+50h] BYREF

  v3 = *(char **)a1;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = (char *)(v4 + *(_QWORD *)a1);
  if ( v4 >= 32 )
  {
    v36 = a2;
    if ( v3 != v5 )
    {
      while ( 1 )
      {
        v17 = v3;
        if ( *v3 != 123 )
        {
          v17 = (char *)memchr(v3 + 1, 123, v5 - (v3 + 1));
          if ( !v17 )
            break;
        }
        if ( v3 != v17 )
        {
          for ( i = (char *)memchr(v3, 125, v17 - v3); i; i = (char *)memchr(v19 + 1, 125, v17 - (v19 + 1)) )
          {
            v19 = i + 1;
            if ( v19 == v17 || *v19 != 125 )
            {
              v34 = &std::exception::`vftable';
              v35 = 0i64;
              pExceptionObject = "unmatched '}' in format string";
              v33 = 1;
              _std_exception_copy(&pExceptionObject);
              v34 = &fmt::v8::format_error::`vftable';
              sub_146162440((__int64)&pExceptionObject, (__int64)&v34);
              CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
            }
            v20 = (__int64)a2[3];
            sub_14615AAE0(v20, v3, v19);
            a2[3] = (void **)v20;
            v3 = v19 + 1;
          }
          v21 = (__int64)a2[3];
          sub_14615AAE0(v21, v3, v17);
          a2[3] = (void **)v21;
        }
        v22 = v17 + 1;
        if ( v17 + 1 == v5 )
        {
          v34 = &std::exception::`vftable';
          v35 = 0i64;
          pExceptionObject = "invalid format string";
          v33 = 1;
          _std_exception_copy(&pExceptionObject);
          v34 = &fmt::v8::format_error::`vftable';
          sub_146162440((__int64)&pExceptionObject, (__int64)&v34);
          CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
        }
        v23 = *v22;
        if ( *v22 == 125 )
        {
          v24 = sub_14619FD90((__int64)a2);
          sub_1461A0200(a2, v24);
        }
        else if ( v23 == 123 )
        {
          v25 = (__int64)a2[3];
          sub_14615AAE0(v25, v17 + 1, v17 + 2);
          a2[3] = (void **)v25;
        }
        else
        {
          v30 = a2;
          v31 = 0;
          if ( v23 == 58 )
          {
            v27 = sub_14619FD90((__int64)a2);
            v26 = v17 + 1;
          }
          else
          {
            v26 = sub_146196920(v17 + 1, v5, (__int64)&v30);
            v22 = v26;
            if ( v26 == v5 )
              goto LABEL_56;
            v27 = v31;
          }
          if ( *v26 == 125 )
          {
            sub_1461A0200(a2, v27);
          }
          else
          {
            if ( *v26 != 58 )
            {
LABEL_56:
              v29 = "missing '}' in format string";
LABEL_54:
              sub_14619FE20((__int64)a2, (__int64)v29);
            }
            v28 = sub_14619FFC0(a2, v27, v26 + 1, v5);
            v22 = v28;
            if ( v28 == v5 || *v28 != 125 )
            {
              v29 = "unknown format specifier";
              goto LABEL_54;
            }
          }
        }
        v3 = v22 + 1;
        if ( v3 == v5 )
          return;
      }
      sub_14619ECF0((__int64 *)&v36, v3, v5);
    }
  }
  else
  {
    v6 = *(char **)a1;
    if ( v3 != v5 )
    {
      do
      {
        v7 = v6;
        v8 = *v6++;
        if ( v8 == 123 )
        {
          v9 = (__int64)a2[3];
          sub_14615AAE0(v9, v3, v7);
          a2[3] = (void **)v9;
          if ( v6 == v5 )
          {
            v34 = &std::exception::`vftable';
            v35 = 0i64;
            pExceptionObject = "invalid format string";
            v33 = 1;
            _std_exception_copy(&pExceptionObject);
            v34 = &fmt::v8::format_error::`vftable';
            sub_146162440((__int64)&pExceptionObject, (__int64)&v34);
            CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
          }
          v10 = *v6;
          if ( *v6 == 125 )
          {
            v11 = sub_14619FD90((__int64)a2);
            sub_1461A0200(a2, v11);
            v3 = ++v6;
          }
          else if ( v10 == 123 )
          {
            sub_14615AAE0(v9, v6, v6 + 1);
            a2[3] = (void **)v9;
            v3 = ++v6;
          }
          else
          {
            v30 = a2;
            v31 = 0;
            if ( v10 == 58 )
            {
              v13 = sub_14619FD90((__int64)a2);
              v12 = v6;
            }
            else
            {
              v6 = sub_146196920(v6, v5, (__int64)&v30);
              v12 = v6;
              if ( v6 == v5 )
                goto LABEL_20;
              v13 = v31;
            }
            if ( *v12 == 125 )
            {
              sub_1461A0200(a2, v13);
              v3 = ++v6;
            }
            else
            {
              if ( *v12 != 58 )
LABEL_20:
                sub_14619FE20((__int64)a2, (__int64)"missing '}' in format string");
              v14 = sub_14619FFC0(a2, v13, v12 + 1, v5);
              if ( v14 == v5 || *v14 != 125 )
                sub_14619FE20((__int64)a2, (__int64)"unknown format specifier");
              v3 = v14 + 1;
              v6 = v14 + 1;
            }
          }
        }
        else if ( v8 == 125 )
        {
          if ( v6 == v5 || *v6 != 125 )
          {
            v34 = &std::exception::`vftable';
            v35 = 0i64;
            pExceptionObject = "unmatched '}' in format string";
            v33 = 1;
            _std_exception_copy(&pExceptionObject);
            v34 = &fmt::v8::format_error::`vftable';
            sub_146162440((__int64)&pExceptionObject, (__int64)&v34);
            CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
          }
          v15 = (__int64)a2[3];
          sub_14615AAE0(v15, v3, v6);
          a2[3] = (void **)v15;
          v3 = ++v6;
        }
      }
      while ( v6 != v5 );
    }
    v16 = (__int64)a2[3];
    sub_14615AAE0(v16, v3, v5);
    a2[3] = (void **)v16;
  }
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146199530) ----------------------------------------------------
char *__fastcall sub_146199530(__int64 a1, char *a2, __int64 a3)
{
  _BYTE *v5; // rdi
  int v6; // ecx
  char *v7; // rdi
  char *v8; // rsi
  char *v9; // rdi
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // rdx
  __int64 v13; // rax
  int v14; // edx
  int v15; // ecx
  __int128 v17; // [rsp+30h] [rbp-31h] BYREF
  const char *v18; // [rsp+40h] [rbp-21h] BYREF
  __int128 v19; // [rsp+48h] [rbp-19h]
  _BYTE v20[24]; // [rsp+58h] [rbp-9h] BYREF
  __int128 pExceptionObject; // [rsp+78h] [rbp+17h] BYREF
  __int64 v22; // [rsp+88h] [rbp+27h]
  char *v23; // [rsp+C8h] [rbp+67h] BYREF
  char v24; // [rsp+D0h] [rbp+6Fh]

  v5 = (_BYTE *)(a1 + 1);
  v23 = (char *)(a1 + 1);
  if ( (char *)(a1 + 1) == a2 )
    goto LABEL_25;
  if ( (unsigned __int8)(*v5 - 48) <= 9u )
  {
    v6 = sub_14615B920(&v23, a2, 0xFFFFFFFF);
    if ( v6 == -1 )
    {
      v18 = (const char *)&std::exception::`vftable';
      v19 = 0i64;
      *(_QWORD *)&v17 = "number is too big";
      BYTE8(v17) = 1;
      _std_exception_copy(&v17);
      v18 = (const char *)&fmt::v8::format_error::`vftable';
      v24 = 1;
      sub_146162440((__int64)&pExceptionObject, (__int64)&v18);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    }
    *(_DWORD *)(*(_QWORD *)a3 + 4i64) = v6;
    v7 = v23;
    goto LABEL_21;
  }
  if ( *v5 != 123 )
  {
LABEL_25:
    *(_QWORD *)v20 = &std::exception::`vftable';
    *(_OWORD *)&v20[8] = 0i64;
    v18 = "missing precision specifier";
    LOBYTE(v19) = 1;
    _std_exception_copy(&v18);
    *(_QWORD *)v20 = &fmt::v8::format_error::`vftable';
    LOBYTE(v23) = 1;
    sub_146162440((__int64)&pExceptionObject, (__int64)v20);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  v8 = (char *)(a1 + 2);
  v9 = (char *)(a1 + 2);
  if ( (char *)(a1 + 2) != a2 )
  {
    v23 = (char *)a3;
    if ( *v8 != 125 && *v8 != 58 )
    {
      v8 = sub_146196B00(v8, a2, (__int64 *)&v23);
LABEL_18:
      v9 = v8;
      goto LABEL_19;
    }
    v10 = (int)sub_14619FD90(*(_QWORD *)(a3 + 8));
    v11 = *(_QWORD *)(a3 + 16);
    LODWORD(v22) = 0;
    v12 = *(_QWORD *)(v11 + 8);
    if ( v12 >= 0 )
    {
      if ( (int)v10 < 15 )
      {
        v14 = ((unsigned __int64)v12 >> (4 * (unsigned __int8)v10)) & 0xF;
        LODWORD(v22) = v14;
        if ( v14 )
        {
          v17 = *(_OWORD *)(*(_QWORD *)(v11 + 16) + 16 * v10);
LABEL_16:
          if ( v14 )
          {
            *(_OWORD *)v20 = v17;
            *(_QWORD *)&v20[16] = v22;
            *(_DWORD *)(*(_QWORD *)a3 + 4i64) = sub_146198650((unsigned int *)v20, 0);
            goto LABEL_18;
          }
LABEL_29:
          *(_QWORD *)v20 = &std::exception::`vftable';
          *(_OWORD *)&v20[8] = 0i64;
          v18 = "argument not found";
          LOBYTE(v19) = 1;
          _std_exception_copy(&v18);
          *(_QWORD *)v20 = &fmt::v8::format_error::`vftable';
          LOBYTE(v23) = 1;
          sub_146162440((__int64)&pExceptionObject, (__int64)v20);
          CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
        }
      }
    }
    else if ( (int)v10 < (int)v12 )
    {
      v13 = *(_QWORD *)(v11 + 16);
      v17 = *(_OWORD *)(v13 + 24 * v10);
      v22 = *(_QWORD *)(v13 + 24 * v10 + 16);
      v14 = v22;
      goto LABEL_16;
    }
    v17 = pExceptionObject;
    goto LABEL_29;
  }
LABEL_19:
  if ( v9 == a2 || (v7 = v9 + 1, *v8 != 125) )
  {
    *(_QWORD *)v20 = &std::exception::`vftable';
    *(_OWORD *)&v20[8] = 0i64;
    v18 = "invalid format string";
    LOBYTE(v19) = 1;
    _std_exception_copy(&v18);
    *(_QWORD *)v20 = &fmt::v8::format_error::`vftable';
    LOBYTE(v23) = 1;
    sub_146162440((__int64)&pExceptionObject, (__int64)v20);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
LABEL_21:
  v15 = *(_DWORD *)(a3 + 24);
  if ( (unsigned int)(v15 - 1) <= 7 || v15 == 14 )
  {
    *(_QWORD *)v20 = &std::exception::`vftable';
    *(_OWORD *)&v20[8] = 0i64;
    v18 = "precision not allowed for this argument type";
    LOBYTE(v19) = 1;
    _std_exception_copy(&v18);
    *(_QWORD *)v20 = &fmt::v8::format_error::`vftable';
    LOBYTE(v23) = 1;
    sub_146162440((__int64)&pExceptionObject, (__int64)v20);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  return v7;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146199890) ----------------------------------------------------
char *__fastcall sub_146199890(char *a1, char *a2, __int64 a3)
{
  char *v5; // rbx
  char v6; // r9
  unsigned int v7; // r11d
  char *v8; // r10
  char *v9; // rdx
  __int64 v10; // r8
  char *v12; // rbx
  char *v13; // rax
  int v14; // eax
  __int64 v15; // r8
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // rax
  int v19; // edx
  __int128 v20; // [rsp+30h] [rbp-21h] BYREF
  const char *v21; // [rsp+40h] [rbp-11h] BYREF
  __int128 v22; // [rsp+48h] [rbp-9h]
  _BYTE v23[24]; // [rsp+58h] [rbp+7h] BYREF
  __int128 pExceptionObject; // [rsp+78h] [rbp+27h] BYREF
  __int64 v25; // [rsp+88h] [rbp+37h]
  __int64 v26; // [rsp+B8h] [rbp+67h] BYREF

  v5 = a1;
  v6 = *a1;
  if ( (unsigned __int8)(*a1 - 48) > 9u )
  {
    if ( v6 != 123 )
      return v5;
    v12 = a1 + 1;
    if ( a1 + 1 == a2 )
    {
LABEL_29:
      *(_QWORD *)v23 = &std::exception::`vftable';
      *(_OWORD *)&v23[8] = 0i64;
      v21 = "invalid format string";
      LOBYTE(v22) = 1;
      _std_exception_copy(&v21);
      *(_QWORD *)v23 = &fmt::v8::format_error::`vftable';
      LOBYTE(v26) = 1;
      sub_146162440((__int64)&pExceptionObject, (__int64)v23);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    }
    v26 = a3;
    if ( *v12 != 125 && *v12 != 58 )
    {
      v13 = sub_146196DA0(v12, a2, &v26);
      if ( v13 == a2 )
        goto LABEL_29;
      goto LABEL_26;
    }
    v14 = sub_14619FD90(*(_QWORD *)(a3 + 8));
    v15 = *(_QWORD *)(a3 + 16);
    LODWORD(v25) = 0;
    v16 = *(_QWORD *)(v15 + 8);
    if ( v16 >= 0 )
    {
      if ( v14 < 15 )
      {
        v19 = ((unsigned __int64)v16 >> (4 * (unsigned __int8)v14)) & 0xF;
        LODWORD(v25) = v19;
        if ( v19 )
        {
          v20 = *(_OWORD *)(*(_QWORD *)(v15 + 16) + 16i64 * v14);
LABEL_24:
          if ( v19 )
          {
            *(_OWORD *)v23 = v20;
            *(_QWORD *)&v23[16] = v25;
            **(_DWORD **)a3 = sub_146198700((unsigned int *)v23, 0);
            v13 = v12;
LABEL_26:
            if ( *v13 == 125 )
              return v13 + 1;
            goto LABEL_29;
          }
LABEL_31:
          *(_QWORD *)v23 = &std::exception::`vftable';
          *(_OWORD *)&v23[8] = 0i64;
          v21 = "argument not found";
          LOBYTE(v22) = 1;
          _std_exception_copy(&v21);
          *(_QWORD *)v23 = &fmt::v8::format_error::`vftable';
          LOBYTE(v26) = 1;
          sub_146162440((__int64)&pExceptionObject, (__int64)v23);
          CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
        }
      }
    }
    else if ( v14 < (int)v16 )
    {
      v17 = 3i64 * v14;
      v18 = *(_QWORD *)(v15 + 16);
      v20 = *(_OWORD *)(v18 + 8 * v17);
      v25 = *(_QWORD *)(v18 + 8 * v17 + 16);
      v19 = v25;
      goto LABEL_24;
    }
    v20 = pExceptionObject;
    goto LABEL_31;
  }
  v7 = 0;
  v8 = a1;
  do
  {
    v9 = v8;
    v10 = v7;
    v7 = v6 + 2 * (5 * v7 - 24);
    if ( ++v8 == a2 )
      break;
    v6 = *v8;
    if ( *v8 < 48 )
      break;
  }
  while ( v6 <= 57 );
  v5 = v8;
  if ( v8 - a1 > 9 && (v8 - a1 != 10 || (unsigned __int64)(unsigned int)(*v9 - 48) + 10 * v10 > 0x7FFFFFFF) || v7 == -1 )
  {
    v21 = (const char *)&std::exception::`vftable';
    v22 = 0i64;
    *(_QWORD *)&v20 = "number is too big";
    BYTE8(v20) = 1;
    _std_exception_copy(&v20);
    v21 = (const char *)&fmt::v8::format_error::`vftable';
    LOBYTE(v26) = 1;
    sub_146162440((__int64)&pExceptionObject, (__int64)&v21);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  **(_DWORD **)a3 = v7;
  return v5;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (0000000146199B80) ----------------------------------------------------
unsigned __int64 __fastcall sub_146199B80(int a1)
{
  __int64 *v1; // rdx
  __int128 *v3; // rax
  unsigned int v4; // r10d
  int v5; // ebx
  __int64 v6; // rcx
  __int128 v7; // xmm0
  __int128 v8; // xmm1
  __int128 v9; // xmm0
  __int128 v10; // xmm1
  __int128 v11; // xmm0
  __int128 v12; // xmm1
  __int128 v13; // xmm0
  __int128 v14; // xmm1
  __int128 v15; // xmm1
  __int128 v16; // xmm0
  __int128 v17; // xmm1
  __int128 v18; // xmm0
  __int128 v19; // xmm1
  __int128 v20; // xmm0
  unsigned __int64 v21; // r9
  unsigned int v22; // edi
  unsigned __int64 v23; // rdx
  int v24; // r9d
  unsigned int v25; // r10d
  int v26; // ecx
  int v27; // r8d
  unsigned int v29; // r9d
  __int64 v30; // rcx
  __int64 v31[79]; // [rsp+0h] [rbp-278h] BYREF

  v1 = v31;
  v3 = (__int128 *)&unk_14612F950;
  v4 = (1262611 * a1 - 524031) >> 22;
  v5 = a1 + ((int)(-1741647 * v4) >> 19);
  v6 = 4i64;
  do
  {
    v1 += 16;
    v7 = *v3;
    v8 = v3[1];
    v3 += 8;
    *((_OWORD *)v1 - 8) = v7;
    v9 = *(v3 - 6);
    *((_OWORD *)v1 - 7) = v8;
    v10 = *(v3 - 5);
    *((_OWORD *)v1 - 6) = v9;
    v11 = *(v3 - 4);
    *((_OWORD *)v1 - 5) = v10;
    v12 = *(v3 - 3);
    *((_OWORD *)v1 - 4) = v11;
    v13 = *(v3 - 2);
    *((_OWORD *)v1 - 3) = v12;
    v14 = *(v3 - 1);
    *((_OWORD *)v1 - 2) = v13;
    *((_OWORD *)v1 - 1) = v14;
    --v6;
  }
  while ( v6 );
  v15 = v3[1];
  *(_OWORD *)v1 = *v3;
  v16 = v3[2];
  *((_OWORD *)v1 + 1) = v15;
  v17 = v3[3];
  *((_OWORD *)v1 + 2) = v16;
  v18 = v3[4];
  *((_OWORD *)v1 + 3) = v17;
  v19 = v3[5];
  *((_OWORD *)v1 + 4) = v18;
  v20 = v3[6];
  *((_OWORD *)v1 + 5) = v19;
  *((_OWORD *)v1 + 6) = v20;
  v21 = v31[31 - v4];
  v22 = ((v21 - (v21 >> 25)) >> (40 - (unsigned __int8)v5)) + 1;
  if ( (unsigned int)(a1 - 2) <= 1 )
    v22 = (v21 - (v21 >> 25)) >> (40 - (unsigned __int8)v5);
  v23 = (unsigned int)((v21 + (v21 >> 24)) >> (40 - (unsigned __int8)v5)) / 0xA;
  if ( 10 * (int)v23 >= v22 )
  {
    _BitScanForward((unsigned int *)&v24, v23);
    v25 = v4 + 1;
    v26 = 0;
    if ( v24 <= 7 )
    {
      v27 = v24 - 1;
      if ( v24 - 1 <= 0 )
        goto LABEL_11;
    }
    else
    {
      v24 = 7;
      v27 = 6;
    }
    do
    {
      if ( (unsigned int)(-1030792151 * v23) > 0xA3D70A3 )
        break;
      v26 += 2;
      v23 = (unsigned int)(-1030792151 * v23);
    }
    while ( v26 < v27 );
LABEL_11:
    if ( v26 < v24 && (unsigned int)(-858993459 * v23) <= 0x33333333 )
    {
      v23 = (unsigned int)(-858993459 * v23);
      ++v26;
    }
    return (v23 >> v26) | ((unsigned __int64)(v25 + v26) << 32);
  }
  v29 = ((unsigned int)(v21 >> (39 - (unsigned __int8)v5)) + 1) >> 1;
  if ( a1 == -35 )
  {
    v30 = v29 - 1;
    if ( (v29 & 1) == 0 )
      v30 = v29;
  }
  else
  {
    v30 = v29;
    if ( v29 < v22 )
      v30 = v29 + 1;
  }
  return v30 | ((unsigned __int64)v4 << 32);
}
// 146199B80: using guessed type __int64 var_278[79];

//----- (0000000146199D60) ----------------------------------------------------
__int64 __fastcall sub_146199D60(double a1, int a2, __int64 a3, __int64 a4)
{
  unsigned __int8 v4; // r13
  int v6; // r14d
  int v7; // r14d
  char v8; // al
  char *v9; // rcx
  char v10; // al
  __int64 v11; // r12
  char *v12; // r15
  size_t v13; // rsi
  unsigned int v14; // eax
  unsigned int v15; // ebp
  unsigned __int64 v16; // rdi
  char *v17; // rcx
  char v18; // al
  char *v19; // rdx
  unsigned int v20; // esi
  bool v21; // cc
  unsigned int v22; // esi
  bool v23; // cc
  __int64 result; // rax
  char *v25; // r9
  char *v26; // rdx
  char *v27; // rax
  char v28; // r11
  char *v29; // r8
  unsigned int v30; // ebp
  int v31; // eax
  int v32; // ecx
  int v33; // eax
  int v34; // r10d
  char *v35; // rcx
  int v36; // esi
  char *i; // rdx
  bool v38; // cc
  char Format; // [rsp+30h] [rbp-58h] BYREF
  char v40; // [rsp+31h] [rbp-57h] BYREF
  char v41; // [rsp+32h] [rbp-56h] BYREF

  v4 = *(_BYTE *)(a3 + 4);
  v6 = a2;
  if ( v4 <= 1u )
  {
    v7 = 6;
    if ( a2 >= 0 )
      v7 = a2;
    v6 = v7 - 1;
  }
  v8 = *(_BYTE *)(a3 + 12);
  v9 = &v40;
  Format = 37;
  if ( (v8 & 0x10) != 0 && v4 == 3 )
  {
    v40 = 35;
    v9 = &v41;
  }
  if ( v6 >= 0 )
  {
    *(_WORD *)v9 = 10798;
    v9 += 2;
  }
  if ( v4 == 3 )
    v10 = ~(32 * v8) & 0x20 | 0x41;
  else
    v10 = (v4 == 2) + 101;
  v11 = *(_QWORD *)(a4 + 16);
  *v9 = v10;
  v9[1] = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v12 = (char *)(v11 + *(_QWORD *)(a4 + 8));
      v13 = *(_QWORD *)(a4 + 24) - v11;
      v14 = v6 < 0 ? sub_14619F9A0(v12, v13, &Format, a1) : sub_14619F9A0(v12, v13, &Format, (unsigned int)v6, a1);
      v15 = v14;
      if ( (v14 & 0x80000000) == 0 )
        break;
      if ( (unsigned __int64)(*(_QWORD *)(a4 + 24) + 1i64) > *(_QWORD *)(a4 + 24) )
        goto LABEL_19;
    }
    v16 = v14;
    if ( v14 < v13 )
      break;
    if ( (unsigned __int64)v14 + v11 + 1 > *(_QWORD *)(a4 + 24) )
LABEL_19:
      (**(void (__fastcall ***)(__int64))a4)(a4);
  }
  if ( v4 == 2 )
  {
    if ( v6 )
    {
      v17 = &v12[v14];
      do
      {
        v18 = *(v17 - 1);
        v19 = v17--;
      }
      while ( (unsigned __int8)(v18 - 48) <= 9u );
      v20 = v15 + (_DWORD)v12 - (_DWORD)v17 - 1;
      memmove(v17, v19, v20);
      v16 = v15 - 1;
      v21 = v16 <= *(_QWORD *)(a4 + 24);
      if ( v16 > *(_QWORD *)(a4 + 24) )
      {
        (**(void (__fastcall ***)(__int64, _QWORD))a4)(a4, (unsigned int)v16);
        v21 = v16 <= *(_QWORD *)(a4 + 24);
      }
      if ( !v21 )
        v16 = *(_QWORD *)(a4 + 24);
      v22 = -v20;
      goto LABEL_54;
    }
LABEL_34:
    v23 = v16 <= *(_QWORD *)(a4 + 24);
    if ( v16 > *(_QWORD *)(a4 + 24) )
    {
      (**(void (__fastcall ***)(__int64, unsigned __int64))a4)(a4, v16);
      v23 = v16 <= *(_QWORD *)(a4 + 24);
    }
    if ( !v23 )
      v16 = *(_QWORD *)(a4 + 24);
    result = 0i64;
  }
  else
  {
    if ( v4 == 3 )
    {
      v16 = v11 + v14;
      goto LABEL_34;
    }
    v25 = &v12[v14];
    v26 = v25;
    do
      v27 = v26--;
    while ( *v26 != 101 );
    v28 = *v27;
    v29 = v26 + 2;
    v30 = 0;
    v31 = 0;
    do
    {
      v32 = 5 * v31;
      v33 = *v29++;
      v34 = v33 + 2 * v32;
      v31 = v34 - 48;
    }
    while ( v29 != v25 );
    v35 = v12 + 1;
    v36 = 48 - v34;
    if ( v28 != 45 )
      v36 = v34 - 48;
    if ( v26 != v35 )
    {
      for ( i = v26 - 1; *i == 48; --i )
        ;
      v30 = (_DWORD)i - (_DWORD)v12 - 1;
      memmove(v35, v12 + 2, v30);
    }
    v16 = v11 + v30 + 1i64;
    v38 = v16 <= *(_QWORD *)(a4 + 24);
    if ( v16 > *(_QWORD *)(a4 + 24) )
    {
      (**(void (__fastcall ***)(__int64, __int64))a4)(a4, v11 + v30 + 1i64);
      v38 = v16 <= *(_QWORD *)(a4 + 24);
    }
    if ( !v38 )
      v16 = *(_QWORD *)(a4 + 24);
    v22 = v36 - v30;
LABEL_54:
    result = v22;
  }
  *(_QWORD *)(a4 + 16) = v16;
  return result;
}

//----- (0000000146199FE0) ----------------------------------------------------
__int64 __fastcall sub_146199FE0(double a1, int a2, __int64 a3, __int64 a4)
{
  unsigned __int8 v4; // r13
  int v6; // r14d
  int v7; // r14d
  char v8; // cl
  char *v9; // rax
  char v10; // cl
  __int64 v11; // r12
  char *v12; // r15
  size_t v13; // rsi
  unsigned int v14; // eax
  unsigned int v15; // ebp
  unsigned __int64 v16; // rdi
  char *v17; // rcx
  char v18; // al
  char *v19; // rdx
  unsigned int v20; // esi
  bool v21; // cc
  unsigned int v22; // esi
  bool v23; // cc
  __int64 result; // rax
  char *v25; // r9
  char *v26; // rdx
  char *v27; // rax
  char v28; // r11
  char *v29; // r8
  unsigned int v30; // ebp
  int v31; // eax
  int v32; // ecx
  int v33; // eax
  int v34; // r10d
  char *v35; // rcx
  int v36; // esi
  char *i; // rdx
  bool v38; // cc
  char Format; // [rsp+30h] [rbp-58h] BYREF
  char v40; // [rsp+31h] [rbp-57h] BYREF
  char v41; // [rsp+32h] [rbp-56h] BYREF

  v4 = *(_BYTE *)(a3 + 4);
  v6 = a2;
  if ( v4 <= 1u )
  {
    v7 = 6;
    if ( a2 >= 0 )
      v7 = a2;
    v6 = v7 - 1;
  }
  v8 = *(_BYTE *)(a3 + 12);
  v9 = &v40;
  Format = 37;
  if ( (v8 & 0x10) != 0 && v4 == 3 )
  {
    v40 = 35;
    v9 = &v41;
  }
  if ( v6 >= 0 )
  {
    *(_WORD *)v9 = 10798;
    v9 += 2;
  }
  *v9 = 76;
  if ( v4 == 3 )
    v10 = ~(32 * v8) & 0x20 | 0x41;
  else
    v10 = (v4 == 2) + 101;
  v11 = *(_QWORD *)(a4 + 16);
  v9[1] = v10;
  v9[2] = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v12 = (char *)(v11 + *(_QWORD *)(a4 + 8));
      v13 = *(_QWORD *)(a4 + 24) - v11;
      v14 = v6 < 0 ? sub_14619F9A0(v12, v13, &Format, a1) : sub_14619F9A0(v12, v13, &Format, (unsigned int)v6, a1);
      v15 = v14;
      if ( (v14 & 0x80000000) == 0 )
        break;
      if ( (unsigned __int64)(*(_QWORD *)(a4 + 24) + 1i64) > *(_QWORD *)(a4 + 24) )
        goto LABEL_19;
    }
    v16 = v14;
    if ( v14 < v13 )
      break;
    if ( (unsigned __int64)v14 + v11 + 1 > *(_QWORD *)(a4 + 24) )
LABEL_19:
      (**(void (__fastcall ***)(__int64))a4)(a4);
  }
  if ( v4 == 2 )
  {
    if ( v6 )
    {
      v17 = &v12[v14];
      do
      {
        v18 = *(v17 - 1);
        v19 = v17--;
      }
      while ( (unsigned __int8)(v18 - 48) <= 9u );
      v20 = v15 + (_DWORD)v12 - (_DWORD)v17 - 1;
      memmove(v17, v19, v20);
      v16 = v15 - 1;
      v21 = v16 <= *(_QWORD *)(a4 + 24);
      if ( v16 > *(_QWORD *)(a4 + 24) )
      {
        (**(void (__fastcall ***)(__int64, _QWORD))a4)(a4, (unsigned int)v16);
        v21 = v16 <= *(_QWORD *)(a4 + 24);
      }
      if ( !v21 )
        v16 = *(_QWORD *)(a4 + 24);
      v22 = -v20;
      goto LABEL_54;
    }
LABEL_34:
    v23 = v16 <= *(_QWORD *)(a4 + 24);
    if ( v16 > *(_QWORD *)(a4 + 24) )
    {
      (**(void (__fastcall ***)(__int64, unsigned __int64))a4)(a4, v16);
      v23 = v16 <= *(_QWORD *)(a4 + 24);
    }
    if ( !v23 )
      v16 = *(_QWORD *)(a4 + 24);
    result = 0i64;
  }
  else
  {
    if ( v4 == 3 )
    {
      v16 = v11 + v14;
      goto LABEL_34;
    }
    v25 = &v12[v14];
    v26 = v25;
    do
      v27 = v26--;
    while ( *v26 != 101 );
    v28 = *v27;
    v29 = v26 + 2;
    v30 = 0;
    v31 = 0;
    do
    {
      v32 = 5 * v31;
      v33 = *v29++;
      v34 = v33 + 2 * v32;
      v31 = v34 - 48;
    }
    while ( v29 != v25 );
    v35 = v12 + 1;
    v36 = 48 - v34;
    if ( v28 != 45 )
      v36 = v34 - 48;
    if ( v26 != v35 )
    {
      for ( i = v26 - 1; *i == 48; --i )
        ;
      v30 = (_DWORD)i - (_DWORD)v12 - 1;
      memmove(v35, v12 + 2, v30);
    }
    v16 = v11 + v30 + 1i64;
    v38 = v16 <= *(_QWORD *)(a4 + 24);
    if ( v16 > *(_QWORD *)(a4 + 24) )
    {
      (**(void (__fastcall ***)(__int64, __int64))a4)(a4, v11 + v30 + 1i64);
      v38 = v16 <= *(_QWORD *)(a4 + 24);
    }
    if ( !v38 )
      v16 = *(_QWORD *)(a4 + 24);
    v22 = v36 - v30;
LABEL_54:
    result = v22;
  }
  *(_QWORD *)(a4 + 16) = v16;
  return result;
}

//----- (000000014619A260) ----------------------------------------------------
__int64 __fastcall sub_14619A260(__int64 a1, __int64 a2)
{
  __int64 v3; // rsi
  struct std::locale::_Locimp *v4; // rdi
  char v5; // bp
  void (__fastcall ***v6)(_QWORD, __int64); // rax
  void (__fastcall ***v7)(_QWORD, __int64); // rax
  std::locale::facet *v8; // rsi
  void (__fastcall ***v9)(_QWORD, __int64); // rax
  char v10; // al
  __int64 v12; // [rsp+20h] [rbp-58h] BYREF
  __int64 v13; // [rsp+28h] [rbp-50h]
  int v14; // [rsp+30h] [rbp-48h]
  __int64 v15; // [rsp+38h] [rbp-40h]
  __int128 v16; // [rsp+40h] [rbp-38h] BYREF
  __int128 v17; // [rsp+50h] [rbp-28h]

  v15 = -2i64;
  v12 = a1;
  v14 = 0;
  if ( a2 )
  {
    v3 = *(_QWORD *)(a2 + 8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8i64))(v3);
    v4 = (struct std::locale::_Locimp *)v3;
    v13 = v3;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8i64))(v3);
    v5 = 10;
  }
  else
  {
    v4 = std::locale::_Init(1);
    v13 = (__int64)v4;
    (*(void (__fastcall **)(struct std::locale::_Locimp *))(*(_QWORD *)v4 + 8i64))(v4);
    v5 = 8;
    if ( v4 )
    {
      v6 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(struct std::locale::_Locimp *))(*(_QWORD *)v4 + 16i64))(v4);
      if ( v6 )
        (**v6)(v6, 1i64);
    }
    v3 = v13;
  }
  if ( (v5 & 2) != 0 )
  {
    if ( v3 )
    {
      v7 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 16i64))(v3);
      if ( v7 )
        (**v7)(v7, 1i64);
    }
  }
  v8 = sub_14619AD00((__int64)&v12);
  v9 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(struct std::locale::_Locimp *))(*(_QWORD *)v4 + 16i64))(v4);
  if ( v9 )
    (**v9)(v9, 1i64);
  (*(void (__fastcall **)(std::locale::facet *, __int128 *))(*(_QWORD *)v8 + 40i64))(v8, &v16);
  if ( (_QWORD)v17 )
    v10 = (*(__int64 (__fastcall **)(std::locale::facet *))(*(_QWORD *)v8 + 32i64))(v8);
  else
    v10 = 0;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_OWORD *)a1 = v16;
  *(_OWORD *)(a1 + 16) = v17;
  *(_BYTE *)(a1 + 32) = v10;
  return a1;
}

//----- (000000014619A3D0) ----------------------------------------------------
__int64 __fastcall sub_14619A3D0(__int64 a1, __int64 a2)
{
  __int64 v3; // rsi
  struct std::locale::_Locimp *v4; // rdi
  char v5; // bp
  void (__fastcall ***v6)(_QWORD, __int64); // rax
  void (__fastcall ***v7)(_QWORD, __int64); // rax
  __int64 v8; // rsi
  void (__fastcall ***v9)(_QWORD, __int64); // rax
  __int16 v10; // ax
  __int64 v12; // [rsp+20h] [rbp-68h] BYREF
  __int64 v13; // [rsp+28h] [rbp-60h]
  int v14; // [rsp+30h] [rbp-58h]
  __int64 v15; // [rsp+38h] [rbp-50h]
  __int128 v16; // [rsp+40h] [rbp-48h] BYREF
  __int128 v17; // [rsp+50h] [rbp-38h]

  v15 = -2i64;
  v12 = a1;
  v14 = 0;
  if ( a2 )
  {
    v3 = *(_QWORD *)(a2 + 8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8i64))(v3);
    v4 = (struct std::locale::_Locimp *)v3;
    v13 = v3;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8i64))(v3);
    v5 = 10;
  }
  else
  {
    v4 = std::locale::_Init(1);
    v13 = (__int64)v4;
    (*(void (__fastcall **)(struct std::locale::_Locimp *))(*(_QWORD *)v4 + 8i64))(v4);
    v5 = 8;
    if ( v4 )
    {
      v6 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(struct std::locale::_Locimp *))(*(_QWORD *)v4 + 16i64))(v4);
      if ( v6 )
        (**v6)(v6, 1i64);
    }
    v3 = v13;
  }
  if ( (v5 & 2) != 0 )
  {
    if ( v3 )
    {
      v7 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 16i64))(v3);
      if ( v7 )
        (**v7)(v7, 1i64);
    }
  }
  v8 = sub_14619AEC0((__int64)&v12);
  v9 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(struct std::locale::_Locimp *))(*(_QWORD *)v4 + 16i64))(v4);
  if ( v9 )
    (**v9)(v9, 1i64);
  (*(void (__fastcall **)(__int64, __int128 *))(*(_QWORD *)v8 + 40i64))(v8, &v16);
  if ( (_QWORD)v17 )
    v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 32i64))(v8);
  else
    v10 = 0;
  *(_OWORD *)a1 = v16;
  *(_OWORD *)(a1 + 16) = v17;
  *(_WORD *)(a1 + 32) = v10;
  return a1;
}

//----- (000000014619A530) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
unsigned __int64 __fastcall sub_14619A530(double a1)
{
  unsigned int v1; // edx
  unsigned int v2; // eax
  int v3; // edx
  int v4; // r9d
  __int64 *v6; // rcx
  __int128 *v7; // rax
  bool v8; // r11
  __int64 v9; // r8
  unsigned int v10; // esi
  unsigned int v11; // r10d
  __int128 v12; // xmm0
  __int128 v13; // xmm1
  __int128 v14; // xmm0
  __int128 v15; // xmm1
  __int128 v16; // xmm0
  __int128 v17; // xmm1
  __int128 v18; // xmm0
  __int128 v19; // xmm1
  unsigned int v20; // edi
  __int128 v21; // xmm1
  __int128 v22; // xmm0
  __int128 v23; // xmm1
  __int128 v24; // xmm0
  __int128 v25; // xmm1
  __int128 v26; // xmm0
  unsigned __int64 v27; // r12
  int v28; // r13d
  unsigned __int64 v29; // rbp
  unsigned int v30; // kr00_4
  unsigned int v31; // r8d
  unsigned int v32; // ebx
  unsigned int v33; // ebx
  int v34; // r8d
  unsigned int v35; // eax
  unsigned int v36; // r8d
  bool v37; // al
  unsigned int v38; // edx
  int v39; // r9d
  int v40; // edx
  int v41; // ecx
  int v42; // eax
  __int64 v43; // rcx
  __int64 v44[78]; // [rsp+20h] [rbp-298h] BYREF

  v1 = _mm_cvtsi128_si32(*(__m128i *)&a1);
  v2 = v1 >> 23;
  v3 = v1 & 0x7FFFFF;
  if ( (_BYTE)v2 )
  {
    v4 = (unsigned __int8)v2 - 150;
    if ( !v3 )
      return sub_146199B80(v4);
    v3 |= 0x800000u;
  }
  else
  {
    if ( !v3 )
      return 0i64;
    v4 = -149;
  }
  v6 = v44;
  v7 = (__int128 *)&unk_14612F950;
  v8 = (v3 & 1) == 0;
  v9 = 4i64;
  v10 = (1262611 * v4) >> 22;
  v11 = v10 - 1;
  do
  {
    v6 += 16;
    v12 = *v7;
    v13 = v7[1];
    v7 += 8;
    *((_OWORD *)v6 - 8) = v12;
    v14 = *(v7 - 6);
    *((_OWORD *)v6 - 7) = v13;
    v15 = *(v7 - 5);
    *((_OWORD *)v6 - 6) = v14;
    v16 = *(v7 - 4);
    *((_OWORD *)v6 - 5) = v15;
    v17 = *(v7 - 3);
    *((_OWORD *)v6 - 4) = v16;
    v18 = *(v7 - 2);
    *((_OWORD *)v6 - 3) = v17;
    v19 = *(v7 - 1);
    *((_OWORD *)v6 - 2) = v18;
    *((_OWORD *)v6 - 1) = v19;
    --v9;
  }
  while ( v9 );
  v20 = 2 * v3;
  v21 = v7[1];
  *(_OWORD *)v6 = *v7;
  v22 = v7[2];
  *((_OWORD *)v6 + 1) = v21;
  v23 = v7[3];
  *((_OWORD *)v6 + 2) = v22;
  v24 = v7[4];
  *((_OWORD *)v6 + 3) = v23;
  v25 = v7[5];
  *((_OWORD *)v6 + 4) = v24;
  v26 = v7[6];
  *((_OWORD *)v6 + 5) = v25;
  *((_OWORD *)v6 + 6) = v26;
  v27 = v44[31 - v11];
  v28 = v4 + ((int)(-1741647 * v11) >> 19);
  v29 = v27 >> (63 - ((unsigned __int8)v4 + (unsigned __int8)((int)(-1741647 * v11) >> 19)));
  v30 = ((((2 * v3) | 1u) << (v4 + ((int)(-1741647 * v11) >> 19))) * (unsigned __int128)v27) >> 64;
  v31 = v30 / 0x64;
  v32 = v30 % 0x64;
  if ( v30 % 0x64 > (unsigned int)v29 )
    goto LABEL_19;
  if ( v32 >= (unsigned int)v29 )
  {
    v38 = v20 - 1;
    if ( (!v8 || v4 < -1 || v4 > 6 && (v4 > 39 || dword_14612F300[2 * v11] * v38 > dword_14612F300[2 * v11 + 1]))
      && (((v27 * v38) >> (64 - (unsigned __int8)v28)) & 1) == 0 )
    {
      goto LABEL_19;
    }
  }
  else if ( !v32
         && (v3 & 1) != 0
         && v4 >= -1
         && (v4 <= 6 || v4 <= 39 && dword_14612F300[2 * v11] * ((2 * v3) | 1u) <= dword_14612F300[2 * v11 + 1]) )
  {
    --v31;
    v32 = 100;
LABEL_19:
    v33 = v32 - ((unsigned int)v29 >> 1);
    v34 = 10 * v31;
    v35 = v33 + 5;
    if ( (((_BYTE)v33 + 5) & 1) != 0 )
    {
      v43 = v34 + ((52429 * v35) >> 19);
      return v43 | ((unsigned __int64)v10 << 32);
    }
    v36 = ((52429 * (v35 >> 1)) >> 18) + v34;
    if ( (unsigned __int16)(-13107 * (v35 >> 1)) > 0x3333u )
      goto LABEL_45;
    if ( (((v27 * v20) >> (64 - (unsigned __int8)v28)) & 1) != 1 )
    {
LABEL_44:
      v43 = v36 - 1;
      return v43 | ((unsigned __int64)v10 << 32);
    }
    if ( v4 > 39 )
    {
LABEL_45:
      v43 = v36;
      return v43 | ((unsigned __int64)v10 << 32);
    }
    if ( v4 <= 6 )
    {
      if ( v4 >= -2 )
      {
LABEL_43:
        v43 = v36;
        if ( (v36 & 1) != 0 )
          goto LABEL_44;
        return v43 | ((unsigned __int64)v10 << 32);
      }
      _BitScanForward((unsigned int *)&v42, v20);
      v37 = v42 >= (int)(v10 - v4);
    }
    else
    {
      v37 = dword_14612F300[2 * v11] * v20 <= dword_14612F300[2 * v11 + 1];
    }
    v43 = v36;
    if ( !v37 )
      return v43 | ((unsigned __int64)v10 << 32);
    goto LABEL_43;
  }
  _BitScanForward((unsigned int *)&v39, v31);
  v40 = 0;
  if ( v39 <= 7 )
  {
    v41 = v39 - 1;
    if ( v39 - 1 <= 0 )
      goto LABEL_36;
  }
  else
  {
    v41 = 6;
    v39 = 7;
  }
  do
  {
    if ( -1030792151 * v31 > 0xA3D70A3 )
      break;
    v40 += 2;
    v31 *= -1030792151;
  }
  while ( v40 < v41 );
LABEL_36:
  if ( v40 < v39 && -858993459 * v31 <= 0x33333333 )
  {
    v31 *= -858993459;
    ++v40;
  }
  return ((unsigned __int64)(v11 + v40 + 2) << 32) | ((unsigned __int64)v31 >> v40);
}
// 14619A530: inconsistent variable size for 'xmm0_8.8'
// 14612F300: using guessed type _DWORD dword_14612F300[24];
// 14619A530: using guessed type __int64 var_298[78];

//----- (000000014619A920) ----------------------------------------------------
__int64 __fastcall sub_14619A920(__int64 a1, double a2)
{
  __int64 v3; // r14
  int v4; // esi
  int v5; // ebx
  int v6; // ebp
  unsigned __int64 v7; // r9
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rdx
  int v10; // ebx
  __int64 result; // rax
  unsigned __int64 v12; // r9
  int v13; // ebp
  unsigned __int64 v14; // r14
  __int64 v15; // rbx
  int v16; // r11d
  unsigned __int64 v17; // r13
  unsigned __int64 v18; // r15
  unsigned __int64 v19; // r12
  unsigned int v20; // r15d
  __int64 v21; // r8
  unsigned int v22; // r15d
  unsigned int v23; // ecx
  unsigned __int64 v24; // r8
  __int64 v25; // rcx
  bool v26; // al
  unsigned __int64 v27; // rax
  __m128i v28[2]; // [rsp+20h] [rbp-58h] BYREF
  bool v29; // [rsp+80h] [rbp+8h]
  char v30; // [rsp+88h] [rbp+10h]
  int v31; // [rsp+90h] [rbp+18h]

  v3 = *(_QWORD *)&a2 & 0xFFFFFFFFFFFFFi64;
  if ( ((*(_QWORD *)&a2 >> 52) & 0x7FF) == 0 )
  {
    if ( !v3 )
    {
      *(_QWORD *)a1 = 0i64;
      *(_DWORD *)(a1 + 8) = 0;
      return a1;
    }
    v4 = -1074;
LABEL_17:
    v29 = (v3 & 1) == 0;
    v31 = (1262611 * v4) >> 22;
    v13 = v31 - 2;
    sub_14619FB50(v28, 2 - v31);
    v14 = 2 * v3;
    v15 = v28[0].m128i_i64[0];
    v16 = v4 + ((1741647 * (2 - v31)) >> 19);
    v30 = v16;
    v17 = (unsigned __int64)v28[0].m128i_i64[0] >> (63 - (unsigned __int8)v16);
    v18 = (((((v14 | 1) << v16) * (unsigned __int128)v28[0].m128i_u64[1]) >> 64)
         + ((v14 | 1) << v16) * (unsigned __int128)v28[0].m128i_u64[0]) >> 64;
    v19 = (unsigned __int64)((v18 * (unsigned __int128)0x83126E978D4FDF3Cui64) >> 64) >> 9;
    *(_QWORD *)a1 = v19;
    v20 = v18 - 1000 * v19;
    if ( v20 > (unsigned int)v17 )
      goto LABEL_23;
    if ( v20 >= (unsigned int)v17 )
    {
      v25 = v14 - 1;
      if ( v29 )
      {
        if ( sub_146198CE0(v25, v4, v13) )
          goto LABEL_31;
        LOBYTE(v16) = v30;
        v25 = v14 - 1;
      }
      if ( (((unsigned __int64)((((unsigned __int64)v25 * (unsigned __int128)v28[0].m128i_u64[1]) >> 64) + v25 * v15) >> (64 - (unsigned __int8)v16)) & 1) == 0 )
      {
LABEL_23:
        v21 = 10 * v19;
        v22 = v20 - ((unsigned int)v17 >> 1);
        *(_DWORD *)(a1 + 8) = v31;
        v23 = v22 + 50;
        if ( (((_BYTE)v22 + 50) & 3) != 0 )
        {
          *(_QWORD *)a1 = v21 + ((unsigned __int64)(41944 * v23) >> 22);
          return a1;
        }
        v24 = ((unsigned __int64)(42025 * (v23 >> 2)) >> 20) + v21;
        *(_QWORD *)a1 = v24;
        if ( (unsigned __int8)(41 * (v23 >> 2)) > 0xAu )
          return a1;
        if ( (((unsigned __int64)((__PAIR128__(v15, v28[0].m128i_u64[1]) * v14) >> 64) >> (64 - (unsigned __int8)v16)) & 1) != (v23 & 1) )
        {
          *(_QWORD *)a1 = v24 - 1;
          return a1;
        }
        if ( v4 > 86 )
          return a1;
        if ( v4 <= 9 )
        {
          if ( v4 >= -4 )
            goto LABEL_38;
          _BitScanForward64(&v27, v14);
          v26 = (int)v27 >= v13 - v4 + 1;
        }
        else
        {
          v26 = qword_14612F360[2 * v13] * v14 <= qword_14612F360[2 * v13 + 1];
        }
        if ( !v26 )
          return a1;
LABEL_38:
        if ( (v24 & 1) != 0 )
          --v24;
        *(_QWORD *)a1 = v24;
        return a1;
      }
    }
    else if ( !v20 && !v29 && sub_146198CE0(v14 | 1, v4, v13) )
    {
      LOBYTE(v16) = v30;
      v20 = 1000;
      --v19;
      goto LABEL_23;
    }
LABEL_31:
    *(_DWORD *)(a1 + 8) = v13 + 3;
    *(_DWORD *)(a1 + 8) = v13 + 3 + sub_1461A0410((unsigned __int64 *)a1);
    return a1;
  }
  v4 = ((*(_QWORD *)&a2 >> 52) & 0x7FF) - 1075;
  if ( v3 )
  {
    v3 |= 0x10000000000000ui64;
    goto LABEL_17;
  }
  v5 = (1262611 * v4 - 524031) >> 22;
  v6 = v4 + ((-1741647 * v5) >> 19);
  sub_14619FB50(v28, -v5);
  v7 = v28[0].m128i_i64[0];
  v8 = ((v28[0].m128i_i64[0] - ((unsigned __int64)v28[0].m128i_i64[0] >> 54)) >> (11 - (unsigned __int8)v6)) + 1;
  if ( (unsigned int)((*(_QWORD *)&a2 >> 52) & 0x7FF) - 1077 <= 1 )
    v8 = (v28[0].m128i_i64[0] - ((unsigned __int64)v28[0].m128i_i64[0] >> 54)) >> (11 - (unsigned __int8)v6);
  v9 = ((v28[0].m128i_i64[0] + ((unsigned __int64)v28[0].m128i_i64[0] >> 53)) >> (11 - (unsigned __int8)v6)) / 0xA;
  *(_QWORD *)a1 = v9;
  if ( 10 * v9 >= v8 )
  {
    v10 = v5 + 1;
    *(_DWORD *)(a1 + 8) = v10;
    *(_DWORD *)(a1 + 8) = v10 + sub_1461A0410((unsigned __int64 *)a1);
    return a1;
  }
  *(_DWORD *)(a1 + 8) = v5;
  v12 = ((v7 >> (10 - (unsigned __int8)v6)) + 1) >> 1;
  *(_QWORD *)a1 = v12;
  if ( ((*(_QWORD *)&a2 >> 52) & 0x7FF) != 998 )
  {
    if ( v12 < v8 )
    {
      *(_QWORD *)a1 = v12 + 1;
      return a1;
    }
    return a1;
  }
  if ( (v12 & 1) != 0 )
    --v12;
  result = a1;
  *(_QWORD *)a1 = v12;
  return result;
}
// 14612F360: using guessed type _QWORD qword_14612F360[48];

//----- (000000014619AD00) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
std::locale::facet *__fastcall sub_14619AD00(__int64 a1)
{
  char v2; // si
  __int64 v3; // rbp
  __int64 v4; // rcx
  __int64 v5; // rbx
  std::locale::facet *v6; // rdi
  struct std::locale::_Locimp *v7; // rax
  __int64 v8; // rcx
  const char *v9; // rax
  std::_Locinfo *v10; // rbx
  char v12[144]; // [rsp+28h] [rbp-90h] BYREF
  std::locale::facet *v13; // [rsp+C0h] [rbp+8h] BYREF
  char v14; // [rsp+C8h] [rbp+10h] BYREF
  std::locale::facet *v15; // [rsp+D0h] [rbp+18h]

  v2 = 0;
  LODWORD(v13) = 0;
  std::_Lockit::_Lockit((std::_Lockit *)&v14, 0);
  v3 = qword_14611AC88;
  if ( !std::numpunct<char>::id )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v13, 0);
    std::numpunct<char>::id = ++std::locale::id::_Id_cnt;
    std::_Lockit::~_Lockit((std::_Lockit *)&v13);
  }
  v4 = *(_QWORD *)(a1 + 8);
  v5 = 8i64 * std::numpunct<char>::id;
  if ( std::numpunct<char>::id >= *(_QWORD *)(v4 + 24) )
  {
    v6 = 0i64;
  }
  else
  {
    v6 = *(std::locale::facet **)(v5 + *(_QWORD *)(v4 + 16));
    if ( v6 )
      goto LABEL_22;
  }
  if ( !*(_BYTE *)(v4 + 36) )
    goto LABEL_10;
  v7 = std::locale::_Getgloballocale();
  if ( std::numpunct<char>::id < *((_QWORD *)v7 + 3) )
  {
    v6 = *(std::locale::facet **)(v5 + *((_QWORD *)v7 + 2));
LABEL_10:
    if ( v6 )
      goto LABEL_22;
  }
  if ( v3 )
  {
    v6 = (std::locale::facet *)v3;
  }
  else
  {
    v6 = (std::locale::facet *)operator new(0x30ui64);
    v15 = v6;
    if ( v6 )
    {
      v8 = *(_QWORD *)(a1 + 8);
      if ( v8 )
        v9 = (const char *)std::_Yarn<char>::c_str(v8 + 40);
      else
        v9 = Src;
      v10 = (std::_Locinfo *)std::_Locinfo::_Locinfo((std::_Locinfo *)v12, v9);
      v2 = 1;
      LODWORD(v13) = 1;
      std::locale::facet::facet(v6, 0i64);
      *(_QWORD *)v6 = &std::numpunct<char>::`vftable';
      sub_14619EFB0((__int64)v6, v10, 1);
    }
    else
    {
      v6 = 0i64;
    }
    if ( (v2 & 1) != 0 )
      std::_Locinfo::~_Locinfo((std::_Locinfo *)v12);
    v13 = v6;
    sub_1461A7888((__int64)v6);
    (*(void (__fastcall **)(std::locale::facet *))(*(_QWORD *)v6 + 8i64))(v6);
    qword_14611AC88 = (__int64)v6;
  }
LABEL_22:
  std::_Lockit::~_Lockit((std::_Lockit *)&v14);
  return v6;
}
// 14619AD62: write access to const memory at 14611C398 has been detected
// 14619AD6E: write access to const memory at 14611C410 has been detected
// 14611AC88: using guessed type __int64 qword_14611AC88;
// 14611C398: using guessed type int std::locale::id::_Id_cnt;
// 14611C3C0: using guessed type _QWORD __fastcall std::_Locinfo::_Locinfo(std::_Locinfo *__hidden this, const char *);
// 14611C3C8: using guessed type void std::_Locinfo::~_Locinfo(std::_Locinfo *__hidden this);
// 14611C3E0: using guessed type __int64 __fastcall std::_Yarn<char>::c_str(_QWORD);
// 14611C3E8: using guessed type _QWORD __fastcall std::locale::facet::facet(std::locale::facet *__hidden this, unsigned __int64);
// 14611C468: using guessed type _QWORD __fastcall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 14611C470: using guessed type void std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 14612EE30: using guessed type void *std::numpunct<char>::`vftable';

//----- (000000014619AEC0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_14619AEC0(__int64 a1)
{
  char v2; // di
  __int64 v3; // rbp
  __int64 v4; // rcx
  __int64 v5; // rsi
  __int64 v6; // rbx
  struct std::locale::_Locimp *v7; // rax
  void *v8; // rbx
  __int64 v9; // rcx
  const char *v10; // rax
  std::_Locinfo *v11; // rax
  char v13[144]; // [rsp+28h] [rbp-90h] BYREF
  __int64 v14; // [rsp+C0h] [rbp+8h] BYREF
  char v15; // [rsp+C8h] [rbp+10h] BYREF
  void *v16; // [rsp+D0h] [rbp+18h]

  v2 = 0;
  LODWORD(v14) = 0;
  std::_Lockit::_Lockit((std::_Lockit *)&v15, 0);
  v3 = qword_14611AC80;
  if ( !std::numpunct<wchar_t>::id )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v14, 0);
    std::numpunct<wchar_t>::id = ++std::locale::id::_Id_cnt;
    std::_Lockit::~_Lockit((std::_Lockit *)&v14);
  }
  v4 = *(_QWORD *)(a1 + 8);
  v5 = 8i64 * std::numpunct<wchar_t>::id;
  if ( std::numpunct<wchar_t>::id >= *(_QWORD *)(v4 + 24) )
  {
    v6 = 0i64;
  }
  else
  {
    v6 = *(_QWORD *)(v5 + *(_QWORD *)(v4 + 16));
    if ( v6 )
      goto LABEL_22;
  }
  if ( !*(_BYTE *)(v4 + 36) )
    goto LABEL_10;
  v7 = std::locale::_Getgloballocale();
  if ( std::numpunct<wchar_t>::id < *((_QWORD *)v7 + 3) )
  {
    v6 = *(_QWORD *)(v5 + *((_QWORD *)v7 + 2));
LABEL_10:
    if ( v6 )
      goto LABEL_22;
  }
  if ( v3 )
  {
    v6 = v3;
  }
  else
  {
    v8 = operator new(0x30ui64);
    v16 = v8;
    if ( v8 )
    {
      v9 = *(_QWORD *)(a1 + 8);
      if ( v9 )
        v10 = (const char *)std::_Yarn<char>::c_str(v9 + 40);
      else
        v10 = Src;
      v11 = (std::_Locinfo *)std::_Locinfo::_Locinfo((std::_Locinfo *)v13, v10);
      v2 = 1;
      LODWORD(v14) = 1;
      v6 = (__int64)sub_14619E2B0((mbstate_t)v8, v11, 0i64, 1);
    }
    else
    {
      v6 = 0i64;
    }
    if ( (v2 & 1) != 0 )
      std::_Locinfo::~_Locinfo((std::_Locinfo *)v13);
    v14 = v6;
    sub_1461A7888(v6);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 8i64))(v6);
    qword_14611AC80 = v6;
  }
LABEL_22:
  std::_Lockit::~_Lockit((std::_Lockit *)&v15);
  return v6;
}
// 14619AF22: write access to const memory at 14611C398 has been detected
// 14619AF2E: write access to const memory at 14611C418 has been detected
// 14611AC80: using guessed type __int64 qword_14611AC80;
// 14611C398: using guessed type int std::locale::id::_Id_cnt;
// 14611C3C0: using guessed type _QWORD __fastcall std::_Locinfo::_Locinfo(std::_Locinfo *__hidden this, const char *);
// 14611C3C8: using guessed type void std::_Locinfo::~_Locinfo(std::_Locinfo *__hidden this);
// 14611C3E0: using guessed type __int64 __fastcall std::_Yarn<char>::c_str(_QWORD);
// 14611C468: using guessed type _QWORD __fastcall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 14611C470: using guessed type void std::_Lockit::~_Lockit(std::_Lockit *__hidden this);

//----- (000000014619B060) ----------------------------------------------------
void __fastcall sub_14619B060(__int64 a1, __int64 a2, __int64 *a3, __int64 a4)
{
  __int64 v5; // rcx
  __int64 v6; // rax
  int v7; // ecx
  __int128 pExceptionObject; // [rsp+28h] [rbp-29h] BYREF
  __int64 v9; // [rsp+38h] [rbp-19h]
  __int128 v10; // [rsp+48h] [rbp-9h] BYREF
  _BYTE v11[24]; // [rsp+58h] [rbp+7h] BYREF
  __int64 v12; // [rsp+70h] [rbp+1Fh]
  __int128 v13; // [rsp+78h] [rbp+27h]
  __int64 v14; // [rsp+88h] [rbp+37h]
  __int64 v15; // [rsp+90h] [rbp+3Fh]
  __int64 v16; // [rsp+B8h] [rbp+67h] BYREF

  v15 = -2i64;
  if ( *(_QWORD *)(a2 + 8) == 2i64 && **(_WORD **)a2 == 32123 )
  {
    LODWORD(v9) = 0;
    v5 = *a3;
    if ( *a3 >= 0 )
    {
      v7 = v5 & 0xF;
      LODWORD(v9) = v7;
      if ( !v7 )
        goto LABEL_9;
      v6 = a3[1];
    }
    else
    {
      if ( (int)v5 <= 0 )
        goto LABEL_12;
      v6 = a3[1];
      v9 = *(_QWORD *)(v6 + 16);
      v7 = v9;
    }
    pExceptionObject = *(_OWORD *)v6;
LABEL_9:
    if ( v7 )
    {
      *(_QWORD *)v11 = a1;
      *(_OWORD *)&v11[8] = *(_OWORD *)a3;
      v12 = a4;
      sub_14619B6F0(&v16, v11, (int *)&pExceptionObject);
      return;
    }
LABEL_12:
    *(_QWORD *)v11 = &std::exception::`vftable';
    *(_OWORD *)&v11[8] = 0i64;
    *(_QWORD *)&v10 = "argument not found";
    BYTE8(v10) = 1;
    _std_exception_copy(&v10);
    *(_QWORD *)v11 = &fmt::v8::format_error::`vftable';
    LOBYTE(v16) = 1;
    sub_146162440((__int64)&pExceptionObject, (__int64)v11);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  *(_OWORD *)v11 = *(_OWORD *)a2;
  *(_DWORD *)&v11[16] = 0;
  v12 = a1;
  v13 = *(_OWORD *)a3;
  v14 = a4;
  v10 = *(_OWORD *)a2;
  sub_146199020((__int64)&v10, (void ***)v11);
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014619B1C0) ----------------------------------------------------
__int64 *__fastcall sub_14619B1C0(__int64 *a1, __int64 *a2, unsigned int *a3)
{
  unsigned int v4; // r9d
  __int64 v5; // r11
  unsigned int v6; // ecx
  __int64 v7; // r8
  __int64 v8; // rax
  __int64 v9; // r9
  int v10; // ecx
  __int64 v11; // rax
  __int64 v12; // r9
  int v13; // r12d
  __int64 v14; // rdi
  __int64 v15; // r14
  __int64 v16; // rbx
  char v17; // cl
  unsigned int v18; // edx
  unsigned int v19; // ecx
  int v20; // ecx
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // r14
  char *v25; // r13
  __int64 v26; // rdi
  char v27; // al
  unsigned __int64 v28; // rax
  unsigned int v29; // ebx
  size_t v30; // rax
  __int128 pExceptionObject[2]; // [rsp+40h] [rbp-40h] BYREF
  _BYTE v33[24]; // [rsp+60h] [rbp-20h] BYREF
  __int64 v34; // [rsp+D0h] [rbp+50h] BYREF
  __int64 v35; // [rsp+D8h] [rbp+58h] BYREF

  switch ( a3[4] )
  {
    case 1u:
      v4 = *a3;
      v5 = a2[1];
      if ( (*a3 & 0x80000000) == 0 )
      {
        v6 = dword_14611CFB0[(__int64)(int)(*(_DWORD *)(v5 + 12) << 25) >> 29];
      }
      else
      {
        v6 = 16777261;
        v4 = -v4;
      }
      sub_14615EFB0(a1, *a2, v4 | ((unsigned __int64)v6 << 32), v5, a2[2]);
      break;
    case 2u:
      sub_14615EFB0(
        a1,
        *a2,
        *a3 | ((unsigned __int64)(unsigned int)dword_14611CFB0[(__int64)(int)(*(_DWORD *)(a2[1] + 12) << 25) >> 29] << 32),
        a2[1],
        a2[2]);
      break;
    case 3u:
      v7 = *(_QWORD *)a3;
      v8 = a2[2];
      v9 = a2[1];
      if ( v7 >= 0 )
      {
        v10 = dword_14611CFB0[(__int64)(int)(*(_DWORD *)(v9 + 12) << 25) >> 29];
      }
      else
      {
        v10 = 16777261;
        v7 = -v7;
      }
      *(_QWORD *)&pExceptionObject[0] = v7;
      DWORD2(pExceptionObject[0]) = v10;
      sub_14615F5D0(a1, *a2, (__int64)pExceptionObject, v9, v8);
      break;
    case 4u:
      v11 = a2[2];
      v12 = a2[1];
      *(_QWORD *)&pExceptionObject[0] = *(_QWORD *)a3;
      DWORD2(pExceptionObject[0]) = dword_14611CFB0[(__int64)(int)(*(_DWORD *)(v12 + 12) << 25) >> 29];
      sub_14615F5D0(a1, *a2, (__int64)pExceptionObject, v12, v11);
      break;
    case 7u:
      sub_14619CB40(a1, *a2, *(_BYTE *)a3, a2[1]);
      break;
    case 8u:
      v13 = *(char *)a3;
      v14 = a2[2];
      v15 = a2[1];
      v16 = *a2;
      v17 = *(_BYTE *)(v15 + 8);
      if ( !v17 || v17 == 99 )
      {
        v20 = *(_DWORD *)(v15 + 12);
        if ( (v20 & 0xF) == 4 || (v20 & 0x70) != 0 || (*(_BYTE *)(v15 + 16) & 1) != 0 )
        {
          *(_QWORD *)v33 = &std::exception::`vftable';
          *(_OWORD *)&v33[8] = 0i64;
          *(_QWORD *)&pExceptionObject[0] = "invalid format specifier for char";
          BYTE8(pExceptionObject[0]) = 1;
          _std_exception_copy(pExceptionObject);
          *(_QWORD *)v33 = &fmt::v8::format_error::`vftable';
          LOBYTE(v34) = 1;
          sub_146162440((__int64)pExceptionObject, (__int64)v33);
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
        }
        LOBYTE(v34) = *(_BYTE *)a3;
        sub_1461601E0(&v35, v16, (char *)v15, 1i64, 1ui64, &v34);
        *a1 = v35;
      }
      else
      {
        sub_146169020(v17, (__int64)&v34);
        v18 = v13;
        if ( v13 >= 0 )
        {
          v19 = dword_14611CFB0[(__int64)(int)(*(_DWORD *)(v15 + 12) << 25) >> 29];
        }
        else
        {
          v19 = 16777261;
          v18 = -v13;
        }
        sub_14615EFB0(&v34, v16, v18 | ((unsigned __int64)v19 << 32), v15, v14);
        *a1 = v34;
      }
      break;
    case 9u:
      v21 = a2[1];
      *(_OWORD *)v33 = *(_OWORD *)v21;
      *(_QWORD *)&v33[16] = *(_QWORD *)(v21 + 16);
      sub_14615DBD0(a1, *a2, *(float *)a3, (__int64)v33, a2[2]);
      break;
    case 0xAu:
      v22 = a2[1];
      *(_OWORD *)v33 = *(_OWORD *)v22;
      *(_QWORD *)&v33[16] = *(_QWORD *)(v22 + 16);
      sub_14615E050(a1, *a2, *(double *)a3, (__int64)v33, a2[2]);
      break;
    case 0xBu:
      v23 = a2[1];
      *(_OWORD *)v33 = *(_OWORD *)v23;
      *(_QWORD *)&v33[16] = *(_QWORD *)(v23 + 16);
      sub_14615E4D0(a1, *a2, *(long double *)a3, (__int64)v33, a2[2]);
      break;
    case 0xCu:
      v24 = *(_QWORD *)a3;
      v25 = (char *)a2[1];
      v26 = *a2;
      v27 = v25[8];
      if ( !v27 || v27 == 115 )
      {
        v30 = strlen(*(const char **)a3);
        *(_QWORD *)&pExceptionObject[0] = v24;
        *((_QWORD *)&pExceptionObject[0] + 1) = v30;
        *a1 = *sub_14615DA40(&v35, v26, (unsigned __int64 *)pExceptionObject, (__int64)v25);
      }
      else
      {
        if ( v27 != 112 )
        {
          *(_QWORD *)v33 = &std::exception::`vftable';
          *(_OWORD *)&v33[8] = 0i64;
          *(_QWORD *)&pExceptionObject[0] = "invalid type specifier";
          BYTE8(pExceptionObject[0]) = 1;
          _std_exception_copy(pExceptionObject);
          *(_QWORD *)v33 = &fmt::v8::format_error::`vftable';
          LOBYTE(v34) = 1;
          sub_146162440((__int64)pExceptionObject, (__int64)v33);
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
        }
        v28 = *(_QWORD *)a3;
        v29 = 0;
        do
        {
          ++v29;
          v28 >>= 4;
        }
        while ( v28 );
        *(_QWORD *)&pExceptionObject[0] = *(_QWORD *)a3;
        DWORD2(pExceptionObject[0]) = v29;
        sub_146160CD0(&v34, v26, v25, v29 + 2i64, v29 + 2i64, (__int64)pExceptionObject);
        *a1 = v34;
      }
      break;
    case 0xDu:
      pExceptionObject[0] = *(_OWORD *)a3;
      sub_14615DA40(a1, *a2, (unsigned __int64 *)pExceptionObject, a2[1]);
      break;
    case 0xEu:
      sub_14615E950(a1, *a2, *(_QWORD *)a3, (char *)a2[1]);
      break;
    default:
      *a1 = *a2;
      break;
  }
  return a1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 14611CFB0: using guessed type int dword_14611CFB0[];
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014619B6F0) ----------------------------------------------------
__int64 *__fastcall sub_14619B6F0(__int64 *a1, _QWORD *a2, int *a3)
{
  unsigned __int64 v5; // r14
  __int64 v6; // rbx
  __int64 v7; // rsi
  int v8; // eax
  int v9; // r15d
  __int64 v10; // r8
  unsigned __int64 v11; // r9
  unsigned __int64 v12; // rcx
  __int64 v13; // rdx
  bool v14; // zf
  _BYTE *v15; // rdx
  const char *v16; // rbx
  __int64 v17; // rax
  char v18; // r14
  __int64 v19; // rbx
  __m128i v20; // xmm2
  __int64 v21; // rbx
  int v22; // eax
  __int128 v23; // xmm6
  unsigned __int64 v24; // r10
  const char *v25; // rax
  const char *v26; // rcx
  __int64 v27; // r9
  char v28; // al
  double v29; // xmm2_8
  __int64 v30; // rcx
  __int128 v31; // xmm6
  const char *v32; // rax
  char v33; // al
  __int128 *v34; // rax
  __int128 *v35; // r9
  double v36; // xmm2_8
  __int64 v37; // rcx
  const char *v38; // rax
  char v39; // al
  char *v40; // rbx
  __int64 v41; // rsi
  size_t v42; // rax
  __int64 v43; // rbx
  unsigned __int64 v44; // rdx
  unsigned int v45; // ecx
  unsigned __int64 v46; // rax
  __m128i v47; // xmm1
  _BYTE pExceptionObject[24]; // [rsp+48h] [rbp-49h] BYREF
  __int64 v50; // [rsp+60h] [rbp-31h]
  __int64 v51; // [rsp+68h] [rbp-29h]
  _BYTE v52[24]; // [rsp+78h] [rbp-19h] BYREF
  __int128 v53; // [rsp+98h] [rbp+7h] BYREF

  v51 = -2i64;
  switch ( a3[4] )
  {
    case 1:
      sub_14619C860(a1, *a2, *a3);
      return a1;
    case 2:
      sub_14619C9B0(a1, (_QWORD *)*a2, *a3);
      return a1;
    case 3:
      v5 = *(_QWORD *)a3;
      v6 = *a2;
      v7 = *(_QWORD *)a3 >> 63;
      if ( *(__int64 *)a3 < 0 )
        v5 = -(__int64)v5;
      v8 = sub_146165560(v5);
      v9 = v8;
      v10 = *(_QWORD *)(v6 + 16);
      v11 = v8 + v10 + (unsigned __int8)v7;
      v12 = *(_QWORD *)(v6 + 24);
      if ( v12 < v11
        || (*(_QWORD *)(v6 + 16) = v11,
            v13 = *(_QWORD *)(v6 + 8),
            v14 = v10 + v13 == 0,
            v15 = (_BYTE *)(v10 + v13),
            v10 += v8 + (unsigned __int64)(unsigned __int8)v7,
            v14) )
      {
        if ( (_BYTE)v7 )
        {
          if ( v10 + 1 > v12 )
            (**(void (__fastcall ***)(__int64))v6)(v6);
          *(_BYTE *)(*(_QWORD *)(v6 + 16) + *(_QWORD *)(v6 + 8)) = 45;
          ++*(_QWORD *)(v6 + 16);
        }
        *a1 = sub_1461981B0(pExceptionObject, v6, v5, v9)[1];
      }
      else
      {
        if ( (_BYTE)v7 )
          *v15++ = 45;
        sub_14615ABC0(pExceptionObject, (__int64)v15, v5, v8);
        *a1 = v6;
      }
      return a1;
    case 4:
      sub_14619CAB0(a1, (_QWORD *)*a2, *(_QWORD *)a3);
      return a1;
    case 7:
      *(_QWORD *)v52 = 0xFFFFFFFF00000000ui64;
      v52[8] = 0;
      *(_DWORD *)&v52[12] &= 0xFFFFFF80;
      v52[16] &= 0xFCu;
      *(_DWORD *)&v52[17] = 32;
      v52[21] = 1;
      v16 = "false";
      if ( *(_BYTE *)a3 )
        v16 = "true";
      *(_QWORD *)pExceptionObject = v16;
      *(_QWORD *)&pExceptionObject[8] = strlen(v16);
      sub_146160390(
        (__int64 *)&v53,
        *a2,
        v52,
        *(__int64 *)&pExceptionObject[8],
        *(unsigned __int64 *)&pExceptionObject[8],
        (__int64)pExceptionObject);
      v17 = v53;
      goto LABEL_74;
    case 8:
      v18 = *(_BYTE *)a3;
      v19 = *a2;
      if ( (unsigned __int64)(*(_QWORD *)(*a2 + 16i64) + 1i64) > *(_QWORD *)(*a2 + 24i64) )
        (**(void (__fastcall ***)(_QWORD))v19)(*a2);
      *(_BYTE *)(*(_QWORD *)(v19 + 8) + (*(_QWORD *)(v19 + 16))++) = v18;
      *a1 = v19;
      return a1;
    case 9:
      v20 = (__m128i)(unsigned int)*a3;
      v21 = *a2;
      v22 = _mm_cvtsi128_si32(v20);
      v23 = 0i64;
      v53 = 0i64;
      if ( v22 < 0 )
      {
        DWORD2(v53) = 1;
        v20.m128i_i64[0] ^= 0x8000000080000000ui64;
        v23 = v53;
      }
      LODWORD(v24) = (unsigned int)v22 >> 31;
      if ( (v22 & 0x7F800000) != 2139095040 )
      {
        *(_QWORD *)&v53 = sub_14619A530(*(double *)v20.m128i_i64);
        *(_OWORD *)pExceptionObject = v23;
        sub_14619CC20(a1, v21, (int *)&v53, (char *)&xmmword_1461099B8, pExceptionObject, 46);
        return a1;
      }
      *(_OWORD *)v52 = xmmword_1461099B8;
      *(_QWORD *)&v52[16] = qword_1461099C8;
      if ( fabs(*(float *)v20.m128i_i32) >= INFINITY )
      {
        v25 = "INF";
        v26 = "inf";
      }
      else
      {
        v25 = "NAN";
        v26 = "nan";
      }
      if ( (BYTE12(v53) & 1) != 0 )
        v26 = v25;
      v27 = (unsigned int)v24 + 3i64;
      if ( BYTE5(qword_1461099C8) == 1 )
      {
        v28 = v52[17];
        if ( BYTE1(qword_1461099C8) == 48 )
          v28 = 32;
        v52[17] = v28;
      }
      goto LABEL_63;
    case 10:
      v29 = *(double *)a3;
      v21 = *a2;
      v30 = *(_QWORD *)a3;
      v31 = 0i64;
      v53 = 0i64;
      if ( v30 < 0 )
      {
        DWORD2(v53) = 1;
        v29 = -v29;
        v31 = v53;
      }
      v24 = (unsigned __int64)v30 >> 63;
      if ( (v30 & 0x7FF0000000000000i64) != 0x7FF0000000000000i64 )
      {
        v34 = (__int128 *)sub_14619A920((__int64)pExceptionObject, v29);
        v35 = &xmmword_1461099D0;
        goto LABEL_65;
      }
      *(_OWORD *)v52 = xmmword_1461099D0;
      *(_QWORD *)&v52[16] = qword_1461099E0;
      if ( fabs(v29) >= INFINITY )
      {
        v32 = "INF";
        v26 = "inf";
      }
      else
      {
        v32 = "NAN";
        v26 = "nan";
      }
      if ( (BYTE12(v53) & 1) != 0 )
        v26 = v32;
      v27 = (unsigned int)v24 + 3i64;
      if ( BYTE5(qword_1461099E0) == 1 )
      {
        v33 = v52[17];
        if ( BYTE1(qword_1461099E0) == 48 )
          v33 = 32;
        v52[17] = v33;
      }
      goto LABEL_63;
    case 11:
      v36 = *(double *)a3;
      v21 = *a2;
      v37 = *(_QWORD *)a3;
      v31 = 0i64;
      v53 = 0i64;
      if ( v37 < 0 )
      {
        DWORD2(v53) = 1;
        v36 = -v36;
        v31 = v53;
      }
      v24 = (unsigned __int64)v37 >> 63;
      if ( (v37 & 0x7FF0000000000000i64) == 0x7FF0000000000000i64 )
      {
        *(_OWORD *)v52 = xmmword_1461099E8;
        *(_QWORD *)&v52[16] = qword_1461099F8;
        if ( fabs(v36) >= INFINITY )
        {
          v38 = "INF";
          v26 = "inf";
        }
        else
        {
          v38 = "NAN";
          v26 = "nan";
        }
        if ( (BYTE12(v53) & 1) != 0 )
          v26 = v38;
        v27 = (unsigned int)v24 + 3i64;
        if ( BYTE5(qword_1461099F8) == 1 )
        {
          v39 = v52[17];
          if ( BYTE1(qword_1461099F8) == 48 )
            v39 = 32;
          v52[17] = v39;
        }
LABEL_63:
        *(_DWORD *)pExceptionObject = v24;
        *(_QWORD *)&pExceptionObject[8] = v26;
        *(_QWORD *)&pExceptionObject[16] = 3i64;
        sub_146160020(a1, v21, v52, v27, (unsigned int)v24 + 3i64, (char **)pExceptionObject);
      }
      else
      {
        v34 = (__int128 *)sub_14619A920((__int64)pExceptionObject, v36);
        v35 = &xmmword_1461099E8;
LABEL_65:
        v53 = *v34;
        *(_OWORD *)pExceptionObject = v31;
        sub_14619CF40(a1, v21, (__int64)&v53, (char *)v35, (__int64)pExceptionObject, 46);
      }
      return a1;
    case 12:
      v40 = *(char **)a3;
      v41 = *a2;
      if ( !*(_QWORD *)a3 )
      {
        *(_QWORD *)v52 = &std::exception::`vftable';
        *(_OWORD *)&v52[8] = 0i64;
        *(_QWORD *)pExceptionObject = "string pointer is null";
        pExceptionObject[8] = 1;
        _std_exception_copy(pExceptionObject);
        *(_QWORD *)v52 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)pExceptionObject, (__int64)v52);
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      v42 = strlen(*(const char **)a3);
      sub_14615AAE0(v41, v40, &v40[v42]);
      *a1 = v41;
      return a1;
    case 13:
      v43 = *a2;
      sub_14615AAE0(*a2, *(char **)a3, (char *)(*(_QWORD *)a3 + *((_QWORD *)a3 + 1)));
      *a1 = v43;
      return a1;
    case 14:
      v44 = *(_QWORD *)a3;
      v45 = 0;
      *(_QWORD *)v52 = 0xFFFFFFFF00000000ui64;
      v52[8] = 0;
      *(_DWORD *)&v52[12] &= 0xFFFFFF80;
      v52[16] &= 0xFCu;
      *(_DWORD *)&v52[17] = 32;
      v52[21] = 1;
      v46 = v44;
      do
      {
        ++v45;
        v46 >>= 4;
      }
      while ( v46 );
      *(_QWORD *)pExceptionObject = v44;
      *(_DWORD *)&pExceptionObject[8] = v45;
      sub_146160CD0(&v53, *a2, v52, v45 + 2i64, v45 + 2i64, (__int64)pExceptionObject);
      v17 = v53;
      goto LABEL_74;
    case 15:
      v47 = *(__m128i *)a3;
      memset(v52, 0, 20);
      *(_QWORD *)pExceptionObject = *a2;
      *(_OWORD *)&pExceptionObject[8] = *(_OWORD *)(a2 + 1);
      v50 = a2[3];
      ((void (__fastcall *)(__int64, _BYTE *, _BYTE *))_mm_srli_si128(v47, 8).m128i_i64[0])(
        v47.m128i_i64[0],
        v52,
        pExceptionObject);
      v17 = *(_QWORD *)pExceptionObject;
      goto LABEL_74;
    default:
      v17 = *a2;
LABEL_74:
      *a1 = v17;
      return a1;
  }
}
// 1461099B8: using guessed type __int128 xmmword_1461099B8;
// 1461099C8: using guessed type __int64 qword_1461099C8;
// 1461099D0: using guessed type __int128 xmmword_1461099D0;
// 1461099E0: using guessed type __int64 qword_1461099E0;
// 1461099E8: using guessed type __int128 xmmword_1461099E8;
// 1461099F8: using guessed type __int64 qword_1461099F8;
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014619BE40) ----------------------------------------------------
__int64 __fastcall sub_14619BE40(__int64 a1, unsigned int *a2)
{
  __int64 v2; // rdi
  __int64 result; // rax
  const char *pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  char v5; // [rsp+30h] [rbp-30h]
  void **v6; // [rsp+40h] [rbp-20h] BYREF
  __int128 v7; // [rsp+48h] [rbp-18h]
  unsigned __int8 v8; // [rsp+78h] [rbp+18h]

  switch ( a2[4] )
  {
    case 1u:
      v2 = (int)*a2;
      if ( (*a2 & 0x80000000) != 0 )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "negative precision";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      goto LABEL_3;
    case 2u:
      return *a2;
    case 3u:
      v2 = *(_QWORD *)a2;
      if ( *(__int64 *)a2 < 0 )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "negative precision";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
LABEL_3:
      result = v2;
      break;
    case 4u:
      result = *(_QWORD *)a2;
      break;
    case 7u:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 8u:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 9u:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xAu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xBu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xCu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xDu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xEu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xFu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "precision is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    default:
      sub_146196480(a1, v8);
  }
  return result;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 146196480: using guessed type void __fastcall __noreturn sub_146196480(_QWORD, _QWORD);
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014619C350) ----------------------------------------------------
__int64 __fastcall sub_14619C350(__int64 a1, unsigned int *a2)
{
  __int64 v2; // rdi
  __int64 result; // rax
  const char *pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  char v5; // [rsp+30h] [rbp-30h]
  void **v6; // [rsp+40h] [rbp-20h] BYREF
  __int128 v7; // [rsp+48h] [rbp-18h]
  unsigned __int8 v8; // [rsp+78h] [rbp+18h]

  switch ( a2[4] )
  {
    case 1u:
      v2 = (int)*a2;
      if ( (*a2 & 0x80000000) != 0 )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "negative width";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      goto LABEL_3;
    case 2u:
      return *a2;
    case 3u:
      v2 = *(_QWORD *)a2;
      if ( *(__int64 *)a2 < 0 )
      {
        v6 = &std::exception::`vftable';
        v7 = 0i64;
        pExceptionObject = "negative width";
        v5 = 1;
        _std_exception_copy(&pExceptionObject);
        v6 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
LABEL_3:
      result = v2;
      break;
    case 4u:
      result = *(_QWORD *)a2;
      break;
    case 7u:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 8u:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 9u:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xAu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xBu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xCu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xDu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xEu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    case 0xFu:
      v6 = &std::exception::`vftable';
      v7 = 0i64;
      pExceptionObject = "width is not integer";
      v5 = 1;
      _std_exception_copy(&pExceptionObject);
      v6 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v6);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    default:
      sub_146196500(a1, v8);
  }
  return result;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 146196500: using guessed type void __fastcall __noreturn sub_146196500(_QWORD, _QWORD);
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014619C860) ----------------------------------------------------
__int64 *__fastcall sub_14619C860(__int64 *a1, __int64 a2, int a3)
{
  _BOOL8 v3; // r9
  __int64 v5; // rdx
  unsigned int v6; // eax
  __int64 v8; // rdi
  unsigned __int64 v9; // rbp
  unsigned __int64 v10; // r8
  __int64 v11; // rcx
  bool v12; // zf
  _BYTE *v13; // rcx
  _WORD *i; // rcx
  __int16 v15; // ax
  __int64 v17[5]; // [rsp+20h] [rbp-28h] BYREF

  v3 = a3 < 0;
  v5 = *(_QWORD *)(a2 + 16);
  v6 = -a3;
  if ( a3 >= 0 )
    v6 = a3;
  v8 = v6;
  _BitScanReverse(&v6, v6 | 1);
  v9 = (unsigned __int64)(v8 + qword_14611CFD0[v6]) >> 32;
  v10 = (int)v9 + v5 + v3;
  if ( *(_QWORD *)(a2 + 24) < v10
    || (v11 = *(_QWORD *)(a2 + 8),
        v12 = v5 + v11 == 0,
        v13 = (_BYTE *)(v5 + v11),
        *(_QWORD *)(a2 + 16) = v10,
        v5 += (int)v9 + v3,
        v12) )
  {
    if ( v3 )
    {
      if ( (unsigned __int64)(v5 + 1) > *(_QWORD *)(a2 + 24) )
        (**(void (__fastcall ***)(__int64))a2)(a2);
      *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = 45;
      ++*(_QWORD *)(a2 + 16);
    }
    *a1 = sub_146198090(v17, a2, v8, v9)[1];
  }
  else
  {
    if ( v3 )
      *v13++ = 45;
    for ( i = &v13[(int)v9]; (unsigned int)v8 >= 0x64; *i = v15 )
    {
      --i;
      v15 = *(_WORD *)&a00010203040506[2 * ((unsigned int)v8 % 0x64)];
      LODWORD(v8) = (unsigned int)v8 / 0x64;
    }
    *a1 = a2;
    if ( (unsigned int)v8 >= 0xA )
      *(i - 1) = *(_WORD *)&a00010203040506[2 * (unsigned int)v8];
    else
      *((_BYTE *)i - 1) = v8 + 48;
  }
  return a1;
}
// 14611CFD0: using guessed type __int64 qword_14611CFD0[32];
// 14619C860: using guessed type __int64 var_28[5];

//----- (000000014619C9B0) ----------------------------------------------------
_QWORD *__fastcall sub_14619C9B0(_QWORD *a1, _QWORD *a2, unsigned int a3)
{
  unsigned int v4; // eax
  __int64 v5; // rcx
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rax
  __int64 v8; // rcx
  _WORD *i; // rcx
  __int16 v10; // ax
  _QWORD *result; // rax
  __int64 v12; // rcx
  __int64 v13[3]; // [rsp+20h] [rbp-18h] BYREF

  _BitScanReverse(&v4, a3 | 1);
  v5 = a2[2];
  v6 = ((unsigned __int64)a3 + qword_14611CFD0[v4]) >> 32;
  v7 = v5 + (int)v6;
  if ( a2[3] >= v7 && (a2[2] = v7, (v8 = a2[1] + v5) != 0) )
  {
    for ( i = (_WORD *)((int)v6 + v8); a3 >= 0x64; *i = v10 )
    {
      --i;
      v10 = *(_WORD *)&a00010203040506[2 * (a3 % 0x64)];
      a3 /= 0x64u;
    }
    *a1 = a2;
    if ( a3 >= 0xA )
      *(i - 1) = *(_WORD *)&a00010203040506[2 * a3];
    else
      *((_BYTE *)i - 1) = a3 + 48;
    return a1;
  }
  else
  {
    v12 = sub_146198090(v13, (__int64)a2, a3, v6)[1];
    result = a1;
    *a1 = v12;
  }
  return result;
}
// 14611CFD0: using guessed type __int64 qword_14611CFD0[32];
// 14619C9B0: using guessed type __int64 var_18[3];

//----- (000000014619CAB0) ----------------------------------------------------
_QWORD *__fastcall sub_14619CAB0(_QWORD *a1, _QWORD *a2, unsigned __int64 a3)
{
  int v6; // eax
  __int64 v7; // r8
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // rdx
  _QWORD *result; // rax
  __int64 v12; // rcx
  _QWORD v13[3]; // [rsp+20h] [rbp-18h] BYREF

  v6 = sub_146165560(a3);
  v7 = a2[2];
  v8 = v7 + v6;
  if ( a2[3] >= v8 && (v9 = a2[1], a2[2] = v8, (v10 = v7 + v9) != 0) )
  {
    sub_14615ABC0(v13, v10, a3, v6);
    result = a1;
    *a1 = a2;
  }
  else
  {
    v12 = sub_1461981B0(v13, (__int64)a2, a3, v6)[1];
    result = a1;
    *a1 = v12;
  }
  return result;
}
// 14619CAB0: using guessed type _QWORD var_18[3];

//----- (000000014619CB40) ----------------------------------------------------
_QWORD *__fastcall sub_14619CB40(_QWORD *a1, __int64 a2, unsigned __int8 a3, __int64 a4)
{
  char v7; // al
  const char *v8; // rdi
  const char *v10; // [rsp+30h] [rbp-18h] BYREF
  size_t v11; // [rsp+38h] [rbp-10h]
  __int64 v12; // [rsp+50h] [rbp+8h] BYREF

  v7 = *(_BYTE *)(a4 + 8);
  if ( !v7 || v7 == 115 )
  {
    v8 = "false";
    if ( a3 )
      v8 = "true";
    v10 = v8;
    v11 = strlen(v8);
    sub_146160390(&v12, a2, (char *)a4, v11, v11, (__int64)&v10);
  }
  else
  {
    sub_14615EFB0(
      &v12,
      a2,
      a3 | ((unsigned __int64)(unsigned int)dword_14611CFB0[(__int64)(int)(*(_DWORD *)(a4 + 12) << 25) >> 29] << 32),
      a4,
      0i64);
  }
  *a1 = v12;
  return a1;
}
// 14611CFB0: using guessed type int dword_14611CFB0[];

//----- (000000014619CC20) ----------------------------------------------------
__int64 *__fastcall sub_14619CC20(__int64 *a1, __int64 a2, int *a3, char *a4, char *a5, char a6)
{
  int v6; // eax
  __int64 v7; // r15
  __int64 v10; // r9
  __int64 v12; // r8
  unsigned __int64 v13; // rdi
  int v14; // ecx
  int v15; // esi
  __int64 v16; // r11
  int v17; // eax
  unsigned __int64 v18; // r11
  int v19; // eax
  bool v20; // zf
  int v21; // eax
  int v22; // ecx
  int v23; // eax
  unsigned __int64 v24; // r9
  char v25; // r8
  __int64 v26; // r15
  char v27; // r10
  __int64 v28; // rcx
  int v29; // eax
  unsigned __int64 v30; // r9
  __int64 v31; // rax
  char v33; // [rsp+30h] [rbp-49h] BYREF
  int *v34; // [rsp+34h] [rbp-45h] BYREF
  int v35; // [rsp+3Ch] [rbp-3Dh] BYREF
  __int64 v36; // [rsp+40h] [rbp-39h] BYREF
  int v37; // [rsp+48h] [rbp-31h] BYREF
  int v38; // [rsp+4Ch] [rbp-2Dh] BYREF
  int **v39; // [rsp+50h] [rbp-29h] BYREF
  char *v40; // [rsp+58h] [rbp-21h]
  int *v41; // [rsp+60h] [rbp-19h]
  int *v42; // [rsp+68h] [rbp-11h]
  char *v43; // [rsp+70h] [rbp-9h]
  __int64 *v44; // [rsp+78h] [rbp-1h]
  __int64 *v45; // [rsp+80h] [rbp+7h]
  __int64 v46[7]; // [rsp+88h] [rbp+Fh] BYREF

  v6 = *a3 | 1;
  HIDWORD(v34) = *a3;
  _BitScanReverse((unsigned int *)&v6, v6);
  v7 = *(_QWORD *)a5;
  v10 = 0i64;
  LODWORD(v34) = a5[8];
  v12 = (unsigned int)a3[1];
  v38 = 0;
  v13 = ((unsigned __int64)HIDWORD(v34) + qword_14611CFD0[v6]) >> 32;
  v35 = v13;
  v14 = v12 + v13;
  v15 = v12 + v13 - 1;
  v16 = (unsigned int)v13 + ((_DWORD)v34 != 0);
  if ( BYTE4(v7) == 1 )
    goto LABEL_30;
  if ( !BYTE4(v7) )
  {
    if ( v15 < -4 )
      goto LABEL_30;
    v17 = 16;
    if ( (int)v7 > 0 )
      v17 = v7;
    if ( v15 >= v17 )
    {
LABEL_30:
      v25 = a5[12];
      v26 = 0i64;
      if ( (v25 & 0x10) != 0 )
      {
        if ( *(_DWORD *)a5 - (int)v13 >= 0 )
          v26 = (unsigned int)(*(_DWORD *)a5 - v13);
        v16 += v26;
      }
      else if ( (_DWORD)v13 == 1 )
      {
        v27 = 0;
        a6 = 0;
        goto LABEL_35;
      }
      v27 = a6;
LABEL_35:
      v28 = 2i64;
      v29 = -v15;
      if ( v15 > 0 )
        v29 = v15;
      if ( v29 >= 100 )
        v28 = (v29 >= 1000) + 3i64;
      v39 = (int **)v34;
      LOBYTE(v10) = v27 != 0;
      LODWORD(v40) = v13;
      BYTE4(v40) = v27;
      LODWORD(v41) = v26;
      LODWORD(v42) = v15;
      v30 = v16 + v28 + v10 + 2;
      BYTE4(v41) = ~(32 * v25) & 0x20 | 0x45;
      if ( *(int *)a4 <= 0 )
      {
        v31 = *sub_14619EBE0((int *)&v39, v46, a2);
      }
      else
      {
        sub_14619DB90(&v36, a2, a4, v30, v30, (int *)&v39);
        v31 = v36;
      }
      *a1 = v31;
      return a1;
    }
  }
  v38 = v12 + v13;
  if ( (int)v12 >= 0 )
  {
    v18 = v12 + v16;
    v19 = *(_DWORD *)a5 - v14;
    v20 = (a5[12] & 0x10) == 0;
    LODWORD(v36) = v19;
    if ( !v20 )
    {
      if ( v19 > 0 )
      {
LABEL_12:
        v18 += (unsigned int)(v19 + 1);
        goto LABEL_13;
      }
      if ( a5[4] != 2 )
      {
        v19 = 1;
        LODWORD(v36) = 1;
        goto LABEL_12;
      }
    }
LABEL_13:
    v42 = a3;
    v39 = &v34;
    v43 = a5;
    v40 = (char *)&v34 + 4;
    v41 = &v35;
    v44 = (__int64 *)&a6;
    v45 = &v36;
    sub_14619D3C0(a1, a2, a4, v18, v18, (int **)&v39);
    return a1;
  }
  if ( v14 <= 0 )
  {
    v22 = -v14;
    v37 = v22;
    v23 = v22;
    if ( !(_DWORD)v13 && *(int *)a5 >= 0 && *(_DWORD *)a5 < v22 )
    {
      v22 = *(_DWORD *)a5;
      v23 = *(_DWORD *)a5;
      v37 = *(_DWORD *)a5;
    }
    if ( v23 || (_DWORD)v13 || (a5[12] & 0x10) != 0 )
      LOBYTE(v23) = 1;
    v33 = v23;
    v24 = v16 + v22 + 1 + (unsigned int)(unsigned __int8)v23;
    v39 = &v34;
    v40 = &v33;
    v41 = (int *)&a6;
    v42 = &v37;
    v43 = (char *)&v34 + 4;
    v44 = (__int64 *)&v35;
    sub_14619D8B0(a1, a2, a4, v24, v24, (int **)&v39);
  }
  else
  {
    if ( (a5[12] & 0x10) != 0 )
      v21 = *(_DWORD *)a5 - v13;
    else
      v21 = 0;
    LODWORD(v36) = v21;
    if ( v21 > 0 )
      LODWORD(v10) = v21;
    v39 = &v34;
    v40 = (char *)&v34 + 4;
    v41 = &v35;
    v42 = &v38;
    v43 = &a6;
    v44 = &v36;
    sub_14619DD00(a1, a2, a4, v16 + (unsigned int)(v10 + 1), v16 + (unsigned int)(v10 + 1), (int **)&v39);
  }
  return a1;
}
// 14611CFD0: using guessed type __int64 qword_14611CFD0[32];
// 14619CC20: using guessed type __int64 var_38[7];

//----- (000000014619CF40) ----------------------------------------------------
__int64 *__fastcall sub_14619CF40(__int64 *a1, __int64 a2, __int64 a3, char *a4, __int64 a5, char a6)
{
  int v10; // r11d
  __int64 v11; // r8
  __int64 v12; // rdx
  unsigned __int64 v13; // rcx
  int v14; // esi
  __int64 v15; // r9
  int v16; // eax
  int v17; // ecx
  unsigned __int64 v18; // r9
  int v19; // eax
  bool v20; // zf
  int v21; // eax
  int v22; // ecx
  int v23; // eax
  int v24; // edx
  unsigned __int64 v25; // r9
  char v26; // r8
  __int64 v27; // r15
  char v28; // r10
  __int64 v29; // rcx
  int v30; // eax
  unsigned __int64 v31; // r9
  __int64 v32; // rax
  char v34; // [rsp+30h] [rbp-59h] BYREF
  int v35; // [rsp+34h] [rbp-55h] BYREF
  int v36; // [rsp+38h] [rbp-51h] BYREF
  __int64 v37; // [rsp+40h] [rbp-49h] BYREF
  int v38; // [rsp+48h] [rbp-41h] BYREF
  unsigned __int64 *v39; // [rsp+50h] [rbp-39h] BYREF
  int *v40; // [rsp+58h] [rbp-31h] BYREF
  unsigned __int64 *v41; // [rsp+60h] [rbp-29h]
  int *v42; // [rsp+68h] [rbp-21h]
  int *v43; // [rsp+70h] [rbp-19h]
  unsigned __int64 *v44; // [rsp+78h] [rbp-11h]
  __int64 *v45; // [rsp+80h] [rbp-9h]
  __int64 *v46; // [rsp+88h] [rbp-1h]
  int v47; // [rsp+90h] [rbp+7h] BYREF
  __int64 v48[7]; // [rsp+98h] [rbp+Fh] BYREF

  v39 = *(unsigned __int64 **)a3;
  v10 = sub_146165560((unsigned __int64)v39);
  v11 = *(unsigned int *)(a3 + 8);
  v12 = 0i64;
  v36 = v10;
  v13 = *(_QWORD *)a5;
  v35 = *(char *)(a5 + 8);
  v14 = v10 + v11 - 1;
  v15 = v10 + (unsigned int)(v35 != 0);
  if ( BYTE4(v13) == 1 )
    goto LABEL_30;
  if ( !BYTE4(v13) )
  {
    if ( v14 < -4 )
      goto LABEL_30;
    v16 = 16;
    if ( (int)v13 > 0 )
      v16 = v13;
    if ( v14 >= v16 )
    {
LABEL_30:
      v26 = *(_BYTE *)(a5 + 12);
      v27 = 0i64;
      if ( (v26 & 0x10) != 0 )
      {
        if ( *(_DWORD *)a5 - v10 >= 0 )
          v27 = (unsigned int)(*(_DWORD *)a5 - v10);
        v15 += v27;
      }
      else if ( v10 == 1 )
      {
        v28 = 0;
        a6 = 0;
        goto LABEL_35;
      }
      v28 = a6;
LABEL_35:
      v29 = 2i64;
      v30 = -v14;
      if ( v14 > 0 )
        v30 = v14;
      if ( v30 >= 100 )
        v29 = (v30 >= 1000) + 3i64;
      LODWORD(v40) = v35;
      LOBYTE(v12) = v28 != 0;
      v41 = v39;
      LODWORD(v42) = v10;
      BYTE4(v42) = v28;
      LODWORD(v43) = v27;
      LODWORD(v44) = v14;
      v31 = v29 + v12 + 2 + v15;
      BYTE4(v43) = ~(32 * v26) & 0x20 | 0x45;
      if ( *(int *)a4 <= 0 )
      {
        v32 = *sub_14619E7F0((int *)&v40, v48, a2);
      }
      else
      {
        sub_14619D740(&v37, a2, a4, v31, v31, (int *)&v40);
        v32 = v37;
      }
      *a1 = v32;
      return a1;
    }
  }
  v17 = v11 + v10;
  v47 = v11 + v10;
  if ( (int)v11 >= 0 )
  {
    v18 = v11 + v15;
    v19 = *(_DWORD *)a5 - v17;
    v20 = (*(_BYTE *)(a5 + 12) & 0x10) == 0;
    LODWORD(v37) = v19;
    if ( !v20 )
    {
      if ( v19 > 0 )
      {
LABEL_12:
        v18 += (unsigned int)(v19 + 1);
        goto LABEL_13;
      }
      if ( *(_BYTE *)(a5 + 4) != 2 )
      {
        v19 = 1;
        LODWORD(v37) = 1;
        goto LABEL_12;
      }
    }
LABEL_13:
    v43 = (int *)a3;
    v40 = &v35;
    v44 = (unsigned __int64 *)a5;
    v41 = (unsigned __int64 *)&v39;
    v42 = &v36;
    v45 = (__int64 *)&a6;
    v46 = &v37;
    sub_14619D250(a1, a2, a4, v18, v18, &v40);
    return a1;
  }
  if ( v17 <= 0 )
  {
    v22 = -v17;
    v38 = v22;
    v23 = v22;
    if ( !v10 )
    {
      v24 = *(_DWORD *)a5;
      if ( *(int *)a5 >= 0 && v24 < v22 )
      {
        v22 = *(_DWORD *)a5;
        v38 = *(_DWORD *)a5;
        v23 = v24;
      }
    }
    if ( v23 || v10 || (*(_BYTE *)(a5 + 12) & 0x10) != 0 )
      LOBYTE(v23) = 1;
    v34 = v23;
    v25 = v22 + 1 + (unsigned int)(unsigned __int8)v23 + v15;
    v40 = &v35;
    v41 = (unsigned __int64 *)&v34;
    v42 = (int *)&a6;
    v43 = &v38;
    v44 = (unsigned __int64 *)&v39;
    v45 = (__int64 *)&v36;
    sub_14619DA20(a1, a2, a4, v25, v25, &v40);
  }
  else
  {
    if ( (*(_BYTE *)(a5 + 12) & 0x10) != 0 )
      v21 = *(_DWORD *)a5 - v10;
    else
      v21 = 0;
    LODWORD(v37) = v21;
    if ( v21 > 0 )
      LODWORD(v12) = v21;
    v40 = &v35;
    v41 = (unsigned __int64 *)&v39;
    v42 = &v36;
    v43 = &v47;
    v44 = (unsigned __int64 *)&a6;
    v45 = &v37;
    sub_14619D530(a1, a2, a4, (unsigned int)(v12 + 1) + v15, (unsigned int)(v12 + 1) + v15, &v40);
  }
  return a1;
}
// 14619CF40: using guessed type __int64 var_38[7];

//----- (000000014619D250) ----------------------------------------------------
__int64 *__fastcall sub_14619D250(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6)
{
  unsigned __int64 v9; // rdi
  char v10; // cl
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rdi
  __int64 v13; // rax
  char *v14; // r14
  char *v15; // rbp
  __int64 v16; // rbx
  __int64 v17; // rax
  _BYTE *v18; // rsi
  char *v19; // rbp
  __int64 *result; // rax

  v9 = *(unsigned int *)a3 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v9 = 0i64;
  v10 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v11 = v9 >> v10;
  v12 = v9 - (v9 >> v10);
  if ( v11 )
  {
    v13 = (unsigned __int8)a3[21];
    v14 = a3 + 17;
    if ( v13 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = *v14;
        ++*(_QWORD *)(a2 + 16);
        --v11;
      }
      while ( v11 );
    }
    else
    {
      v15 = &v14[v13];
      do
      {
        sub_14615AAE0(a2, v14, v15);
        --v11;
      }
      while ( v11 );
    }
  }
  v16 = *sub_14619E550(a6, &a5, a2);
  if ( v12 )
  {
    v17 = (unsigned __int8)a3[21];
    v18 = a3 + 17;
    if ( v17 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v16 + 16) + 1i64) > *(_QWORD *)(v16 + 24) )
          (**(void (__fastcall ***)(__int64))v16)(v16);
        *(_BYTE *)(*(_QWORD *)(v16 + 16) + *(_QWORD *)(v16 + 8)) = *v18;
        ++*(_QWORD *)(v16 + 16);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v19 = &v18[v17];
      do
      {
        sub_14615AAE0(v16, a3 + 17, v19);
        --v12;
      }
      while ( v12 );
    }
  }
  result = a1;
  *a1 = v16;
  return result;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014619D3C0) ----------------------------------------------------
__int64 *__fastcall sub_14619D3C0(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6)
{
  unsigned __int64 v9; // rdi
  char v10; // cl
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rdi
  __int64 v13; // rax
  char *v14; // r14
  char *v15; // rbp
  __int64 v16; // rbx
  __int64 v17; // rax
  _BYTE *v18; // rsi
  char *v19; // rbp
  __int64 *result; // rax

  v9 = *(unsigned int *)a3 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v9 = 0i64;
  v10 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v11 = v9 >> v10;
  v12 = v9 - (v9 >> v10);
  if ( v11 )
  {
    v13 = (unsigned __int8)a3[21];
    v14 = a3 + 17;
    if ( v13 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = *v14;
        ++*(_QWORD *)(a2 + 16);
        --v11;
      }
      while ( v11 );
    }
    else
    {
      v15 = &v14[v13];
      do
      {
        sub_14615AAE0(a2, v14, v15);
        --v11;
      }
      while ( v11 );
    }
  }
  v16 = *sub_14619E6A0(a6, &a5, a2);
  if ( v12 )
  {
    v17 = (unsigned __int8)a3[21];
    v18 = a3 + 17;
    if ( v17 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v16 + 16) + 1i64) > *(_QWORD *)(v16 + 24) )
          (**(void (__fastcall ***)(__int64))v16)(v16);
        *(_BYTE *)(*(_QWORD *)(v16 + 16) + *(_QWORD *)(v16 + 8)) = *v18;
        ++*(_QWORD *)(v16 + 16);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v19 = &v18[v17];
      do
      {
        sub_14615AAE0(v16, a3 + 17, v19);
        --v12;
      }
      while ( v12 );
    }
  }
  result = a1;
  *a1 = v16;
  return result;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014619D530) ----------------------------------------------------
__int64 *__fastcall sub_14619D530(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6)
{
  unsigned __int64 v9; // rdi
  char v10; // cl
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rdi
  __int64 v13; // rax
  char *v14; // r14
  char *v15; // rbp
  int **v16; // rsi
  __int64 v17; // rbp
  __int64 v18; // rbx
  int v19; // ecx
  __int64 v20; // rsi
  __int64 v21; // rax
  _BYTE *v22; // rsi
  char *v23; // rbp

  v9 = *(unsigned int *)a3 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v9 = 0i64;
  v10 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v11 = v9 >> v10;
  v12 = v9 - (v9 >> v10);
  if ( v11 )
  {
    v13 = (unsigned __int8)a3[21];
    v14 = a3 + 17;
    if ( v13 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v14;
        --v11;
      }
      while ( v11 );
    }
    else
    {
      v15 = &v14[v13];
      do
      {
        sub_14615AAE0(a2, v14, v15);
        --v11;
      }
      while ( v11 );
    }
  }
  v16 = a6;
  v17 = **a6;
  if ( (_DWORD)v17 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = byte_14611CFAC[v17];
  }
  v18 = *sub_14619E0C0(&a5, a2, *(_QWORD *)v16[1], *v16[2], *v16[3], *(_BYTE *)v16[4]);
  v19 = *v16[5];
  if ( v19 > 0 )
  {
    v20 = (unsigned int)v19;
    do
    {
      if ( (unsigned __int64)(*(_QWORD *)(v18 + 16) + 1i64) > *(_QWORD *)(v18 + 24) )
        (**(void (__fastcall ***)(__int64))v18)(v18);
      *(_BYTE *)(*(_QWORD *)(v18 + 8) + (*(_QWORD *)(v18 + 16))++) = 48;
      --v20;
    }
    while ( v20 );
  }
  if ( v12 )
  {
    v21 = (unsigned __int8)a3[21];
    v22 = a3 + 17;
    if ( v21 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v18 + 16) + 1i64) > *(_QWORD *)(v18 + 24) )
          (**(void (__fastcall ***)(__int64))v18)(v18);
        *(_BYTE *)(*(_QWORD *)(v18 + 8) + (*(_QWORD *)(v18 + 16))++) = *v22;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v23 = &v22[v21];
      do
      {
        sub_14615AAE0(v18, a3 + 17, v23);
        --v12;
      }
      while ( v12 );
    }
  }
  *a1 = v18;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014619D740) ----------------------------------------------------
__int64 *__fastcall sub_14619D740(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int *a6)
{
  unsigned __int64 v9; // rdi
  char v10; // cl
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rdi
  __int64 v13; // rax
  char *v14; // r14
  char *v15; // rbp
  __int64 v16; // rbx
  __int64 v17; // rax
  _BYTE *v18; // rsi
  char *v19; // rbp
  __int64 *result; // rax

  v9 = *(unsigned int *)a3 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v9 = 0i64;
  v10 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v11 = v9 >> v10;
  v12 = v9 - (v9 >> v10);
  if ( v11 )
  {
    v13 = (unsigned __int8)a3[21];
    v14 = a3 + 17;
    if ( v13 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = *v14;
        ++*(_QWORD *)(a2 + 16);
        --v11;
      }
      while ( v11 );
    }
    else
    {
      v15 = &v14[v13];
      do
      {
        sub_14615AAE0(a2, v14, v15);
        --v11;
      }
      while ( v11 );
    }
  }
  v16 = *sub_14619E7F0(a6, &a5, a2);
  if ( v12 )
  {
    v17 = (unsigned __int8)a3[21];
    v18 = a3 + 17;
    if ( v17 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v16 + 16) + 1i64) > *(_QWORD *)(v16 + 24) )
          (**(void (__fastcall ***)(__int64))v16)(v16);
        *(_BYTE *)(*(_QWORD *)(v16 + 16) + *(_QWORD *)(v16 + 8)) = *v18;
        ++*(_QWORD *)(v16 + 16);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v19 = &v18[v17];
      do
      {
        sub_14615AAE0(v16, a3 + 17, v19);
        --v12;
      }
      while ( v12 );
    }
  }
  result = a1;
  *a1 = v16;
  return result;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014619D8B0) ----------------------------------------------------
__int64 *__fastcall sub_14619D8B0(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6)
{
  unsigned __int64 v9; // rdi
  char v10; // cl
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rdi
  __int64 v13; // rax
  char *v14; // r14
  char *v15; // rbp
  __int64 v16; // rbx
  __int64 v17; // rax
  _BYTE *v18; // rsi
  char *v19; // rbp
  __int64 *result; // rax

  v9 = *(unsigned int *)a3 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v9 = 0i64;
  v10 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v11 = v9 >> v10;
  v12 = v9 - (v9 >> v10);
  if ( v11 )
  {
    v13 = (unsigned __int8)a3[21];
    v14 = a3 + 17;
    if ( v13 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = *v14;
        ++*(_QWORD *)(a2 + 16);
        --v11;
      }
      while ( v11 );
    }
    else
    {
      v15 = &v14[v13];
      do
      {
        sub_14615AAE0(a2, v14, v15);
        --v11;
      }
      while ( v11 );
    }
  }
  v16 = *sub_14619E900(a6, (__int64 *)&a5, a2);
  if ( v12 )
  {
    v17 = (unsigned __int8)a3[21];
    v18 = a3 + 17;
    if ( v17 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v16 + 16) + 1i64) > *(_QWORD *)(v16 + 24) )
          (**(void (__fastcall ***)(__int64))v16)(v16);
        *(_BYTE *)(*(_QWORD *)(v16 + 16) + *(_QWORD *)(v16 + 8)) = *v18;
        ++*(_QWORD *)(v16 + 16);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v19 = &v18[v17];
      do
      {
        sub_14615AAE0(v16, a3 + 17, v19);
        --v12;
      }
      while ( v12 );
    }
  }
  result = a1;
  *a1 = v16;
  return result;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014619DA20) ----------------------------------------------------
__int64 *__fastcall sub_14619DA20(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6)
{
  unsigned __int64 v9; // rdi
  char v10; // cl
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rdi
  __int64 v13; // rax
  char *v14; // r14
  char *v15; // rbp
  __int64 v16; // rbx
  __int64 v17; // rax
  _BYTE *v18; // rsi
  char *v19; // rbp
  __int64 *result; // rax

  v9 = *(unsigned int *)a3 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v9 = 0i64;
  v10 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v11 = v9 >> v10;
  v12 = v9 - (v9 >> v10);
  if ( v11 )
  {
    v13 = (unsigned __int8)a3[21];
    v14 = a3 + 17;
    if ( v13 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = *v14;
        ++*(_QWORD *)(a2 + 16);
        --v11;
      }
      while ( v11 );
    }
    else
    {
      v15 = &v14[v13];
      do
      {
        sub_14615AAE0(a2, v14, v15);
        --v11;
      }
      while ( v11 );
    }
  }
  v16 = *sub_14619EA70(a6, (__int64 *)&a5, a2);
  if ( v12 )
  {
    v17 = (unsigned __int8)a3[21];
    v18 = a3 + 17;
    if ( v17 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v16 + 16) + 1i64) > *(_QWORD *)(v16 + 24) )
          (**(void (__fastcall ***)(__int64))v16)(v16);
        *(_BYTE *)(*(_QWORD *)(v16 + 16) + *(_QWORD *)(v16 + 8)) = *v18;
        ++*(_QWORD *)(v16 + 16);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v19 = &v18[v17];
      do
      {
        sub_14615AAE0(v16, a3 + 17, v19);
        --v12;
      }
      while ( v12 );
    }
  }
  result = a1;
  *a1 = v16;
  return result;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014619DB90) ----------------------------------------------------
__int64 *__fastcall sub_14619DB90(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int *a6)
{
  unsigned __int64 v9; // rdi
  char v10; // cl
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rdi
  __int64 v13; // rax
  char *v14; // r14
  char *v15; // rbp
  __int64 v16; // rbx
  __int64 v17; // rax
  _BYTE *v18; // rsi
  char *v19; // rbp
  __int64 *result; // rax

  v9 = *(unsigned int *)a3 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v9 = 0i64;
  v10 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v11 = v9 >> v10;
  v12 = v9 - (v9 >> v10);
  if ( v11 )
  {
    v13 = (unsigned __int8)a3[21];
    v14 = a3 + 17;
    if ( v13 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)) = *v14;
        ++*(_QWORD *)(a2 + 16);
        --v11;
      }
      while ( v11 );
    }
    else
    {
      v15 = &v14[v13];
      do
      {
        sub_14615AAE0(a2, v14, v15);
        --v11;
      }
      while ( v11 );
    }
  }
  v16 = *sub_14619EBE0(a6, &a5, a2);
  if ( v12 )
  {
    v17 = (unsigned __int8)a3[21];
    v18 = a3 + 17;
    if ( v17 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v16 + 16) + 1i64) > *(_QWORD *)(v16 + 24) )
          (**(void (__fastcall ***)(__int64))v16)(v16);
        *(_BYTE *)(*(_QWORD *)(v16 + 16) + *(_QWORD *)(v16 + 8)) = *v18;
        ++*(_QWORD *)(v16 + 16);
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v19 = &v18[v17];
      do
      {
        sub_14615AAE0(v16, a3 + 17, v19);
        --v12;
      }
      while ( v12 );
    }
  }
  result = a1;
  *a1 = v16;
  return result;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014619DD00) ----------------------------------------------------
__int64 *__fastcall sub_14619DD00(__int64 *a1, __int64 a2, char *a3, __int64 a4, unsigned __int64 a5, int **a6)
{
  unsigned __int64 v9; // rdi
  char v10; // cl
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rdi
  __int64 v13; // rax
  char *v14; // r14
  char *v15; // rbp
  int **v16; // rsi
  __int64 v17; // rbp
  __int64 v18; // rbx
  int v19; // ecx
  __int64 v20; // rsi
  __int64 v21; // rax
  _BYTE *v22; // rsi
  char *v23; // rbp

  v9 = *(unsigned int *)a3 - a5;
  if ( *(unsigned int *)a3 <= a5 )
    v9 = 0i64;
  v10 = byte_14611CFC8[(__int64)(int)(*((_DWORD *)a3 + 3) << 28) >> 28];
  v11 = v9 >> v10;
  v12 = v9 - (v9 >> v10);
  if ( v11 )
  {
    v13 = (unsigned __int8)a3[21];
    v14 = a3 + 17;
    if ( v13 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
          (**(void (__fastcall ***)(__int64))a2)(a2);
        *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = *v14;
        --v11;
      }
      while ( v11 );
    }
    else
    {
      v15 = &v14[v13];
      do
      {
        sub_14615AAE0(a2, v14, v15);
        --v11;
      }
      while ( v11 );
    }
  }
  v16 = a6;
  v17 = **a6;
  if ( (_DWORD)v17 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a2 + 16) + 1i64) > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64))a2)(a2);
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + (*(_QWORD *)(a2 + 16))++) = byte_14611CFAC[v17];
  }
  v18 = *sub_14619DF10(&a5, a2, (unsigned int)*v16[1], *v16[2], *v16[3], *(_BYTE *)v16[4]);
  v19 = *v16[5];
  if ( v19 > 0 )
  {
    v20 = (unsigned int)v19;
    do
    {
      if ( (unsigned __int64)(*(_QWORD *)(v18 + 16) + 1i64) > *(_QWORD *)(v18 + 24) )
        (**(void (__fastcall ***)(__int64))v18)(v18);
      *(_BYTE *)(*(_QWORD *)(v18 + 8) + (*(_QWORD *)(v18 + 16))++) = 48;
      --v20;
    }
    while ( v20 );
  }
  if ( v12 )
  {
    v21 = (unsigned __int8)a3[21];
    v22 = a3 + 17;
    if ( v21 == 1 )
    {
      do
      {
        if ( (unsigned __int64)(*(_QWORD *)(v18 + 16) + 1i64) > *(_QWORD *)(v18 + 24) )
          (**(void (__fastcall ***)(__int64))v18)(v18);
        *(_BYTE *)(*(_QWORD *)(v18 + 8) + (*(_QWORD *)(v18 + 16))++) = *v22;
        --v12;
      }
      while ( v12 );
    }
    else
    {
      v23 = &v22[v21];
      do
      {
        sub_14615AAE0(v18, a3 + 17, v23);
        --v12;
      }
      while ( v12 );
    }
  }
  *a1 = v18;
  return a1;
}
// 14611CFC8: using guessed type _BYTE byte_14611CFC8[8];

//----- (000000014619DF10) ----------------------------------------------------
_QWORD *__fastcall sub_14619DF10(_QWORD *a1, __int64 a2, __int64 a3, int a4, int a5, char a6)
{
  __int64 v8; // rcx
  const char *v9; // r9
  char *v10; // rcx
  char *v11; // rbp
  unsigned int v12; // edx
  __int16 v13; // ax
  char *v14; // rcx
  unsigned int v15; // edx
  __int16 v16; // ax
  char *i; // rsi
  unsigned __int64 v18; // rdx
  __int64 v19; // rdx
  size_t v20; // rdi
  _QWORD *result; // rax
  char v22; // [rsp+28h] [rbp-40h] BYREF
  char Src[15]; // [rsp+29h] [rbp-3Fh] BYREF

  v8 = a4;
  v9 = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555"
       "6575859606162636465666768697071727374757677787980818283848586878889909192939495969798990123456789abcdef";
  if ( a6 )
  {
    v14 = &Src[v8];
    v11 = v14;
    if ( (unsigned int)a3 >= 0x64 )
    {
      do
      {
        v14 -= 2;
        v15 = (unsigned int)a3 / 0x64;
        v16 = *(_WORD *)&a00010203040506[2 * ((unsigned int)a3 % 0x64)];
        a3 = (unsigned int)a3 / 0x64;
        *(_WORD *)v14 = v16;
      }
      while ( v15 >= 0x64 );
    }
    if ( (unsigned int)a3 >= 0xA )
    {
      *((_WORD *)v14 - 1) = *(_WORD *)&a00010203040506[2 * (unsigned int)a3];
    }
    else
    {
      LOBYTE(a3) = a3 + 48;
      *(v14 - 1) = a3;
    }
    if ( a5 == 1 )
    {
      v22 = Src[0];
    }
    else if ( a5 > 0 )
    {
      memmove(&v22, Src, a5);
    }
    Src[a5 - 1] = a6;
  }
  else
  {
    v10 = &Src[v8 - 1];
    v11 = v10;
    if ( (unsigned int)a3 >= 0x64 )
    {
      do
      {
        v10 -= 2;
        v12 = (unsigned int)a3 / 0x64;
        v13 = *(_WORD *)&a00010203040506[2 * ((unsigned int)a3 % 0x64)];
        a3 = (unsigned int)a3 / 0x64;
        *(_WORD *)v10 = v13;
      }
      while ( v12 >= 0x64 );
    }
    if ( (unsigned int)a3 >= 0xA )
    {
      *((_WORD *)v10 - 1) = *(_WORD *)&a00010203040506[2 * (unsigned int)a3];
    }
    else
    {
      LOBYTE(a3) = a3 + 48;
      *(v10 - 1) = a3;
    }
  }
  for ( i = &v22; i != v11; i += v20 )
  {
    v18 = v11 - i + *(_QWORD *)(a2 + 16);
    if ( v18 > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64, unsigned __int64, __int64, const char *))a2)(a2, v18, a3, v9);
    v19 = *(_QWORD *)(a2 + 16);
    v20 = *(_QWORD *)(a2 + 24) - v19;
    if ( v20 >= v11 - i )
      v20 = v11 - i;
    if ( v20 )
      memmove((void *)(v19 + *(_QWORD *)(a2 + 8)), i, v20);
    *(_QWORD *)(a2 + 16) += v20;
  }
  result = a1;
  *a1 = a2;
  return result;
}
// 14619E059: variable 'a3' is possibly undefined
// 14619E059: variable 'v9' is possibly undefined
// 14619DF10: using guessed type char Src[15];

//----- (000000014619E0C0) ----------------------------------------------------
_QWORD *__fastcall sub_14619E0C0(_QWORD *a1, __int64 a2, unsigned __int64 a3, int a4, int a5, char a6)
{
  char *v7; // rsi
  unsigned __int64 v8; // rdi
  const char *v10; // r8
  char *i; // rbp
  __int16 v12; // ax
  char *v13; // rsi
  __int16 v14; // ax
  char *j; // rsi
  unsigned __int64 v16; // rdx
  __int64 v17; // rdx
  size_t v18; // rdi
  _QWORD *result; // rax
  char v20; // [rsp+20h] [rbp-58h] BYREF
  char Src[23]; // [rsp+21h] [rbp-57h] BYREF

  v7 = &Src[a4 - 1];
  v8 = a3;
  sub_146165560(a3);
  v10 = "0001020304050607080910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455"
        "56575859606162636465666768697071727374757677787980818283848586878889909192939495969798990123456789abcdef";
  if ( a6 )
  {
    v13 = v7 + 1;
    for ( i = v13; v8 >= 0x64; *(_WORD *)v13 = v14 )
    {
      v13 -= 2;
      v14 = *(_WORD *)&a00010203040506[2 * (v8 % 0x64)];
      v8 /= 0x64ui64;
    }
    if ( v8 >= 0xA )
      *((_WORD *)v13 - 1) = *(_WORD *)&a00010203040506[2 * v8];
    else
      *(v13 - 1) = v8 + 48;
    if ( a5 == 1 )
    {
      v20 = Src[0];
    }
    else if ( a5 > 0 )
    {
      memmove(&v20, Src, a5);
    }
    Src[a5 - 1] = a6;
  }
  else
  {
    for ( i = v7; v8 >= 0x64; *(_WORD *)v7 = v12 )
    {
      v7 -= 2;
      v12 = *(_WORD *)&a00010203040506[2 * (v8 % 0x64)];
      v8 /= 0x64ui64;
    }
    if ( v8 >= 0xA )
      *((_WORD *)v7 - 1) = *(_WORD *)&a00010203040506[2 * v8];
    else
      *(v7 - 1) = v8 + 48;
  }
  for ( j = &v20; j != i; j += v18 )
  {
    v16 = i - j + *(_QWORD *)(a2 + 16);
    if ( v16 > *(_QWORD *)(a2 + 24) )
      (**(void (__fastcall ***)(__int64, unsigned __int64, const char *))a2)(a2, v16, v10);
    v17 = *(_QWORD *)(a2 + 16);
    v18 = *(_QWORD *)(a2 + 24) - v17;
    if ( v18 >= i - j )
      v18 = i - j;
    if ( v18 )
      memmove((void *)(v17 + *(_QWORD *)(a2 + 8)), j, v18);
    *(_QWORD *)(a2 + 16) += v18;
  }
  result = a1;
  *a1 = a2;
  return result;
}
// 14619E249: variable 'v10' is possibly undefined
// 14619E0C0: using guessed type char Src[23];

//----- (000000014619E2B0) ----------------------------------------------------
mbstate_t __fastcall sub_14619E2B0(mbstate_t a1, std::_Locinfo *a2, unsigned __int64 a3, char a4)
{
  struct lconv *v7; // rsi
  const char *grouping; // rdi
  size_t v9; // rbp
  void *v10; // rax
  void *v11; // r14
  char *v12; // rax
  char *v13; // rax
  char v15[8]; // [rsp+30h] [rbp-98h] BYREF
  wchar_t v16; // [rsp+38h] [rbp-90h] BYREF
  mbstate_t v17; // [rsp+40h] [rbp-88h] BYREF
  __int64 v18; // [rsp+48h] [rbp-80h]
  mbstate_t v19; // [rsp+50h] [rbp-78h]
  _Cvtvec v20; // [rsp+58h] [rbp-70h] BYREF

  v18 = -2i64;
  v17 = a1;
  std::locale::facet::facet(*(std::locale::facet **)&a1, a3);
  **(_QWORD **)&a1 = &std::numpunct<wchar_t>::`vftable';
  v7 = localeconv();
  std::_Locinfo::_Getcvt(a2, &v20);
  *(_QWORD *)(*(_QWORD *)&a1 + 16i64) = 0i64;
  *(_QWORD *)(*(_QWORD *)&a1 + 32i64) = 0i64;
  *(_QWORD *)(*(_QWORD *)&a1 + 40i64) = 0i64;
  v19 = a1;
  grouping = Src;
  if ( !a4 )
    grouping = v7->grouping;
  v9 = strlen(grouping) + 1;
  v10 = calloc(v9, 1ui64);
  v11 = v10;
  if ( !v10 )
  {
    std::_Xbad_alloc();
    JUMPOUT(0x14619E484i64);
  }
  if ( v9 )
    memcpy(v10, grouping, v9);
  *(_QWORD *)(*(_QWORD *)&a1 + 16i64) = v11;
  v12 = (char *)std::_Locinfo::_Getfalse(a2);
  *(_QWORD *)(*(_QWORD *)&a1 + 32i64) = sub_146196600(v12, 0i64, &v20);
  v13 = (char *)std::_Locinfo::_Gettrue(a2);
  *(_QWORD *)(*(_QWORD *)&a1 + 40i64) = sub_146196600(v13, 0i64, &v20);
  if ( a4 )
  {
    v15[0] = 46;
    v16 = 0;
    v17 = 0i64;
    Mbrtowc(&v16, v15, 1ui64, &v17, &v20);
    *(_WORD *)(*(_QWORD *)&a1 + 24i64) = v16;
    v15[0] = 44;
    v16 = 0;
    v17 = 0i64;
    Mbrtowc(&v16, v15, 1ui64, &v17, &v20);
    *(_WORD *)(*(_QWORD *)&a1 + 26i64) = v16;
  }
  else
  {
    *(_WORD *)(*(_QWORD *)&a1 + 24i64) = *v7->_W_decimal_point;
    *(_WORD *)(*(_QWORD *)&a1 + 26i64) = *v7->_W_thousands_sep;
  }
  return a1;
}
// 14619E483: control flows out of bounds to 14619E484
// 14611C3B0: using guessed type struct _Cvtvec *std::_Locinfo::_Getcvt(std::_Locinfo *__hidden this, struct _Cvtvec *__return_ptr __struct_ptr retstr);
// 14611C3D0: using guessed type const char *std::_Locinfo::_Getfalse(std::_Locinfo *__hidden this);
// 14611C3D8: using guessed type const char *std::_Locinfo::_Gettrue(std::_Locinfo *__hidden this);
// 14611C3E8: using guessed type _QWORD __fastcall std::locale::facet::facet(std::locale::facet *__hidden this, unsigned __int64);
// 14612EE78: using guessed type void *std::numpunct<wchar_t>::`vftable';
// 14619E2B0: using guessed type char var_98[8];

//----- (000000014619E490) ----------------------------------------------------
void __fastcall sub_14619E490(void ***a1)
{
  void **v1; // rbx

  v1 = *a1;
  if ( *a1 )
  {
    free_0(v1[2]);
    free_0(v1[4]);
    free_0(v1[5]);
  }
}

//----- (000000014619E4D0) ----------------------------------------------------
void __fastcall sub_14619E4D0(_QWORD *a1)
{
  _QWORD *v2; // rcx

  *a1 = &fmt::v8::basic_memory_buffer<unsigned int,32,std::allocator<unsigned int>>::`vftable';
  v2 = (_QWORD *)a1[1];
  if ( v2 != a1 + 4 )
  {
    if ( (unsigned __int64)(4i64 * a1[3]) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - *(v2 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v2 = (_QWORD *)*(v2 - 1);
    }
    j_j_free(v2);
  }
}
// 14612F258: using guessed type void *fmt::v8::basic_memory_buffer<unsigned int,32,std::allocator<unsigned int>>::`vftable';

//----- (000000014619E550) ----------------------------------------------------
_QWORD *__fastcall sub_14619E550(int **a1, _QWORD *a2, __int64 a3)
{
  __int64 v6; // rdi
  __int64 v7; // rbx
  int v8; // ecx
  __int64 v9; // rsi
  int *v10; // rsi
  __int64 v11; // rdx
  int v12; // ecx
  __int64 v13; // rsi
  _QWORD *result; // rax
  __int64 v15[3]; // [rsp+20h] [rbp-18h] BYREF

  v6 = **a1;
  if ( (_DWORD)v6 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_BYTE *)(*(_QWORD *)(a3 + 8) + (*(_QWORD *)(a3 + 16))++) = byte_14611CFAC[v6];
  }
  v7 = sub_1461981B0(v15, a3, *(_QWORD *)a1[1], *a1[2])[1];
  v8 = a1[3][2];
  if ( v8 > 0 )
  {
    v9 = (unsigned int)v8;
    do
    {
      if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
        (**(void (__fastcall ***)(__int64))v7)(v7);
      *(_BYTE *)(*(_QWORD *)(v7 + 16) + *(_QWORD *)(v7 + 8)) = 48;
      ++*(_QWORD *)(v7 + 16);
      --v9;
    }
    while ( v9 );
  }
  if ( (a1[4][3] & 0x10) != 0 )
  {
    v10 = a1[5];
    if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
      (**(void (__fastcall ***)(__int64))v7)(v7);
    *(_BYTE *)(*(_QWORD *)(v7 + 16) + *(_QWORD *)(v7 + 8)) = *(_BYTE *)v10;
    v11 = *(_QWORD *)(v7 + 16) + 1i64;
    *(_QWORD *)(v7 + 16) = v11;
    v12 = *a1[6];
    if ( v12 > 0 )
    {
      v13 = (unsigned int)v12;
      do
      {
        if ( (unsigned __int64)(v11 + 1) > *(_QWORD *)(v7 + 24) )
          (**(void (__fastcall ***)(__int64))v7)(v7);
        *(_BYTE *)(*(_QWORD *)(v7 + 16) + *(_QWORD *)(v7 + 8)) = 48;
        v11 = ++*(_QWORD *)(v7 + 16);
        --v13;
      }
      while ( v13 );
    }
  }
  result = a2;
  *a2 = v7;
  return result;
}
// 14619E550: using guessed type __int64 var_18[3];

//----- (000000014619E6A0) ----------------------------------------------------
_QWORD *__fastcall sub_14619E6A0(int **a1, _QWORD *a2, __int64 a3)
{
  __int64 v6; // rdi
  __int64 v7; // rbx
  int v8; // ecx
  __int64 v9; // rsi
  int *v10; // rsi
  __int64 v11; // rdx
  int v12; // ecx
  __int64 v13; // rsi
  _QWORD *result; // rax
  __int64 v15[3]; // [rsp+20h] [rbp-18h] BYREF

  v6 = **a1;
  if ( (_DWORD)v6 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_BYTE *)(*(_QWORD *)(a3 + 8) + (*(_QWORD *)(a3 + 16))++) = byte_14611CFAC[v6];
  }
  v7 = sub_146198090(v15, a3, *a1[1], *a1[2])[1];
  v8 = a1[3][1];
  if ( v8 > 0 )
  {
    v9 = (unsigned int)v8;
    do
    {
      if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
        (**(void (__fastcall ***)(__int64))v7)(v7);
      *(_BYTE *)(*(_QWORD *)(v7 + 16) + *(_QWORD *)(v7 + 8)) = 48;
      ++*(_QWORD *)(v7 + 16);
      --v9;
    }
    while ( v9 );
  }
  if ( (a1[4][3] & 0x10) != 0 )
  {
    v10 = a1[5];
    if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
      (**(void (__fastcall ***)(__int64))v7)(v7);
    *(_BYTE *)(*(_QWORD *)(v7 + 16) + *(_QWORD *)(v7 + 8)) = *(_BYTE *)v10;
    v11 = *(_QWORD *)(v7 + 16) + 1i64;
    *(_QWORD *)(v7 + 16) = v11;
    v12 = *a1[6];
    if ( v12 > 0 )
    {
      v13 = (unsigned int)v12;
      do
      {
        if ( (unsigned __int64)(v11 + 1) > *(_QWORD *)(v7 + 24) )
          (**(void (__fastcall ***)(__int64))v7)(v7);
        *(_BYTE *)(*(_QWORD *)(v7 + 16) + *(_QWORD *)(v7 + 8)) = 48;
        v11 = ++*(_QWORD *)(v7 + 16);
        --v13;
      }
      while ( v13 );
    }
  }
  result = a2;
  *a2 = v7;
  return result;
}
// 14619E6A0: using guessed type __int64 var_18[3];

//----- (000000014619E7F0) ----------------------------------------------------
_QWORD *__fastcall sub_14619E7F0(int *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v7; // rbx
  int v8; // eax
  __int64 v9; // rdi
  __int64 v11; // [rsp+40h] [rbp+8h] BYREF

  v3 = *a1;
  if ( (_DWORD)v3 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_BYTE *)(*(_QWORD *)(a3 + 8) + (*(_QWORD *)(a3 + 16))++) = byte_14611CFAC[v3];
  }
  v7 = *sub_14619E0C0(&v11, a3, *((_QWORD *)a1 + 1), a1[4], 1, *((_BYTE *)a1 + 20));
  v8 = a1[6];
  if ( v8 > 0 )
  {
    v9 = (unsigned int)v8;
    do
    {
      if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
        (**(void (__fastcall ***)(__int64))v7)(v7);
      *(_BYTE *)(*(_QWORD *)(v7 + 8) + (*(_QWORD *)(v7 + 16))++) = 48;
      --v9;
    }
    while ( v9 );
  }
  if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
    (**(void (__fastcall ***)(__int64))v7)(v7);
  *(_BYTE *)(*(_QWORD *)(v7 + 8) + (*(_QWORD *)(v7 + 16))++) = *((_BYTE *)a1 + 28);
  sub_14615EA50(a2, a1[8], v7);
  return a2;
}

//----- (000000014619E900) ----------------------------------------------------
__int64 *__fastcall sub_14619E900(int **a1, __int64 *a2, __int64 a3)
{
  _QWORD *v3; // rbp
  __int64 v7; // rdi
  _QWORD *v8; // r12
  __int64 v9; // rdx
  int *v10; // rax
  __int64 *v11; // rdi
  _QWORD *v12; // r14
  __int64 v13; // rdx
  int v14; // ecx
  __int64 v15; // rsi
  __int64 v17[7]; // [rsp+20h] [rbp-38h] BYREF
  int *v18; // [rsp+60h] [rbp+8h]

  v3 = (_QWORD *)(a3 + 24);
  v7 = **a1;
  if ( (_DWORD)v7 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *v3 )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    v8 = (_QWORD *)(a3 + 8);
    *(_BYTE *)(*(_QWORD *)(a3 + 8) + (*(_QWORD *)(a3 + 16))++) = byte_14611CFAC[v7];
  }
  else
  {
    v8 = (_QWORD *)(a3 + 8);
  }
  if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *v3 )
    (**(void (__fastcall ***)(__int64))a3)(a3);
  *(_BYTE *)(*(_QWORD *)(a3 + 16) + *v8) = 48;
  v9 = *(_QWORD *)(a3 + 16) + 1i64;
  *(_QWORD *)(a3 + 16) = v9;
  if ( *(_BYTE *)a1[1] )
  {
    v10 = a1[2];
    v11 = (__int64 *)(a3 + 16);
    v12 = v8;
    v18 = v10;
    if ( (unsigned __int64)(v9 + 1) > *v3 )
    {
      (**(void (__fastcall ***)(__int64))a3)(a3);
      v10 = v18;
      v3 = (_QWORD *)(a3 + 24);
      v12 = (_QWORD *)(a3 + 8);
      v11 = (__int64 *)(a3 + 16);
    }
    *(_BYTE *)(*(_QWORD *)(a3 + 16) + *v8) = *(_BYTE *)v10;
    v13 = *(_QWORD *)(a3 + 16) + 1i64;
    *(_QWORD *)(a3 + 16) = v13;
    v14 = *a1[3];
    if ( v14 > 0 )
    {
      v15 = (unsigned int)v14;
      do
      {
        if ( (unsigned __int64)(v13 + 1) > *v3 )
          (**(void (__fastcall ***)(__int64))a3)(a3);
        *(_BYTE *)(*v12 + (*v11)++) = 48;
        v13 = *v11;
        --v15;
      }
      while ( v15 );
    }
    *a2 = sub_146198090(v17, a3, *a1[4], *a1[5])[1];
  }
  else
  {
    *a2 = a3;
  }
  return a2;
}
// 14619E900: using guessed type __int64 var_38[7];

//----- (000000014619EA70) ----------------------------------------------------
__int64 *__fastcall sub_14619EA70(int **a1, __int64 *a2, __int64 a3)
{
  _QWORD *v3; // rbp
  __int64 v7; // rdi
  _QWORD *v8; // r12
  __int64 v9; // rdx
  int *v10; // rax
  __int64 *v11; // rdi
  _QWORD *v12; // r14
  __int64 v13; // rdx
  int v14; // ecx
  __int64 v15; // rsi
  __int64 v17[7]; // [rsp+20h] [rbp-38h] BYREF
  int *v18; // [rsp+60h] [rbp+8h]

  v3 = (_QWORD *)(a3 + 24);
  v7 = **a1;
  if ( (_DWORD)v7 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *v3 )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    v8 = (_QWORD *)(a3 + 8);
    *(_BYTE *)(*(_QWORD *)(a3 + 8) + (*(_QWORD *)(a3 + 16))++) = byte_14611CFAC[v7];
  }
  else
  {
    v8 = (_QWORD *)(a3 + 8);
  }
  if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *v3 )
    (**(void (__fastcall ***)(__int64))a3)(a3);
  *(_BYTE *)(*(_QWORD *)(a3 + 16) + *v8) = 48;
  v9 = *(_QWORD *)(a3 + 16) + 1i64;
  *(_QWORD *)(a3 + 16) = v9;
  if ( *(_BYTE *)a1[1] )
  {
    v10 = a1[2];
    v11 = (__int64 *)(a3 + 16);
    v12 = v8;
    v18 = v10;
    if ( (unsigned __int64)(v9 + 1) > *v3 )
    {
      (**(void (__fastcall ***)(__int64))a3)(a3);
      v10 = v18;
      v3 = (_QWORD *)(a3 + 24);
      v12 = (_QWORD *)(a3 + 8);
      v11 = (__int64 *)(a3 + 16);
    }
    *(_BYTE *)(*(_QWORD *)(a3 + 16) + *v8) = *(_BYTE *)v10;
    v13 = *(_QWORD *)(a3 + 16) + 1i64;
    *(_QWORD *)(a3 + 16) = v13;
    v14 = *a1[3];
    if ( v14 > 0 )
    {
      v15 = (unsigned int)v14;
      do
      {
        if ( (unsigned __int64)(v13 + 1) > *v3 )
          (**(void (__fastcall ***)(__int64))a3)(a3);
        *(_BYTE *)(*v12 + (*v11)++) = 48;
        v13 = *v11;
        --v15;
      }
      while ( v15 );
    }
    *a2 = sub_1461981B0(v17, a3, *(_QWORD *)a1[4], *a1[5])[1];
  }
  else
  {
    *a2 = a3;
  }
  return a2;
}
// 14619EA70: using guessed type __int64 var_38[7];

//----- (000000014619EBE0) ----------------------------------------------------
_QWORD *__fastcall sub_14619EBE0(int *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v7; // rbx
  int v8; // eax
  __int64 v9; // rdi
  __int64 v11; // [rsp+40h] [rbp+8h] BYREF

  v3 = *a1;
  if ( (_DWORD)v3 )
  {
    if ( (unsigned __int64)(*(_QWORD *)(a3 + 16) + 1i64) > *(_QWORD *)(a3 + 24) )
      (**(void (__fastcall ***)(__int64))a3)(a3);
    *(_BYTE *)(*(_QWORD *)(a3 + 8) + (*(_QWORD *)(a3 + 16))++) = byte_14611CFAC[v3];
  }
  v7 = *sub_14619DF10(&v11, a3, (unsigned int)a1[1], a1[2], 1, *((_BYTE *)a1 + 12));
  v8 = a1[4];
  if ( v8 > 0 )
  {
    v9 = (unsigned int)v8;
    do
    {
      if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
        (**(void (__fastcall ***)(__int64))v7)(v7);
      *(_BYTE *)(*(_QWORD *)(v7 + 8) + (*(_QWORD *)(v7 + 16))++) = 48;
      --v9;
    }
    while ( v9 );
  }
  if ( (unsigned __int64)(*(_QWORD *)(v7 + 16) + 1i64) > *(_QWORD *)(v7 + 24) )
    (**(void (__fastcall ***)(__int64))v7)(v7);
  *(_BYTE *)(*(_QWORD *)(v7 + 8) + (*(_QWORD *)(v7 + 16))++) = *((_BYTE *)a1 + 20);
  sub_14615EA50(a2, a1[6], v7);
  return a2;
}

//----- (000000014619ECF0) ----------------------------------------------------
void __fastcall sub_14619ECF0(__int64 *a1, char *a2, char *a3)
{
  char *v4; // r14
  char *i; // rbx
  char *v7; // rbx
  __int64 v8; // rsi
  __int64 v9; // rdi
  __int64 v10; // rdi
  __int64 v11; // rbx
  const char *pExceptionObject; // [rsp+28h] [rbp-50h] BYREF
  char v13; // [rsp+30h] [rbp-48h]
  void **v14; // [rsp+40h] [rbp-38h] BYREF
  __int128 v15; // [rsp+48h] [rbp-30h]

  if ( a2 != a3 )
  {
    v4 = a2;
    for ( i = (char *)memchr(a2, 125, a3 - a2); i; i = (char *)memchr(v7 + 1, 125, a3 - (v7 + 1)) )
    {
      v7 = i + 1;
      if ( v7 == a3 || *v7 != 125 )
      {
        v14 = &std::exception::`vftable';
        v15 = 0i64;
        pExceptionObject = "unmatched '}' in format string";
        v13 = 1;
        _std_exception_copy(&pExceptionObject);
        v14 = &fmt::v8::format_error::`vftable';
        sub_146162440((__int64)&pExceptionObject, (__int64)&v14);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
      }
      v8 = *a1;
      v9 = *(_QWORD *)(*a1 + 24);
      sub_14615AAE0(v9, v4, v7);
      *(_QWORD *)(v8 + 24) = v9;
      v4 = v7 + 1;
    }
    v10 = *a1;
    v11 = *(_QWORD *)(*a1 + 24);
    sub_14615AAE0(v11, v4, a3);
    *(_QWORD *)(v10 + 24) = v11;
  }
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014619EE30) ----------------------------------------------------
__int64 __fastcall sub_14619EE30(__int64 a1, int a2)
{
  int v4; // edx
  int v5; // eax
  unsigned __int64 v6; // rsi
  int v7; // edi
  unsigned __int64 v8; // r9
  _DWORD *v9; // rdx
  int v10; // r8d

  v4 = (a2 >> 31) & 0x1F;
  v5 = ((v4 + a2) & 0x1F) - v4;
  *(_DWORD *)(a1 + 168) += (v4 + a2) >> 5;
  if ( !v5 )
    return a1;
  v6 = *(_QWORD *)(a1 + 16);
  v7 = 0;
  v8 = 0i64;
  if ( v6 )
  {
    do
    {
      v9 = (_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v8++);
      v10 = *v9 >> (32 - v5);
      *v9 = v7 + (*v9 << v5);
      v7 = v10;
    }
    while ( v8 < v6 );
    if ( v10 )
    {
      if ( (unsigned __int64)(*(_QWORD *)(a1 + 16) + 1i64) > *(_QWORD *)(a1 + 24) )
        (**(void (__fastcall ***)(__int64))a1)(a1);
      *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4i64 * (*(_QWORD *)(a1 + 16))++) = v7;
    }
  }
  return a1;
}

//----- (000000014619EEF0) ----------------------------------------------------
void **__fastcall sub_14619EEF0(void **Block, char a2)
{
  *Block = &std::numpunct<char>::`vftable';
  free_0(Block[2]);
  free_0(Block[4]);
  free_0(Block[5]);
  std::locale::facet::~facet((std::locale::facet *)Block);
  if ( (a2 & 1) != 0 )
    j_j_free(Block);
  return Block;
}
// 14611C3F0: using guessed type void std::locale::facet::~facet(std::locale::facet *__hidden this);
// 14612EE30: using guessed type void *std::numpunct<char>::`vftable';

//----- (000000014619EF50) ----------------------------------------------------
void **__fastcall sub_14619EF50(void **Block, char a2)
{
  *Block = &std::numpunct<wchar_t>::`vftable';
  free_0(Block[2]);
  free_0(Block[4]);
  free_0(Block[5]);
  std::locale::facet::~facet((std::locale::facet *)Block);
  if ( (a2 & 1) != 0 )
    j_j_free(Block);
  return Block;
}
// 14611C3F0: using guessed type void std::locale::facet::~facet(std::locale::facet *__hidden this);
// 14612EE78: using guessed type void *std::numpunct<wchar_t>::`vftable';

//----- (000000014619EFB0) ----------------------------------------------------
char __fastcall sub_14619EFB0(__int64 a1, std::_Locinfo *a2, char a3)
{
  struct lconv *v6; // r14
  const char *grouping; // rdi
  size_t v8; // rsi
  void *v9; // rax
  void *v10; // rbp
  const char *v11; // rbp
  size_t v12; // rdi
  void *v13; // rax
  void *v14; // rsi
  const char *v15; // rbp
  size_t v16; // rdi
  void *v17; // rax
  void *v18; // rsi
  char result; // al
  struct _Cvtvec v20; // [rsp+30h] [rbp-68h] BYREF

  v6 = localeconv();
  std::_Locinfo::_Getcvt(a2, &v20);
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  grouping = Src;
  if ( !a3 )
    grouping = v6->grouping;
  v8 = strlen(grouping) + 1;
  v9 = calloc(v8, 1ui64);
  v10 = v9;
  if ( !v9 )
  {
LABEL_17:
    std::_Xbad_alloc();
    __debugbreak();
  }
  if ( v8 )
    memcpy(v9, grouping, v8);
  *(_QWORD *)(a1 + 16) = v10;
  v11 = std::_Locinfo::_Getfalse(a2);
  v12 = strlen(v11) + 1;
  v13 = calloc(v12, 1ui64);
  v14 = v13;
  if ( !v13 )
  {
    std::_Xbad_alloc();
    JUMPOUT(0x14619F144i64);
  }
  if ( v12 )
    memcpy(v13, v11, v12);
  *(_QWORD *)(a1 + 32) = v14;
  v15 = std::_Locinfo::_Gettrue(a2);
  v16 = strlen(v15) + 1;
  v17 = calloc(v16, 1ui64);
  v18 = v17;
  if ( !v17 )
  {
    std::_Xbad_alloc();
    goto LABEL_17;
  }
  if ( v16 )
    memcpy(v17, v15, v16);
  *(_QWORD *)(a1 + 40) = v18;
  if ( a3 )
  {
    *(_BYTE *)(a1 + 24) = 46;
    result = 44;
  }
  else
  {
    *(_BYTE *)(a1 + 24) = *v6->decimal_point;
    result = *v6->thousands_sep;
  }
  *(_BYTE *)(a1 + 25) = result;
  return result;
}
// 14619F13F: control flows out of bounds to 14619F144
// 14611C3B0: using guessed type struct _Cvtvec *std::_Locinfo::_Getcvt(std::_Locinfo *__hidden this, struct _Cvtvec *__return_ptr __struct_ptr retstr);
// 14611C3D0: using guessed type const char *std::_Locinfo::_Getfalse(std::_Locinfo *__hidden this);
// 14611C3D8: using guessed type const char *std::_Locinfo::_Gettrue(std::_Locinfo *__hidden this);
// 14619EFB0: using guessed type struct _Cvtvec var_68;

//----- (000000014619F150) ----------------------------------------------------
__int64 __fastcall sub_14619F150(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // ebx
  int v4; // r15d
  int v5; // r11d
  int v6; // r14d
  int v7; // edi
  int v8; // r9d
  int v9; // ebp
  unsigned __int64 v10; // r8
  __int64 v11; // rax
  int v12; // esi
  int v13; // eax
  __int64 v14; // r9
  unsigned int v15; // r10d
  unsigned __int64 v16; // r9
  unsigned int v17; // r10d
  unsigned __int64 v18; // r8

  v3 = *(_DWORD *)(a2 + 168);
  v4 = v3 + *(_DWORD *)(a2 + 16);
  v5 = *(_DWORD *)(a1 + 168);
  v6 = v5 + *(_DWORD *)(a1 + 16);
  v7 = *(_DWORD *)(a3 + 168);
  v8 = v6;
  if ( v6 < v4 )
    v8 = v3 + *(_DWORD *)(a2 + 16);
  v9 = v7 + *(_DWORD *)(a3 + 16);
  if ( v8 + 1 < v9 )
    return 0xFFFFFFFFi64;
  if ( v8 <= v9 )
  {
    v10 = 0i64;
    v11 = a1;
    if ( v3 < v5 )
      v11 = a2;
    v12 = *(_DWORD *)(v11 + 168);
    v13 = v9 - 1;
    if ( v7 < v12 )
      v12 = v7;
    if ( v13 < v12 )
      return (unsigned int)-(v10 != 0);
    while ( 1 )
    {
      v14 = v13 < v5 || v13 >= v6 ? 0i64 : *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4i64 * (unsigned int)(v13 - v5));
      v15 = v13 < v3 || v13 >= v4 ? 0 : *(_DWORD *)(*(_QWORD *)(a2 + 8) + 4i64 * (unsigned int)(v13 - v3));
      v16 = v15 + v14;
      if ( v13 < v7 || v13 >= v9 )
        v17 = 0;
      else
        v17 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4i64 * (unsigned int)(v13 - v7));
      if ( v16 > v17 + v10 )
        break;
      v18 = v17 - v16 + v10;
      if ( v18 > 1 )
        return 0xFFFFFFFFi64;
      v10 = v18 << 32;
      if ( --v13 < v12 )
        return (unsigned int)-(v10 != 0);
    }
  }
  return 1i64;
}

//----- (000000014619F290) ----------------------------------------------------
void __fastcall __noreturn sub_14619F290(const char *a1, unsigned int a2, const char *a3)
{
  FILE *v6; // rax

  v6 = _acrt_iob_func(2u);
  sub_1461662A0(v6, "%s:%d: assertion failed: %s", a1, a2, a3);
  terminate();
  JUMPOUT(0x14619F2D2i64);
}
// 14619F2CC: control flows out of bounds to 14619F2D2
// 14611C798: using guessed type __int64 terminate(void);

//----- (000000014619F2E0) ----------------------------------------------------
_DWORD *__fastcall sub_14619F2E0(__int64 a1, _DWORD *a2, unsigned __int64 a3)
{
  int v3; // ebp
  __int64 v5; // rdi
  _DWORD *result; // rax
  int i; // esi
  int v8; // esi
  unsigned __int64 v9; // r9
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // rdi

  v3 = (int)a2;
  v5 = 1i64;
  if ( (_DWORD)a2 )
  {
    for ( i = 1; (int)a2 >= i; i *= 2 )
      ;
    **(_DWORD **)(a1 + 8) = 5;
    if ( !*(_QWORD *)(a1 + 24) )
      (**(void (__fastcall ***)(__int64, __int64))a1)(a1, 1i64);
    if ( !*(_QWORD *)(a1 + 24) )
      v5 = *(_QWORD *)(a1 + 24);
    v8 = i >> 2;
    *(_QWORD *)(a1 + 16) = v5;
    for ( *(_DWORD *)(a1 + 168) = 0; v8; v8 >>= 1 )
    {
      sub_1461A06B0(a1, (__int64)a2, a3);
      if ( (v8 & v3) != 0 )
      {
        v9 = *(_QWORD *)(a1 + 16);
        LODWORD(v10) = 0;
        a3 = 0i64;
        if ( v9 )
        {
          do
          {
            a2 = (_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a3++);
            v11 = 5i64 * (unsigned int)*a2 + (unsigned int)v10;
            *a2 = v11;
            v10 = HIDWORD(v11);
          }
          while ( a3 < v9 );
          if ( (_DWORD)v10 )
          {
            a2 = (_DWORD *)(*(_QWORD *)(a1 + 16) + 1i64);
            if ( (unsigned __int64)a2 > *(_QWORD *)(a1 + 24) )
              (**(void (__fastcall ***)(__int64))a1)(a1);
            *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4i64 * (*(_QWORD *)(a1 + 16))++) = v10;
          }
        }
      }
    }
    return (_DWORD *)sub_14619EE30(a1, v3);
  }
  else
  {
    result = *(_DWORD **)(a1 + 8);
    *result = 1;
    if ( !*(_QWORD *)(a1 + 24) )
      result = (_DWORD *)(**(__int64 (__fastcall ***)(__int64, __int64))a1)(a1, 1i64);
    if ( !*(_QWORD *)(a1 + 24) )
      v5 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 16) = v5;
    *(_DWORD *)(a1 + 168) = 0;
  }
  return result;
}
// 14619F383: variable 'a2' is possibly undefined
// 14619F383: variable 'a3' is possibly undefined

//----- (000000014619F410) ----------------------------------------------------
void __fastcall sub_14619F410(__int64 a1)
{
  const char *pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v2; // [rsp+30h] [rbp-38h]
  void **v3; // [rsp+40h] [rbp-28h] BYREF
  __int128 v4; // [rsp+48h] [rbp-20h]

  if ( *(int *)(a1 + 16) > 0 )
  {
    v3 = &std::exception::`vftable';
    v4 = 0i64;
    pExceptionObject = "cannot switch from automatic to manual argument indexing";
    v2 = 1;
    _std_exception_copy(&pExceptionObject);
    v3 = &fmt::v8::format_error::`vftable';
    sub_146162440((__int64)&pExceptionObject, (__int64)&v3);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  *(_DWORD *)(a1 + 16) = -1;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014619F4A0) ----------------------------------------------------
__int64 __fastcall sub_14619F4A0(__int64 a1, __int64 a2)
{
  int v4; // ecx
  int v5; // edx
  int v6; // r8d
  int v7; // r9d
  bool v8; // cc
  __int64 result; // rax
  __int64 v10; // rax
  __int64 v11; // rdx
  int v12; // ecx
  int v13; // r8d
  __int64 v14; // r11
  __int64 v15; // rbx
  unsigned int v16; // r9d

  v4 = *(_DWORD *)(a1 + 16);
  v5 = v4 + *(_DWORD *)(a1 + 168);
  v6 = *(_DWORD *)(a2 + 16);
  v7 = v6 + *(_DWORD *)(a2 + 168);
  v8 = v5 <= v7;
  if ( v5 != v7 )
  {
LABEL_2:
    result = 0xFFFFFFFFi64;
    if ( !v8 )
      return 1i64;
    return result;
  }
  v10 = (unsigned int)(v4 - 1);
  v11 = (unsigned int)(v6 - 1);
  v12 = v4 - v6;
  v13 = 0;
  if ( v12 >= 0 )
    v13 = v12;
  if ( (int)v10 < v13 )
  {
LABEL_11:
    v8 = (int)v10 <= (int)v11;
    if ( (_DWORD)v10 == (_DWORD)v11 )
      return 0i64;
    goto LABEL_2;
  }
  v14 = *(_QWORD *)(a1 + 8);
  v15 = *(_QWORD *)(a2 + 8);
  while ( 1 )
  {
    v16 = *(_DWORD *)(v14 + 4 * v10);
    if ( v16 != *(_DWORD *)(v15 + 4 * v11) )
      break;
    v10 = (unsigned int)(v10 - 1);
    v11 = (unsigned int)(v11 - 1);
    if ( (int)v10 < v13 )
      goto LABEL_11;
  }
  result = 0xFFFFFFFFi64;
  if ( v16 > *(_DWORD *)(v15 + 4 * v11) )
    return 1i64;
  return result;
}

//----- (000000014619F540) ----------------------------------------------------
__int64 __fastcall sub_14619F540(__int64 a1, __int64 a2)
{
  __int64 v4; // r8
  _DWORD *v6; // r12
  int v7; // edi
  __int64 v8; // r14
  unsigned __int64 v9; // rsi
  bool v10; // cc
  __int64 v11; // rdx
  __int64 v12; // r8
  _DWORD *v13; // rcx
  void *v14; // r9
  __int64 v15; // rcx
  unsigned __int8 v16; // al
  int v17; // eax
  size_t v18; // r8
  unsigned int v19; // esi
  unsigned __int64 v20; // r9
  __int64 v21; // r10
  __int64 v22; // r11
  __int64 v23; // rdi
  __int64 v24; // rax
  __int64 v25; // rdx
  __int64 v26; // rcx
  __int64 v27; // rdx
  __int64 v28; // rcx
  unsigned __int64 v29; // rdx
  __int64 v30; // rax
  unsigned __int64 v31; // rdi
  bool v32; // cc
  int v33; // ecx
  int v34; // edx
  bool v35; // cc
  __int64 v36; // rcx
  int v37; // r10d
  __int64 v38; // rdx
  __int64 v39; // rdi
  int v40; // eax
  _QWORD v41[2]; // [rsp+20h] [rbp-28h] BYREF

  if ( (int)sub_14619F4A0(a1, a2) < 0 )
    return 0i64;
  v6 = (_DWORD *)(a1 + 168);
  v7 = *(_DWORD *)(a1 + 168) - *(_DWORD *)(a2 + 168);
  if ( v7 > 0 )
  {
    v8 = *(int *)(a1 + 16);
    v9 = (unsigned int)(v8 + v7);
    v10 = v9 <= *(_QWORD *)(a1 + 24);
    if ( v9 > *(_QWORD *)(a1 + 24) )
    {
      (**(void (__fastcall ***)(__int64, _QWORD))a1)(a1, (unsigned int)v9);
      v10 = v9 <= *(_QWORD *)(a1 + 24);
    }
    if ( !v10 )
      v9 = *(_QWORD *)(a1 + 24);
    v11 = v8 - 1;
    *(_QWORD *)(a1 + 16) = v9;
    if ( v8 - 1 >= 0 )
    {
      v12 = 4 * ((int)v8 + v7 - v11) - 4;
      do
      {
        v13 = (_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v11--);
        *(_DWORD *)((char *)v13 + v12) = *v13;
      }
      while ( v11 >= 0 );
      v6 = (_DWORD *)(a1 + 168);
    }
    v14 = *(void **)(a1 + 8);
    v41[0] = 0i64;
    v15 = 0i64;
    while ( 1 )
    {
      v16 = *((_BYTE *)v41 + v15++);
      if ( v16 != *((_BYTE *)v41 + v15 + 3) )
        break;
      if ( v15 == 4 )
      {
        v17 = 0;
        goto LABEL_17;
      }
    }
    v17 = v16 < *((_BYTE *)v41 + v15 + 3) ? -1 : 1;
LABEL_17:
    if ( v17 )
      v18 = 4i64 * (unsigned int)v7;
    else
      v18 = 4i64 * v7;
    memset(v14, 0, v18);
    *v6 = *(_DWORD *)(a1 + 168) - v7;
  }
  v19 = 0;
  do
  {
    while ( 1 )
    {
      v20 = 0i64;
      v21 = (unsigned int)(*(_DWORD *)(a2 + 168) - *v6);
      v22 = 0i64;
      v23 = *(_QWORD *)(a2 + 16);
      if ( v23 )
      {
        do
        {
          v24 = *(_QWORD *)(a1 + 8);
          v25 = *(unsigned int *)(v24 + 4 * v21);
          v4 = v24 + 4 * v21;
          v21 = (unsigned int)(v21 + 1);
          v26 = *(unsigned int *)(*(_QWORD *)(a2 + 8) + 4 * v22++);
          v27 = v25 - v26 - (unsigned int)v20;
          *(_DWORD *)v4 = v27;
          v20 = (unsigned __int64)v27 >> 63;
        }
        while ( v22 != v23 );
        if ( v27 < 0 )
        {
          v4 = 4 * v21;
          do
          {
            v28 = *(_QWORD *)(a1 + 8);
            v29 = *(unsigned int *)(v28 + 4 * v21) - (unsigned __int64)(unsigned int)v20;
            *(_DWORD *)(v28 + 4 * v21) = v29;
            v29 >>= 63;
            v20 = (unsigned int)v29;
          }
          while ( (_DWORD)v29 );
        }
      }
      v30 = (unsigned int)(*(_DWORD *)(a1 + 16) - 1);
      if ( *(_DWORD *)(a1 + 16) - 1 > 0 )
      {
        do
        {
          if ( *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v30) )
            break;
          v30 = (unsigned int)(v30 - 1);
        }
        while ( (int)v30 > 0 );
      }
      v31 = (unsigned int)(v30 + 1);
      v32 = v31 <= *(_QWORD *)(a1 + 24);
      if ( v31 > *(_QWORD *)(a1 + 24) )
      {
        (**(void (__fastcall ***)(__int64, _QWORD, __int64, unsigned __int64, _QWORD))a1)(
          a1,
          (unsigned int)v31,
          v4,
          v20,
          v41[0]);
        v32 = v31 <= *(_QWORD *)(a1 + 24);
      }
      if ( !v32 )
        v31 = *(_QWORD *)(a1 + 24);
      ++v19;
      *(_QWORD *)(a1 + 16) = v31;
      v33 = v31 + *v6;
      v4 = *(unsigned int *)(a2 + 16);
      v34 = v4 + *(_DWORD *)(a2 + 168);
      v35 = v33 <= v34;
      if ( v33 != v34 )
      {
LABEL_42:
        v40 = -1;
        if ( !v35 )
          v40 = 1;
        goto LABEL_44;
      }
      v36 = (unsigned int)(v31 - 1);
      v37 = 0;
      v38 = (unsigned int)(v4 - 1);
      if ( (int)v31 - (int)v4 >= 0 )
        v37 = v31 - v4;
      if ( (int)v36 >= v37 )
        break;
LABEL_41:
      v35 = (int)v36 <= (int)v38;
      if ( (_DWORD)v36 != (_DWORD)v38 )
        goto LABEL_42;
    }
    v39 = *(_QWORD *)(a2 + 8);
    while ( 1 )
    {
      v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v36);
      if ( (_DWORD)v4 != *(_DWORD *)(v39 + 4 * v38) )
        break;
      v36 = (unsigned int)(v36 - 1);
      v38 = (unsigned int)(v38 - 1);
      if ( (int)v36 < v37 )
        goto LABEL_41;
    }
    v40 = -1;
    if ( (unsigned int)v4 > *(_DWORD *)(v39 + 4 * v38) )
      v40 = 1;
LABEL_44:
    ;
  }
  while ( v40 >= 0 );
  return v19;
}
// 14619F71D: variable 'v4' is possibly undefined

//----- (000000014619F7D0) ----------------------------------------------------
__int64 __fastcall sub_14619F7D0(__int64 a1)
{
  return *(unsigned __int8 *)(a1 + 24);
}

//----- (000000014619F7F0) ----------------------------------------------------
_QWORD *__fastcall sub_14619F7F0(__int64 a1, _QWORD *a2)
{
  const char *v2; // rbx
  size_t v4; // rax

  v2 = *(const char **)(a1 + 32);
  *(_OWORD *)a2 = 0i64;
  a2[2] = 0i64;
  a2[3] = 0i64;
  v4 = strlen(v2);
  sub_14615A650(a2, v2, v4);
  return a2;
}

//----- (000000014619F840) ----------------------------------------------------
_QWORD *__fastcall sub_14619F840(__int64 a1, _QWORD *a2)
{
  const wchar_t *v2; // rbx
  unsigned __int64 v4; // rax
  __int64 v5; // r9

  v2 = *(const wchar_t **)(a1 + 32);
  *(_OWORD *)a2 = 0i64;
  a2[2] = 0i64;
  a2[3] = 0i64;
  v4 = wcslen(v2);
  sub_146168F30(a2, v2, v4, v5);
  return a2;
}
// 14619F872: variable 'v5' is possibly undefined

//----- (000000014619F890) ----------------------------------------------------
_QWORD *__fastcall sub_14619F890(__int64 a1, _QWORD *a2)
{
  const char *v2; // rbx
  size_t v4; // rax

  v2 = *(const char **)(a1 + 16);
  *(_OWORD *)a2 = 0i64;
  a2[2] = 0i64;
  a2[3] = 0i64;
  v4 = strlen(v2);
  sub_14615A650(a2, v2, v4);
  return a2;
}

//----- (000000014619F8E0) ----------------------------------------------------
__int64 __fastcall sub_14619F8E0(__int64 a1)
{
  return *(unsigned __int8 *)(a1 + 25);
}

//----- (000000014619F8F0) ----------------------------------------------------
__int64 __fastcall sub_14619F8F0(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 26);
}

//----- (000000014619F900) ----------------------------------------------------
_QWORD *__fastcall sub_14619F900(__int64 a1, _QWORD *a2)
{
  const char *v2; // rbx
  size_t v4; // rax

  v2 = *(const char **)(a1 + 40);
  *(_OWORD *)a2 = 0i64;
  a2[2] = 0i64;
  a2[3] = 0i64;
  v4 = strlen(v2);
  sub_14615A650(a2, v2, v4);
  return a2;
}

//----- (000000014619F950) ----------------------------------------------------
_QWORD *__fastcall sub_14619F950(__int64 a1, _QWORD *a2)
{
  const wchar_t *v2; // rbx
  unsigned __int64 v4; // rax
  __int64 v5; // r9

  v2 = *(const wchar_t **)(a1 + 40);
  *(_OWORD *)a2 = 0i64;
  a2[2] = 0i64;
  a2[3] = 0i64;
  v4 = wcslen(v2);
  sub_146168F30(a2, v2, v4, v5);
  return a2;
}
// 14619F982: variable 'v5' is possibly undefined

//----- (000000014619F9A0) ----------------------------------------------------
int sub_14619F9A0(char *Buffer, size_t BufferCount, char *Format, ...)
{
  unsigned __int64 *v6; // rax
  int result; // eax
  va_list va; // [rsp+88h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = (unsigned __int64 *)sub_146166290();
  result = _stdio_common_vsnprintf_s(*v6, Buffer, BufferCount, 0xFFFFFFFFFFFFFFFFui64, Format, 0i64, va);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (000000014619FA10) ----------------------------------------------------
__int64 __fastcall sub_14619FA10(__int64 a1, __int64 a2, _OWORD *a3)
{
  __int64 v4; // rdi
  int v5; // eax
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // rax
  __int128 v9; // xmm0
  _OWORD pExceptionObject[2]; // [rsp+30h] [rbp-48h] BYREF
  _BYTE v12[24]; // [rsp+50h] [rbp-28h] BYREF

  v4 = *(_QWORD *)(a1 + 16);
  pExceptionObject[0] = *a3;
  v5 = sub_1461987B0((_QWORD *)(v4 + 8), (__int64)pExceptionObject);
  *(_DWORD *)&v12[16] = 0;
  if ( v5 >= 0 )
  {
    v6 = *(_QWORD *)(v4 + 8);
    if ( v6 < 0 )
    {
      if ( v5 >= (int)v6 )
        goto LABEL_9;
      v7 = 3i64 * v5;
      v8 = *(_QWORD *)(v4 + 16);
      v9 = *(_OWORD *)(v8 + 8 * v7);
      *(_QWORD *)&v12[16] = *(_QWORD *)(v8 + 8 * v7 + 16);
      goto LABEL_8;
    }
    if ( v5 < 15 )
    {
      *(_DWORD *)&v12[16] = ((unsigned __int64)v6 >> (4 * (unsigned __int8)v5)) & 0xF;
      if ( *(_DWORD *)&v12[16] )
      {
        v9 = *(_OWORD *)(*(_QWORD *)(v4 + 16) + 16i64 * v5);
LABEL_8:
        *(_OWORD *)v12 = v9;
      }
    }
  }
LABEL_9:
  *(_OWORD *)a2 = *(_OWORD *)v12;
  *(_QWORD *)(a2 + 16) = *(_QWORD *)&v12[16];
  if ( !*(_DWORD *)(a2 + 16) )
  {
    *(_QWORD *)v12 = &std::exception::`vftable';
    *(_OWORD *)&v12[8] = 0i64;
    *(_QWORD *)&pExceptionObject[0] = "argument not found";
    BYTE8(pExceptionObject[0]) = 1;
    _std_exception_copy(pExceptionObject);
    *(_QWORD *)v12 = &fmt::v8::format_error::`vftable';
    sub_146162440((__int64)pExceptionObject, (__int64)v12);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  return a2;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014619FB50) ----------------------------------------------------
__m128i *__fastcall sub_14619FB50(__m128i *a1, int a2)
{
  int v3; // esi
  int v5; // edx
  int v6; // ebp
  __m128i v7; // xmm0
  int v8; // ecx
  char v9; // r10
  unsigned __int64 v10; // xmm0_8
  __int64 v11; // r8
  __int64 v12; // r9
  unsigned __int64 v13; // r11
  unsigned __int128 v14; // rax
  unsigned __int64 v15; // rbx
  unsigned __int64 v16; // r11

  v3 = a2 + 292;
  v5 = (a2 + 292) / 27;
  v6 = 27 * v5 - 292;
  v7 = (__m128i)xmmword_14612F4E0[v5];
  v8 = a2 - v6;
  if ( a2 == v6 )
  {
    *a1 = v7;
  }
  else
  {
    v9 = ((1741647 * a2) >> 19) - ((1741647 * v6) >> 19) - v8;
    v10 = _mm_srli_si128(v7, 8).m128i_u64[0];
    v11 = qword_14612F650[v8];
    v13 = (*(unsigned __int64 *)&xmmword_14612F4E0[v5] * (unsigned __int128)(unsigned __int64)v11) >> 64;
    v12 = *(_QWORD *)&xmmword_14612F4E0[v5] * v11;
    v14 = (v10 - ((unsigned __int64)(unsigned int)v6 >> 31)) * (unsigned __int128)(unsigned __int64)v11;
    v15 = (((v10 - ((unsigned __int64)(unsigned int)v6 >> 31)) * v11) >> v9) | ((*((_QWORD *)&v14 + 1) + v12) << (64 - v9));
    v16 = ((unsigned __int64)(*((_QWORD *)&v14 + 1) + v12) >> v9) | ((__PAIR128__(v13, *((unsigned __int64 *)&v14 + 1))
                                                                    + (unsigned __int64)v12) >> 64 << (64 - v9));
    if ( v6 < 0 )
      v16 = (__PAIR128__(v16, v15++) + 1) >> 64;
    a1->m128i_i64[0] = v16;
    a1->m128i_i64[1] = v15
                     + (((unsigned __int64)(unsigned int)dword_14612F730[v3 / 16] >> (2 * (unsigned __int8)(v3 % 16))) & 3);
  }
  return a1;
}
// 14612F4E0: using guessed type __int128 xmmword_14612F4E0[23];
// 14612F650: using guessed type __int64 qword_14612F650[28];
// 14612F730: using guessed type int dword_14612F730[40];

//----- (000000014619FC90) ----------------------------------------------------
void __fastcall sub_14619FC90(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r14
  unsigned __int64 v4; // rsi
  _QWORD *v5; // rdi
  _QWORD *v6; // rbx

  v2 = a1[3];
  v4 = v2 + (v2 >> 1);
  if ( a2 <= v4 )
  {
    if ( v4 > 0x3FFFFFFFFFFFFFFFi64 )
    {
      v4 = 0x3FFFFFFFFFFFFFFFi64;
      if ( a2 > 0x3FFFFFFFFFFFFFFFi64 )
        v4 = a2;
    }
  }
  else
  {
    v4 = a2;
  }
  v5 = (_QWORD *)a1[1];
  if ( v4 > 0x3FFFFFFFFFFFFFFFi64 )
    sub_146165390();
  v6 = sub_14615A5E0(4 * v4);
  memmove(v6, v5, 4i64 * a1[2]);
  a1[1] = v6;
  a1[3] = v4;
  if ( v5 != a1 + 4 )
  {
    if ( 4 * v2 >= 0x1000 )
    {
      if ( (unsigned __int64)v5 - *(v5 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v5 = (_QWORD *)*(v5 - 1);
    }
    j_j_free(v5);
  }
}
// 146165390: using guessed type void __noreturn sub_146165390(void);

//----- (000000014619FD90) ----------------------------------------------------
__int64 __fastcall sub_14619FD90(__int64 a1)
{
  __int64 result; // rax
  const char *pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v3; // [rsp+30h] [rbp-38h]
  void **v4; // [rsp+40h] [rbp-28h] BYREF
  __int128 v5; // [rsp+48h] [rbp-20h]

  result = *(unsigned int *)(a1 + 16);
  if ( (int)result < 0 )
  {
    v4 = &std::exception::`vftable';
    v5 = 0i64;
    pExceptionObject = "cannot switch from manual to automatic argument indexing";
    v3 = 1;
    _std_exception_copy(&pExceptionObject);
    v4 = &fmt::v8::format_error::`vftable';
    sub_146162440((__int64)&pExceptionObject, (__int64)&v4);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  *(_DWORD *)(a1 + 16) = result + 1;
  return result;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014619FE20) ----------------------------------------------------
void __fastcall __noreturn sub_14619FE20(__int64 a1, __int64 a2)
{
  __int64 pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v3; // [rsp+30h] [rbp-38h]
  void **v4; // [rsp+40h] [rbp-28h] BYREF
  __int128 v5; // [rsp+48h] [rbp-20h]

  v4 = &std::exception::`vftable';
  v5 = 0i64;
  pExceptionObject = a2;
  v3 = 1;
  _std_exception_copy(&pExceptionObject);
  v4 = &fmt::v8::format_error::`vftable';
  sub_146162440((__int64)&pExceptionObject, (__int64)&v4);
  CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014619FE90) ----------------------------------------------------
void **__fastcall sub_14619FE90(_QWORD *a1, __int64 a2)
{
  void **result; // rax
  __int64 v3; // rbp
  unsigned __int64 v4; // rdi
  _BYTE *v5; // rcx
  __int64 v6; // rsi
  __int64 v7; // rdx
  _OWORD pExceptionObject[2]; // [rsp+30h] [rbp-48h] BYREF
  void **v9; // [rsp+50h] [rbp-28h] BYREF
  __int128 v10; // [rsp+58h] [rbp-20h]
  void *retaddr; // [rsp+78h] [rbp+0h] BYREF

  result = &retaddr;
  pExceptionObject[0] = *(_OWORD *)a2;
  v3 = *a1 + 17i64;
  v4 = *(_QWORD *)(a2 + 8);
  if ( v4 > 4 )
  {
    v9 = &std::exception::`vftable';
    v10 = 0i64;
    *(_QWORD *)&pExceptionObject[0] = "invalid fill";
    BYTE8(pExceptionObject[0]) = 1;
    _std_exception_copy(pExceptionObject);
    v9 = &fmt::v8::format_error::`vftable';
    sub_146162440((__int64)pExceptionObject, (__int64)&v9);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  if ( v4 )
  {
    v5 = (_BYTE *)(*a1 + 17i64);
    v6 = *(_QWORD *)&pExceptionObject[0] - v3;
    v7 = *(_QWORD *)(a2 + 8);
    do
    {
      result = (void **)(unsigned __int8)v5[v6];
      *v5++ = (_BYTE)result;
      --v7;
    }
    while ( v7 );
  }
  *(_BYTE *)(v3 + 4) = v4;
  return result;
}
// 14619FED7: conditional instruction was optimized away because rdi.8 is in (1..4)
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (000000014619FFC0) ----------------------------------------------------
char *__fastcall sub_14619FFC0(void ***a1, int a2, const char *a3, char *a4)
{
  void ***v7; // rsi
  __int64 v8; // r8
  void **v9; // rax
  __int128 v10; // xmm0
  __int64 v11; // rdi
  void **v12; // rax
  char *v14; // rax
  char *v15; // rdi
  void **v16; // [rsp+28h] [rbp-61h] BYREF
  __int128 v17; // [rsp+30h] [rbp-59h]
  __int128 pExceptionObject; // [rsp+40h] [rbp-49h] BYREF
  void *v19; // [rsp+50h] [rbp-39h]
  const char *v20; // [rsp+58h] [rbp-31h] BYREF
  char v21; // [rsp+60h] [rbp-29h]
  __int64 v22[3]; // [rsp+68h] [rbp-21h] BYREF
  int v23; // [rsp+80h] [rbp-9h]
  __int64 v24; // [rsp+88h] [rbp-1h]
  int v25[2]; // [rsp+90h] [rbp+7h] BYREF
  char v26; // [rsp+98h] [rbp+Fh]
  int v27; // [rsp+9Ch] [rbp+13h]
  char v28; // [rsp+A0h] [rbp+17h]
  int v29; // [rsp+A1h] [rbp+18h]
  char v30; // [rsp+A5h] [rbp+1Ch]

  v24 = -2i64;
  v7 = a1 + 3;
  LODWORD(v19) = 0;
  v8 = (__int64)a1[4];
  if ( v8 >= 0 )
  {
    if ( a2 >= 15 )
      goto LABEL_15;
    v11 = ((unsigned __int64)v8 >> (4 * (unsigned __int8)a2)) & 0xF;
    LODWORD(v19) = ((unsigned __int64)v8 >> (4 * (unsigned __int8)a2)) & 0xF;
    if ( !(_DWORD)v19 )
      goto LABEL_8;
    v10 = *(_OWORD *)&a1[5][2 * a2];
  }
  else
  {
    if ( a2 >= (int)v8 )
      goto LABEL_15;
    v9 = a1[5];
    v10 = *(_OWORD *)&v9[3 * a2];
    v19 = v9[3 * a2 + 2];
    LODWORD(v11) = (_DWORD)v19;
  }
  pExceptionObject = v10;
LABEL_8:
  if ( !(_DWORD)v11 )
  {
LABEL_15:
    v17 = 0i64;
    v20 = "argument not found";
    v21 = 1;
    _std_exception_copy(&v20);
    v16 = &fmt::v8::format_error::`vftable';
    sub_146162440((__int64)&pExceptionObject, (__int64)&v16);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  if ( (_DWORD)v11 == 15 )
  {
    v12 = *a1;
    *a1 = (void **)a3;
    a1[1] = (void **)((char *)a1[1] + (char *)v12 - a3);
    (*((void (__fastcall **)(_QWORD, void ***, void ***))&pExceptionObject + 1))(pExceptionObject, a1, v7);
    return (char *)*a1;
  }
  else
  {
    v25[0] = 0;
    v25[1] = -1;
    v26 = 0;
    v27 &= 0xFFFFFF80;
    v28 &= 0xFCu;
    v29 = 32;
    v30 = 1;
    v22[0] = (__int64)v25;
    v22[1] = (__int64)a1;
    v22[2] = (__int64)(a1 + 3);
    v23 = v11;
    v14 = sub_146198E90(a3, a4, v22);
    v15 = v14;
    if ( v14 == a4 || *v14 != 125 )
    {
      v17 = 0i64;
      v20 = "missing '}' in format string";
      v21 = 1;
      _std_exception_copy(&v20);
      v16 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v16);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    }
    v16 = *v7;
    *(_QWORD *)&v17 = v25;
    *((_QWORD *)&v17 + 1) = a1[6];
    *v7 = (void **)*sub_14619B1C0((__int64 *)&v20, (__int64 *)&v16, (unsigned int *)&pExceptionObject);
    return v15;
  }
}
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (00000001461A0200) ----------------------------------------------------
__int64 *__fastcall sub_1461A0200(_QWORD *a1, int a2)
{
  __int64 v3; // r8
  __int64 v4; // rax
  __int128 v5; // xmm0
  int v6; // r8d
  __int64 *result; // rax
  const char *v8; // [rsp+28h] [rbp-48h] BYREF
  char v9; // [rsp+30h] [rbp-40h]
  void **v10; // [rsp+38h] [rbp-38h] BYREF
  __int128 v11; // [rsp+40h] [rbp-30h]
  __int64 v12; // [rsp+50h] [rbp-20h]
  __int128 pExceptionObject; // [rsp+58h] [rbp-18h] BYREF
  __int64 v14; // [rsp+68h] [rbp-8h]
  __int64 v15; // [rsp+80h] [rbp+10h] BYREF

  LODWORD(v14) = 0;
  v3 = a1[4];
  if ( v3 >= 0 )
  {
    if ( a2 >= 15 )
      goto LABEL_10;
    v6 = ((unsigned __int64)v3 >> (4 * (unsigned __int8)a2)) & 0xF;
    LODWORD(v14) = v6;
    if ( !v6 )
      goto LABEL_8;
    v5 = *(_OWORD *)(a1[5] + 16i64 * a2);
  }
  else
  {
    if ( a2 >= (int)v3 )
      goto LABEL_10;
    v4 = a1[5];
    v5 = *(_OWORD *)(v4 + 24i64 * a2);
    v14 = *(_QWORD *)(v4 + 24i64 * a2 + 16);
    v6 = v14;
  }
  pExceptionObject = v5;
LABEL_8:
  if ( !v6 )
  {
LABEL_10:
    v10 = &std::exception::`vftable';
    v11 = 0i64;
    v8 = "argument not found";
    v9 = 1;
    _std_exception_copy(&v8);
    v10 = &fmt::v8::format_error::`vftable';
    LOBYTE(v15) = 1;
    sub_146162440((__int64)&pExceptionObject, (__int64)&v10);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  v10 = (void **)a1[3];
  v11 = *((_OWORD *)a1 + 2);
  v12 = a1[6];
  result = sub_14619B6F0(&v15, &v10, (int *)&pExceptionObject);
  a1[3] = *result;
  return result;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (00000001461A0330) ----------------------------------------------------
__int64 __fastcall sub_1461A0330(_DWORD *a1, int a2)
{
  unsigned int v4; // r8d
  int v5; // eax
  __int64 result; // rax
  const char *pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v8; // [rsp+30h] [rbp-38h]
  void **v9; // [rsp+40h] [rbp-28h] BYREF
  __int128 v10; // [rsp+48h] [rbp-20h]

  sub_1461A0620((__int64)a1);
  v4 = a1[6];
  if ( v4 - 1 <= 7 )
  {
    if ( v4 > 8 || (v5 = 266, !_bittest(&v5, v4)) )
    {
      v9 = &std::exception::`vftable';
      v10 = 0i64;
      pExceptionObject = "format specifier requires signed argument";
      v8 = 1;
      _std_exception_copy(&pExceptionObject);
      v9 = &fmt::v8::format_error::`vftable';
      sub_146162440((__int64)&pExceptionObject, (__int64)&v9);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
    }
  }
  result = (16 * a2) ^ (*(_DWORD *)(*(_QWORD *)a1 + 12i64) ^ (16 * a2)) & 0xFFFFFF8F;
  *(_DWORD *)(*(_QWORD *)a1 + 12i64) = result;
  return result;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (00000001461A0410) ----------------------------------------------------
__int64 __fastcall sub_1461A0410(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r10
  __int64 v3; // r8
  unsigned __int64 v4; // rdx
  __int64 result; // rax
  unsigned __int64 v6; // rcx
  unsigned int v7; // edx
  unsigned int v8; // r10d
  unsigned int v9; // edx
  unsigned int v10; // r10d
  unsigned int v11; // edx
  unsigned __int64 v12; // rdx

  v1 = *a1;
  _BitScanForward64((unsigned __int64 *)&v3, *a1);
  if ( (int)v3 <= 16 )
  {
    if ( (int)v3 < 8 )
    {
LABEL_9:
      v6 = v1 / 0x5F5E100;
      if ( !(_DWORD)v3 )
        return 0i64;
      v7 = -858993459 * v1 - 20000000 * v6;
      if ( v7 > 0x33333333 )
        return 0i64;
      if ( (_DWORD)v3 == 1 || (v8 = -858993459 * v7, -858993459 * v7 > 0x33333333) )
      {
        result = 1i64;
        *a1 = ((unsigned __int64)v7 >> 1) + 10000000i64 * (unsigned int)v6;
      }
      else if ( (_DWORD)v3 == 2 || (v9 = -1030792151 * v7, -858993459 * v8 > 0x33333333) )
      {
        result = 2i64;
        *a1 = ((unsigned __int64)v8 >> 2) + 1000000i64 * (unsigned int)v6;
      }
      else if ( (_DWORD)v3 == 3 || (v10 = -1030792151 * v8, -858993459 * v9 > 0x33333333) )
      {
        result = 3i64;
        *a1 = ((unsigned __int64)v9 >> 3) + 100000i64 * (unsigned int)v6;
      }
      else if ( (_DWORD)v3 == 4 || (v11 = -1030792151 * v9, -858993459 * v10 > 0x33333333) )
      {
        result = 4i64;
        *a1 = ((unsigned __int64)v10 >> 4) + 10000i64 * (unsigned int)v6;
      }
      else if ( (_DWORD)v3 == 5 || -1030792151 * v10 > 0x33333333 )
      {
        result = 5i64;
        *a1 = ((unsigned __int64)v11 >> 5) + 1000i64 * (unsigned int)v6;
      }
      else if ( (_DWORD)v3 == 6 || (v12 = -1030792151 * v11, (unsigned int)v12 > 0x33333333) )
      {
        result = 6i64;
        *a1 = 100i64 * (unsigned int)v6 + ((unsigned __int64)(-1030792151 * v10) >> 6);
      }
      else
      {
        *a1 = (v12 >> 7) + 10i64 * (unsigned int)v6;
        return 7i64;
      }
      return result;
    }
  }
  else
  {
    LODWORD(v3) = 16;
  }
  if ( 0xC767074B22E90E21ui64 * v1 > 0x2AF31DC46118i64 )
    goto LABEL_9;
  v4 = (0xC767074B22E90E21ui64 * v1) >> 8;
  result = 8i64;
  if ( (unsigned int)v3 > 8 )
  {
    do
    {
      if ( (unsigned int)(-858993459 * v4) > 0x33333333 )
        break;
      result = (unsigned int)(result + 1);
      LODWORD(v4) = -858993459 * v4;
    }
    while ( (int)result < (int)v3 );
  }
  *a1 = (unsigned __int64)(unsigned int)v4 >> ((unsigned __int8)result - 8);
  return result;
}

//----- (00000001461A0620) ----------------------------------------------------
__int64 __fastcall sub_1461A0620(__int64 a1)
{
  __int64 result; // rax
  const char *pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v3; // [rsp+30h] [rbp-38h]
  void **v4; // [rsp+40h] [rbp-28h] BYREF
  __int128 v5; // [rsp+48h] [rbp-20h]

  result = (unsigned int)(*(_DWORD *)(a1 + 24) - 1);
  if ( (unsigned int)result > 0xA )
  {
    v4 = &std::exception::`vftable';
    v5 = 0i64;
    pExceptionObject = "format specifier requires numeric argument";
    v3 = 1;
    _std_exception_copy(&pExceptionObject);
    v4 = &fmt::v8::format_error::`vftable';
    sub_146162440((__int64)&pExceptionObject, (__int64)&v4);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVformat_error_v8_fmt__);
  }
  return result;
}
// 14611CDC0: using guessed type void *std::exception::`vftable';
// 14611CEB8: using guessed type void *fmt::v8::format_error::`vftable';
// 1461A8F16: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);

//----- (00000001461A06B0) ----------------------------------------------------
void __fastcall sub_1461A06B0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rsi
  unsigned int v5; // r14d
  void **v6; // rcx
  char *v7; // r9
  unsigned __int64 v8; // rdi
  __int64 v9; // rdi
  bool v10; // cc
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // r8
  __int64 v13; // rdi
  __int64 v14; // rsi
  __int64 v15; // r10
  char *v16; // r11
  unsigned __int64 v17; // rdx
  unsigned __int64 v18; // rcx
  __int64 v19; // r15
  __int64 v20; // r14
  __int64 v21; // rsi
  __int64 v22; // r15
  __int64 v23; // r10
  char *v24; // r11
  unsigned __int64 v25; // rdx
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  unsigned __int64 v28; // rdi
  bool v29; // cc
  char *v30; // rax
  void **v31; // [rsp+48h] [rbp-89h] BYREF
  void *Block; // [rsp+50h] [rbp-81h]
  unsigned __int64 v33; // [rsp+58h] [rbp-79h]
  unsigned __int64 v34; // [rsp+60h] [rbp-71h]
  char v35[144]; // [rsp+68h] [rbp-69h] BYREF

  v4 = *(int *)(a1 + 16);
  v5 = 2 * v4;
  v33 = 0i64;
  v6 = &fmt::v8::basic_memory_buffer<unsigned int,32,std::allocator<unsigned int>>::`vftable';
  v31 = &fmt::v8::basic_memory_buffer<unsigned int,32,std::allocator<unsigned int>>::`vftable';
  v7 = *(char **)(a1 + 8);
  v8 = *(_QWORD *)(a1 + 16);
  v34 = *(_QWORD *)(a1 + 24);
  if ( v7 == (char *)(a1 + 32) )
  {
    Block = v35;
    memcpy(v35, (const void *)(a1 + 32), 4 * v8);
    v7 = v35;
    v6 = v31;
  }
  else
  {
    Block = v7;
    *(_QWORD *)(a1 + 8) = a1 + 32;
    *(_QWORD *)(a1 + 24) = 0i64;
  }
  if ( v8 <= v34 )
    goto LABEL_9;
  if ( *v6 == sub_14619FC90 )
    sub_14619FC90(&v31, v8);
  else
    ((void (__fastcall *)(void ***, unsigned __int64, __int64, char *))*v6)(&v31, v8, a3, v7);
  v7 = (char *)Block;
  v33 = v34;
  if ( v8 <= v34 )
LABEL_9:
    v33 = v8;
  v9 = v5;
  v10 = (unsigned __int64)v5 <= *(_QWORD *)(a1 + 24);
  if ( (unsigned __int64)v5 > *(_QWORD *)(a1 + 24) )
  {
    (**(void (__fastcall ***)(__int64, _QWORD, __int64, char *))a1)(a1, v5, a3, v7);
    v7 = (char *)Block;
    v10 = (unsigned __int64)v5 <= *(_QWORD *)(a1 + 24);
  }
  if ( !v10 )
    v9 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = v9;
  v11 = 0i64;
  v12 = 0i64;
  v13 = v4;
  if ( (int)v4 > 0 )
  {
    v14 = 0i64;
    do
    {
      v15 = v14;
      v16 = v7;
      do
      {
        v17 = *(unsigned int *)v16 * (unsigned __int64)*(unsigned int *)&v7[4 * v15];
        v11 += v17;
        v18 = v12 + 1;
        if ( v11 >= v17 )
          v18 = v12;
        v12 = v18;
        v16 += 4;
        --v15;
      }
      while ( v15 >= 0 );
      *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v14) = v11;
      v11 = (v18 << 32) | HIDWORD(v11);
      v12 = HIDWORD(v18);
      ++v14;
      v7 = (char *)Block;
    }
    while ( v14 < v13 );
  }
  v19 = (int)v5;
  if ( v13 < (int)v5 )
  {
    v20 = 4 * v13;
    v21 = 1i64;
    v22 = v19 - v13;
    do
    {
      v23 = v21;
      if ( v21 < v13 )
      {
        v24 = &v7[4 * v13 - 4];
        do
        {
          v25 = *(unsigned int *)v24 * (unsigned __int64)*(unsigned int *)&v7[4 * v23];
          v24 -= 4;
          ++v23;
          v11 += v25;
          v26 = v12 + 1;
          if ( v11 >= v25 )
            v26 = v12;
          v12 = v26;
        }
        while ( v23 < v13 );
      }
      *(_DWORD *)(v20 + *(_QWORD *)(a1 + 8)) = v11;
      v11 = HIDWORD(v11) | (v12 << 32);
      v12 >>= 32;
      ++v21;
      v20 += 4i64;
      --v22;
      v7 = (char *)Block;
    }
    while ( v22 );
  }
  v27 = (unsigned int)(*(_DWORD *)(a1 + 16) - 1);
  if ( *(_DWORD *)(a1 + 16) - 1 > 0 )
  {
    do
    {
      if ( *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v27) )
        break;
      v27 = (unsigned int)(v27 - 1);
    }
    while ( (int)v27 > 0 );
  }
  v28 = (unsigned int)(v27 + 1);
  v29 = v28 <= *(_QWORD *)(a1 + 24);
  if ( v28 > *(_QWORD *)(a1 + 24) )
  {
    (**(void (__fastcall ***)(__int64, _QWORD, unsigned __int64, char *))a1)(a1, (unsigned int)v28, v12, v7);
    v7 = (char *)Block;
    v29 = v28 <= *(_QWORD *)(a1 + 24);
  }
  if ( !v29 )
    v28 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = v28;
  *(_DWORD *)(a1 + 168) *= 2;
  v31 = &fmt::v8::basic_memory_buffer<unsigned int,32,std::allocator<unsigned int>>::`vftable';
  if ( v7 != v35 )
  {
    v30 = v7;
    if ( 4 * v34 >= 0x1000 )
    {
      v7 = (char *)*((_QWORD *)v7 - 1);
      if ( (unsigned __int64)(v30 - v7 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v7);
  }
}
// 1461A0784: variable 'a3' is possibly undefined
// 14612F258: using guessed type void *fmt::v8::basic_memory_buffer<unsigned int,32,std::allocator<unsigned int>>::`vftable';

//----- (00000001461A0990) ----------------------------------------------------
unsigned __int64 __fastcall sub_1461A0990(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax

  if ( a2 > *(_QWORD *)(a1 + 24) )
    (**(void (__fastcall ***)(__int64))a1)(a1);
  result = *(_QWORD *)(a1 + 24);
  if ( a2 <= result )
    result = a2;
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

//----- (00000001461A09D0) ----------------------------------------------------
_QWORD *__fastcall sub_1461A09D0(_QWORD *a1, __int128 *a2, __int128 *a3)
{
  _BYTE *v4; // rcx
  __int128 v6; // [rsp+40h] [rbp-278h] BYREF
  __int64 v7; // [rsp+50h] [rbp-268h]
  __int128 v8; // [rsp+60h] [rbp-258h] BYREF
  void **v9; // [rsp+70h] [rbp-248h] BYREF
  void *Block; // [rsp+78h] [rbp-240h]
  size_t v11; // [rsp+80h] [rbp-238h]
  unsigned __int64 v12; // [rsp+88h] [rbp-230h]
  char v13[512]; // [rsp+90h] [rbp-228h] BYREF

  v7 = -2i64;
  *(_QWORD *)&v6 = a1;
  v11 = 0i64;
  v9 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  Block = v13;
  v12 = 500i64;
  v6 = *a3;
  v8 = *a2;
  sub_14619B060((__int64)&v9, (__int64)&v8, (__int64 *)&v6, 0i64);
  *(_OWORD *)a1 = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  sub_14615A650(a1, Block, v11);
  v9 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  v4 = Block;
  if ( Block != v13 )
  {
    if ( v12 >= 0x1000 )
    {
      v4 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v4 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v4);
  }
  return a1;
}
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';

//----- (00000001461A0B00) ----------------------------------------------------
__int64 __fastcall sub_1461A0B00(__int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rsi
  void *v4; // rcx
  wchar_t *v5; // r14
  HMODULE ModuleHandleW; // rax
  unsigned __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r9
  unsigned __int64 v12; // rdx
  _QWORD *v13; // rcx
  unsigned __int64 v14; // rdx
  void *v15; // rcx
  void *v16; // rcx
  __int64 v17; // r12
  const void *v18; // r13
  __int64 v19; // r15
  unsigned __int64 v20; // rbx
  __int128 *p_lpFileName_8; // r14
  __int64 v22; // rcx
  const WCHAR *v23; // rcx
  DWORD FileAttributesW; // ebx
  void *v25; // r8
  const WCHAR *v26; // rax
  BOOL DirectoryW; // ebx
  void *v28; // r8
  const WCHAR *v29; // rax
  DWORD v30; // ebx
  void *v31; // r8
  const WCHAR *v32; // rcx
  const WCHAR *v33; // rcx
  __int64 v34; // rdx
  __int64 v35; // r8
  __int64 v36; // r9
  __int64 v37; // r12
  __int128 *v38; // r13
  __int64 v39; // r15
  unsigned __int64 v40; // rbx
  __int128 *p_Block_8; // r14
  __int64 v42; // rcx
  __int64 v43; // r8
  __int64 v44; // r9
  unsigned __int64 v45; // rdx
  _QWORD *v46; // rcx
  void *v47; // rcx
  void *v48; // rcx
  void *v49; // rcx
  HANDLE hObject; // [rsp+40h] [rbp-C8h] BYREF
  LPCVOID lpBaseAddress; // [rsp+48h] [rbp-C0h]
  __int64 v53; // [rsp+50h] [rbp-B8h]
  LPCWSTR lpFileName; // [rsp+58h] [rbp-B0h]
  __int128 lpFileName_8; // [rsp+60h] [rbp-A8h] BYREF
  __int128 v56; // [rsp+70h] [rbp-98h]
  __int128 Block_8; // [rsp+80h] [rbp-88h] BYREF
  __m128i si128; // [rsp+90h] [rbp-78h]
  void *v59[2]; // [rsp+A0h] [rbp-68h] BYREF
  __int128 v60; // [rsp+B0h] [rbp-58h]
  void *v61[2]; // [rsp+C0h] [rbp-48h] BYREF
  __int128 v62; // [rsp+D0h] [rbp-38h]
  WCHAR Buffer[40]; // [rsp+E8h] [rbp-20h] BYREF
  WCHAR Filename[512]; // [rsp+4E8h] [rbp+3E0h] BYREF

  v53 = -2i64;
  lpFileName = (LPCWSTR)a2;
  *(_OWORD *)a2 = 0i64;
  *(_QWORD *)(a2 + 16) = 0i64;
  v3 = 7i64;
  *(_QWORD *)(a2 + 24) = 7i64;
  *(_WORD *)a2 = 0;
  BYTE13(Block_8) = 0;
  HIWORD(Block_8) = 0;
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611E150);
  strcpy((char *)&Block_8, "CfxInitState");
  sub_146166700((__int64)&hObject, (__int64 *)&Block_8);
  if ( si128.m128i_i64[1] > 0xFui64 )
  {
    v4 = (void *)Block_8;
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v4 = *(void **)(Block_8 - 8);
      if ( (unsigned __int64)(Block_8 - (_QWORD)v4 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v4);
  }
  si128 = _mm_load_si128((const __m128i *)&Size);
  LOBYTE(Block_8) = 0;
  v5 = (wchar_t *)lpBaseAddress;
  if ( !*((_WORD *)lpBaseAddress + 8) )
  {
    ModuleHandleW = GetModuleHandleW(0i64);
    GetModuleFileNameW(ModuleHandleW, Filename, 0x200u);
    GetFullPathNameW(Filename, 0x200u, Buffer, 0i64);
    wcsrchr(Buffer, 0x5Cu)[1] = 0;
    wcscpy_s(v5 + 8, 0x400ui64, Buffer);
  }
  lpFileName_8 = 0i64;
  v56 = 0i64;
  v7 = wcslen(v5 + 8);
  sub_146168F30(&lpFileName_8, v5 + 8, v7, v8);
  sub_146170F20((__int64)v59, (__int64)&lpFileName_8, v9, v10);
  if ( (void **)a2 == v59 )
  {
    v14 = *((_QWORD *)&v60 + 1);
  }
  else
  {
    v12 = *(_QWORD *)(a2 + 24);
    if ( v12 > 7 )
    {
      v13 = *(_QWORD **)a2;
      if ( 2 * v12 + 2 >= 0x1000 )
      {
        if ( (unsigned __int64)v13 - *(v13 - 1) - 8 > 0x1F )
          goto LABEL_19;
        v13 = (_QWORD *)*(v13 - 1);
      }
      j_j_free(v13);
    }
    *(_OWORD *)a2 = *(_OWORD *)v59;
    *(_OWORD *)(a2 + 16) = v60;
    v14 = 7i64;
    LOWORD(v59[0]) = 0;
  }
  if ( v14 > 7 )
  {
    v15 = v59[0];
    if ( 2 * v14 + 2 >= 0x1000 )
    {
      v15 = (void *)*((_QWORD *)v59[0] - 1);
      if ( (unsigned __int64)(v59[0] - v15 - 8) > 0x1F )
LABEL_19:
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v15);
  }
  if ( *((_QWORD *)&v56 + 1) > 7ui64 )
  {
    v16 = (void *)lpFileName_8;
    if ( (unsigned __int64)(2i64 * *((_QWORD *)&v56 + 1) + 2) >= 0x1000 )
    {
      v16 = *(void **)(lpFileName_8 - 8);
      if ( (unsigned __int64)(lpFileName_8 - (_QWORD)v16 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v16);
  }
  if ( *((_BYTE *)v5 + 14) )
  {
    v17 = *(_QWORD *)(a2 + 16);
    if ( (unsigned __int64)(0x7FFFFFFFFFFFFFFEi64 - v17) < 0xA )
      unknown_libname_4(0x7FFFFFFFFFFFFFFEi64, 0x7FFFFFFFFFFFFFFFi64, 10i64, v11);
    v18 = (const void *)a2;
    if ( *(_QWORD *)(a2 + 24) > 7ui64 )
      v18 = *(const void **)a2;
    lpFileName_8 = 0i64;
    v56 = 0i64;
    v19 = v17 + 10;
    v20 = 7i64;
    p_lpFileName_8 = &lpFileName_8;
    if ( (unsigned __int64)(v17 + 10) > 7 )
    {
      v20 = v19 | 7;
      if ( (v19 | 7ui64) <= 0x7FFFFFFFFFFFFFFEi64 )
      {
        if ( v20 < 0xA )
          v20 = 10i64;
        v22 = v20 + 1;
        if ( v20 + 1 > 0x7FFFFFFFFFFFFFFFi64 )
          sub_146165390(v22, 0x7FFFFFFFFFFFFFFFi64, 10i64);
      }
      else
      {
        v20 = 0x7FFFFFFFFFFFFFFEi64;
        v22 = 0x7FFFFFFFFFFFFFFFi64;
      }
      p_lpFileName_8 = (__int128 *)sub_14615A5E0(2 * v22);
      *(_QWORD *)&lpFileName_8 = p_lpFileName_8;
    }
    *(_QWORD *)&v56 = v17 + 10;
    *((_QWORD *)&v56 + 1) = v20;
    memcpy(p_lpFileName_8, v18, 2 * v17);
    *(__int128 *)((char *)p_lpFileName_8 + 2 * v17) = *(_OWORD *)L"CoreRT.dll";
    *(_DWORD *)((char *)p_lpFileName_8 + 2 * v17 + 16) = *(_DWORD *)L"ll";
    *((_WORD *)p_lpFileName_8 + v19) = 0;
    v23 = (const WCHAR *)&lpFileName_8;
    if ( *((_QWORD *)&v56 + 1) > 7ui64 )
      v23 = (const WCHAR *)lpFileName_8;
    FileAttributesW = GetFileAttributesW(v23);
    if ( *((_QWORD *)&v56 + 1) > 7ui64 )
    {
      v25 = (void *)lpFileName_8;
      if ( (unsigned __int64)(2i64 * *((_QWORD *)&v56 + 1) + 2) >= 0x1000 )
      {
        v25 = *(void **)(lpFileName_8 - 8);
        if ( (unsigned __int64)(lpFileName_8 - (_QWORD)v25 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v25);
    }
    if ( FileAttributesW == -1 )
    {
      v26 = (const WCHAR *)sub_146194910(&lpFileName_8, (_QWORD *)a2, (wchar_t *)L"ChanCity.app");
      if ( *((_QWORD *)v26 + 3) > 7ui64 )
        v26 = *(const WCHAR **)v26;
      DirectoryW = CreateDirectoryW(v26, 0i64);
      if ( *((_QWORD *)&v56 + 1) > 7ui64 )
      {
        v28 = (void *)lpFileName_8;
        if ( (unsigned __int64)(2i64 * *((_QWORD *)&v56 + 1) + 2) >= 0x1000 )
        {
          v28 = *(void **)(lpFileName_8 - 8);
          if ( (unsigned __int64)(lpFileName_8 - (_QWORD)v28 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v28);
      }
      if ( !DirectoryW && GetLastError() != 183 )
        ExitProcess(1u);
    }
  }
  v29 = (const WCHAR *)sub_146194910(&lpFileName_8, (_QWORD *)a2, (wchar_t *)L"CoreRT.dll");
  if ( *((_QWORD *)v29 + 3) > 7ui64 )
    v29 = *(const WCHAR **)v29;
  v30 = GetFileAttributesW(v29);
  if ( *((_QWORD *)&v56 + 1) > 7ui64 )
  {
    v31 = (void *)lpFileName_8;
    if ( (unsigned __int64)(2i64 * *((_QWORD *)&v56 + 1) + 2) >= 0x1000 )
    {
      v31 = *(void **)(lpFileName_8 - 8);
      if ( (unsigned __int64)(lpFileName_8 - (_QWORD)v31 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v31);
  }
  if ( v30 == -1 )
  {
    sub_146194910(&lpFileName_8, (_QWORD *)a2, (wchar_t *)L"ChanCity.app");
    v32 = (const WCHAR *)&lpFileName_8;
    if ( *((_QWORD *)&v56 + 1) > 7ui64 )
      v32 = (const WCHAR *)lpFileName_8;
    if ( GetFileAttributesW(v32) != -1 )
    {
      v33 = (const WCHAR *)&lpFileName_8;
      if ( *((_QWORD *)&v56 + 1) > 7ui64 )
        v33 = (const WCHAR *)lpFileName_8;
      if ( (GetFileAttributesW(v33) & 0x10) != 0 )
      {
        v37 = v56;
        if ( (_QWORD)v56 == 0x7FFFFFFFFFFFFFFEi64 )
          unknown_libname_4(0x7FFFFFFFFFFFFFFEi64, v34, v35, v36);
        v38 = &lpFileName_8;
        if ( *((_QWORD *)&v56 + 1) > 7ui64 )
          v38 = (__int128 *)lpFileName_8;
        Block_8 = 0i64;
        si128 = 0i64;
        v39 = v56 + 1;
        v40 = 7i64;
        p_Block_8 = &Block_8;
        if ( (unsigned __int64)(v56 + 1) > 7 )
        {
          v40 = v39 | 7;
          if ( (v39 | 7ui64) <= 0x7FFFFFFFFFFFFFFEi64 )
          {
            if ( v40 < 0xA )
              v40 = 10i64;
            v42 = v40 + 1;
            if ( v40 + 1 > 0x7FFFFFFFFFFFFFFFi64 )
              sub_146165390(v42, v34, v35);
          }
          else
          {
            v40 = 0x7FFFFFFFFFFFFFFEi64;
            v42 = 0x7FFFFFFFFFFFFFFFi64;
          }
          p_Block_8 = (__int128 *)sub_14615A5E0(2 * v42);
          *(_QWORD *)&Block_8 = p_Block_8;
        }
        si128.m128i_i64[0] = v37 + 1;
        si128.m128i_i64[1] = v40;
        memcpy(p_Block_8, v38, 2 * v37);
        *((_WORD *)p_Block_8 + v37) = 92;
        *((_WORD *)p_Block_8 + v39) = 0;
        sub_146170F20((__int64)v61, (__int64)&Block_8, v43, v44);
        if ( (void **)a2 == v61 )
        {
          v3 = *((_QWORD *)&v62 + 1);
        }
        else
        {
          v45 = *(_QWORD *)(a2 + 24);
          if ( v45 > 7 )
          {
            v46 = *(_QWORD **)a2;
            if ( 2 * v45 + 2 >= 0x1000 )
            {
              if ( (unsigned __int64)v46 - *(v46 - 1) - 8 > 0x1F )
                goto LABEL_92;
              v46 = (_QWORD *)*(v46 - 1);
            }
            j_j_free(v46);
          }
          *(_OWORD *)a2 = *(_OWORD *)v61;
          *(_OWORD *)(a2 + 16) = v62;
          LOWORD(v61[0]) = 0;
        }
        if ( v3 > 7 )
        {
          v47 = v61[0];
          if ( 2 * v3 + 2 >= 0x1000 )
          {
            v47 = (void *)*((_QWORD *)v61[0] - 1);
            if ( (unsigned __int64)(v61[0] - v47 - 8) > 0x1F )
LABEL_92:
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v47);
        }
        if ( si128.m128i_i64[1] > 7ui64 )
        {
          v48 = (void *)Block_8;
          if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
          {
            v48 = *(void **)(Block_8 - 8);
            if ( (unsigned __int64)(Block_8 - (_QWORD)v48 - 8) > 0x1F )
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v48);
        }
      }
    }
    if ( *((_QWORD *)&v56 + 1) > 7ui64 )
    {
      v49 = (void *)lpFileName_8;
      if ( (unsigned __int64)(2i64 * *((_QWORD *)&v56 + 1) + 2) >= 0x1000 )
      {
        v49 = *(void **)(lpFileName_8 - 8);
        if ( (unsigned __int64)(lpFileName_8 - (_QWORD)v49 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v49);
    }
  }
  if ( lpBaseAddress != &unk_146106050 )
    UnmapViewOfFile(lpBaseAddress);
  if ( hObject )
    CloseHandle(hObject);
  return a2;
}
// 1461A0CA0: variable 'v8' is possibly undefined
// 1461A0CB6: variable 'v9' is possibly undefined
// 1461A0CB6: variable 'v10' is possibly undefined
// 1461A114F: variable 'v43' is possibly undefined
// 1461A114F: variable 'v44' is possibly undefined
// 1461A1330: variable 'v34' is possibly undefined
// 1461A1330: variable 'v35' is possibly undefined
// 1461A1330: variable 'v36' is possibly undefined
// 1461A1342: variable 'v11' is possibly undefined
// 14611E150: using guessed type __int128 xmmword_14611E150;
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001461A1350) ----------------------------------------------------
__int64 __fastcall sub_1461A1350(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  void *v5; // rcx
  LPCVOID v6; // rbx
  __int64 v7; // rdi
  void *v8; // rcx
  _BYTE *v9; // rcx
  __int64 v11; // r9
  char v12[8]; // [rsp+30h] [rbp-98h] BYREF
  __int64 v13; // [rsp+38h] [rbp-90h]
  HANDLE hObject; // [rsp+48h] [rbp-80h] BYREF
  LPCVOID lpBaseAddress; // [rsp+50h] [rbp-78h]
  __int64 v16; // [rsp+58h] [rbp-70h]
  void *Block[2]; // [rsp+60h] [rbp-68h] BYREF
  __m128i si128; // [rsp+70h] [rbp-58h]
  void *v19; // [rsp+80h] [rbp-48h] BYREF
  unsigned __int64 v20; // [rsp+98h] [rbp-30h]

  v16 = -2i64;
  v13 = a1;
  if ( dword_14611ACE0 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                   + 380i64) )
  {
    sub_1461A7CF4(&dword_14611ACE0);
    if ( dword_14611ACE0 == -1 )
    {
      sub_1461A0B00((__int64)v12, (__int64)&unk_14611ACA0);
      xmmword_14611ACC0 = 0i64;
      unk_14611ACD0 = 0i64;
      sub_146168F30(&xmmword_14611ACC0, &Default, 0i64, v11);
      atexit(sub_1461AE9C0);
      Init_thread_footer(&dword_14611ACE0);
    }
  }
  if ( !_InterlockedCompareExchange(&dword_14611ACE8, 0, 0) )
  {
    si128 = _mm_load_si128((const __m128i *)&xmmword_14611E150);
    strcpy((char *)Block, "CfxInitState");
    BYTE5(Block[1]) = 0;
    HIWORD(Block[1]) = 0;
    sub_146166700((__int64)&hObject, (__int64 *)Block);
    if ( si128.m128i_i64[1] > 0xFui64 )
    {
      v5 = Block[0];
      if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
      {
        v5 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)(Block[0] - v5 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v5);
    }
    si128 = _mm_load_si128((const __m128i *)&Size);
    LOBYTE(Block[0]) = 0;
    v6 = lpBaseAddress;
    if ( *((_BYTE *)lpBaseAddress + 14) && !_InterlockedCompareExchange(&dword_14611ACE8, 1, 0) )
    {
      v7 = sub_1461A0B00((__int64)v12, (__int64)&v19);
      if ( &xmmword_14611ACC0 != (__int128 *)v7 )
      {
        if ( (unsigned __int64)qword_14611ACD8 > 7 )
        {
          v8 = (void *)xmmword_14611ACC0;
          if ( (unsigned __int64)(2 * qword_14611ACD8 + 2) >= 0x1000 )
          {
            v8 = *(void **)(xmmword_14611ACC0 - 8);
            if ( (unsigned __int64)(xmmword_14611ACC0 - (_QWORD)v8 - 8) > 0x1F )
LABEL_19:
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
          }
          j_j_free(v8);
        }
        unk_14611ACD0 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
        LOWORD(xmmword_14611ACC0) = 0;
        xmmword_14611ACC0 = *(_OWORD *)v7;
        unk_14611ACD0 = *(_OWORD *)(v7 + 16);
        *(_QWORD *)(v7 + 16) = 0i64;
        *(_QWORD *)(v7 + 24) = 7i64;
        *(_WORD *)v7 = 0;
      }
      if ( v20 > 7 )
      {
        v9 = v19;
        if ( 2 * v20 + 2 >= 0x1000 )
        {
          v9 = (_BYTE *)*((_QWORD *)v19 - 1);
          if ( (unsigned __int64)((_BYTE *)v19 - v9 - 8) > 0x1F )
            goto LABEL_19;
        }
        j_j_free(v9);
      }
      dword_14611ACE4 = 1;
    }
    if ( v6 != &unk_146106050 )
      UnmapViewOfFile(v6);
    if ( hObject )
      CloseHandle(hObject);
  }
  sub_146170F20(a1, (__int64)&unk_14611ACA0 + 32 * dword_14611ACE4, a3, a4);
  return a1;
}
// 1461A15CD: variable 'a3' is possibly undefined
// 1461A15CD: variable 'a4' is possibly undefined
// 1461A164F: variable 'v11' is possibly undefined
// 14611ACC0: using guessed type __int128 xmmword_14611ACC0;
// 14611ACD8: using guessed type __int64 qword_14611ACD8;
// 14611ACE0: using guessed type int dword_14611ACE0;
// 14611ACE4: using guessed type int dword_14611ACE4;
// 14611ACE8: using guessed type int dword_14611ACE8;
// 14611AE78: using guessed type int TlsIndex;
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 14611E150: using guessed type __int128 xmmword_14611E150;
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);
// 1461A1350: using guessed type char var_98[8];

//----- (00000001461A1680) ----------------------------------------------------
_QWORD *__fastcall sub_1461A1680(_QWORD *a1)
{
  __int64 v2; // r9
  void *v3; // rcx
  wchar_t *v4; // rdi
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rax
  _BYTE *v8; // rcx
  const WCHAR *p_lpFileName_8; // rcx
  __int64 v10; // r9
  void *v11; // rcx
  const wchar_t *CommandLineW; // rax
  wchar_t *v13; // rax
  const WCHAR *v14; // rdx
  const WCHAR *v15; // rax
  void *v16; // rcx
  unsigned __int64 v17; // rax
  __int64 v18; // r9
  HANDLE hObject; // [rsp+48h] [rbp-C0h] BYREF
  _QWORD lpBaseAddress[6]; // [rsp+50h] [rbp-B8h] BYREF
  __int128 lpFileName_8; // [rsp+80h] [rbp-88h] BYREF
  __m128i v23; // [rsp+90h] [rbp-78h]
  void *Block[2]; // [rsp+A0h] [rbp-68h] BYREF
  __m128i si128; // [rsp+B0h] [rbp-58h]
  void *v26; // [rsp+C0h] [rbp-48h] BYREF
  __m128i v27; // [rsp+D0h] [rbp-38h]
  WCHAR ReturnedString[512]; // [rsp+E8h] [rbp-20h] BYREF

  lpBaseAddress[5] = -2i64;
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611E150);
  strcpy((char *)Block, "CfxInitState");
  BYTE5(Block[1]) = 0;
  HIWORD(Block[1]) = 0;
  sub_146166700((__int64)&hObject, (__int64 *)Block);
  if ( si128.m128i_i64[1] > 0xFui64 )
  {
    v3 = Block[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v3 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v3 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v3);
  }
  si128 = _mm_load_si128((const __m128i *)&Size);
  LOBYTE(Block[0]) = 0;
  v4 = (wchar_t *)lpBaseAddress[0];
  if ( *(_WORD *)(lpBaseAddress[0] + 4112i64) )
    goto LABEL_29;
  memset(&lpBaseAddress[1], 0, 32);
  sub_146168F30(&lpBaseAddress[1], L"CitizenFX.ini", 0xDui64, v2);
  v7 = sub_1461645B0((__int64)&v26, (void **)&lpBaseAddress[1], v5, v6);
  lpFileName_8 = 0i64;
  v23 = 0i64;
  lpFileName_8 = *(_OWORD *)v7;
  v23 = *(__m128i *)(v7 + 16);
  *(_QWORD *)(v7 + 16) = 0i64;
  *(_QWORD *)(v7 + 24) = 7i64;
  *(_WORD *)v7 = 0;
  if ( v27.m128i_i64[1] > 7ui64 )
  {
    v8 = v26;
    if ( (unsigned __int64)(2 * v27.m128i_i64[1] + 2) >= 0x1000 )
    {
      v8 = (_BYTE *)*((_QWORD *)v26 - 1);
      if ( (unsigned __int64)((_BYTE *)v26 - v8 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v8);
  }
  v27 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(v26) = 0;
  p_lpFileName_8 = (const WCHAR *)&lpFileName_8;
  if ( v23.m128i_i64[1] > 7ui64 )
    p_lpFileName_8 = (const WCHAR *)lpFileName_8;
  if ( GetFileAttributesW(p_lpFileName_8) != -1 )
  {
    CommandLineW = GetCommandLineW();
    v13 = wcsstr(CommandLineW, L"cl2");
    v14 = L"PathCL2";
    if ( !v13 )
      v14 = L"IVPath";
    v15 = (const WCHAR *)&lpFileName_8;
    if ( v23.m128i_i64[1] > 7ui64 )
      v15 = (const WCHAR *)lpFileName_8;
    GetPrivateProfileStringW(L"Game", v14, &Default, ReturnedString, 0x200u, v15);
    wcscpy_s(v4 + 2056, 0x400ui64, ReturnedString);
    wcscat_s(v4 + 2056, 0x400ui64, asc_14612C3A4);
    if ( v23.m128i_i64[1] > 7ui64 )
    {
      v16 = (void *)lpFileName_8;
      if ( (unsigned __int64)(2 * v23.m128i_i64[1] + 2) >= 0x1000 )
      {
        v16 = *(void **)(lpFileName_8 - 8);
        if ( (unsigned __int64)(lpFileName_8 - (_QWORD)v16 - 8) > 0x1F )
          goto LABEL_27;
      }
      j_j_free(v16);
    }
LABEL_29:
    *(_OWORD *)a1 = 0i64;
    a1[2] = 0i64;
    a1[3] = 0i64;
    v17 = wcslen(v4 + 2056);
    sub_146168F30(a1, v4 + 2056, v17, v18);
    goto LABEL_30;
  }
  *(_OWORD *)a1 = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  sub_146168F30(a1, L"null", 4ui64, v10);
  if ( v23.m128i_i64[1] > 7ui64 )
  {
    v11 = (void *)lpFileName_8;
    if ( (unsigned __int64)(2 * v23.m128i_i64[1] + 2) < 0x1000
      || (v11 = *(void **)(lpFileName_8 - 8), (unsigned __int64)(lpFileName_8 - (_QWORD)v11 - 8) <= 0x1F) )
    {
      j_j_free(v11);
      goto LABEL_19;
    }
LABEL_27:
    invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
  }
LABEL_19:
  v23 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(lpFileName_8) = 0;
LABEL_30:
  if ( v4 && v4 != (wchar_t *)&unk_146106050 )
    UnmapViewOfFile(v4);
  if ( hObject )
    CloseHandle(hObject);
  return a1;
}
// 1461A1794: variable 'v2' is possibly undefined
// 1461A17A2: variable 'v5' is possibly undefined
// 1461A17A2: variable 'v6' is possibly undefined
// 1461A1874: variable 'v10' is possibly undefined
// 1461A19DC: variable 'v18' is possibly undefined
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 14611E150: using guessed type __int128 xmmword_14611E150;
// 14612E388: using guessed type wchar_t aCitizenfxIni[14];
// 14612FC98: using guessed type wchar_t aNull_2[5];
// 14612FCB8: using guessed type wchar_t aPathcl2[8];

//----- (00000001461A1A40) ----------------------------------------------------
void __fastcall sub_1461A1A40(signed int dwThreadId, char *Str)
{
  HMODULE ModuleHandleW; // rax
  FARPROC ProcAddress; // rsi
  HANDLE v6; // rax
  void *v7; // rbx
  _QWORD *v8; // rax
  _BYTE *v9; // rcx
  unsigned __int8 (*v10)(void); // rax
  HMODULE v11; // rax
  __int64 v12[6]; // [rsp+30h] [rbp-118h] BYREF
  __int64 v13[3]; // [rsp+60h] [rbp-E8h] BYREF
  int v14; // [rsp+78h] [rbp-D0h]
  int v15; // [rsp+80h] [rbp-C8h]
  int v16; // [rsp+84h] [rbp-C4h]
  char *v17; // [rsp+88h] [rbp-C0h]
  int v18; // [rsp+90h] [rbp-B8h]
  int v19; // [rsp+94h] [rbp-B4h]
  void *Block; // [rsp+100h] [rbp-48h] BYREF
  unsigned __int64 v21; // [rsp+118h] [rbp-30h]
  __int64 retaddr; // [rsp+148h] [rbp+0h]

  v12[4] = -2i64;
  ModuleHandleW = GetModuleHandleW(L"kernelbase.dll");
  ProcAddress = GetProcAddress(ModuleHandleW, "SetThreadDescription");
  if ( ProcAddress )
  {
    v6 = dwThreadId >= 0 ? OpenThread(0x400u, 0, dwThreadId) : GetCurrentThread();
    v7 = v6;
    if ( v6 )
    {
      v12[0] = (__int64)Str;
      v12[1] = strlen(Str);
      v8 = (_QWORD *)sub_1461A2C60((__int64)&Block, (__int64)v12);
      if ( v8[3] > 7ui64 )
        v8 = (_QWORD *)*v8;
      ((void (__fastcall *)(void *, _QWORD *))ProcAddress)(v7, v8);
      if ( v21 > 7 )
      {
        v9 = Block;
        if ( 2 * v21 + 2 >= 0x1000 )
        {
          v9 = (_BYTE *)*((_QWORD *)Block - 1);
          if ( (unsigned __int64)((_BYTE *)Block - v9 - 8) > 0x1F )
            invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
        }
        j_j_free(v9);
      }
      if ( dwThreadId >= 0 )
        CloseHandle(v7);
    }
  }
  v10 = (unsigned __int8 (*)(void))qword_14611AC90;
  if ( qword_14611AC90
    || (v11 = GetModuleHandleW(L"CoreRT.dll"),
        v10 = (unsigned __int8 (*)(void))GetProcAddress(v11, "CoreIsDebuggerPresent"),
        (qword_14611AC90 = (__int64)v10) != 0) )
  {
    if ( v10() )
    {
      v13[2] = retaddr;
      v13[0] = 1080890248i64;
      v14 = 3;
      v15 = 4096;
      v16 = HIDWORD(v12[0]);
      v17 = Str;
      v18 = dwThreadId;
      v19 = 0;
      v13[1] = (__int64)v13;
      sub_1461A29A0((__int64)v13);
    }
  }
}
// 14611AC90: using guessed type __int64 qword_14611AC90;

//----- (00000001461A1C30) ----------------------------------------------------
__int64 *__fastcall sub_1461A1C30(wchar_t *String, wchar_t *a2, int a3)
{
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 *v7; // rbx
  size_t v8; // rax
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 *v11; // rax
  __int64 v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // rax
  __int128 v15; // xmm0
  _BYTE *v16; // rcx
  _BYTE *v17; // rcx
  __int64 *result; // rax
  __int128 v19; // [rsp+30h] [rbp-39h] BYREF
  _BYTE *v20; // [rsp+40h] [rbp-29h] BYREF
  __m128i si128; // [rsp+50h] [rbp-19h]
  __int64 v22[4]; // [rsp+60h] [rbp-9h] BYREF
  __int128 v23; // [rsp+80h] [rbp+17h]
  void *Block; // [rsp+90h] [rbp+27h] BYREF
  unsigned __int64 v25; // [rsp+A8h] [rbp+3Fh]
  __int64 *retaddr; // [rsp+C8h] [rbp+5Fh]

  *(_QWORD *)&v19 = a2;
  *((_QWORD *)&v19 + 1) = wcslen(a2);
  v7 = (__int64 *)sub_1461A2B60((__int64)&Block, (unsigned __int16 **)&v19, v5, v6);
  v8 = wcslen(String);
  *(_QWORD *)&v19 = String;
  *((_QWORD *)&v19 + 1) = v8;
  v11 = (__int64 *)sub_1461A2B60((__int64)&v20, (unsigned __int16 **)&v19, v9, v10);
  v12 = (__int64)v11;
  if ( (unsigned __int64)v11[3] > 0xF )
    v12 = *v11;
  v13 = v11[2];
  v14 = (__int64)v7;
  if ( (unsigned __int64)v7[3] > 0xF )
    v14 = *v7;
  v22[2] = v14;
  v22[3] = v7[2];
  LODWORD(v19) = a3;
  v15 = v19;
  *((_QWORD *)&v19 + 1) = v22;
  v22[0] = v12;
  v22[1] = v13;
  v23 = v15;
  *(_QWORD *)&v19 = 733i64;
  sub_146163EF0(
    "F:\\NewBuildFivem\\LauncherGTA\\code\\client\\shared\\Utils.Win32.cpp",
    99999,
    -1783869478,
    "Assertion failure: %s\nFile: %s, Line: %d",
    &v19);
  if ( si128.m128i_i64[1] > 0xFui64 )
  {
    v16 = v20;
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v16 = (_BYTE *)*((_QWORD *)v20 - 1);
      if ( (unsigned __int64)(v20 - v16 - 8) > 0x1F )
LABEL_12:
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v16);
  }
  LOBYTE(v20) = 0;
  si128 = _mm_load_si128((const __m128i *)&Size);
  if ( v25 > 0xF )
  {
    v17 = Block;
    if ( v25 + 1 >= 0x1000 )
    {
      v17 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v17 - 8) > 0x1F )
        goto LABEL_12;
    }
    j_j_free(v17);
  }
  __writegsqword(0x38u, (unsigned __int64)retaddr);
  result = qword_1461A4C50;
  retaddr = qword_1461A4C50;
  return result;
}
// 1461A1C7B: variable 'v5' is possibly undefined
// 1461A1C7B: variable 'v6' is possibly undefined
// 1461A1C9B: variable 'v9' is possibly undefined
// 1461A1C9B: variable 'v10' is possibly undefined
// 1461A4C50: using guessed type __int64 qword_1461A4C50[4];

//----- (00000001461A1DF0) ----------------------------------------------------
char *__fastcall sub_1461A1DF0(char **a1, unsigned __int64 a2)
{
  char *v2; // rbp
  char *result; // rax
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rax
  __int64 v10; // r15
  _QWORD *v11; // r14
  char *v12; // rcx
  size_t v13; // rbx

  v2 = a1[1];
  result = *a1;
  v6 = (v2 - *a1) >> 1;
  if ( a2 >= v6 )
  {
    if ( a2 > v6 )
    {
      v7 = (a1[2] - result) >> 1;
      if ( a2 <= v7 )
      {
        v13 = 2 * (a2 - v6);
        memset(v2, 0, v13);
        result = &v2[v13];
        a1[1] = &v2[v13];
      }
      else
      {
        if ( a2 > 0x7FFFFFFFFFFFFFFFi64 )
          unknown_libname_6(v7, a2, 0x7FFFFFFFFFFFFFFFi64);
        v8 = v7 >> 1;
        if ( v7 <= 0x7FFFFFFFFFFFFFFFi64 - (v7 >> 1) )
        {
          v9 = v7 + v8;
          if ( v7 + v8 >= a2 )
          {
            if ( v9 > 0x7FFFFFFFFFFFFFFFi64 )
              sub_146165390(v7, v8, 0x7FFFFFFFFFFFFFFFi64);
          }
          else
          {
            v9 = a2;
          }
        }
        else
        {
          v9 = 0x7FFFFFFFFFFFFFFFi64;
        }
        v10 = 2 * v9;
        v11 = sub_14615A5E0(2 * v9);
        memset((char *)v11 + 2 * v6, 0, 2 * (a2 - v6));
        memmove(v11, *a1, a1[1] - *a1);
        v12 = *a1;
        if ( *a1 )
        {
          if ( (unsigned __int64)(2 * ((a1[2] - v12) >> 1)) >= 0x1000 )
          {
            if ( (unsigned __int64)&v12[-*((_QWORD *)v12 - 1) - 8] > 0x1F )
              invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
            v12 = (char *)*((_QWORD *)v12 - 1);
          }
          j_j_free(v12);
        }
        *a1 = (char *)v11;
        a1[1] = (char *)v11 + 2 * a2;
        result = (char *)v11 + v10;
        a1[2] = (char *)v11 + v10;
      }
    }
  }
  else
  {
    result += 2 * a2;
    a1[1] = result;
  }
  return result;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (00000001461A1F80) ----------------------------------------------------
void ***__fastcall sub_1461A1F80(void ***a1, __int64 a2, void **a3, __int64 a4)
{
  void **v6; // rcx
  unsigned __int8 v7; // si
  unsigned int v8; // edi
  unsigned __int8 v9; // di
  unsigned int v10; // ebp
  unsigned __int8 v11; // bp
  __int64 v12; // rdx
  __int64 v13; // r8
  __int64 v14; // r9

  if ( (unsigned int)a2 >= 0x80 )
  {
    v6 = a3;
    v7 = a2 & 0x3F | 0x80;
    v8 = (unsigned int)a2 >> 6;
    if ( (unsigned int)a2 >= 0x800 )
    {
      v9 = v8 & 0x3F | 0x80;
      v10 = (unsigned int)a2 >> 12;
      if ( (unsigned int)a2 >= 0x10000 )
      {
        v12 = (unsigned int)a2 >> 18;
        LOBYTE(v12) = v12 | 0xF0;
        sub_146190570(a3, v12, (__int64)a3, a4);
        v6 = a3;
        v11 = v10 & 0x3F | 0x80;
      }
      else
      {
        v11 = v10 | 0xE0;
      }
      sub_146190570(v6, v11, (__int64)a3, a4);
      sub_146190570(a3, v9, v13, v14);
    }
    else
    {
      sub_146190570(a3, (unsigned __int8)v8 | 0xC0u, (__int64)a3, a4);
    }
    a2 = v7;
  }
  sub_146190570(a3, a2, (__int64)a3, a4);
  *a1 = a3;
  return a1;
}
// 1461A200B: variable 'a3' is possibly undefined
// 1461A200B: variable 'a4' is possibly undefined
// 1461A2017: variable 'v13' is possibly undefined
// 1461A2017: variable 'v14' is possibly undefined

//----- (00000001461A2050) ----------------------------------------------------
_QWORD *__fastcall sub_1461A2050(_QWORD *a1, const char *a2, __int64 *a3, __int64 *a4)
{
  __int64 v5; // rax
  _BYTE *v6; // rcx
  __int128 v8; // [rsp+30h] [rbp-298h] BYREF
  __int64 v9[3]; // [rsp+50h] [rbp-278h] BYREF
  __int64 v10[5]; // [rsp+68h] [rbp-260h] BYREF
  void **v11; // [rsp+90h] [rbp-238h] BYREF
  void *Block; // [rsp+98h] [rbp-230h]
  size_t v13; // [rsp+A0h] [rbp-228h]
  unsigned __int64 v14; // [rsp+A8h] [rbp-220h]
  char v15[512]; // [rsp+B0h] [rbp-218h] BYREF

  v9[2] = -2i64;
  *(_QWORD *)&v8 = a1;
  v5 = a3[1];
  v10[0] = *a3;
  v10[1] = v5;
  v10[2] = *a4;
  v10[3] = (__int64)a1;
  v13 = 0i64;
  v11 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  Block = v15;
  v14 = 500i64;
  *(_QWORD *)&v8 = 205i64;
  *((_QWORD *)&v8 + 1) = v10;
  v9[0] = (__int64)a2;
  v9[1] = strlen(a2);
  sub_14615CF80((__int64)&v11, (__int64)v9, &v8);
  *(_OWORD *)a1 = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  sub_14615A650(a1, Block, v13);
  v11 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  v6 = Block;
  if ( Block != v15 )
  {
    if ( v14 >= 0x1000 )
    {
      v6 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v6 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v6);
  }
  return a1;
}
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';

//----- (00000001461A21E0) ----------------------------------------------------
__int64 __fastcall sub_1461A21E0(__int128 *a1, __int128 *a2)
{
  __int64 v4; // rbp
  int v5; // eax
  const void **v6; // rbx
  char *v7; // rdi
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  size_t v10; // rdi
  _QWORD *v11; // rsi
  _QWORD *v12; // rcx
  int v13; // esi
  unsigned __int64 v14; // r14
  void **v15; // rdx
  char *v16; // rbx
  unsigned __int64 v17; // rdi
  __int64 v18; // rsi
  __int64 v19; // rsi
  char *v20; // rax
  __int128 v22; // [rsp+30h] [rbp-88h] BYREF
  __int64 v23; // [rsp+40h] [rbp-78h]
  void *Src[2]; // [rsp+48h] [rbp-70h] BYREF
  unsigned __int64 v25; // [rsp+58h] [rbp-60h]
  unsigned __int64 v26; // [rsp+60h] [rbp-58h]
  char v27; // [rsp+68h] [rbp-50h] BYREF

  v23 = -2i64;
  v4 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v5 = *(_DWORD *)(v4 + 344);
  v6 = (const void **)(v4 + 320);
  if ( (v5 & 1) == 0 )
  {
    *(_DWORD *)(v4 + 344) = v5 | 1;
    *v6 = 0i64;
    *(_QWORD *)(v4 + 328) = 0i64;
    *(_QWORD *)(v4 + 336) = 0i64;
    _tlregdtor(sub_1461AE9E0);
  }
  v7 = *(char **)(v4 + 328);
  if ( v7 == *v6 )
  {
    v8 = *(_QWORD *)(v4 + 336) - (_QWORD)*v6;
    if ( v8 >= 0x40000 )
    {
      memset(*(void **)(v4 + 328), 0, 0x40000ui64);
      *(_QWORD *)(v4 + 328) = v7 + 0x40000;
    }
    else
    {
      v9 = v8 >> 1;
      v10 = 0x7FFFFFFFFFFFFFFFi64;
      if ( v8 <= 0x7FFFFFFFFFFFFFFFi64 - (v8 >> 1) )
      {
        v10 = v8 + v9;
        if ( v8 + v9 < 0x40000 )
          v10 = 0x40000i64;
      }
      v11 = sub_14615A5E0(v10);
      memset(v11, 0, 0x40000ui64);
      memmove(v11, *v6, *(_QWORD *)(v4 + 328) - (_QWORD)*v6);
      v12 = *v6;
      if ( *v6 )
      {
        if ( *(_QWORD *)(v4 + 336) - (_QWORD)v12 >= 0x1000ui64 )
        {
          if ( (unsigned __int64)v12 - *(v12 - 1) - 8 > 0x1F )
            goto LABEL_23;
          v12 = (_QWORD *)*(v12 - 1);
        }
        j_j_free(v12);
      }
      *v6 = v11;
      *(_QWORD *)(v4 + 328) = v11 + 0x8000;
      *(_QWORD *)(v4 + 336) = (char *)v11 + v10;
    }
  }
  v13 = *(_DWORD *)(v4 + 316);
  v22 = *a2;
  sub_1461A2730(Src, a1, &v22);
  v14 = v25;
  if ( v25 >= 0x8000 )
  {
    *(_QWORD *)&v22 = 0i64;
    *((_QWORD *)&v22 + 1) = &v27;
    if ( (int)sub_146163F20(
                "F:\\NewBuildFivem\\LauncherGTA\\code\\client\\shared\\Utils.cpp",
                76i64,
                2178581208i64,
                "Exceeded buffer length in va()!",
                &v22) < 0 )
      MEMORY[0xDEED] = 0;
  }
  v15 = Src;
  v16 = (char *)Src[0];
  v17 = v26;
  if ( v26 > 0xF )
    v15 = (void **)Src[0];
  v18 = v13 << 15;
  memcpy((void *)(v18 + *(_QWORD *)(v4 + 320)), v15, v14 + 1);
  *(_DWORD *)(v4 + 316) = (*(_DWORD *)(v4 + 316) + 1) % 8;
  v19 = *(_QWORD *)(v4 + 320) + v18;
  if ( v17 > 0xF )
  {
    v20 = v16;
    if ( v17 + 1 >= 0x1000 )
    {
      v16 = (char *)*((_QWORD *)v16 - 1);
      if ( (unsigned __int64)(v20 - v16 - 8) > 0x1F )
LABEL_23:
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v16);
  }
  return v19;
}
// 14611AE78: using guessed type int TlsIndex;
// 146163F20: using guessed type __int64 __fastcall sub_146163F20(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1461A7E18: using guessed type __int64 __fastcall _tlregdtor(_QWORD);

//----- (00000001461A2480) ----------------------------------------------------
__int64 __fastcall sub_1461A2480(__int128 *a1, __int128 *a2)
{
  __int64 v4; // rdi
  int v5; // eax
  int v6; // r15d
  __int128 v7; // xmm1
  __int64 v8; // r9
  _BYTE *v9; // rcx
  __int64 v10; // r14
  __int128 *p_Src_8; // rdx
  char *v12; // rbx
  unsigned __int64 v13; // rsi
  __int64 v14; // r15
  __int64 v15; // rdi
  char *v16; // rax
  __int128 v18; // [rsp+48h] [rbp-C0h] BYREF
  __int64 Src; // [rsp+60h] [rbp-A8h]
  __int128 Src_8; // [rsp+68h] [rbp-A0h] BYREF
  __int128 v21; // [rsp+78h] [rbp-90h]
  __int128 v22; // [rsp+88h] [rbp-80h] BYREF
  void **v23; // [rsp+98h] [rbp-70h] BYREF
  void *Block; // [rsp+A0h] [rbp-68h]
  unsigned __int64 v25; // [rsp+A8h] [rbp-60h]
  __int64 v26; // [rsp+B0h] [rbp-58h]
  char v27[1008]; // [rsp+B8h] [rbp-50h] BYREF

  Src = -2i64;
  v4 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex);
  v5 = *(_DWORD *)(v4 + 376);
  if ( (v5 & 1) == 0 )
  {
    *(_DWORD *)(v4 + 376) = v5 | 1;
    *(_QWORD *)(v4 + 352) = 0i64;
    *(_QWORD *)(v4 + 360) = 0i64;
    *(_QWORD *)(v4 + 368) = 0i64;
    _tlregdtor(sub_1461AEA70);
  }
  if ( *(_QWORD *)(v4 + 360) - *(_QWORD *)(v4 + 352) < 2ui64 )
    sub_1461A1DF0((char **)(v4 + 352), 0x40000ui64);
  v6 = *(_DWORD *)(v4 + 348);
  v25 = 0i64;
  v23 = &fmt::v8::basic_memory_buffer<wchar_t,500,std::allocator<wchar_t>>::`vftable';
  Block = v27;
  v26 = 500i64;
  v7 = *a1;
  v22 = *a2;
  *(_QWORD *)&v18 = v7;
  *((_QWORD *)&v18 + 1) = *((_QWORD *)a1 + 1);
  sub_14616B4B0((__int64)&v23, (__int64)&v18, &v22);
  Src_8 = 0i64;
  v21 = 0i64;
  sub_146168F30(&Src_8, Block, v25, v8);
  v23 = &fmt::v8::basic_memory_buffer<wchar_t,500,std::allocator<wchar_t>>::`vftable';
  v9 = Block;
  if ( Block != v27 )
  {
    if ( (unsigned __int64)(2 * v26) >= 0x1000 )
    {
      v9 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v9 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v9);
  }
  v10 = v21;
  if ( (unsigned __int64)v21 >= 0x8000 )
  {
    *(_QWORD *)&v18 = 0i64;
    *((_QWORD *)&v18 + 1) = &v22;
    if ( (int)sub_146163F20(
                "F:\\NewBuildFivem\\LauncherGTA\\code\\client\\shared\\Utils.cpp",
                76,
                -2116386088,
                "Exceeded buffer length in va()!",
                &v18) < 0 )
      MEMORY[0xDEED] = 0;
  }
  p_Src_8 = &Src_8;
  v12 = (char *)Src_8;
  v13 = *((_QWORD *)&v21 + 1);
  if ( *((_QWORD *)&v21 + 1) > 7ui64 )
    p_Src_8 = (__int128 *)Src_8;
  v14 = 2i64 * (v6 << 15);
  memcpy((void *)(v14 + *(_QWORD *)(v4 + 352)), p_Src_8, 2 * v10 + 2);
  *(_DWORD *)(v4 + 348) = (*(_DWORD *)(v4 + 348) + 1) % 8;
  v15 = v14 + *(_QWORD *)(v4 + 352);
  if ( v13 > 7 )
  {
    v16 = v12;
    if ( 2 * v13 + 2 >= 0x1000 )
    {
      v12 = (char *)*((_QWORD *)v12 - 1);
      if ( (unsigned __int64)(v16 - v12 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v12);
  }
  return v15;
}
// 1461A25A3: variable 'v8' is possibly undefined
// 14611AE78: using guessed type int TlsIndex;
// 14611E348: using guessed type void *fmt::v8::basic_memory_buffer<wchar_t,500,std::allocator<wchar_t>>::`vftable';
// 1461A7E18: using guessed type __int64 __fastcall _tlregdtor(_QWORD);

//----- (00000001461A2730) ----------------------------------------------------
_QWORD *__fastcall sub_1461A2730(_QWORD *a1, __int128 *a2, __int128 *a3)
{
  __int128 v4; // xmm1
  _BYTE *v5; // rcx
  __int64 v7[4]; // [rsp+40h] [rbp-268h] BYREF
  __int128 v8; // [rsp+60h] [rbp-248h] BYREF
  void **v9; // [rsp+70h] [rbp-238h] BYREF
  void *Block; // [rsp+78h] [rbp-230h]
  size_t v11; // [rsp+80h] [rbp-228h]
  unsigned __int64 v12; // [rsp+88h] [rbp-220h]
  char v13[512]; // [rsp+90h] [rbp-218h] BYREF

  v7[2] = -2i64;
  v7[0] = (__int64)a1;
  v11 = 0i64;
  v9 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  Block = v13;
  v12 = 500i64;
  v4 = *a2;
  v8 = *a3;
  v7[0] = v4;
  v7[1] = *((_QWORD *)a2 + 1);
  sub_14615CF80((__int64)&v9, (__int64)v7, &v8);
  *(_OWORD *)a1 = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  sub_14615A650(a1, Block, v11);
  v9 = &fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';
  v5 = Block;
  if ( Block != v13 )
  {
    if ( v12 >= 0x1000 )
    {
      v5 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v5 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v5);
  }
  return a1;
}
// 14611D220: using guessed type void *fmt::v8::basic_memory_buffer<char,500,std::allocator<char>>::`vftable';

//----- (00000001461A2870) ----------------------------------------------------
__int64 __fastcall sub_1461A2870(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  __int16 v4; // bp
  __int64 v5; // rdi
  _WORD *v8; // rdi
  unsigned __int64 j; // rcx
  size_t v10; // rcx
  _QWORD *v11; // rdx
  _WORD *v12; // rdi
  unsigned __int64 i; // rcx

  v4 = a3;
  v5 = 0x7FFFFFFFFFFFFFFEi64;
  *(_OWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  if ( a2 > 0x7FFFFFFFFFFFFFFEi64 )
    unknown_libname_4(a1, a2, a3, a4);
  if ( a2 > 7 )
  {
    if ( (a2 | 7) <= 0x7FFFFFFFFFFFFFFEi64 )
    {
      v5 = a2 | 7;
      if ( (a2 | 7) < 0xA )
        v5 = 10i64;
      if ( (unsigned __int64)(v5 + 1) > 0x7FFFFFFFFFFFFFFFi64 )
        sub_146165390();
      v10 = 2 * v5 + 2;
    }
    else
    {
      v10 = -2i64;
    }
    v11 = sub_14615A5E0(v10);
    *(_QWORD *)a1 = v11;
    *(_QWORD *)(a1 + 16) = a2;
    *(_QWORD *)(a1 + 24) = v5;
    v12 = v11;
    for ( i = a2; i; --i )
      *v12++ = v4;
    *((_WORD *)v11 + a2) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 16) = a2;
    *(_QWORD *)(a1 + 24) = 7i64;
    if ( a2 )
    {
      v8 = (_WORD *)a1;
      for ( j = a2; j; --j )
        *v8++ = a3;
    }
    *(_WORD *)(a1 + 2 * a2) = 0;
  }
  return a1;
}
// 146165390: using guessed type void __noreturn sub_146165390(void);
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001461A2980) ----------------------------------------------------
__int64 __fastcall sub_1461A2980(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 16) = a2;
  *(_QWORD *)a1 = &InitFunctionBase::`vftable';
  return a1;
}
// 14612FE48: using guessed type void *InitFunctionBase::`vftable';

//----- (00000001461A29A0) ----------------------------------------------------
void __fastcall sub_1461A29A0(__int64 a1)
{
  HMODULE ModuleHandleW; // rax
  CHAR OutputString[16]; // [rsp+20h] [rbp-4F8h] BYREF
  CONTEXT ContextRecord; // [rsp+30h] [rbp-4E8h] BYREF

  OutputString[0] = 0;
  RtlCaptureContext(&ContextRecord);
  if ( dword_14611AD08 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                   + 380i64) )
  {
    sub_1461A7CF4(&dword_14611AD08);
    if ( dword_14611AD08 == -1 )
    {
      ModuleHandleW = GetModuleHandleW(L"ntdll.dll");
      qword_14611AD00 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))GetProcAddress(
                                                                          ModuleHandleW,
                                                                          "NtRaiseException");
      Init_thread_footer(&dword_14611AD08);
    }
  }
  OutputString[0] = 1;
  qword_14611AD00(a1, &ContextRecord, 1i64);
  OutputDebugStringA(OutputString);
}
// 1461A29F6: conditional instruction was optimized away because %OutputString.1==0
// 14611AD00: using guessed type __int64 (__fastcall *qword_14611AD00)(_QWORD, _QWORD, _QWORD);
// 14611AD08: using guessed type int dword_14611AD08;
// 14611AE78: using guessed type int TlsIndex;
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);
// 1461A29A0: using guessed type CHAR OutputString[16];

//----- (00000001461A2A80) ----------------------------------------------------
void __fastcall sub_1461A2A80(__int64 a1, __int64 a2)
{
  __int64 v2[3]; // [rsp+30h] [rbp-B8h] BYREF
  int v3; // [rsp+48h] [rbp-A0h]
  __int64 v4; // [rsp+50h] [rbp-98h]
  __int64 v5; // [rsp+58h] [rbp-90h]
  __int64 retaddr; // [rsp+E8h] [rbp+0h]

  v2[2] = retaddr;
  v2[0] = 1073807366i64;
  v3 = 2;
  v4 = a2 + 1;
  v5 = a1;
  v2[1] = (__int64)v2;
  sub_1461A29A0((__int64)v2);
}

//----- (00000001461A2B10) ----------------------------------------------------
__int64 __fastcall sub_1461A2B10(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rdx

  result = qword_14611ACF8;
  v2 = 0i64;
  if ( qword_14611ACF8 )
  {
    do
    {
      if ( *(_DWORD *)(a1 + 16) < *(_DWORD *)(result + 16) )
        break;
      v2 = result;
      result = *(_QWORD *)(result + 8);
    }
    while ( result );
    *(_QWORD *)(a1 + 8) = result;
    if ( v2 )
      *(_QWORD *)(v2 + 8) = a1;
    else
      qword_14611ACF8 = a1;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0i64;
    qword_14611ACF8 = a1;
  }
  return result;
}
// 14611ACF8: using guessed type __int64 qword_14611ACF8;

//----- (00000001461A2B60) ----------------------------------------------------
__int64 __fastcall sub_1461A2B60(__int64 a1, unsigned __int16 **a2, __int64 a3, __int64 a4)
{
  unsigned __int16 *v4; // rbx
  unsigned __int64 v6; // rdi
  __int64 v7; // r9
  unsigned __int16 *v8; // rdi
  void **v9; // r8
  __int64 v10; // rdx
  unsigned __int16 *v11; // rcx
  void **v13[3]; // [rsp+20h] [rbp-48h] BYREF
  __int128 v14; // [rsp+38h] [rbp-30h] BYREF
  __m128i si128; // [rsp+48h] [rbp-20h]

  v13[2] = (void **)-2i64;
  v4 = *a2;
  v13[0] = (void **)a1;
  v14 = 0i64;
  si128 = _mm_load_si128((const __m128i *)&Size);
  LOBYTE(v14) = 0;
  v6 = (unsigned __int64)a2[1];
  sub_146190960((void **)&v14, v6, a3, a4);
  v8 = &v4[v6];
  if ( v4 != v8 )
  {
    v9 = (void **)&v14;
    do
    {
      v10 = *v4++;
      v11 = v4;
      if ( (unsigned int)(v10 - 55296) <= 0x3FF )
      {
        if ( v4 == v8 )
          break;
        ++v4;
        v10 = (unsigned int)*v11 + ((_DWORD)v10 << 10) - 56613888;
      }
      sub_1461A1F80(v13, v10, v9, v7);
      v9 = v13[0];
    }
    while ( v4 != v8 );
  }
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_OWORD *)a1 = v14;
  *(__m128i *)(a1 + 16) = si128;
  return a1;
}
// 1461A2C03: variable 'v7' is possibly undefined

//----- (00000001461A2C60) ----------------------------------------------------
__int64 __fastcall sub_1461A2C60(__int64 a1, __int64 a2)
{
  const CHAR *v2; // rbp
  int v3; // esi
  int v5; // eax
  __int64 v6; // r9
  int cchWideChar; // edi
  WCHAR *lpWideCharStr; // rax
  __int128 v9; // xmm1
  LPWSTR v11[2]; // [rsp+40h] [rbp-48h] BYREF
  __int128 v12; // [rsp+50h] [rbp-38h]

  v2 = *(const CHAR **)a2;
  v3 = *(_DWORD *)(a2 + 8);
  v5 = MultiByteToWideChar(0xFDE9u, 0, *(LPCCH *)a2, v3, 0i64, 0);
  cchWideChar = v5;
  if ( v5 > 0 )
  {
    sub_1461A2870((__int64)v11, v5, 0i64, v6);
    lpWideCharStr = (WCHAR *)v11;
    if ( *((_QWORD *)&v12 + 1) > 7ui64 )
      lpWideCharStr = v11[0];
    MultiByteToWideChar(0xFDE9u, 0, v2, v3, lpWideCharStr, cchWideChar);
    v9 = v12;
    *(_OWORD *)a1 = *(_OWORD *)v11;
    *(_OWORD *)(a1 + 16) = v9;
  }
  else
  {
    *(_OWORD *)a1 = 0i64;
    *(_QWORD *)(a1 + 16) = 0i64;
    *(_QWORD *)(a1 + 24) = 0i64;
    sub_146168F30((_QWORD *)a1, &Default, 0i64, v6);
  }
  return a1;
}
// 1461A2CD1: variable 'v6' is possibly undefined

//----- (00000001461A2D50) ----------------------------------------------------
void __fastcall sub_1461A2D50(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int128 *a5, __int128 *a6)
{
  __m128i *v10; // rbx
  void *v11; // rax
  _BYTE *v12; // rcx
  void **v13; // rbx
  FARPROC ProcAddress; // rax
  HMODULE ModuleHandleW; // rax
  unsigned __int8 (*v16)(void); // rax
  HMODULE v17; // rax
  void **v18; // rcx
  void **v19; // rcx
  void **v20; // rbx
  FARPROC v21; // rax
  HMODULE v22; // rax
  FARPROC v23; // rcx
  HMODULE v24; // rax
  void *v25; // rcx
  __int128 v26; // [rsp+40h] [rbp-B8h] BYREF
  __int128 *v27; // [rsp+50h] [rbp-A8h]
  __int64 v28; // [rsp+58h] [rbp-A0h]
  __int64 v29; // [rsp+60h] [rbp-98h]
  __int64 v30; // [rsp+68h] [rbp-90h]
  __int64 v31; // [rsp+70h] [rbp-88h]
  void *Block[2]; // [rsp+80h] [rbp-78h] BYREF
  __m128i si128; // [rsp+90h] [rbp-68h]
  void *v34; // [rsp+A0h] [rbp-58h] BYREF
  unsigned __int64 v35; // [rsp+B8h] [rbp-40h]

  v31 = -2i64;
  v28 = a1;
  v30 = a2;
  v29 = a3;
  v27 = a5;
  *(_OWORD *)Block = 0i64;
  si128 = _mm_load_si128((const __m128i *)&Size);
  LOBYTE(Block[0]) = 0;
  v26 = *a6;
  v10 = (__m128i *)sub_1461A2730(&v34, a5, &v26);
  if ( Block != (void **)v10 )
  {
    if ( si128.m128i_i64[1] > 0xFui64 )
    {
      v11 = Block[0];
      if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
      {
        v11 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)(Block[0] - v11 - 8) > 0x1F )
LABEL_10:
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v11);
    }
    si128 = _mm_load_si128((const __m128i *)&Size);
    LOBYTE(Block[0]) = 0;
    *(__m128i *)Block = *v10;
    si128 = v10[1];
    v10[1].m128i_i64[0] = 0i64;
    v10[1].m128i_i64[1] = 15i64;
    v10->m128i_i8[0] = 0;
  }
  if ( v35 > 0xF )
  {
    v12 = v34;
    if ( v35 + 1 >= 0x1000 )
    {
      v12 = (_BYTE *)*((_QWORD *)v34 - 1);
      if ( (unsigned __int64)((_BYTE *)v34 - v12 - 8) > 0x1F )
        goto LABEL_10;
    }
    j_j_free(v12);
  }
  v13 = Block;
  if ( si128.m128i_i64[1] > 0xFui64 )
    v13 = (void **)Block[0];
  ProcAddress = (FARPROC)qword_14611ACF0;
  if ( qword_14611ACF0
    || (ModuleHandleW = GetModuleHandleW(L"CoreRT.dll"),
        ProcAddress = GetProcAddress(ModuleHandleW, "CoreTrace"),
        (qword_14611ACF0 = (__int64)ProcAddress) != 0) )
  {
    ((void (__fastcall *)(__int64, __int64, __int64, _QWORD, void **))ProcAddress)(a1, a2, a3, a4, v13);
  }
  v16 = (unsigned __int8 (*)(void))qword_14611AC90;
  if ( (qword_14611AC90
     || (v17 = GetModuleHandleW(L"CoreRT.dll"),
         v16 = (unsigned __int8 (*)(void))GetProcAddress(v17, "CoreIsDebuggerPresent"),
         (qword_14611AC90 = (__int64)v16) != 0))
    && v16() )
  {
    v18 = Block;
    if ( si128.m128i_i64[1] > 0xFui64 )
      v18 = (void **)Block[0];
    sub_1461A2A80((__int64)v18, si128.m128i_i64[0]);
  }
  else
  {
    v19 = Block;
    if ( si128.m128i_i64[1] > 0xFui64 )
      v19 = (void **)Block[0];
    OutputDebugStringA((LPCSTR)v19);
  }
  v20 = Block;
  if ( si128.m128i_i64[1] > 0xFui64 )
    v20 = (void **)Block[0];
  v21 = (FARPROC)qword_14611AD10;
  if ( qword_14611AD10 )
    goto LABEL_32;
  v22 = GetModuleHandleW(0i64);
  v21 = GetProcAddress(v22, "AsyncTrace");
  qword_14611AD10 = (__int64)v21;
  v23 = v21;
  if ( !v21 )
  {
    v24 = GetModuleHandleW(L"CoreRT.dll");
    v21 = GetProcAddress(v24, "AsyncTrace");
    qword_14611AD10 = (__int64)v21;
    v23 = v21;
  }
  if ( v23 )
LABEL_32:
    ((void (__fastcall *)(void **))v21)(v20);
  if ( si128.m128i_i64[1] > 0xFui64 )
  {
    v25 = Block[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v25 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v25 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v25);
  }
}
// 1461A2D50: could not find valid save-restore pair for rbp
// 14611AC90: using guessed type __int64 qword_14611AC90;
// 14611ACF0: using guessed type __int64 qword_14611ACF0;
// 14611AD10: using guessed type __int64 qword_14611AD10;

//----- (00000001461A30D0) ----------------------------------------------------
__int64 __fastcall sub_1461A30D0(__int128 *a1, __int128 *a2)
{
  __int128 v3; // [rsp+20h] [rbp-18h] BYREF

  v3 = *a1;
  return sub_1461A21E0(&v3, a2);
}
// 1461A30D0: using guessed type __int128 var_18;

//----- (00000001461A30F0) ----------------------------------------------------
__int64 __fastcall sub_1461A30F0(__int128 *a1, __int128 *a2)
{
  __int128 v3; // [rsp+20h] [rbp-18h] BYREF

  v3 = *a1;
  return sub_1461A2480(&v3, a2);
}
// 1461A30F0: using guessed type __int128 var_18;

//----- (00000001461A3120) ----------------------------------------------------
HMODULE sub_1461A3120()
{
  HMODULE result; // rax

  result = GetModuleHandleW(0i64) - 1342177280;
  qword_14611AD18 = (__int64)result;
  return result;
}
// 14611AD18: using guessed type __int64 qword_14611AD18;

//----- (00000001461A3150) ----------------------------------------------------
__int64 __fastcall sub_1461A3150(__int64 a1, unsigned int a2)
{
  FARPROC ProcAddress; // rax
  HMODULE ModuleHandleW; // rax

  ProcAddress = (FARPROC)qword_14611AD40;
  if ( !qword_14611AD40 )
  {
    ModuleHandleW = GetModuleHandleW(L"CoreRT.dll");
    ProcAddress = GetProcAddress(ModuleHandleW, "AllocateFunctionStubImpl");
    qword_14611AD40 = (__int64)ProcAddress;
  }
  return ((__int64 (__fastcall *)(__int64, _QWORD))ProcAddress)(a1, a2);
}
// 14611AD40: using guessed type __int64 qword_14611AD40;

//----- (00000001461A31D0) ----------------------------------------------------
_QWORD *__fastcall sub_1461A31D0(__int64 a1, _QWORD *a2)
{
  __int64 v3; // rcx
  unsigned int v4; // edi
  char *v5; // r15
  char *v6; // rbx
  char *v7; // r14
  unsigned __int64 v8; // rsi
  size_t v9; // r8
  int v10; // eax
  size_t v11; // r8
  int v12; // eax
  char v13; // cl
  char *v14; // rax
  _DWORD *v15; // rcx
  void *v16; // rcx
  __int64 v18; // rdx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rcx
  int v22; // eax
  char v23; // al
  __int128 v24; // [rsp+38h] [rbp-59h] BYREF
  __int128 v25; // [rsp+48h] [rbp-49h] BYREF
  __int64 v26; // [rsp+60h] [rbp-31h]
  __int128 Buf2; // [rsp+68h] [rbp-29h] BYREF
  __int64 v28; // [rsp+78h] [rbp-19h]
  unsigned __int64 v29; // [rsp+80h] [rbp-11h]
  __int128 v30; // [rsp+88h] [rbp-9h] BYREF
  __int128 v31; // [rsp+98h] [rbp+7h]
  __int128 v32; // [rsp+A8h] [rbp+17h]

  v26 = -2i64;
  *(_QWORD *)&v25 = a2;
  v3 = *(unsigned int *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 380i64);
  if ( dword_14610AABC > (int)v3 )
  {
    sub_1461A7CF4(&dword_14610AABC);
    if ( dword_14610AABC == -1 )
    {
      if ( !sub_1461A4660(v3, v18, v19, v20) )
        goto LABEL_54;
      v22 = dword_1461090C0;
      if ( dword_1461090C0 == -1 )
      {
        v22 = sub_1461A48B0(v21);
        dword_1461090C0 = v22;
      }
      if ( v22 == 1 )
LABEL_54:
        v23 = 0;
      else
        v23 = 1;
      byte_14610AAB8 = v23;
      Init_thread_footer(&dword_14610AABC);
    }
  }
  v4 = dword_1461090C0;
  if ( byte_14610AAB8 )
    goto LABEL_8;
  if ( dword_1461090C0 == -1 )
  {
    v4 = sub_1461A48B0(v3);
    dword_1461090C0 = v4;
  }
  if ( v4 >= 0xB80 )
  {
LABEL_8:
    if ( v4 == -1 )
    {
      v4 = sub_1461A48B0(v3);
      dword_1461090C0 = v4;
    }
  }
  else
  {
    v4 = dword_1461090C4;
    if ( dword_1461090C4 == -1 )
    {
      v4 = 2944;
      dword_1461090C4 = 2944;
    }
  }
  Buf2 = 0i64;
  v28 = 4i64;
  v29 = 15i64;
  strcpy((char *)&Buf2, "gta5");
  *(_QWORD *)&v30 = &Buf2;
  *((_QWORD *)&v30 + 1) = 4i64;
  LODWORD(v31) = v4;
  v5 = (char *)qword_14611AD48;
  v6 = (char *)*((_QWORD *)qword_14611AD48 + 1);
  v7 = (char *)qword_14611AD48;
  if ( !v6[25] )
  {
    do
    {
      v8 = *((_QWORD *)v6 + 5);
      v9 = v8;
      if ( v8 > 4 )
        v9 = 4i64;
      v10 = memcmp(*((const void **)v6 + 4), &Buf2, v9);
      if ( !v10 )
      {
        if ( v8 >= 4 )
          v10 = v8 > 4;
        else
          v10 = -1;
      }
      if ( v10 < 0 )
        goto LABEL_27;
      v11 = 4i64;
      if ( v8 < 4 )
        v11 = v8;
      v12 = memcmp(&Buf2, *((const void **)v6 + 4), v11);
      if ( !v12 )
      {
        if ( v8 <= 4 )
          v12 = v8 < 4;
        else
          v12 = -1;
      }
      if ( v12 >= 0 && *((_DWORD *)v6 + 12) < (signed int)v4 )
      {
LABEL_27:
        v13 = 1;
      }
      else
      {
        v13 = 0;
        v7 = v6;
      }
      v14 = v6 + 16;
      if ( !v13 )
        v14 = v6;
      v6 = *(char **)v14;
    }
    while ( !*(_BYTE *)(*(_QWORD *)v14 + 25i64) );
    v5 = (char *)qword_14611AD48;
  }
  if ( v7[25] || sub_146163510((__int64)&qword_14611AD48, (__int64)&v30, (__int64)(v7 + 32)) )
    v7 = v5;
  v15 = v7 + 56;
  if ( v7 == v5 )
    v15 = 0i64;
  if ( !v15 )
  {
    LODWORD(v24) = v4;
    v30 = v24;
    *(_QWORD *)&v25 = "%d";
    *((_QWORD *)&v25 + 1) = 2i64;
    *(_QWORD *)&v24 = 1i64;
    *((_QWORD *)&v24 + 1) = &v30;
    sub_1461784D0(a2, &v25, &v24);
    if ( v29 <= 0xF )
      return a2;
    v16 = (void *)Buf2;
    if ( v29 + 1 < 0x1000 )
      goto LABEL_41;
    v16 = *(void **)(Buf2 - 8);
    if ( (unsigned __int64)(Buf2 - (_QWORD)v16 - 8) <= 0x1F )
      goto LABEL_41;
    goto LABEL_46;
  }
  LODWORD(v24) = *v15;
  LODWORD(v25) = v15[1];
  LODWORD(v30) = v4;
  *(_QWORD *)((char *)&v30 + 4) = *(_QWORD *)((char *)&v24 + 4);
  HIDWORD(v30) = HIDWORD(v24);
  v31 = v24;
  v32 = v25;
  *(_QWORD *)&v24 = "%d_%d_%d";
  *((_QWORD *)&v24 + 1) = 8i64;
  *(_QWORD *)&v25 = 273i64;
  *((_QWORD *)&v25 + 1) = &v30;
  sub_1461784D0(a2, &v24, &v25);
  if ( v29 > 0xF )
  {
    v16 = (void *)Buf2;
    if ( v29 + 1 < 0x1000 || (v16 = *(void **)(Buf2 - 8), (unsigned __int64)(Buf2 - (_QWORD)v16 - 8) <= 0x1F) )
    {
LABEL_41:
      j_j_free(v16);
      return a2;
    }
LABEL_46:
    invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
  }
  return a2;
}
// 1461A3252: variable 'v3' is possibly undefined
// 1461A354B: variable 'v18' is possibly undefined
// 1461A354B: variable 'v19' is possibly undefined
// 1461A354B: variable 'v20' is possibly undefined
// 1461A355F: variable 'v21' is possibly undefined
// 1461090C0: using guessed type int dword_1461090C0;
// 1461090C4: using guessed type int dword_1461090C4;
// 14610AAB8: using guessed type char byte_14610AAB8;
// 14610AABC: using guessed type int dword_14610AABC;
// 14611AE78: using guessed type int TlsIndex;
// 1461A48B0: using guessed type __int64 __fastcall sub_1461A48B0(_QWORD);
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);

//----- (00000001461A3580) ----------------------------------------------------
void __fastcall sub_1461A3580(__int64 a1, unsigned __int64 a2)
{
  _DWORD *v2; // rbx
  __int64 *v3; // rdi
  void **v4; // rax
  __int64 v5; // rdx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rdx
  __int64 v9; // r8
  __int64 v10; // r9
  _QWORD *v11; // rax
  __int64 v12; // r9
  void **v13; // rdx
  _QWORD *v14; // rax
  __int64 v15; // r8
  __int64 v16; // r9
  void *v17; // rcx
  void *v18; // rcx
  __m128i si128; // xmm6
  _BYTE *v20; // rcx
  void *v21; // rcx
  const wchar_t *v22; // rcx
  FILE *v23; // rax
  FILE *v24; // rbx
  wchar_t *v25; // rcx
  __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // [rsp+38h] [rbp-D0h] BYREF
  unsigned __int64 v29; // [rsp+40h] [rbp-C8h] BYREF
  __int64 Buffer; // [rsp+48h] [rbp-C0h] BYREF
  void *v31[5]; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v32[2]; // [rsp+78h] [rbp-90h] BYREF
  void *Block[2]; // [rsp+88h] [rbp-80h] BYREF
  __int128 v34; // [rsp+98h] [rbp-70h]
  __int128 v35; // [rsp+A8h] [rbp-60h] BYREF
  __m128i v36; // [rsp+B8h] [rbp-50h]
  void *v37[3]; // [rsp+C8h] [rbp-40h] BYREF
  unsigned __int64 v38; // [rsp+E0h] [rbp-28h]
  wchar_t *FileName[3]; // [rsp+E8h] [rbp-20h] BYREF
  unsigned __int64 v40; // [rsp+100h] [rbp-8h]
  void *v41; // [rsp+108h] [rbp+0h] BYREF
  __m128i v42; // [rsp+118h] [rbp+10h]

  v31[4] = (void *)-2i64;
  Buffer = a1;
  v29 = a2;
  v2 = (_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 380i64);
  if ( dword_14611ADA0 > *v2 )
  {
    sub_1461A7CF4(&dword_14611ADA0);
    if ( dword_14611ADA0 == -1 )
    {
      qword_14611AD90 = (__int64)GetModuleHandleW(0i64);
      qword_14611AD98 = qword_14611AD90 + *(unsigned int *)(*(int *)(qword_14611AD90 + 60) + qword_14611AD90 + 80);
      Init_thread_footer(&dword_14611ADA0);
    }
  }
  if ( dword_14611ADB0 > *v2 )
  {
    sub_1461A7CF4(&dword_14611ADB0);
    if ( dword_14611ADB0 == -1 )
    {
      v26 = qword_14611AD90;
      if ( qword_14611AD90 >= qword_14611AD18 + 0x140000000ui64
        && qword_14611AD90 <= (unsigned __int64)(qword_14611AD18 + 0x146000000i64) )
      {
        v26 = qword_14611AD90 - qword_14611AD18;
      }
      qword_14611ADA8 = v26;
      Init_thread_footer(&dword_14611ADB0);
    }
  }
  if ( dword_14611ADC0 > *v2 )
  {
    sub_1461A7CF4(&dword_14611ADC0);
    if ( dword_14611ADC0 == -1 )
    {
      v27 = qword_14611AD98;
      if ( qword_14611AD98 >= qword_14611AD18 + 0x140000000ui64
        && qword_14611AD98 <= (unsigned __int64)(qword_14611AD18 + 0x146000000i64) )
      {
        v27 = qword_14611AD98 - qword_14611AD18;
      }
      qword_14611ADB8 = v27;
      Init_thread_footer(&dword_14611ADC0);
    }
  }
  if ( v29 >= qword_14611ADA8 && v29 < qword_14611ADB8 )
  {
    v3 = &qword_14611AD58;
    if ( dword_14611AD78 > *v2 )
    {
      sub_1461A7CF4(&dword_14611AD78);
      if ( dword_14611AD78 == -1 )
      {
        sub_1461A31D0((__int64)&v28, &qword_14611AD58);
        atexit(sub_1461AEB00);
        Init_thread_footer(&dword_14611AD78);
      }
    }
    if ( *((_QWORD *)&xmmword_14611AD68 + 1) > 0xFui64 )
      v3 = (__int64 *)qword_14611AD58;
    v32[0] = (__int64)v3;
    v32[1] = xmmword_14611AD68;
    Block[0] = "data\\cache\\hints_%s.dat";
    Block[1] = (void *)23;
    *(_QWORD *)&v35 = 13i64;
    *((_QWORD *)&v35 + 1) = v32;
    sub_1461784D0(v37, (__int128 *)Block, &v35);
    v4 = v37;
    if ( v38 > 0xF )
      v4 = (void **)v37[0];
    Block[0] = v4;
    Block[1] = v37[2];
    v5 = sub_1461A2C60((__int64)&v41, (__int64)Block);
    sub_146170F20((__int64)v31, v5, v6, v7);
    v32[0] = (__int64)v31;
    v11 = (_QWORD *)sub_1461A1350((__int64)&v35, v8, v9, v10);
    v13 = v31;
    if ( v31[3] > (void *)7 )
      v13 = (void **)v31[0];
    v14 = sub_1461653F0(v11, v13, (unsigned __int64)v31[2], v12);
    *(_OWORD *)Block = *(_OWORD *)v14;
    v34 = *((_OWORD *)v14 + 1);
    v14[2] = 0i64;
    v14[3] = 7i64;
    *(_WORD *)v14 = 0;
    sub_146170F20((__int64)FileName, (__int64)Block, v15, v16);
    if ( *((_QWORD *)&v34 + 1) > 7ui64 )
    {
      v17 = Block[0];
      if ( (unsigned __int64)(2i64 * *((_QWORD *)&v34 + 1) + 2) >= 0x1000 )
      {
        v17 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)(Block[0] - v17 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v17);
    }
    if ( v36.m128i_i64[1] > 7ui64 )
    {
      v18 = (void *)v35;
      if ( (unsigned __int64)(2 * v36.m128i_i64[1] + 2) >= 0x1000 )
      {
        v18 = *(void **)(v35 - 8);
        if ( (unsigned __int64)(v35 - (_QWORD)v18 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v18);
    }
    si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
    v36 = si128;
    LOWORD(v35) = 0;
    sub_146162730((__int64)v31);
    if ( v42.m128i_i64[1] > 7ui64 )
    {
      v20 = v41;
      if ( (unsigned __int64)(2 * v42.m128i_i64[1] + 2) >= 0x1000 )
      {
        v20 = (_BYTE *)*((_QWORD *)v41 - 1);
        if ( (unsigned __int64)((_BYTE *)v41 - v20 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v20);
      si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
    }
    v42 = si128;
    LOWORD(v41) = 0;
    if ( v38 > 0xF )
    {
      v21 = v37[0];
      if ( v38 + 1 >= 0x1000 )
      {
        v21 = (void *)*((_QWORD *)v37[0] - 1);
        if ( (unsigned __int64)(v37[0] - v21 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v21);
    }
    v22 = (const wchar_t *)FileName;
    if ( v40 > 7 )
      v22 = FileName[0];
    v23 = wfopen(v22, L"ab");
    v24 = v23;
    if ( v23 )
    {
      fwrite(&Buffer, 1ui64, 8ui64, v23);
      fwrite(&v29, 1ui64, 8ui64, v24);
      fclose(v24);
    }
    if ( v40 > 7 )
    {
      v25 = FileName[0];
      if ( 2 * v40 + 2 >= 0x1000 )
      {
        v25 = (wchar_t *)*((_QWORD *)FileName[0] - 1);
        if ( (unsigned __int64)((char *)FileName[0] - (char *)v25 - 8) > 0x1F )
          invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      }
      j_j_free(v25);
    }
  }
}
// 1461A36D5: variable 'v6' is possibly undefined
// 1461A36D5: variable 'v7' is possibly undefined
// 1461A36E8: variable 'v8' is possibly undefined
// 1461A36E8: variable 'v9' is possibly undefined
// 1461A36E8: variable 'v10' is possibly undefined
// 1461A3707: variable 'v12' is possibly undefined
// 1461A3732: variable 'v15' is possibly undefined
// 1461A3732: variable 'v16' is possibly undefined
// 14611AD18: using guessed type __int64 qword_14611AD18;
// 14611AD58: using guessed type __int64 qword_14611AD58;
// 14611AD68: using guessed type __int128 xmmword_14611AD68;
// 14611AD78: using guessed type int dword_14611AD78;
// 14611AD90: using guessed type __int64 qword_14611AD90;
// 14611AD98: using guessed type __int64 qword_14611AD98;
// 14611ADA0: using guessed type int dword_14611ADA0;
// 14611ADA8: using guessed type __int64 qword_14611ADA8;
// 14611ADB0: using guessed type int dword_14611ADB0;
// 14611ADB8: using guessed type __int64 qword_14611ADB8;
// 14611ADC0: using guessed type int dword_14611ADC0;
// 14611AE78: using guessed type int TlsIndex;
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);

//----- (00000001461A3AC0) ----------------------------------------------------
char __fastcall sub_1461A3AC0(_QWORD *a1, _BYTE *a2)
{
  _QWORD *v3; // rdx
  char *v5; // r8
  unsigned __int64 v6; // r9
  char *v7; // r8
  _BYTE *v8; // rax
  char *v9; // rcx
  char *v10; // rsi
  __int64 v12; // rax
  __int64 v13; // rbp
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // r14
  _QWORD *v17; // r15
  _QWORD *v18; // rcx
  char *v19; // r8
  char *v20; // rdx
  size_t v21; // r8

  v3 = a1;
  if ( a1[3] > 0xFui64 )
    v3 = (_QWORD *)*a1;
  v5 = (char *)(a1 + 4);
  if ( a1[7] > 0xFui64 )
    v5 = *(char **)v5;
  v6 = a1[6];
  if ( v6 )
  {
    v7 = (char *)(v5 - a2);
    v8 = a2;
    v3 = (_QWORD *)((char *)v3 - a2);
    while ( v8[(_QWORD)v7] == 63 || v8[(_QWORD)v3] == *v8 )
    {
      if ( ++v8 - a2 >= v6 )
        goto LABEL_10;
    }
    return 0;
  }
  else
  {
LABEL_10:
    v9 = (char *)a1[11];
    v10 = (char *)a1[10];
    if ( v10 == v9 )
    {
      v12 = a1[9];
      v13 = (__int64)&v10[-v12] >> 3;
      if ( v13 == 0x1FFFFFFFFFFFFFFFi64 )
        unknown_libname_6(v9, v3, 0x1FFFFFFFFFFFFFFFi64);
      v14 = (__int64)&v9[-v12] >> 3;
      v15 = v14 >> 1;
      if ( v14 <= 0x1FFFFFFFFFFFFFFFi64 - (v14 >> 1) )
      {
        v16 = v13 + 1;
        if ( v15 + v14 >= v13 + 1 )
          v16 = v15 + v14;
        if ( v16 > 0x1FFFFFFFFFFFFFFFi64 )
          sub_146165390(v14, v15, 0x1FFFFFFFFFFFFFFFi64);
      }
      else
      {
        v16 = 0x1FFFFFFFFFFFFFFFi64;
      }
      v17 = sub_14615A5E0(8 * v16);
      v18 = v17;
      v17[v13] = a2;
      v19 = (char *)a1[10];
      v20 = (char *)a1[9];
      if ( v10 == v19 )
      {
        v21 = v19 - v20;
      }
      else
      {
        memmove(v17, v20, v10 - v20);
        v21 = a1[10] - (_QWORD)v10;
        v18 = &v17[v13 + 1];
        v20 = v10;
      }
      memmove(v18, v20, v21);
      sub_14618ACC0((__int64)(a1 + 9), (__int64)v17, v13 + 1, v16);
    }
    else
    {
      *(_QWORD *)v10 = a2;
      a1[10] += 8i64;
    }
    return 1;
  }
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (00000001461A3C40) ----------------------------------------------------
__int64 __fastcall sub_1461A3C40(__int64 a1, unsigned int a2)
{
  __int64 result; // rax
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // r15
  __int64 v6; // r12
  __int64 *v7; // rbx
  __int64 v8; // rcx
  __int64 v9; // rbp
  __int64 v10; // rsi
  __int64 v11; // rsi
  __int64 v12; // rcx
  __int64 v13; // rbx
  __int64 v14; // rbx
  __int64 v15; // rax
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 i; // rcx
  unsigned __int64 v19; // r15
  __int64 v20; // rax
  __int64 v21; // r8
  __int64 v22; // rdx
  _BYTE *v23; // rcx
  unsigned __int64 *v24; // rcx
  unsigned __int64 *v25; // rsi
  __int64 v26; // rdx
  __int64 v27; // rax
  __int64 v28; // rbp
  unsigned __int64 v29; // rcx
  unsigned __int64 v30; // rdx
  unsigned __int64 v31; // r14
  _QWORD *v32; // r15
  unsigned __int64 *v33; // r8
  unsigned __int64 *v34; // rdx
  _QWORD *v35; // rcx
  size_t v36; // r8
  _QWORD *v37; // r14
  unsigned __int64 v38; // rsi
  __int64 v39; // rbx
  unsigned __int64 v40; // rcx
  _QWORD *v41; // r10
  unsigned __int64 v42; // r8
  __int64 *v43; // r9
  _BOOL8 v44; // rdx
  __int64 *v45; // rax
  unsigned __int64 v46; // rdx
  __int64 *v48; // [rsp+28h] [rbp-8A0h]
  __int64 Buf2; // [rsp+30h] [rbp-898h] BYREF
  unsigned __int64 Buf1; // [rsp+38h] [rbp-890h] BYREF
  __int64 v51; // [rsp+40h] [rbp-888h]
  __int64 *v52; // [rsp+50h] [rbp-878h] BYREF
  BOOL v53; // [rsp+58h] [rbp-870h]
  _QWORD *v54; // [rsp+70h] [rbp-858h]
  _QWORD *v55; // [rsp+78h] [rbp-850h]
  __int64 v56; // [rsp+80h] [rbp-848h]
  __int64 v57[256]; // [rsp+90h] [rbp-838h] BYREF
  void *retaddr; // [rsp+8C8h] [rbp+0h] BYREF

  result = (__int64)&retaddr;
  v56 = -2i64;
  if ( !*(_BYTE *)(a1 + 96) )
  {
    v4 = *(_QWORD *)(a1 + 104);
    if ( !v4 || (v5 = *(_QWORD *)(a1 + 112)) == 0 )
      v5 = v4 + *(unsigned int *)(*(int *)(v4 + 60) + v4 + 80);
    v6 = a1;
    v51 = a1;
    if ( *(_QWORD *)(a1 + 24) > 0xFui64 )
    {
      v6 = *(_QWORD *)a1;
      v51 = *(_QWORD *)a1;
    }
    v7 = (__int64 *)(a1 + 32);
    v48 = v7;
    v8 = *(_QWORD *)(a1 + 48);
    v9 = v8;
    if ( (unsigned __int64)v7[3] <= 0xF )
    {
      v10 = (__int64)v7;
    }
    else
    {
      v10 = *v7;
      v7 = (__int64 *)*v7;
      v48 = v7;
    }
    if ( v8 )
    {
      v12 = v8 - 1;
      v13 = -1i64;
      if ( v12 != -1 )
        v13 = v12;
      v14 = v10 + v13 + 1;
      v15 = sub_1461A7810(v10, v14, 0x3Fu);
      v16 = v15 - v10;
      v11 = -1i64;
      if ( v15 != v14 )
        v11 = v16;
      v7 = v48;
    }
    else
    {
      v11 = -1i64;
    }
    if ( v11 == -1 )
      v11 = -1i64;
    Buf1 = v11;
    Buf2 = 0i64;
    if ( !memcmp(&Buf1, &Buf2, 8ui64) )
    {
      result = (__int64)memset(v57, 0, sizeof(v57));
    }
    else
    {
      result = (__int64)v57;
      v17 = 32i64;
      do
      {
        *(_QWORD *)result = v11;
        *(_QWORD *)(result + 8) = v11;
        *(_QWORD *)(result + 16) = v11;
        result += 64i64;
        *(_QWORD *)(result - 40) = v11;
        *(_QWORD *)(result - 32) = v11;
        *(_QWORD *)(result - 24) = v11;
        *(_QWORD *)(result - 16) = v11;
        *(_QWORD *)(result - 8) = v11;
        --v17;
      }
      while ( v17 );
    }
    for ( i = 0i64; i < v9; ++i )
    {
      result = *(unsigned __int8 *)(v6 + i);
      if ( v57[result] < i )
        v57[result] = i;
    }
    v19 = v5 - v9;
    Buf1 = v19;
    if ( v4 <= v19 )
    {
      v20 = v9 - 1;
      for ( Buf2 = v9 - 1; ; v20 = Buf2 )
      {
        v21 = 0x1FFFFFFFFFFFFFFFi64;
        v22 = v20;
        if ( v20 < 0 )
        {
LABEL_35:
          v24 = *(unsigned __int64 **)(a1 + 88);
          v25 = *(unsigned __int64 **)(a1 + 80);
          if ( v25 == v24 )
          {
            v27 = *(_QWORD *)(a1 + 72);
            v28 = ((__int64)v25 - v27) >> 3;
            if ( v28 == 0x1FFFFFFFFFFFFFFFi64 )
              unknown_libname_6(v24, v22, 0x1FFFFFFFFFFFFFFFi64);
            v29 = ((__int64)v24 - v27) >> 3;
            v30 = v29 >> 1;
            if ( v29 <= 0x1FFFFFFFFFFFFFFFi64 - (v29 >> 1) )
            {
              v31 = v28 + 1;
              if ( v30 + v29 >= v28 + 1 )
                v31 = v30 + v29;
              if ( v31 > 0x1FFFFFFFFFFFFFFFi64 )
                sub_146165390(v29, v30, 0x1FFFFFFFFFFFFFFFi64);
            }
            else
            {
              v31 = 0x1FFFFFFFFFFFFFFFi64;
            }
            v32 = sub_14615A5E0(8 * v31);
            v32[v28] = v4;
            v33 = *(unsigned __int64 **)(a1 + 80);
            v34 = *(unsigned __int64 **)(a1 + 72);
            v35 = v32;
            if ( v25 == v33 )
            {
              v36 = (char *)v33 - (char *)v34;
            }
            else
            {
              memmove(v32, v34, (char *)v25 - (char *)v34);
              v36 = *(_QWORD *)(a1 + 80) - (_QWORD)v25;
              v35 = &v32[v28 + 1];
              v34 = v25;
            }
            memmove(v35, v34, v36);
            sub_14618ACC0(a1 + 72, (__int64)v32, v28 + 1, v31);
            v19 = Buf1;
          }
          else
          {
            *v25 = v4;
            *(_QWORD *)(a1 + 80) += 8i64;
          }
          v37 = (_QWORD *)sub_1461A40E0(v24, v22, v21);
          if ( v4 < qword_14611AD18 + 0x140000000ui64 || v4 > qword_14611AD18 + 0x146000000i64 )
            v38 = v4;
          else
            v38 = v4 - qword_14611AD18;
          v39 = *v37;
          v54 = v37;
          v55 = 0i64;
          v41 = operator new(0x30ui64);
          v55 = v41;
          v42 = *(_QWORD *)(a1 + 64);
          v41[4] = v42;
          v41[5] = v38;
          *v41 = v39;
          v41[1] = v39;
          v41[2] = v39;
          *((_WORD *)v41 + 12) = 0;
          v43 = *(__int64 **)(*v37 + 8i64);
          v44 = 0i64;
          if ( !*((_BYTE *)v43 + 25) )
          {
            v45 = *(__int64 **)(*v37 + 8i64);
            do
            {
              v43 = v45;
              v40 = v45[4];
              if ( v42 >= v40 )
                v45 += 2;
              v44 = v42 < v40;
              v45 = (__int64 *)*v45;
            }
            while ( !*((_BYTE *)v45 + 25) );
          }
          v52 = v43;
          v53 = v44;
          if ( v37[1] == 0x555555555555555i64 )
            unknown_libname_3(v40, v44, v42);
          v55 = 0i64;
          sub_146165130(v37, (__int64)&v52, (__int64)v41);
          if ( v4 < qword_14611AD18 + 0x140000000ui64 || v4 > qword_14611AD18 + 0x146000000i64 )
            v46 = v4;
          else
            v46 = v4 - qword_14611AD18;
          sub_1461A3580(*(_QWORD *)(a1 + 64), v46);
          result = a2;
          if ( (__int64)(*(_QWORD *)(a1 + 80) - *(_QWORD *)(a1 + 72)) >> 3 == a2 )
            break;
          ++v4;
          v6 = v51;
          v7 = v48;
        }
        else
        {
          v23 = (_BYTE *)(v20 + v4);
          while ( v23[(_QWORD)v7 - v4] == 63 || v23[v6 - v4] == *v23 )
          {
            --v23;
            if ( --v22 < 0 )
            {
              v21 = 0x1FFFFFFFFFFFFFFFi64;
              goto LABEL_35;
            }
          }
          v26 = v22 - v57[*(unsigned __int8 *)(v22 + v4)];
          result = 1i64;
          if ( v26 > 1 )
            result = v26;
          v4 += result;
        }
        if ( v4 > v19 )
          break;
      }
    }
    *(_BYTE *)(a1 + 96) = 1;
  }
  return result;
}
// 1461A3F3F: variable 'v24' is possibly undefined
// 1461A3F3F: variable 'v22' is possibly undefined
// 1461A3F3F: variable 'v21' is possibly undefined
// 1461A40CC: variable 'v40' is possibly undefined
// 14611AD18: using guessed type __int64 qword_14611AD18;
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461653B0: using guessed type void __fastcall __noreturn unknown_libname_3(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);
// 1461A40E0: using guessed type __int64 __fastcall sub_1461A40E0(_QWORD, _QWORD, _QWORD);
// 1461A3C40: using guessed type __int64 var_838[256];

//----- (00000001461A40E0) ----------------------------------------------------
__int64 sub_1461A40E0()
{
  HMODULE ModuleHandleW; // rax
  FARPROC ProcAddress; // rax
  __int64 v3; // rcx

  if ( dword_14611AD88 <= *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex)
                                    + 380i64) )
    return qword_14611AD80;
  sub_1461A7CF4(&dword_14611AD88);
  if ( dword_14611AD88 != -1 )
    return qword_14611AD80;
  ModuleHandleW = GetModuleHandleW(L"CoreRT.dll");
  ProcAddress = GetProcAddress(ModuleHandleW, "CoreGetPatternHints");
  qword_14611AD80 = ((__int64 (__fastcall *)(__int64))ProcAddress)(v3);
  Init_thread_footer(&dword_14611AD88);
  return qword_14611AD80;
}
// 1461A414E: variable 'v3' is possibly undefined
// 14611AD80: using guessed type __int64 qword_14611AD80;
// 14611AD88: using guessed type int dword_14611AD88;
// 14611AE78: using guessed type int TlsIndex;
// 1461A40E0: using guessed type __int64 sub_1461A40E0();
// 1461A7C88: using guessed type __int64 __fastcall Init_thread_footer(_QWORD);

//----- (00000001461A4170) ----------------------------------------------------
HMODULE __fastcall sub_1461A4170(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v4; // r9
  char *i; // r10
  __int64 v6; // rax
  HMODULE v7; // rbx
  HMODULE result; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // rax
  _QWORD *v13; // rbx
  HMODULE v14; // rdi
  HMODULE v15; // rcx
  unsigned __int64 v16; // r8
  unsigned __int64 v17; // rdx
  _BYTE *v18; // rdx
  __int64 **v19; // rcx
  __int64 j; // rax
  __int64 *k; // rcx
  __int64 v22[3]; // [rsp+20h] [rbp-18h] BYREF

  v4 = 0xCBF29CE484222325ui64;
  for ( i = (char *)a2; i != (char *)(a2 + a3); v4 = v6 ^ (0x100000001B3i64 * v4) )
    v6 = *i++;
  v22[0] = a2;
  v22[1] = a3;
  *(_QWORD *)(a1 + 64) = v4;
  sub_1461A4320((unsigned __int64)v22, (void **)a1, (_QWORD *)(a1 + 32), v4);
  v7 = *(HMODULE *)(a1 + 104);
  result = GetModuleHandleW(0i64);
  if ( v7 == result )
  {
    v12 = sub_1461A40E0(v10, v9, v11);
    v13 = *(_QWORD **)v12;
    v14 = *(HMODULE *)v12;
    result = *(HMODULE *)(*(_QWORD *)v12 + 8i64);
    v15 = result;
    if ( !*((_BYTE *)result + 25) )
    {
      v16 = *(_QWORD *)(a1 + 64);
      do
      {
        v17 = *((_QWORD *)v15 + 4);
        if ( v17 >= v16 )
        {
          if ( *((_BYTE *)v14 + 25) && v16 < v17 )
            v14 = v15;
          v13 = v15;
        }
        else
        {
          v15 += 4;
        }
        v15 = *(HMODULE *)v15;
      }
      while ( !*((_BYTE *)v15 + 25) );
    }
    if ( !*((_BYTE *)v14 + 25) )
      result = *(HMODULE *)v14;
    for ( ; !*((_BYTE *)result + 25); result = *(HMODULE *)result )
    {
      if ( *(_QWORD *)(a1 + 64) >= *((_QWORD *)result + 4) )
        result += 4;
      else
        v14 = result;
    }
    if ( v13 != (_QWORD *)v14 )
    {
      do
      {
        v18 = (_BYTE *)v13[5];
        if ( (unsigned __int64)(v18 - 0x140000000i64) <= 0x6000000 )
          v18 += qword_14611AD18;
        sub_1461A3AC0((_QWORD *)a1, v18);
        v19 = (__int64 **)v13[2];
        if ( *((_BYTE *)v19 + 25) )
        {
          for ( j = v13[1]; !*(_BYTE *)(j + 25); j = *(_QWORD *)(j + 8) )
          {
            if ( v13 != *(_QWORD **)(j + 16) )
              break;
            v13 = (_QWORD *)j;
          }
          v13 = (_QWORD *)j;
        }
        else
        {
          v13 = (_QWORD *)v13[2];
          for ( k = *v19; !*((_BYTE *)k + 25); k = (__int64 *)*k )
            v13 = k;
        }
      }
      while ( v13 != (_QWORD *)v14 );
      result = *(HMODULE *)(a1 + 80);
      if ( *(HMODULE *)(a1 + 72) != result )
        *(_BYTE *)(a1 + 96) = 1;
    }
  }
  return result;
}
// 1461A41EC: variable 'v10' is possibly undefined
// 1461A41EC: variable 'v9' is possibly undefined
// 1461A41EC: variable 'v11' is possibly undefined
// 14611AD18: using guessed type __int64 qword_14611AD18;
// 1461A40E0: using guessed type __int64 __fastcall sub_1461A40E0(_QWORD, _QWORD, _QWORD);

//----- (00000001461A4320) ----------------------------------------------------
void __fastcall sub_1461A4320(unsigned __int64 a1, void **a2, _QWORD *a3, __int64 a4)
{
  char v4; // bl
  unsigned __int8 *v6; // rdx
  unsigned __int8 v7; // r13
  int v9; // eax
  size_t v10; // rdi
  unsigned __int64 v11; // r15
  char *v12; // rax
  unsigned __int64 v13; // rbx
  unsigned __int64 v14; // rcx
  _QWORD *v15; // rax
  _QWORD *v16; // rbp
  _QWORD *v17; // rbx
  size_t v18; // rdi
  unsigned __int64 v19; // rbp
  _QWORD *v20; // rax
  unsigned __int64 v21; // rbx
  unsigned __int64 v22; // rcx
  _QWORD *v23; // rax
  _QWORD *v24; // r15
  _QWORD *v25; // rbx
  char v26; // al
  __int64 v27; // rdx
  __int64 v28; // r8
  __int64 v29; // r9
  unsigned __int8 *v30; // [rsp+30h] [rbp-48h]
  char v31; // [rsp+80h] [rbp+8h]
  unsigned __int8 *v32; // [rsp+98h] [rbp+20h]

  v4 = 0;
  v31 = 0;
  v6 = *(unsigned __int8 **)a1;
  v7 = 0;
  v32 = *(unsigned __int8 **)a1;
  v30 = (unsigned __int8 *)(*(_QWORD *)a1 + *(_QWORD *)(a1 + 8));
  if ( *(unsigned __int8 **)a1 != v30 )
  {
    do
    {
      v9 = *v6;
      if ( (_BYTE)v9 != 32 )
      {
        if ( (_BYTE)v9 == 63 )
        {
          v10 = (size_t)a2[2];
          v11 = (unsigned __int64)a2[3];
          if ( v10 >= v11 )
          {
            if ( v10 == 0x7FFFFFFFFFFFFFFFi64 )
              goto LABEL_54;
            v13 = (v10 + 1) | 0xF;
            if ( v13 <= 0x7FFFFFFFFFFFFFFFi64 )
            {
              v14 = v11 >> 1;
              if ( v11 <= 0x7FFFFFFFFFFFFFFFi64 - (v11 >> 1) )
              {
                if ( v13 < v11 + v14 )
                  v13 = v11 + v14;
              }
              else
              {
                v13 = 0x7FFFFFFFFFFFFFFFi64;
              }
            }
            else
            {
              v13 = 0x7FFFFFFFFFFFFFFFi64;
            }
            v15 = sub_14615A5E0(v13 + 1);
            a2[2] = (void *)(v10 + 1);
            v16 = v15;
            a2[3] = (void *)v13;
            if ( v11 <= 0xF )
            {
              memcpy(v15, a2, v10);
              *(_WORD *)((char *)v16 + v10) = 0;
            }
            else
            {
              v17 = *a2;
              memcpy(v15, *a2, v10);
              *(_WORD *)((char *)v16 + v10) = 0;
              if ( v11 + 1 >= 0x1000 )
              {
                if ( (unsigned __int64)v17 - *(v17 - 1) - 8 > 0x1F )
                  goto LABEL_53;
                v17 = (_QWORD *)*(v17 - 1);
              }
              j_j_free(v17);
            }
            v4 = v31;
            v6 = v32;
            *a2 = v16;
          }
          else
          {
            a2[2] = (void *)(v10 + 1);
            v12 = (char *)a2;
            if ( v11 > 0xF )
              v12 = (char *)*a2;
            *(_WORD *)&v12[v10] = 0;
          }
          v18 = a3[2];
          v19 = a3[3];
          if ( v18 < v19 )
          {
            a3[2] = v18 + 1;
            v20 = a3;
            if ( v19 > 0xF )
              v20 = (_QWORD *)*a3;
            *(_WORD *)((char *)v20 + v18) = 63;
            goto LABEL_51;
          }
          if ( v18 == 0x7FFFFFFFFFFFFFFFi64 )
LABEL_54:
            unknown_libname_4(a1, v6, 0x7FFFFFFFFFFFFFFFi64, a4);
          v21 = (v18 + 1) | 0xF;
          if ( v21 <= 0x7FFFFFFFFFFFFFFFi64 )
          {
            v22 = v19 >> 1;
            if ( v19 <= 0x7FFFFFFFFFFFFFFFi64 - (v19 >> 1) )
            {
              if ( v21 < v22 + v19 )
                v21 = v22 + v19;
            }
            else
            {
              v21 = 0x7FFFFFFFFFFFFFFFi64;
            }
          }
          else
          {
            v21 = 0x7FFFFFFFFFFFFFFFi64;
          }
          v23 = sub_14615A5E0(v21 + 1);
          a3[2] = v18 + 1;
          v24 = v23;
          a3[3] = v21;
          if ( v19 <= 0xF )
          {
            memcpy(v23, a3, v18);
            v4 = v31;
            *(_WORD *)((char *)v24 + v18) = 63;
            *a3 = v24;
          }
          else
          {
            v25 = (_QWORD *)*a3;
            memcpy(v23, (const void *)*a3, v18);
            *(_WORD *)((char *)v24 + v18) = 63;
            if ( v19 + 1 >= 0x1000 )
            {
              if ( (unsigned __int64)v25 - *(v25 - 1) - 8 > 0x1F )
LABEL_53:
                invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
              v25 = (_QWORD *)*(v25 - 1);
            }
            j_j_free(v25);
            v4 = v31;
            *a3 = v24;
          }
          goto LABEL_50;
        }
        if ( (unsigned __int8)(v9 - 48) > 9u && (unsigned __int8)(v9 - 65) > 5u )
        {
          a1 = (unsigned int)(v9 - 97);
          if ( (unsigned __int8)(v9 - 97) > 5u )
            goto LABEL_51;
        }
        a1 = (unsigned int)(v9 - 65);
        if ( (unsigned __int8)(v9 - 65) > 5u )
        {
          a1 = (unsigned int)(v9 - 97);
          if ( (unsigned __int8)(v9 - 97) > 5u )
            v26 = v9 - 48;
          else
            v26 = v9 - 87;
        }
        else
        {
          v26 = v9 - 55;
        }
        if ( v4 )
        {
          v7 |= v26;
          v4 = 0;
          v31 = 0;
          sub_146190570(a2, v7, 0x7FFFFFFFFFFFFFFFi64, a4);
          LOBYTE(v27) = 120;
          sub_146190570((void **)a3, v27, v28, v29);
LABEL_50:
          v6 = v32;
          goto LABEL_51;
        }
        v4 = 1;
        v7 = 16 * v26;
        v31 = 1;
      }
LABEL_51:
      v32 = ++v6;
    }
    while ( v6 != v30 );
  }
}
// 1461A45EA: variable 'a4' is possibly undefined
// 1461A45F4: variable 'v27' is possibly undefined
// 1461A45F4: variable 'v28' is possibly undefined
// 1461A45F4: variable 'v29' is possibly undefined
// 1461A4653: variable 'a1' is possibly undefined
// 1461653D0: using guessed type void __fastcall __noreturn unknown_libname_4(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001461A4660) ----------------------------------------------------
_BOOL8 __fastcall sub_1461A4660(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  bool v4; // bl
  __int64 v5; // rdx
  __int64 v6; // r8
  __int64 v7; // r9
  _QWORD *v8; // rax
  __int64 v9; // r9
  void **v10; // rdx
  _QWORD *v11; // rax
  __int64 v12; // r8
  __int64 v13; // r9
  void *v14; // rcx
  _BYTE *v15; // rcx
  const WCHAR *v16; // rcx
  const WCHAR *v17; // r9
  WCHAR *v18; // rcx
  void *v20[2]; // [rsp+40h] [rbp-61h] BYREF
  unsigned __int64 v21; // [rsp+50h] [rbp-51h]
  unsigned __int64 v22; // [rsp+58h] [rbp-49h]
  __int64 v23; // [rsp+60h] [rbp-41h]
  LPCWSTR v24[2]; // [rsp+68h] [rbp-39h] BYREF
  __m128i v25; // [rsp+78h] [rbp-29h]
  void *Block[2]; // [rsp+88h] [rbp-19h] BYREF
  __int128 v27; // [rsp+98h] [rbp-9h]
  void *v28; // [rsp+A8h] [rbp+7h] BYREF
  __m128i si128; // [rsp+B8h] [rbp+17h]
  LPCWSTR lpFileName[2]; // [rsp+C8h] [rbp+27h] BYREF
  __m128i v31; // [rsp+D8h] [rbp+37h]

  v23 = -2i64;
  v4 = 1;
  *(_OWORD *)v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  sub_146168F30(v20, L"CitizenFX.ini", 0xDui64, a4);
  v8 = (_QWORD *)sub_1461A1350((__int64)&v28, v5, v6, v7);
  v10 = v20;
  if ( v22 > 7 )
    v10 = (void **)v20[0];
  v11 = sub_1461653F0(v8, v10, v21, v9);
  *(_OWORD *)Block = *(_OWORD *)v11;
  v27 = *((_OWORD *)v11 + 1);
  v11[2] = 0i64;
  v11[3] = 7i64;
  *(_WORD *)v11 = 0;
  sub_146170F20((__int64)lpFileName, (__int64)Block, v12, v13);
  if ( *((_QWORD *)&v27 + 1) > 7ui64 )
  {
    v14 = Block[0];
    if ( (unsigned __int64)(2i64 * *((_QWORD *)&v27 + 1) + 2) >= 0x1000 )
    {
      v14 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v14 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v14);
  }
  if ( si128.m128i_i64[1] > 7ui64 )
  {
    v15 = v28;
    if ( (unsigned __int64)(2 * si128.m128i_i64[1] + 2) >= 0x1000 )
    {
      v15 = (_BYTE *)*((_QWORD *)v28 - 1);
      if ( (unsigned __int64)((_BYTE *)v28 - v15 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v15);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(v28) = 0;
  sub_146162730((__int64)v20);
  *(_OWORD *)v24 = *(_OWORD *)lpFileName;
  v25 = v31;
  v16 = (const WCHAR *)v24;
  if ( _mm_srli_si128(v31, 8).m128i_u64[0] > 7 )
    v16 = lpFileName[0];
  if ( GetFileAttributesW(v16) != -1 )
  {
    v17 = (const WCHAR *)v24;
    if ( v25.m128i_i64[1] > 7ui64 )
      v17 = v24[0];
    v4 = GetPrivateProfileIntW(L"Game", L"ReplaceExecutable", 1, v17) != 0;
  }
  if ( v25.m128i_i64[1] > 7ui64 )
  {
    v18 = (WCHAR *)v24[0];
    if ( (unsigned __int64)(2 * v25.m128i_i64[1] + 2) >= 0x1000 )
    {
      v18 = (WCHAR *)*((_QWORD *)v24[0] - 1);
      if ( (unsigned __int64)((char *)v24[0] - (char *)v18 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v18);
  }
  return v4;
}
// 1461A46C2: variable 'v5' is possibly undefined
// 1461A46C2: variable 'v6' is possibly undefined
// 1461A46C2: variable 'v7' is possibly undefined
// 1461A46DD: variable 'v9' is possibly undefined
// 1461A4708: variable 'v12' is possibly undefined
// 1461A4708: variable 'v13' is possibly undefined
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 14612E388: using guessed type wchar_t aCitizenfxIni[14];

//----- (00000001461A48B0) ----------------------------------------------------
__int64 sub_1461A48B0()
{
  unsigned int v0; // r14d
  void *v1; // rcx
  LPCVOID v2; // r15
  const WCHAR *CommandLineW; // rax
  LPWSTR *v4; // rax
  LPWSTR *v5; // r13
  const wchar_t **v6; // rdi
  __int64 v7; // rsi
  const wchar_t *v8; // rbx
  size_t v9; // r10
  __int64 *v10; // r9
  __int128 v11; // xmm2
  size_t v12; // rdx
  _WORD *v13; // rax
  int pNumArgs[2]; // [rsp+38h] [rbp-D0h] BYREF
  HANDLE hObject; // [rsp+40h] [rbp-C8h] BYREF
  LPCVOID lpBaseAddress; // [rsp+48h] [rbp-C0h]
  __int64 v18[42]; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v19; // [rsp+1A8h] [rbp+A0h] BYREF
  void *Block[2]; // [rsp+1B0h] [rbp+A8h] BYREF
  __m128i si128; // [rsp+1C0h] [rbp+B8h]

  v19 = -2i64;
  v18[0] = (__int64)L"-b1";
  v18[1] = 3i64;
  v18[2] = 1i64;
  v18[3] = (__int64)L"-b1604";
  v18[4] = 6i64;
  v18[5] = 1604i64;
  v18[6] = (__int64)L"-b2060";
  v18[7] = 6i64;
  v18[8] = 2060i64;
  v18[9] = (__int64)L"-b2189";
  v18[10] = 6i64;
  v18[11] = 2189i64;
  v18[12] = (__int64)L"-b2372";
  v18[13] = 6i64;
  v18[14] = 2372i64;
  v18[15] = (__int64)L"-b2545";
  v18[16] = 6i64;
  v18[17] = 2545i64;
  v18[18] = (__int64)L"-b2612";
  v18[19] = 6i64;
  v18[20] = 2612i64;
  v18[21] = (__int64)L"-b2699";
  v18[22] = 6i64;
  v18[23] = 2699i64;
  v18[24] = (__int64)L"-b2802";
  v18[25] = 6i64;
  v18[26] = 2802i64;
  v18[27] = (__int64)L"-b2944";
  v18[28] = 6i64;
  v0 = 2944;
  v18[29] = 2944i64;
  v18[30] = (__int64)L"-b3095";
  v18[31] = 6i64;
  v18[32] = 3095i64;
  v18[33] = (__int64)L"-b3258";
  v18[34] = 6i64;
  v18[35] = 3258i64;
  v18[36] = (__int64)L"-b3323";
  v18[37] = 6i64;
  v18[38] = 3323i64;
  v18[39] = (__int64)L"-b3407";
  v18[40] = 6i64;
  v18[41] = 3407i64;
  si128 = _mm_load_si128((const __m128i *)&xmmword_14611E150);
  strcpy((char *)Block, "CfxInitState");
  BYTE5(Block[1]) = 0;
  HIWORD(Block[1]) = 0;
  sub_146166700((__int64)&hObject, (__int64 *)Block);
  if ( si128.m128i_i64[1] > 0xFui64 )
  {
    v1 = Block[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v1 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)(Block[0] - v1 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v1);
  }
  v2 = lpBaseAddress;
  CommandLineW = (const WCHAR *)((char *)lpBaseAddress + 8208);
  if ( !*((_WORD *)lpBaseAddress + 4104) )
    CommandLineW = GetCommandLineW();
  v4 = CommandLineToArgvW(CommandLineW, pNumArgs);
  v5 = v4;
  if ( pNumArgs[0] <= 1 )
    goto LABEL_18;
  v6 = (const wchar_t **)(v4 + 1);
  v7 = (unsigned int)(pNumArgs[0] - 1);
  do
  {
    v8 = *v6;
    v9 = wcslen(*v6);
    v10 = v18;
    while ( 1 )
    {
      v11 = *(_OWORD *)v10;
      si128.m128i_i64[0] = v10[2];
      if ( v9 == v10[1] )
        break;
LABEL_24:
      v10 += 3;
      if ( v10 == &v19 )
        goto LABEL_17;
    }
    if ( v9 )
    {
      v12 = v9;
      v13 = (_WORD *)v11;
      while ( *(_WORD *)((char *)v13 + (_QWORD)v8 - v11) == *v13 )
      {
        ++v13;
        if ( !--v12 )
          goto LABEL_16;
      }
      goto LABEL_24;
    }
LABEL_16:
    v0 = si128.m128i_i32[0];
LABEL_17:
    ++v6;
    --v7;
  }
  while ( v7 );
LABEL_18:
  LocalFree(v5);
  if ( v2 && v2 != &unk_146106050 )
    UnmapViewOfFile(v2);
  if ( hObject )
    CloseHandle(hObject);
  return v0;
}
// 14611E150: using guessed type __int128 xmmword_14611E150;
// 1461300C8: using guessed type wchar_t aB1[4];
// 1461300D0: using guessed type wchar_t aB1604[7];
// 1461300E0: using guessed type wchar_t aB2060[7];
// 1461300F0: using guessed type wchar_t aB2189[7];
// 146130100: using guessed type wchar_t aB2372[7];
// 146130110: using guessed type wchar_t aB2545[7];
// 146130120: using guessed type wchar_t aB2612[7];
// 146130130: using guessed type wchar_t aB2699[7];
// 146130140: using guessed type wchar_t aB2802[7];
// 146130150: using guessed type wchar_t aB2944[7];
// 146130160: using guessed type wchar_t aB3095[7];
// 146130170: using guessed type wchar_t aB3258[7];
// 146130180: using guessed type wchar_t aB3323[7];
// 146130190: using guessed type wchar_t aB3407[7];
// 1461A48B0: using guessed type __int64 sub_1461A48B0();

//----- (00000001461A4C70) ----------------------------------------------------
__int64 __fastcall sub_1461A4C70(__int64 a1, __int64 a2, int a3, _OWORD *a4)
{
  __int64 result; // rax

  *(_OWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 7i64;
  *(_WORD *)a1 = 0;
  *(_QWORD *)(a1 + 32) = a2;
  *(_OWORD *)(a1 + 40) = 0i64;
  *(_DWORD *)(a1 + 56) = a3;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_QWORD *)(a1 + 80) = 0i64;
  *(_QWORD *)(a1 + 88) = 0i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  memset((void *)(a1 + 104), 0, 0x308ui64);
  result = a1;
  if ( a4 )
    *(_OWORD *)(a1 + 40) = *a4;
  return result;
}

//----- (00000001461A4CF0) ----------------------------------------------------
__int64 __fastcall sub_1461A4CF0(__int64 a1, const wchar_t *a2, int a3, _OWORD *a4)
{
  unsigned __int64 v8; // rax
  __int64 v9; // r9
  __int64 result; // rax

  *(_OWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  v8 = wcslen(a2);
  sub_146168F30((_QWORD *)a1, a2, v8, v9);
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_OWORD *)(a1 + 40) = 0i64;
  *(_DWORD *)(a1 + 56) = a3;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_QWORD *)(a1 + 80) = 0i64;
  *(_QWORD *)(a1 + 88) = 0i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  memset((void *)(a1 + 104), 0, 0x308ui64);
  result = a1;
  if ( a4 )
    *(_OWORD *)(a1 + 40) = *a4;
  return result;
}
// 1461A4D38: variable 'v9' is possibly undefined

//----- (00000001461A4DA0) ----------------------------------------------------
__int64 __fastcall sub_1461A4DA0(_QWORD *a1)
{
  void *v2; // rcx
  void *v3; // rcx
  void *v4; // rcx

  v2 = (void *)a1[8];
  if ( v2 )
    CloseHandle(v2);
  v3 = (void *)a1[9];
  if ( v3 )
    CloseHandle(v3);
  v4 = (void *)a1[10];
  if ( v4 )
    CloseHandle(v4);
  return sub_146162730((__int64)a1);
}

//----- (00000001461A4DF0) ----------------------------------------------------
HANDLE __fastcall sub_1461A4DF0(const WCHAR *lpNamedPipeName)
{
  const WCHAR *v1; // rsi
  void *v2; // rbx
  HANDLE v3; // rdi
  int v5; // edi
  HANDLE FileW; // rax
  DWORD Mode; // [rsp+50h] [rbp+8h] BYREF

  v1 = lpNamedPipeName;
  if ( *((_QWORD *)lpNamedPipeName + 3) > 7ui64 )
    v1 = *(const WCHAR **)lpNamedPipeName;
  v2 = (void *)*((_QWORD *)lpNamedPipeName + 4);
  if ( v2 )
  {
    *((_QWORD *)lpNamedPipeName + 4) = 0i64;
    v3 = v2;
LABEL_5:
    Mode = 2;
    if ( !SetNamedPipeHandleState(v2, &Mode, 0i64, 0i64) )
    {
      CloseHandle(v2);
      return 0i64;
    }
    return v3;
  }
  else
  {
    v5 = 0;
    while ( 1 )
    {
      FileW = CreateFileW(v1, 0x103u, 0, 0i64, 3u, 0x110000u, 0i64);
      v2 = FileW;
      if ( FileW != (HANDLE)-1i64 )
        break;
      if ( GetLastError() != 231 || !WaitNamedPipeW(v1, 0x7D0u) )
        return 0i64;
      if ( ++v5 >= 2 )
        return 0i64;
    }
    v3 = FileW;
    if ( FileW )
      goto LABEL_5;
    return 0i64;
  }
}

//----- (00000001461A4EE0) ----------------------------------------------------
char __fastcall sub_1461A4EE0(__int64 a1)
{
  HANDLE v2; // rax
  void *v3; // rsi
  int v4; // ebx
  DWORD CurrentProcessId; // eax
  __int128 v6; // xmm0
  char v7; // bl
  __int64 OutBuffer; // [rsp+40h] [rbp-C0h] BYREF
  int v10; // [rsp+48h] [rbp-B8h]
  __int128 v11; // [rsp+50h] [rbp-B0h]
  __int64 v12; // [rsp+60h] [rbp-A0h]
  __int128 v13; // [rsp+68h] [rbp-98h]
  __int64 v14; // [rsp+78h] [rbp-88h]
  __int128 v15; // [rsp+80h] [rbp-80h]
  int InBuffer[4]; // [rsp+90h] [rbp-70h] BYREF
  __int64 v17; // [rsp+A0h] [rbp-60h]
  __int64 v18; // [rsp+A8h] [rbp-58h]
  __int64 v19; // [rsp+B0h] [rbp-50h]
  __int128 v20; // [rsp+B8h] [rbp-48h]
  __int64 v21; // [rsp+C8h] [rbp-38h]
  __int128 v22; // [rsp+D0h] [rbp-30h]
  int Buffer; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v24; // [rsp+E4h] [rbp-1Ch]
  __int128 v25; // [rsp+F0h] [rbp-10h]
  __int64 v26; // [rsp+100h] [rbp+0h]
  __int128 v27; // [rsp+108h] [rbp+8h]
  __int64 v28; // [rsp+118h] [rbp+18h]
  __int128 v29; // [rsp+120h] [rbp+20h]
  DWORD BytesRead; // [rsp+140h] [rbp+40h] BYREF

  if ( *(_QWORD *)(a1 + 64) )
  {
    LOBYTE(v2) = 1;
  }
  else
  {
    v2 = sub_1461A4DF0((const WCHAR *)a1);
    v3 = v2;
    if ( v2 )
    {
      v4 = *(_DWORD *)(a1 + 56);
      CurrentProcessId = GetCurrentProcessId();
      v6 = *(_OWORD *)(a1 + 40);
      InBuffer[1] = CurrentProcessId;
      InBuffer[2] = v4;
      v7 = 0;
      v17 = a1 + 92;
      v18 = a1 + 96;
      InBuffer[0] = 1;
      v19 = a1 + 104;
      v21 = 0i64;
      v20 = v6;
      v22 = 0i64;
      OutBuffer = 0i64;
      v10 = 0;
      v11 = 0i64;
      v12 = 0i64;
      v13 = 0i64;
      v14 = 0i64;
      v15 = 0i64;
      BytesRead = 0;
      if ( TransactNamedPipe(v3, InBuffer, 0x50u, &OutBuffer, 0x50u, &BytesRead, 0i64) )
      {
        if ( (_DWORD)OutBuffer == 2 )
        {
          if ( HIDWORD(OutBuffer) )
          {
            if ( v14 )
            {
              if ( (_QWORD)v15 )
              {
                if ( *((_QWORD *)&v15 + 1) )
                {
                  v24 = 0i64;
                  v25 = 0i64;
                  v29 = 0i64;
                  v26 = 0i64;
                  v28 = 0i64;
                  Buffer = 3;
                  v27 = 0i64;
                  if ( WriteFile(v3, &Buffer, 0x50u, &BytesRead, 0i64) )
                  {
                    v7 = 1;
                    *(_QWORD *)(a1 + 64) = v14;
                    *(_OWORD *)(a1 + 72) = v15;
                    *(_DWORD *)(a1 + 88) = HIDWORD(OutBuffer);
                  }
                }
              }
            }
          }
        }
      }
      CloseHandle(v3);
      LOBYTE(v2) = v7;
    }
  }
  return (char)v2;
}

//----- (00000001461A5090) ----------------------------------------------------
bool __fastcall sub_1461A5090(__int64 a1, __int64 a2, __int128 *a3)
{
  _QWORD *v5; // rcx
  __int64 v6; // rax
  __int128 v7; // xmm0
  HANDLE Handles[3]; // [rsp+20h] [rbp-18h] BYREF

  if ( !*(_QWORD *)(a1 + 64) )
    return 0;
  *(_QWORD *)(a1 + 96) = a2;
  *(_DWORD *)(a1 + 92) = GetCurrentThreadId();
  v5 = (_QWORD *)(a1 + 104);
  if ( a3 )
  {
    v6 = 6i64;
    do
    {
      v5 += 16;
      v7 = *a3;
      a3 += 8;
      *((_OWORD *)v5 - 8) = v7;
      *((_OWORD *)v5 - 7) = *(a3 - 7);
      *((_OWORD *)v5 - 6) = *(a3 - 6);
      *((_OWORD *)v5 - 5) = *(a3 - 5);
      *((_OWORD *)v5 - 4) = *(a3 - 4);
      *((_OWORD *)v5 - 3) = *(a3 - 3);
      *((_OWORD *)v5 - 2) = *(a3 - 2);
      *((_OWORD *)v5 - 1) = *(a3 - 1);
      --v6;
    }
    while ( v6 );
    *v5 = *(_QWORD *)a3;
  }
  else
  {
    memset(v5, 0, 0x308ui64);
  }
  if ( !ResetEvent(*(HANDLE *)(a1 + 72)) || !SetEvent(*(HANDLE *)(a1 + 64)) )
    return 0;
  Handles[0] = *(HANDLE *)(a1 + 72);
  Handles[1] = *(HANDLE *)(a1 + 80);
  return WaitForMultipleObjects(2u, Handles, 0, 0x3A98u) == 0;
}

//----- (00000001461A51A0) ----------------------------------------------------
_QWORD *__fastcall sub_1461A51A0(_QWORD *a1, _BYTE *a2, _QWORD *a3)
{
  _QWORD *v4; // rdx
  __int64 v6; // rbp
  __int64 v7; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r15
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  __int64 v13; // r12
  _QWORD *v14; // rdi
  _QWORD *v15; // rcx
  _BYTE *v16; // r8
  _QWORD *v17; // rdx
  size_t v18; // r8
  unsigned __int64 v19; // rax
  _QWORD *v20; // rcx
  _QWORD *result; // rax

  v4 = (_QWORD *)*a1;
  v6 = (__int64)&a2[-*a1] >> 3;
  v7 = (__int64)(a1[1] - *a1) >> 3;
  if ( v7 == 0x1FFFFFFFFFFFFFFFi64 )
    unknown_libname_6(a1, v4, 0x1FFFFFFFFFFFFFFFi64);
  v9 = (__int64)(a1[2] - (_QWORD)v4) >> 3;
  v10 = v7 + 1;
  v11 = v9 >> 1;
  if ( v9 <= 0x1FFFFFFFFFFFFFFFi64 - (v9 >> 1) )
  {
    v19 = v11 + v9;
    v12 = v10;
    if ( v19 >= v10 )
      v12 = v19;
    if ( v12 > 0x1FFFFFFFFFFFFFFFi64 )
      sub_146165390(v12, v11, 0x1FFFFFFFFFFFFFFFi64);
  }
  else
  {
    v12 = 0x1FFFFFFFFFFFFFFFi64;
  }
  v13 = v12;
  v14 = sub_14615A5E0(8 * v12);
  v14[v6] = *a3;
  v15 = v14;
  v16 = (_BYTE *)a1[1];
  v17 = (_QWORD *)*a1;
  if ( a2 == v16 )
  {
    v18 = v16 - (_BYTE *)v17;
  }
  else
  {
    memmove(v14, v17, a2 - (_BYTE *)v17);
    v15 = &v14[v6 + 1];
    v18 = a1[1] - (_QWORD)a2;
    v17 = a2;
  }
  memmove(v15, v17, v18);
  v20 = (_QWORD *)*a1;
  if ( *a1 )
  {
    if ( ((a1[2] - (_QWORD)v20) & 0xFFFFFFFFFFFFFFF8ui64) >= 0x1000 )
    {
      if ( (unsigned __int64)v20 - *(v20 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v20 = (_QWORD *)*(v20 - 1);
    }
    j_j_free(v20);
  }
  *a1 = v14;
  result = &v14[v6];
  a1[1] = &v14[v10];
  a1[2] = &v14[v13];
  return result;
}
// 146165390: using guessed type void __fastcall __noreturn sub_146165390(_QWORD, _QWORD, _QWORD);
// 1461739B0: using guessed type void __fastcall __noreturn unknown_libname_6(_QWORD, _QWORD, _QWORD);

//----- (00000001461A5320) ----------------------------------------------------
__int64 __fastcall sub_1461A5320(__int64 a1)
{
  unsigned __int64 v2; // rcx
  __int64 v3; // rcx

  EnterCriticalSection(&CriticalSection);
  v2 = ((__int64)(*(_QWORD *)(qword_14611ADD8 + 8) - *(_QWORD *)qword_14611ADD8) >> 3) - ++dword_14611ADE0;
  if ( (__int64)(*(_QWORD *)(qword_14611ADD8 + 8) - *(_QWORD *)qword_14611ADD8) >> 3 <= v2 )
    unknown_libname_8();
  v3 = *(_QWORD *)(*(_QWORD *)qword_14611ADD8 + 8 * v2);
  *(_QWORD *)a1 = v3;
  SetUnhandledExceptionFilter(*(LPTOP_LEVEL_EXCEPTION_FILTER *)(v3 + 200));
  set_invalid_parameter_handler(*(_invalid_parameter_handler *)(*(_QWORD *)a1 + 208i64));
  set_purecall_handler(*(_purecall_handler *)(*(_QWORD *)a1 + 216i64));
  return a1;
}
// 14611ADD8: using guessed type __int64 qword_14611ADD8;
// 14611ADE0: using guessed type int dword_14611ADE0;
// 1461A6830: using guessed type void __noreturn unknown_libname_8(void);

//----- (00000001461A53B0) ----------------------------------------------------
struct _RTL_CRITICAL_SECTION *__fastcall sub_1461A53B0(
        struct _RTL_CRITICAL_SECTION *lpParameter,
        char *Src,
        struct _RTL_CRITICAL_SECTION_DEBUG *a3,
        __int64 a4,
        void *a5,
        int a6,
        __int64 a7)
{
  _QWORD *v11; // rax

  lpParameter->LockSemaphore = 0i64;
  *(_OWORD *)&lpParameter->SpinCount = 0i64;
  *(_QWORD *)&lpParameter[1].LockCount = 0i64;
  lpParameter[1].OwningThread = HANDLE_FLAG_PROTECT_FROM_CLOSE|HANDLE_FLAG_INHERIT|0x4;
  LOWORD(lpParameter->SpinCount) = 0;
  *(_OWORD *)&lpParameter[1].LockSemaphore = 0i64;
  lpParameter[2].DebugInfo = 0i64;
  *(_QWORD *)&lpParameter[2].LockCount = 7i64;
  LOWORD(lpParameter[1].LockSemaphore) = 0;
  *(_OWORD *)&lpParameter[2].OwningThread = 0i64;
  lpParameter[2].SpinCount = 0i64;
  lpParameter[3].DebugInfo = (PRTL_CRITICAL_SECTION_DEBUG)7;
  LOWORD(lpParameter[2].OwningThread) = 0;
  *(_QWORD *)&lpParameter[8].LockCount = 0i64;
  lpParameter[8].OwningThread = 0i64;
  v11 = operator new(0x20ui64);
  *v11 = v11;
  v11[1] = v11;
  *(_QWORD *)&lpParameter[8].LockCount = v11;
  sub_1461A5D20(lpParameter, Src, a3, a4, a5, a6, 0, 0i64, 0i64, a7, 0i64);
  return lpParameter;
}

//----- (00000001461A54B0) ----------------------------------------------------
void __fastcall sub_1461A54B0(void **a1)
{
  _QWORD **v1; // rdx
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  v1 = (_QWORD **)*a1;
  **((_QWORD **)*a1 + 1) = 0i64;
  v3 = *v1;
  if ( *v1 )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      j_j_free(v3);
      v3 = v4;
    }
    while ( v4 );
  }
  j_j_free(*a1);
}

//----- (00000001461A5510) ----------------------------------------------------
void __fastcall sub_1461A5510(_QWORD **a1)
{
  void *v1; // rbx

  v1 = *a1;
  if ( *a1 )
  {
    sub_1461A4DA0(*a1);
    j_j_free(v1);
  }
}

//----- (00000001461A5540) ----------------------------------------------------
void sub_1461A5540()
{
  SetUnhandledExceptionFilter(TopLevelExceptionFilter);
  set_invalid_parameter_handler((_invalid_parameter_handler)sub_1461A5820);
  set_purecall_handler(sub_1461A5A10);
  --dword_14611ADE0;
  LeaveCriticalSection(&CriticalSection);
}
// 14611ADE0: using guessed type int dword_14611ADE0;

//----- (00000001461A5590) ----------------------------------------------------
__int64 __fastcall sub_1461A5590(HANDLE *Parameter)
{
  __int128 *v2; // rdi
  __int64 v3; // rsi
  int v4; // ebp
  char v5; // al
  __int64 v6; // rcx
  HANDLE hProcess; // rax
  __int64 (__fastcall *v8)(HANDLE, HANDLE, HANDLE, __int64, __int128 *, int); // r10
  HANDLE v9; // rcx
  int v11; // [rsp+28h] [rbp-10h]

  while ( 1 )
  {
    while ( WaitForSingleObject(Parameter[35], 0xFFFFFFFF) )
      ;
    if ( *((_BYTE *)Parameter + 232) )
      break;
    v2 = (__int128 *)Parameter[39];
    v3 = (__int64)Parameter[38];
    v4 = *((_DWORD *)Parameter + 74);
    if ( !*Parameter
      || (v5 = ((__int64 (__fastcall *)(HANDLE, HANDLE, HANDLE))*Parameter)(Parameter[2], Parameter[38], Parameter[39])) != 0 )
    {
      v6 = (__int64)Parameter[3];
      if ( v6 )
      {
        v5 = sub_1461A5090(v6, v3, v2);
      }
      else
      {
        hProcess = GetCurrentProcess();
        v5 = sub_1461A65F0((__int64)Parameter, v4, v3, (__int64)v2, hProcess, 1);
      }
      v8 = (__int64 (__fastcall *)(HANDLE, HANDLE, HANDLE, __int64, __int128 *, int))Parameter[1];
      if ( v8 )
      {
        LOBYTE(v11) = v5;
        v5 = v8(Parameter[16], Parameter[17], Parameter[2], v3, v2, v11);
      }
    }
    v9 = Parameter[36];
    *((_BYTE *)Parameter + 320) = v5;
    ReleaseSemaphore(v9, 1, 0i64);
  }
  return 0i64;
}
// 1461A565E: variable 'v11' is possibly undefined

//----- (00000001461A56A0) ----------------------------------------------------
__int64 __fastcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  __int64 v2; // rcx
  unsigned __int64 v3; // rbx
  __int64 v4; // rbx
  DWORD ExceptionCode; // ecx
  bool v6; // al
  unsigned int v7; // ebx
  int CurrentThreadId; // edx
  char v9; // al
  __int64 (__fastcall *v10)(struct _EXCEPTION_POINTERS *); // rax

  EnterCriticalSection(&CriticalSection);
  ++dword_14611ADE0;
  v2 = *(_QWORD *)qword_14611ADD8;
  v3 = ((__int64)(*(_QWORD *)(qword_14611ADD8 + 8) - *(_QWORD *)qword_14611ADD8) >> 3) - dword_14611ADE0;
  if ( (__int64)(*(_QWORD *)(qword_14611ADD8 + 8) - *(_QWORD *)qword_14611ADD8) >> 3 <= v3 )
    unknown_libname_8(v2);
  v4 = *(_QWORD *)(v2 + 8 * v3);
  SetUnhandledExceptionFilter(*(LPTOP_LEVEL_EXCEPTION_FILTER *)(v4 + 200));
  set_invalid_parameter_handler(*(_invalid_parameter_handler *)(v4 + 208));
  set_purecall_handler(*(_purecall_handler *)(v4 + 216));
  ExceptionCode = ExceptionInfo->ExceptionRecord->ExceptionCode;
  v6 = ExceptionCode == -2147483645
    || ExceptionCode == -2147483644
    || ExceptionCode == 1073807366
    || ExceptionCode == 1073807370;
  if ( ExceptionCode == -1073741816 && *(_BYTE *)(v4 + 322) )
  {
    v7 = -1;
  }
  else if ( (!v6 || *(_BYTE *)(v4 + 321))
         && (!*(_QWORD *)(v4 + 24)
           ? (v9 = sub_1461A6460(v4, (__int64)ExceptionInfo, 0i64))
           : (CurrentThreadId = GetCurrentThreadId(),
              v9 = sub_1461A6530((_QWORD *)v4, CurrentThreadId, (__int64)ExceptionInfo, 0i64)),
             v9) )
  {
    v7 = 1;
  }
  else
  {
    v10 = *(__int64 (__fastcall **)(struct _EXCEPTION_POINTERS *))(v4 + 200);
    if ( v10 )
      v7 = v10(ExceptionInfo);
    else
      v7 = 0;
  }
  SetUnhandledExceptionFilter(TopLevelExceptionFilter);
  set_invalid_parameter_handler((_invalid_parameter_handler)sub_1461A5820);
  set_purecall_handler(sub_1461A5A10);
  --dword_14611ADE0;
  LeaveCriticalSection(&CriticalSection);
  return v7;
}
// 14611ADD8: using guessed type __int64 qword_14611ADD8;
// 14611ADE0: using guessed type int dword_14611ADE0;
// 1461A6830: using guessed type void __fastcall __noreturn unknown_libname_8(_QWORD);

//----- (00000001461A5820) ----------------------------------------------------
void __fastcall __noreturn sub_1461A5820(
        const wchar_t *a1,
        const wchar_t *a2,
        const wchar_t *a3,
        unsigned int a4,
        uintptr_t a5)
{
  _QWORD *v9; // rbx
  int CurrentThreadId; // edx
  char v11; // al
  void (__fastcall *v12)(const wchar_t *, const wchar_t *, const wchar_t *, _QWORD, uintptr_t); // r10
  char v13[8]; // [rsp+30h] [rbp-D0h] BYREF
  int v14[2]; // [rsp+38h] [rbp-C8h] BYREF
  CONTEXT *p_ContextRecord; // [rsp+40h] [rbp-C0h]
  __int64 v16; // [rsp+48h] [rbp-B8h]
  __int128 v17; // [rsp+50h] [rbp-B0h] BYREF
  __int128 v18; // [rsp+60h] [rbp-A0h]
  __int128 v19; // [rsp+70h] [rbp-90h]
  __int128 v20; // [rsp+80h] [rbp-80h]
  __int128 v21; // [rsp+90h] [rbp-70h]
  __int128 v22; // [rsp+A0h] [rbp-60h]
  __int128 v23; // [rsp+B0h] [rbp-50h]
  __int128 v24; // [rsp+C0h] [rbp-40h]
  __int128 v25; // [rsp+D0h] [rbp-30h]
  __int64 v26; // [rsp+E0h] [rbp-20h]
  wchar_t Buffer[392]; // [rsp+F0h] [rbp-10h] BYREF
  CONTEXT ContextRecord; // [rsp+400h] [rbp+300h] BYREF

  v16 = -2i64;
  sub_1461A5320((__int64)v13);
  v9 = (_QWORD *)sub_1461A6850((__int64)v13);
  memset(Buffer, 0, 0x308ui64);
  sub_1461A6860(Buffer, 0x80ui64, 0xFFFFFFFFFFFFFFFFui64, (wchar_t *)L"%s", a1);
  sub_1461A6860(&Buffer[128], 0x80ui64, 0xFFFFFFFFFFFFFFFFui64, (wchar_t *)L"%s", a2);
  sub_1461A6860(&Buffer[256], 0x80ui64, 0xFFFFFFFFFFFFFFFFui64, (wchar_t *)L"%s", a3);
  *(_DWORD *)&Buffer[384] = a4;
  *(_DWORD *)&Buffer[386] = 1;
  v17 = 0i64;
  v18 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v25 = 0i64;
  v26 = 0i64;
  memset(&ContextRecord, 0, sizeof(ContextRecord));
  *(_QWORD *)v14 = &v17;
  p_ContextRecord = &ContextRecord;
  RtlCaptureContext(&ContextRecord);
  LODWORD(v17) = -1073741811;
  DWORD2(v18) = 3;
  *(_QWORD *)&v19 = Buffer;
  *((_QWORD *)&v19 + 1) = &Buffer[256];
  *(_QWORD *)&v20 = *(unsigned int *)&Buffer[384];
  if ( sub_1461A61B0((__int64)v9) )
  {
    CurrentThreadId = GetCurrentThreadId();
    v11 = sub_1461A6530(v9, CurrentThreadId, (__int64)v14, (__int128 *)Buffer);
  }
  else
  {
    v11 = sub_1461A6460((__int64)v9, (__int64)v14, (__int64)Buffer);
  }
  if ( !v11 )
  {
    v12 = (void (__fastcall *)(const wchar_t *, const wchar_t *, const wchar_t *, _QWORD, uintptr_t))v9[26];
    if ( v12 )
      v12(a1, a2, a3, a4, a5);
    else
      invalid_parameter_noinfo();
  }
  exit(0);
}
// 1461A5820: using guessed type char var_8E0[8];

//----- (00000001461A5A10) ----------------------------------------------------
void __fastcall sub_1461A5A10()
{
  unsigned __int64 v0; // rdx
  __int64 v1; // rbx
  int CurrentThreadId; // edi
  char v3; // di
  __int64 v4; // rcx
  bool v5; // al
  HANDLE hProcess; // rax
  __int64 (__fastcall *v7)(_QWORD, _QWORD, _QWORD, int *, int *, int); // rax
  void (*v8)(void); // rax
  int v9; // [rsp+30h] [rbp-D8h]
  int v10[2]; // [rsp+38h] [rbp-D0h] BYREF
  int v11[2]; // [rsp+40h] [rbp-C8h] BYREF
  CONTEXT *p_ContextRecord; // [rsp+48h] [rbp-C0h]
  __int64 v13; // [rsp+50h] [rbp-B8h]
  __int128 v14; // [rsp+58h] [rbp-B0h] BYREF
  __int128 v15; // [rsp+68h] [rbp-A0h]
  __int128 v16; // [rsp+78h] [rbp-90h]
  __int128 v17; // [rsp+88h] [rbp-80h]
  __int128 v18; // [rsp+98h] [rbp-70h]
  __int128 v19; // [rsp+A8h] [rbp-60h]
  __int128 v20; // [rsp+B8h] [rbp-50h]
  __int128 v21; // [rsp+C8h] [rbp-40h]
  __int128 v22; // [rsp+D8h] [rbp-30h]
  __int64 v23; // [rsp+E8h] [rbp-20h]
  int v24[196]; // [rsp+F8h] [rbp-10h] BYREF
  CONTEXT ContextRecord; // [rsp+408h] [rbp+300h] BYREF

  v13 = -2i64;
  EnterCriticalSection(&CriticalSection);
  v0 = ((__int64)(*(_QWORD *)(qword_14611ADD8 + 8) - *(_QWORD *)qword_14611ADD8) >> 3) - ++dword_14611ADE0;
  if ( (__int64)(*(_QWORD *)(qword_14611ADD8 + 8) - *(_QWORD *)qword_14611ADD8) >> 3 <= v0 )
    unknown_libname_8();
  *(_QWORD *)v10 = *(_QWORD *)(*(_QWORD *)qword_14611ADD8 + 8 * v0);
  SetUnhandledExceptionFilter(*(LPTOP_LEVEL_EXCEPTION_FILTER *)(*(_QWORD *)v10 + 200i64));
  set_invalid_parameter_handler(*(_invalid_parameter_handler *)(*(_QWORD *)v10 + 208i64));
  set_purecall_handler(*(_purecall_handler *)(*(_QWORD *)v10 + 216i64));
  v1 = *(_QWORD *)v10;
  memset(v24, 0, 0x304ui64);
  v24[193] = 2;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v18 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0i64;
  memset(&ContextRecord, 0, sizeof(ContextRecord));
  *(_QWORD *)v11 = &v14;
  p_ContextRecord = &ContextRecord;
  RtlCaptureContext(&ContextRecord);
  LODWORD(v14) = -1073741787;
  DWORD2(v15) = 3;
  *(_QWORD *)&v16 = v24;
  *((_QWORD *)&v16 + 1) = &v24[128];
  *(_QWORD *)&v17 = (unsigned int)v24[192];
  if ( *(_QWORD *)(*(_QWORD *)v10 + 24i64) )
  {
    CurrentThreadId = GetCurrentThreadId();
    if ( !**(_QWORD **)v10
      || (**(unsigned __int8 (__fastcall ***)(_QWORD, int *, int *))v10)(*(_QWORD *)(*(_QWORD *)v10 + 16i64), v11, v24) )
    {
      v4 = *(_QWORD *)(*(_QWORD *)v10 + 24i64);
      if ( v4 )
      {
        v5 = sub_1461A5090(v4, (__int64)v11, (__int128 *)v24);
      }
      else
      {
        hProcess = GetCurrentProcess();
        v5 = sub_1461A65F0(*(__int64 *)v10, CurrentThreadId, (__int64)v11, (__int64)v24, hProcess, 1);
      }
      v3 = v5;
      v7 = *(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, int *, int *, int))(*(_QWORD *)v10 + 8i64);
      if ( v7 )
      {
        LOBYTE(v9) = v3;
        v3 = v7(
               *(_QWORD *)(*(_QWORD *)v10 + 128i64),
               *(_QWORD *)(*(_QWORD *)v10 + 136i64),
               *(_QWORD *)(*(_QWORD *)v10 + 16i64),
               v11,
               v24,
               v9);
      }
    }
    else
    {
      v3 = 0;
    }
  }
  else
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(*(_QWORD *)v10 + 240i64));
    if ( *(_QWORD *)(*(_QWORD *)v10 + 224i64) )
    {
      *(_DWORD *)(*(_QWORD *)v10 + 296i64) = GetCurrentThreadId();
      *(_QWORD *)(v1 + 304) = v11;
      *(_QWORD *)(v1 + 312) = v24;
      ReleaseSemaphore(*(HANDLE *)(v1 + 280), 1, 0i64);
      WaitForSingleObject(*(HANDLE *)(v1 + 288), 0xFFFFFFFF);
      v3 = *(_BYTE *)(v1 + 320);
      *(_DWORD *)(v1 + 296) = 0;
      *(_QWORD *)(v1 + 304) = 0i64;
      *(_QWORD *)(v1 + 312) = 0i64;
      LeaveCriticalSection((LPCRITICAL_SECTION)(v1 + 240));
    }
    else
    {
      LeaveCriticalSection((LPCRITICAL_SECTION)(*(_QWORD *)v10 + 240i64));
      v3 = 0;
    }
  }
  if ( v3 )
LABEL_17:
    exit(0);
  v8 = *(void (**)(void))(v1 + 216);
  if ( v8 )
  {
    v8();
    goto LABEL_17;
  }
  sub_1461A5540(v10);
}
// 1461A5C22: variable 'v9' is possibly undefined
// 14611ADD8: using guessed type __int64 qword_14611ADD8;
// 14611ADE0: using guessed type int dword_14611ADE0;
// 1461A5540: using guessed type __int64 __fastcall sub_1461A5540(_QWORD);
// 1461A6830: using guessed type void __noreturn unknown_libname_8(void);

//----- (00000001461A5D20) ----------------------------------------------------
void __fastcall sub_1461A5D20(
        struct _RTL_CRITICAL_SECTION *lpParameter,
        char *Src,
        struct _RTL_CRITICAL_SECTION_DEBUG *a3,
        __int64 a4,
        void *a5,
        int a6,
        int a7,
        const wchar_t *a8,
        __int64 a9,
        __int64 a10,
        _OWORD *a11)
{
  signed __int32 v13; // r13d
  _QWORD *v14; // rbx
  __int64 v15; // rax
  void *v16; // rax
  void *v17; // rax
  _QWORD *v18; // rbp
  _QWORD *LockSemaphore; // rsi
  HANDLE SemaphoreW; // rax
  HMODULE LibraryW; // rax
  HMODULE v22; // rax
  __int64 v23; // r9
  ULONG_PTR *p_SpinCount; // rsi
  unsigned __int64 v25; // r8
  __int64 v26; // rbp
  _OWORD *v27; // rax
  _QWORD *v28; // rcx
  _QWORD *v29; // rax
  _BYTE *v30; // rdx
  DWORD ThreadId[4]; // [rsp+38h] [rbp-60h] BYREF
  __int64 v32; // [rsp+48h] [rbp-50h]
  char *p_LockCount; // [rsp+50h] [rbp-48h]
  __int64 v34; // [rsp+58h] [rbp-40h]

  v32 = -2i64;
  v13 = _InterlockedIncrement(&dword_14611ADE4);
  lpParameter->DebugInfo = a3;
  *(_QWORD *)&lpParameter->LockCount = a4;
  lpParameter->OwningThread = a5;
  *(_QWORD *)&lpParameter[3].LockCount = 0i64;
  lpParameter[3].OwningThread = 0i64;
  lpParameter[3].LockSemaphore = 0i64;
  lpParameter[3].SpinCount = 0i64;
  lpParameter[4].DebugInfo = 0i64;
  lpParameter[4].LockCount = a7;
  lpParameter[4].OwningThread = 0i64;
  lpParameter[4].LockSemaphore = 0i64;
  LODWORD(lpParameter[4].SpinCount) = a6;
  lpParameter[5].DebugInfo = 0i64;
  *(_QWORD *)&lpParameter[5].LockCount = 0i64;
  lpParameter[5].OwningThread = 0i64;
  lpParameter[5].LockSemaphore = 0i64;
  LOBYTE(lpParameter[5].SpinCount) = 0;
  lpParameter[7].DebugInfo = 0i64;
  *(_QWORD *)&lpParameter[7].LockCount = 0i64;
  LODWORD(lpParameter[7].OwningThread) = 0;
  lpParameter[7].LockSemaphore = 0i64;
  lpParameter[7].SpinCount = 0i64;
  LOWORD(lpParameter[8].DebugInfo) = 0;
  BYTE2(lpParameter[8].DebugInfo) = 0;
  v14 = 0i64;
  v15 = a10;
  if ( a10 )
    goto LABEL_11;
  if ( a8 )
  {
    v16 = operator new(0x370ui64);
    *(_QWORD *)ThreadId = v16;
    v15 = v16 ? sub_1461A4CF0((__int64)v16, a8, lpParameter[4].LockCount, a11) : 0i64;
  }
  else
  {
    if ( !a9 )
      goto LABEL_17;
    v17 = operator new(0x370ui64);
    *(_QWORD *)ThreadId = v17;
    v15 = v17 ? sub_1461A4C70((__int64)v17, a9, lpParameter[4].LockCount, a11) : 0i64;
  }
  if ( v15 )
  {
LABEL_11:
    v14 = (_QWORD *)v15;
    if ( v15 )
    {
      if ( sub_1461A4EE0(v15) )
      {
        v18 = v14;
        v14 = 0i64;
        LockSemaphore = lpParameter->LockSemaphore;
        if ( v18 != LockSemaphore )
        {
          if ( LockSemaphore )
          {
            sub_1461A4DA0((_QWORD *)lpParameter->LockSemaphore);
            j_j_free(LockSemaphore);
          }
          lpParameter->LockSemaphore = v18;
        }
      }
    }
  }
LABEL_17:
  if ( !lpParameter->LockSemaphore )
  {
    InitializeCriticalSection(lpParameter + 6);
    lpParameter[7].DebugInfo = (PRTL_CRITICAL_SECTION_DEBUG)CreateSemaphoreW(0i64, 0, 1, 0i64);
    SemaphoreW = CreateSemaphoreW(0i64, 0, 1, 0i64);
    *(_QWORD *)&lpParameter[7].LockCount = SemaphoreW;
    if ( SemaphoreW && lpParameter[7].DebugInfo )
      lpParameter[5].LockSemaphore = CreateThread(
                                       0i64,
                                       0x10000ui64,
                                       (LPTHREAD_START_ROUTINE)sub_1461A5590,
                                       lpParameter,
                                       0,
                                       ThreadId);
    LibraryW = LoadLibraryW(L"dbghelp.dll");
    lpParameter[3].SpinCount = (ULONG_PTR)LibraryW;
    if ( LibraryW )
      lpParameter[4].DebugInfo = (PRTL_CRITICAL_SECTION_DEBUG)GetProcAddress(LibraryW, "MiniDumpWriteDump");
    v22 = LoadLibraryW(L"rpcrt4.dll");
    lpParameter[4].OwningThread = v22;
    if ( v22 )
      lpParameter[4].LockSemaphore = GetProcAddress(v22, "UuidCreate");
    p_SpinCount = &lpParameter->SpinCount;
    if ( &lpParameter->SpinCount != (ULONG_PTR *)Src )
    {
      v25 = *((_QWORD *)Src + 2);
      if ( *((_QWORD *)Src + 3) > 7ui64 )
        Src = *(char **)Src;
      sub_14617D600((void **)&lpParameter->SpinCount, Src, v25, v23);
    }
    if ( lpParameter[1].OwningThread > HANDLE_FLAG_PROTECT_FROM_CLOSE|HANDLE_FLAG_INHERIT|0x4 )
      p_SpinCount = (ULONG_PTR *)*p_SpinCount;
    *(_QWORD *)&lpParameter[3].LockCount = p_SpinCount;
    sub_1461A6240((__int64)lpParameter);
  }
  *(_QWORD *)ThreadId = 0i64;
  ThreadId[2] = 0;
  v26 = *(_QWORD *)&lpParameter[8].LockCount;
  if ( lpParameter[8].OwningThread == (HANDLE)0x7FFFFFFFFFFFFFFi64 )
    std::_Xlength_error("list too long");
  p_LockCount = (char *)&lpParameter[8].LockCount;
  v34 = 0i64;
  v27 = operator new(0x20ui64);
  v27[1] = *(_OWORD *)ThreadId;
  ++lpParameter[8].OwningThread;
  v28 = *(_QWORD **)(v26 + 8);
  *(_QWORD *)v27 = v26;
  *((_QWORD *)v27 + 1) = v28;
  *(_QWORD *)(v26 + 8) = v27;
  *v28 = v27;
  if ( v13 == 1 )
    InitializeCriticalSection(&CriticalSection);
  if ( a6 )
  {
    EnterCriticalSection(&CriticalSection);
    v29 = (_QWORD *)qword_14611ADD8;
    if ( !qword_14611ADD8 )
    {
      v29 = operator new(0x18ui64);
      if ( v29 )
      {
        *v29 = 0i64;
        v29[1] = 0i64;
        v29[2] = 0i64;
      }
      else
      {
        v29 = 0i64;
      }
      qword_14611ADD8 = (__int64)v29;
    }
    *(_QWORD *)ThreadId = lpParameter;
    v30 = (_BYTE *)v29[1];
    if ( v30 == (_BYTE *)v29[2] )
    {
      sub_1461A51A0(v29, v30, ThreadId);
    }
    else
    {
      *(_QWORD *)v30 = lpParameter;
      v29[1] += 8i64;
    }
    if ( (a6 & 1) != 0 )
      lpParameter[5].DebugInfo = (PRTL_CRITICAL_SECTION_DEBUG)SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)TopLevelExceptionFilter);
    if ( (a6 & 2) != 0 )
      *(_QWORD *)&lpParameter[5].LockCount = set_invalid_parameter_handler((_invalid_parameter_handler)sub_1461A5820);
    if ( (a6 & 4) != 0 )
      lpParameter[5].OwningThread = set_purecall_handler(sub_1461A5A10);
    LeaveCriticalSection(&CriticalSection);
  }
  if ( v14 )
  {
    sub_1461A4DA0(v14);
    j_j_free(v14);
  }
}
// 1461A600F: variable 'v23' is possibly undefined
// 14611ADD8: using guessed type __int64 qword_14611ADD8;
// 14611ADE4: using guessed type int dword_14611ADE4;

//----- (00000001461A61B0) ----------------------------------------------------
bool __fastcall sub_1461A61B0(__int64 a1)
{
  return *(_QWORD *)(a1 + 24) != 0i64;
}

//----- (00000001461A61C0) ----------------------------------------------------
__int64 __fastcall sub_1461A61C0(_QWORD **a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  switch ( *(_DWORD *)(a2 + 12) )
  {
    case 0:
    case 1:
    case 3:
    case 4:
      goto LABEL_4;
    case 5:
      if ( *a1 == a1[1] )
        goto LABEL_6;
      *(_QWORD *)a3 = (*a1)[2];
      *(_DWORD *)(a3 + 8) = *((_DWORD *)*a1 + 6);
      *a1 = (_QWORD *)**a1;
LABEL_4:
      result = 1i64;
      break;
    case 6:
      *(_QWORD *)a3 = 0i64;
      return 1i64;
    default:
LABEL_6:
      result = 0i64;
      break;
  }
  return result;
}

//----- (00000001461A6240) ----------------------------------------------------
void **__fastcall sub_1461A6240(__int64 a1)
{
  void (__fastcall *v1)(__int128 *); // rax
  void **v3; // rbx
  _QWORD *v4; // r14
  unsigned __int64 v5; // rdx
  _QWORD *v6; // rcx
  _BYTE *v7; // rcx
  __int64 v8; // r9
  unsigned __int64 v9; // rax
  _QWORD *v10; // rbx
  __int64 v11; // r9
  void **result; // rax
  __int128 v13; // [rsp+30h] [rbp-268h] BYREF
  void *Block; // [rsp+40h] [rbp-258h] BYREF
  unsigned __int64 v15; // [rsp+58h] [rbp-240h]
  wchar_t String[264]; // [rsp+60h] [rbp-238h] BYREF

  v1 = *(void (__fastcall **)(__int128 *))(a1 + 184);
  v13 = 0i64;
  if ( v1 )
    v1(&v13);
  v3 = (void **)(a1 + 64);
  v4 = sub_1461A6930(&Block, (unsigned int *)&v13);
  if ( (_QWORD *)(a1 + 64) != v4 )
  {
    v5 = *(_QWORD *)(a1 + 88);
    if ( v5 > 7 )
    {
      v6 = *v3;
      if ( 2 * v5 + 2 >= 0x1000 )
      {
        if ( (unsigned __int64)v6 - *(v6 - 1) - 8 > 0x1F )
          goto LABEL_13;
        v6 = (_QWORD *)*(v6 - 1);
      }
      j_j_free(v6);
    }
    *(_QWORD *)(a1 + 80) = 0i64;
    *(_QWORD *)(a1 + 88) = 7i64;
    *(_WORD *)v3 = 0;
    *(_OWORD *)v3 = *(_OWORD *)v4;
    *(_OWORD *)(a1 + 80) = *((_OWORD *)v4 + 1);
    v4[2] = 0i64;
    v4[3] = 7i64;
    *(_WORD *)v4 = 0;
  }
  if ( v15 > 7 )
  {
    v7 = Block;
    if ( 2 * v15 + 2 >= 0x1000 )
    {
      v7 = (_BYTE *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)((_BYTE *)Block - v7 - 8) > 0x1F )
LABEL_13:
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v7);
  }
  if ( *(_QWORD *)(a1 + 88) > 7ui64 )
    v3 = (void **)*v3;
  v8 = *(_QWORD *)(a1 + 128);
  *(_QWORD *)(a1 + 136) = v3;
  swprintf_1(String, (const wchar_t *)0x104, L"%s\\%s.dmp", v8, v3);
  String[259] = 0;
  v9 = wcslen(String);
  v10 = (_QWORD *)(a1 + 96);
  result = sub_14617D600((void **)(a1 + 96), String, v9, v11);
  if ( *(_QWORD *)(a1 + 120) > 7ui64 )
    v10 = (_QWORD *)*v10;
  *(_QWORD *)(a1 + 144) = v10;
  return result;
}
// 1461A63B4: variable 'v11' is possibly undefined
// 1461302B8: using guessed type wchar_t aSSDmp[10];

//----- (00000001461A6400) ----------------------------------------------------
char __fastcall sub_1461A6400(_QWORD *a1, __int64 a2)
{
  int CurrentThreadId; // eax
  char v6; // bl

  if ( a1[3] )
  {
    CurrentThreadId = GetCurrentThreadId();
    return sub_1461A6530(a1, CurrentThreadId, a2, 0i64);
  }
  else
  {
    v6 = sub_1461A6460((__int64)a1, a2, 0i64);
    sub_1461A6240((__int64)a1);
    return v6;
  }
}

//----- (00000001461A6460) ----------------------------------------------------
char __fastcall sub_1461A6460(__int64 a1, __int64 a2, __int64 a3)
{
  DWORD CurrentThreadId; // eax
  void *v8; // rcx
  char v9; // bl

  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 240));
  if ( *(_QWORD *)(a1 + 224) )
  {
    CurrentThreadId = GetCurrentThreadId();
    v8 = *(void **)(a1 + 280);
    *(_DWORD *)(a1 + 296) = CurrentThreadId;
    *(_QWORD *)(a1 + 304) = a2;
    *(_QWORD *)(a1 + 312) = a3;
    ReleaseSemaphore(v8, 1, 0i64);
    WaitForSingleObject(*(HANDLE *)(a1 + 288), 0xFFFFFFFF);
    v9 = *(_BYTE *)(a1 + 320);
    *(_DWORD *)(a1 + 296) = 0;
    *(_QWORD *)(a1 + 304) = 0i64;
    *(_QWORD *)(a1 + 312) = 0i64;
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 240));
    return v9;
  }
  else
  {
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 240));
    return 0;
  }
}

//----- (00000001461A6530) ----------------------------------------------------
char __fastcall sub_1461A6530(_QWORD *a1, int a2, __int64 a3, __int128 *a4)
{
  char result; // al
  __int64 v9; // rcx
  HANDLE hProcess; // rax
  __int64 (__fastcall *v11)(_QWORD, _QWORD, _QWORD, __int64, __int128 *, int); // r10
  int v12; // [rsp+28h] [rbp-10h]

  if ( !*a1 || (result = ((__int64 (__fastcall *)(_QWORD, __int64, __int128 *))*a1)(a1[2], a3, a4)) != 0 )
  {
    v9 = a1[3];
    if ( v9 )
    {
      result = sub_1461A5090(v9, a3, a4);
    }
    else
    {
      hProcess = GetCurrentProcess();
      result = sub_1461A65F0((__int64)a1, a2, a3, (__int64)a4, hProcess, 1);
    }
    v11 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, __int64, __int128 *, int))a1[1];
    if ( v11 )
    {
      LOBYTE(v12) = result;
      return v11(a1[16], a1[17], a1[2], a3, a4, v12);
    }
  }
  return result;
}
// 1461A65CC: variable 'v12' is possibly undefined

//----- (00000001461A65F0) ----------------------------------------------------
bool __fastcall sub_1461A65F0(__int64 a1, int a2, __int64 a3, __int64 a4, HANDLE hProcess, char a6)
{
  HANDLE FileW; // r15
  int v11; // ecx
  __int64 v12; // rax
  __int64 v13; // rax
  char *v14; // rdi
  char *v15; // r8
  char *BaseAddress; // r9
  __int64 v17; // rcx
  __int64 **v18; // rax
  __int64 *v19; // rcx
  unsigned int (__fastcall *v20)(HANDLE, __int64, HANDLE, _QWORD, int *, char *, __int64 *); // rdi
  unsigned int v21; // ebx
  __int64 ProcessId; // rdx
  int *v23; // rax
  bool v24; // bl
  __int64 v26[2]; // [rsp+44h] [rbp-9Dh] BYREF
  __int64 v27[2]; // [rsp+58h] [rbp-89h] BYREF
  int v28; // [rsp+68h] [rbp-79h] BYREF
  __int64 v29; // [rsp+6Ch] [rbp-75h]
  int v30; // [rsp+74h] [rbp-6Dh]
  int v31[8]; // [rsp+78h] [rbp-69h] BYREF
  __int64 v32[2]; // [rsp+98h] [rbp-49h] BYREF
  struct _MEMORY_BASIC_INFORMATION Buffer; // [rsp+A8h] [rbp-39h] BYREF
  int v34; // [rsp+D8h] [rbp-9h] BYREF

  if ( !*(_QWORD *)(a1 + 160) )
    return 0;
  FileW = CreateFileW(*(LPCWSTR *)(a1 + 144), 0x40000000u, 0, 0i64, 1u, 0x80u, 0i64);
  if ( FileW == (HANDLE)-1i64 )
    return 0;
  v11 = 0;
  v28 = a2;
  v29 = a3;
  v30 = 0;
  HIDWORD(v26[0]) = 0;
  v26[1] = (__int64)v31;
  if ( a6 )
  {
    v34 = 3;
    GetCurrentThreadId();
    v12 = 2i64 * SHIDWORD(v26[0]);
    v11 = ++HIDWORD(v26[0]);
    v31[2 * v12] = 1197932545;
    v31[2 * v12 + 1] = 12;
    *(_QWORD *)&v31[2 * v12 + 2] = &v34;
  }
  if ( a4 )
  {
    v13 = 2i64 * v11;
    HIDWORD(v26[0]) = v11 + 1;
    v31[2 * v13] = 1197932546;
    v31[2 * v13 + 1] = 776;
    *(_QWORD *)&v31[2 * v13 + 2] = a4;
  }
  if ( a3 )
  {
    v14 = *(char **)(*(_QWORD *)(a3 + 8) + 248i64);
    if ( VirtualQueryEx(hProcess, v14, &Buffer, 0x30ui64) )
    {
      if ( Buffer.State == 4096 )
      {
        v15 = v14 + 128;
        BaseAddress = (char *)Buffer.BaseAddress;
        if ( Buffer.BaseAddress < v14 - 128 )
          BaseAddress = v14 - 128;
        v17 = **(_QWORD **)(a1 + 328);
        if ( (char *)Buffer.BaseAddress + Buffer.RegionSize < v15 )
          LODWORD(v15) = LODWORD(Buffer.BaseAddress) + LODWORD(Buffer.RegionSize);
        *(_QWORD *)(v17 + 16) = BaseAddress;
        *(_DWORD *)(v17 + 24) = (_DWORD)v15 - (_DWORD)BaseAddress;
      }
    }
  }
  v18 = *(__int64 ***)(a1 + 328);
  v19 = *v18;
  v27[0] = (__int64)v19;
  v27[1] = (__int64)v18;
  if ( !v19[2] )
    v27[0] = *v19;
  v20 = *(unsigned int (__fastcall **)(HANDLE, __int64, HANDLE, _QWORD, int *, char *, __int64 *))(a1 + 160);
  v21 = *(_DWORD *)(a1 + 168);
  v32[0] = (__int64)sub_1461A61C0;
  v32[1] = (__int64)v27;
  ProcessId = GetProcessId(hProcess);
  v23 = &v28;
  if ( !a3 )
    v23 = 0i64;
  v24 = v20(hProcess, ProcessId, FileW, v21, v23, (char *)v26 + 4, v32) == 1;
  CloseHandle(FileW);
  return v24;
}

//----- (00000001461A6850) ----------------------------------------------------
__int64 __fastcall sub_1461A6850(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (00000001461A6860) ----------------------------------------------------
int sub_1461A6860(wchar_t *Buffer, size_t BufferCount, size_t MaxCount, wchar_t *Format, ...)
{
  unsigned __int64 *v8; // rax
  int result; // eax
  va_list va; // [rsp+90h] [rbp+28h] BYREF

  va_start(va, Format);
  v8 = (unsigned __int64 *)sub_146166290();
  result = _stdio_common_vsnwprintf_s(*v8, Buffer, BufferCount, MaxCount, Format, 0i64, va);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (00000001461A6930) ----------------------------------------------------
_QWORD *__fastcall sub_1461A6930(_QWORD *a1, unsigned int *a2)
{
  unsigned __int64 v3; // rax
  __int64 v4; // r9
  int v6; // [rsp+20h] [rbp-E8h]
  int v7; // [rsp+28h] [rbp-E0h]
  int v8; // [rsp+30h] [rbp-D8h]
  int v9; // [rsp+38h] [rbp-D0h]
  int v10; // [rsp+40h] [rbp-C8h]
  int v11; // [rsp+48h] [rbp-C0h]
  int v12; // [rsp+50h] [rbp-B8h]
  int v13; // [rsp+58h] [rbp-B0h]
  int v14; // [rsp+60h] [rbp-A8h]
  int v15; // [rsp+68h] [rbp-A0h]
  wchar_t String[40]; // [rsp+80h] [rbp-88h] BYREF

  v15 = *((unsigned __int8 *)a2 + 15);
  v14 = *((unsigned __int8 *)a2 + 14);
  v13 = *((unsigned __int8 *)a2 + 13);
  v12 = *((unsigned __int8 *)a2 + 12);
  v11 = *((unsigned __int8 *)a2 + 11);
  v10 = *((unsigned __int8 *)a2 + 10);
  v9 = *((unsigned __int8 *)a2 + 9);
  v8 = *((unsigned __int8 *)a2 + 8);
  v7 = *((unsigned __int16 *)a2 + 3);
  v6 = *((unsigned __int16 *)a2 + 2);
  swprintf_1(
    String,
    (const wchar_t *)0x25,
    L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
    *a2,
    v6,
    v7,
    v8,
    v9,
    v10,
    v11,
    v12,
    v13,
    v14,
    v15);
  String[36] = 0;
  *(_OWORD *)a1 = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  v3 = wcslen(String);
  sub_146168F30(a1, String, v3, v4);
  return a1;
}
// 1461A6A0D: variable 'v4' is possibly undefined
// 146130300: using guessed type wchar_t a08x04x04x02x02[49];

//----- (00000001461A6A40) ----------------------------------------------------
__int64 __fastcall sub_1461A6A40(const __m128i *Src, unsigned __int64 a2, __m128i *a3, unsigned __int64 a4)
{
  int v10; // eax
  unsigned __int64 v13; // rbx
  unsigned int v22; // edi
  __int64 v31; // r8
  __m128i *i; // rcx
  __int64 v34; // rax
  __int64 result; // rax
  const __m128i *v36; // rax
  __m256 v37; // [rsp+40h] [rbp+0h] BYREF

  _RBP = (unsigned __int64)&v37 & 0xFFFFFFFFFFFFFFE0ui64;
  _RSI = Src;
  LOBYTE(v10) = sub_1461A6F90(a2, a4, (dword_146109A9C & 0x20) != 0);
  if ( v10 == 2 )
  {
    sub_1461A6E30(a3->m128i_i8, a4);
    _RAX = 0i64;
    __asm
    {
      vmovdqu ymm2, ymm0
      vmovdqu [rbp+150h+var_150], ymm0
    }
    v13 = a2 & 0xFFFFFFFFFFFFFFF8ui64;
    if ( (a2 & 0xFFFFFFFFFFFFFFF8ui64) != 0 )
    {
      __asm { vmovdqu ymm4, cs:ymmword_1461328C0 }
      while ( 1 )
      {
        __asm
        {
          vpmovzxbd ymm3, qword ptr [rax+rsi]
          vpsrld  ymm1, ymm3, 5
          vpermd  ymm2, ymm1, ymm2
          vpandn  ymm0, ymm3, ymm4
          vpsllvd ymm2, ymm2, ymm0
          vmovmskps ecx, ymm2
        }
        if ( _ECX )
          break;
        __asm { vmovdqu ymm2, [rbp+150h+var_150] }
        _RAX += 8i64;
        if ( _RAX == v13 )
          goto LABEL_6;
      }
      __asm
      {
        vzeroupper
        tzcnt   r8d, ecx
      }
      return _RAX + _R8D;
    }
    else
    {
LABEL_6:
      v22 = a2 & 7;
      if ( !v22 )
        goto LABEL_10;
      __asm { vzeroupper }
      memcpy((void *)(_RBP + 288), &_RSI->m128i_i8[v13], v22);
      __asm
      {
        vpmovzxbd ymm3, [rbp+150h+var_30]
        vpandn  ymm0, ymm3, cs:ymmword_1461328C0
        vpsrld  ymm1, ymm3, 5
        vpermd  ymm2, ymm1, [rbp+150h+var_150]
        vpsllvd ymm1, ymm2, ymm0
        vmovmskps edx, ymm1
      }
      if ( ((1 << v22) - 1) & _EDX )
      {
        __asm { tzcnt   r8d, edx }
        v31 = v13 + _R8D;
        __asm { vzeroupper }
      }
      else
      {
LABEL_10:
        v31 = -1i64;
        __asm { vzeroupper }
      }
    }
    return v31;
  }
  if ( v10 != 1 )
  {
    v36 = sub_1461A6C40(_RSI, a2, a3, a4);
    v31 = -1i64;
    if ( v36 != (const __m128i *)&_RSI->m128i_i8[a2] )
      return (char *)v36 - (char *)_RSI;
    return v31;
  }
  memset((void *)(_RBP + 32), 0, 0x100ui64);
  for ( i = (__m128i *)((char *)a3 + a4); a3 != i; *(_BYTE *)(_RBP + 32 + v34) = 1 )
  {
    v34 = a3->m128i_u8[0];
    a3 = (__m128i *)((char *)a3 + 1);
  }
  result = 0i64;
  if ( !a2 )
    return -1i64;
  while ( !*(_BYTE *)(((unsigned __int64)&v37 & 0xFFFFFFFFFFFFFFE0ui64) + 0x20 + _RSI->m128i_u8[result]) )
  {
    if ( ++result == a2 )
      return -1i64;
  }
  return result;
}
// 1461A6A91: variable 'v10' is possibly undefined
// 146109A9C: using guessed type int dword_146109A9C;

//----- (00000001461A6C40) ----------------------------------------------------
const __m128i *__fastcall sub_1461A6C40(const __m128i *Src, __int64 a2, const __m128i *a3, size_t a4)
{
  const __m128i *v4; // rbx
  unsigned int v5; // edi
  const __m128i *v6; // r15
  const __m128i *v7; // rbp
  char v8; // r14
  __m128i i; // xmm6
  __m128i v10; // xmm0
  int v11; // ecx
  unsigned int v12; // r14d
  __m128i v13; // xmm0
  unsigned int v15; // edi
  const __m128i *v16; // rsi
  __m128i v17; // xmm6
  int v18; // r9d
  __m128i v19; // xmm1
  const __m128i *v20; // r8
  __m128i v21; // xmm0
  int v22; // ecx
  int v23; // ecx
  unsigned int v24; // r14d
  __m128i v25; // xmm1
  int v26; // r8d
  __m128i v27; // xmm0
  int v28; // ecx
  int v29; // ecx
  __m128i v30; // [rsp+20h] [rbp-68h] BYREF

  v4 = Src;
  v5 = a4;
  v6 = (const __m128i *)((char *)Src + (a2 & 0xFFFFFFFFFFFFFFF0ui64));
  v7 = a3;
  v8 = a2;
  if ( a4 <= 0x10 )
  {
    memcpy(&v30, a3, a4);
    for ( i = _mm_load_si128(&v30); v4 != v6; ++v4 )
    {
      v10 = _mm_loadu_si128(v4);
      v11 = _mm_cmpestri(i, v10, v5, 0x10u);
      if ( _mm_cmpestrc(i, v10, v5, 0x10u) )
        return (const __m128i *)((char *)v4 + v11);
    }
    v12 = v8 & 0xF;
    if ( v12 )
    {
      memcpy(&v30, v4, v12);
      v13 = _mm_load_si128(&v30);
      v11 = _mm_cmpestri(i, v13, v5, v12);
      if ( _mm_cmpestrc(i, v13, v5, v12) )
        return (const __m128i *)((char *)v4 + v11);
      return (const __m128i *)((char *)v4 + v12);
    }
    return v4;
  }
  v15 = a4 & 0xF;
  v16 = (const __m128i *)((char *)a3 + (a4 & 0xFFFFFFFFFFFFFFF0ui64));
  memcpy(&v30, v16, a4 & 0xF);
  v17 = _mm_load_si128(&v30);
  v18 = 16;
  if ( v4 == v6 )
  {
LABEL_22:
    v24 = v8 & 0xF;
    if ( v24 )
    {
      memcpy(&v30, v4, v24);
      v25 = _mm_load_si128(&v30);
      v26 = v24;
      do
      {
        v27 = _mm_loadu_si128(v7);
        v28 = _mm_cmpestri(v27, v25, 0x10u, v24);
        if ( _mm_cmpestrc(v27, v25, 0x10u, v24) && v28 < v26 )
          v26 = v28;
        ++v7;
      }
      while ( v7 != v16 );
      if ( v15 )
      {
        v29 = _mm_cmpestri(v17, v25, v15, v24);
        if ( _mm_cmpestrc(v17, v25, v15, v24) )
        {
          if ( v29 < v26 )
            v26 = v29;
        }
      }
      return (const __m128i *)((char *)v4 + v26);
    }
    return v4;
  }
  else
  {
    while ( 1 )
    {
      v19 = _mm_loadu_si128(v4);
      v20 = v7;
      do
      {
        v21 = _mm_loadu_si128(v20);
        v22 = _mm_cmpestri(v21, v19, 0x10u, 0x10u);
        if ( _mm_cmpestrc(v21, v19, 0x10u, 0x10u) && v22 < v18 )
          v18 = v22;
        ++v20;
      }
      while ( v20 != v16 );
      if ( v15 )
      {
        v23 = _mm_cmpestri(v17, v19, v15, 0x10u);
        if ( _mm_cmpestrc(v17, v19, v15, 0x10u) )
        {
          if ( v23 < v18 )
            v18 = v23;
        }
      }
      if ( v18 != 16 )
        return (const __m128i *)((char *)v4 + v18);
      if ( ++v4 == v6 )
        goto LABEL_22;
    }
  }
}

//----- (00000001461A6E30) ----------------------------------------------------
int __fastcall sub_1461A6E30(char *a1, unsigned __int64 a2)
{
  char *v5; // rdi
  char *v6; // rbx
  char v8; // dl
  unsigned int v9; // ecx
  int result; // eax
  __int64 v17; // rax
  __m256 v42; // [rsp+40h] [rbp+0h] BYREF

  _RBP = (unsigned __int64)&v42 & 0xFFFFFFFFFFFFFFE0ui64;
  v5 = &a1[a2];
  v6 = a1;
  if ( a2 > 0x14 )
  {
    memset((void *)((unsigned __int64)&v42 & 0xFFFFFFFFFFFFFFE0ui64), 0, 0x100ui64);
    for ( ; v6 != v5; *(_BYTE *)(_RBP + v17) = -1 )
      v17 = (unsigned __int8)*v6++;
    __asm
    {
      vmovdqu ymm1, [rbp+110h+var_50]
      vmovdqu ymm0, [rbp+110h+var_30]
      vpmovmskb ebx, ymm0
      vmovdqu ymm0, [rbp+110h+var_70]
      vpmovmskb r10d, ymm0
      vmovdqu ymm0, [rbp+110h+var_B0]
      vpmovmskb r8d, ymm0
      vmovdqu ymm0, [rbp+110h+var_F0]
      vpmovmskb ecx, ymm0
      vpmovmskb r11d, ymm1
      vmovdqu ymm1, [rbp+110h+var_90]
      vpmovmskb r9d, ymm1
      vmovdqu ymm1, [rbp+110h+var_D0]
      vpmovmskb edx, ymm1
      vmovdqu ymm1, [rbp+110h+var_110]
      vmovd   xmm0, r9d
      vpinsrd xmm0, xmm0, r10d, 1
      vpinsrd xmm0, xmm0, r11d, 2
      vpmovmskb eax, ymm1
      vmovd   xmm2, eax
      vpinsrd xmm2, xmm2, ecx, 1
      vpinsrd xmm2, xmm2, edx, 2
      vpinsrd xmm2, xmm2, r8d, 3
      vpinsrd xmm0, xmm0, ebx, 3
      vinsertf128 ymm0, ymm2, xmm0, 1
    }
  }
  else
  {
    __asm { vpxor   xmm0, xmm0, xmm0 }
    if ( a1 != v5 )
    {
      do
      {
        v8 = *v6;
        v9 = (unsigned __int8)*v6++;
        _EDX = v8 & 0x3F;
        result = 1 << ((v9 >> 3) & 0x18);
        __asm
        {
          vmovd   xmm1, eax
          vpmovzxbq ymm2, xmm1
          vmovd   xmm1, edx
          vpsllq  ymm2, ymm2, xmm1
          vpor    ymm0, ymm2, ymm0
        }
      }
      while ( v6 != v5 );
    }
  }
  return result;
}

//----- (00000001461A6F90) ----------------------------------------------------
char __fastcall sub_1461A6F90(unsigned __int64 a1, unsigned __int64 a2, char a3)
{
  char result; // al

  if ( a3 && a1 > 0x30 )
  {
    if ( a2 > 0x10 )
    {
      if ( a2 > 0x30 )
        return 2;
      else
        return 2 * (a1 > 0x50);
    }
    else
    {
      return 2 * (a1 > 0x3E8);
    }
  }
  else
  {
    result = 0;
    if ( a2 > 0x20 )
    {
      if ( a2 > 0x30 )
      {
        if ( a2 > 0x40 )
        {
          if ( a2 > 0x50 )
          {
            if ( a2 > 0x21C )
              return a1 > 0x20;
            else
              return a1 > 0x30;
          }
          else
          {
            return a1 > 0x80;
          }
        }
        else
        {
          return a1 > 0xE0;
        }
      }
      else
      {
        return a1 > 0x1A0;
      }
    }
  }
  return result;
}

//----- (00000001461A7020) ----------------------------------------------------
__int64 __fastcall sub_1461A7020(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v5; // r9
  __int64 v7; // rbx
  __int64 v13; // rcx
  unsigned int v16; // r9d
  __int64 result; // rax
  unsigned __int64 v24; // r9
  __int64 v25; // rcx
  __m128i v26; // xmm1
  __m128i v27; // xmm0
  __int64 v28; // rax

  v5 = a2 - a1;
  v7 = a2;
  if ( ((a2 - a1) & 0xFFFFFFFFFFFFFFE0ui64) != 0 && (dword_146109A9C & 0x20) != 0 )
  {
    _EAX = (char)a3;
    __asm
    {
      vmovd   xmm3, eax
      vpxor   xmm0, xmm0, xmm0
      vpshufb xmm3, xmm3, xmm0
      vinsertf128 ymm3, ymm3, xmm3, 1
    }
    v13 = a2 - ((a2 - a1) & 0xFFFFFFFFFFFFFFE0ui64);
    do
    {
      __asm { vpcmpeqb ymm1, ymm3, ymmword ptr [rdx-20h] }
      a2 -= 32i64;
      __asm { vpmovmskb eax, ymm1 }
      if ( _EAX )
      {
        __asm { vzeroupper }
        return a2 + 31 - __lzcnt(_EAX);
      }
    }
    while ( a2 != v13 );
    v16 = v5 & 0x1C;
    if ( v16 )
    {
      a2 -= v16;
      _RAX = (char *)&unk_146132880 - (v16 & 0xFFFFFFFC);
      __asm
      {
        vmovdqu ymm2, ymmword ptr [rax]
        vpmaskmovd ymm0, ymm2, ymmword ptr [rdx]
        vpcmpeqb ymm1, ymm0, ymm3
        vpand   ymm2, ymm1, ymm2
        vpmovmskb eax, ymm2
      }
      if ( _EAX )
      {
        result = a2 + 31 - __lzcnt(_EAX);
        __asm { vzeroupper }
        return result;
      }
    }
    __asm { vzeroupper }
    goto LABEL_10;
  }
  v24 = v5 & 0xFFFFFFFFFFFFFFF0ui64;
  if ( !v24 || (dword_146109A9C & 4) == 0 )
  {
LABEL_10:
    if ( a2 == a1 )
      return v7;
    while ( *(_BYTE *)--a2 != a3 )
    {
      if ( a2 == a1 )
        return v7;
    }
    return a2;
  }
  v25 = a2 - v24;
  v26 = _mm_shuffle_epi8(_mm_cvtsi32_si128(a3), (__m128i)0i64);
  while ( 1 )
  {
    v27 = _mm_loadu_si128((const __m128i *)(a2 - 16));
    a2 -= 16i64;
    LODWORD(v28) = _mm_movemask_epi8(_mm_cmpeq_epi8(v27, v26));
    if ( (_DWORD)v28 )
      break;
    if ( a2 == v25 )
      goto LABEL_10;
  }
  _BitScanReverse((unsigned int *)&v28, v28);
  return a2 + v28;
}
// 1461A714F: variable 'v28' is possibly undefined
// 146109A9C: using guessed type int dword_146109A9C;

//----- (00000001461A7170) ----------------------------------------------------
const __m128i *__fastcall sub_1461A7170(const __m128i *a1, const __m128i *a2, unsigned __int8 a3)
{
  signed __int64 v5; // r9
  unsigned __int64 v7; // rdx
  const __m128i *v9; // rdx
  unsigned int v16; // r9d
  unsigned __int64 v24; // r9
  const __m128i *v25; // rdx
  __m128i v26; // xmm1
  __int64 v27; // rax

  v5 = (char *)a2 - (char *)a1;
  v7 = ((char *)a2 - (char *)a1) & 0xFFFFFFFFFFFFFFE0ui64;
  if ( v7 && (dword_146109A9C & 0x20) != 0 )
  {
    _EAX = (char)a3;
    v9 = (const __m128i *)((char *)a1 + v7);
    __asm
    {
      vmovd   xmm3, eax
      vpxor   xmm0, xmm0, xmm0
      vpshufb xmm3, xmm3, xmm0
      vinsertf128 ymm3, ymm3, xmm3, 1
    }
    do
    {
      __asm
      {
        vpcmpeqb ymm1, ymm3, ymmword ptr [rcx]
        vpmovmskb eax, ymm1
      }
      if ( _EAX )
        goto LABEL_14;
      a1 += 2;
    }
    while ( a1 != v9 );
    v16 = v5 & 0x1C;
    if ( !v16 )
    {
LABEL_9:
      __asm { vzeroupper }
      goto LABEL_10;
    }
    _RAX = (char *)&unk_146132880 - (v16 & 0xFFFFFFFC);
    __asm
    {
      vmovdqu ymm2, ymmword ptr [rax]
      vpmaskmovd ymm0, ymm2, ymmword ptr [rcx]
      vpcmpeqb ymm1, ymm0, ymm3
      vpand   ymm2, ymm1, ymm2
      vpmovmskb eax, ymm2
    }
    if ( !_EAX )
    {
      a1 = (const __m128i *)((char *)a1 + v16);
      goto LABEL_9;
    }
LABEL_14:
    __asm
    {
      vzeroupper
      tzcnt   eax, eax
    }
    return (const __m128i *)((char *)a1 + _EAX);
  }
  else
  {
    v24 = v5 & 0xFFFFFFFFFFFFFFF0ui64;
    if ( v24 && (dword_146109A9C & 4) != 0 )
    {
      v25 = (const __m128i *)((char *)a1 + v24);
      v26 = _mm_shuffle_epi8(_mm_cvtsi32_si128(a3), (__m128i)0i64);
      while ( 1 )
      {
        LODWORD(v27) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), v26));
        if ( (_DWORD)v27 )
          break;
        if ( ++a1 == v25 )
          goto LABEL_10;
      }
      _BitScanForward((unsigned int *)&v27, v27);
      return (const __m128i *)((char *)a1 + v27);
    }
    else
    {
LABEL_10:
      while ( a1 != a2 )
      {
        if ( a1->m128i_i8[0] == a3 )
          break;
        a1 = (const __m128i *)((char *)a1 + 1);
      }
      return a1;
    }
  }
}
// 1461A725E: variable 'v27' is possibly undefined
// 146109A9C: using guessed type int dword_146109A9C;

//----- (00000001461A7270) ----------------------------------------------------
const __m128i *__fastcall sub_1461A7270(const __m128i *a1, const __m128i *a2, __int16 a3)
{
  signed __int64 v4; // r9
  unsigned __int64 v6; // rdx
  const __m128i *v8; // rdx
  unsigned int v15; // r9d
  unsigned __int64 v23; // r9
  const __m128i *v24; // rdx
  __m128i v25; // xmm1
  __m128i v26; // xmm1
  __int64 v27; // rax

  v4 = (char *)a2 - (char *)a1;
  v6 = ((char *)a2 - (char *)a1) & 0xFFFFFFFFFFFFFFE0ui64;
  if ( v6 && (dword_146109A9C & 0x20) != 0 )
  {
    _EAX = a3;
    v8 = (const __m128i *)((char *)a1 + v6);
    __asm
    {
      vmovd   xmm3, eax
      vpunpcklwd xmm3, xmm3, xmm3
      vpshufd xmm3, xmm3, 0
      vinsertf128 ymm3, ymm3, xmm3, 1
    }
    do
    {
      __asm
      {
        vpcmpeqw ymm1, ymm3, ymmword ptr [rcx]
        vpmovmskb eax, ymm1
      }
      if ( _EAX )
        goto LABEL_14;
      a1 += 2;
    }
    while ( a1 != v8 );
    v15 = v4 & 0x1C;
    if ( !v15 )
    {
LABEL_9:
      __asm { vzeroupper }
      goto LABEL_10;
    }
    _RAX = (char *)&unk_146132880 - (v15 & 0xFFFFFFFC);
    __asm
    {
      vmovdqu ymm2, ymmword ptr [rax]
      vpmaskmovd ymm0, ymm2, ymmword ptr [rcx]
      vpcmpeqw ymm1, ymm0, ymm3
      vpand   ymm2, ymm1, ymm2
      vpmovmskb eax, ymm2
    }
    if ( !_EAX )
    {
      a1 = (const __m128i *)((char *)a1 + v15);
      goto LABEL_9;
    }
LABEL_14:
    __asm
    {
      vzeroupper
      tzcnt   eax, eax
    }
    return (const __m128i *)((char *)a1 + _EAX);
  }
  else
  {
    v23 = v4 & 0xFFFFFFFFFFFFFFF0ui64;
    if ( v23 && (dword_146109A9C & 4) != 0 )
    {
      v24 = (const __m128i *)((char *)a1 + v23);
      v25 = _mm_cvtsi32_si128(a3);
      v26 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v25, v25), 0);
      while ( 1 )
      {
        LODWORD(v27) = _mm_movemask_epi8(_mm_cmpeq_epi16(_mm_loadu_si128(a1), v26));
        if ( (_DWORD)v27 )
          break;
        if ( ++a1 == v24 )
          goto LABEL_10;
      }
      _BitScanForward((unsigned int *)&v27, v27);
      return (const __m128i *)((char *)a1 + v27);
    }
    else
    {
LABEL_10:
      while ( a1 != a2 )
      {
        if ( a1->m128i_i16[0] == a3 )
          break;
        a1 = (const __m128i *)((char *)a1 + 2);
      }
      return a1;
    }
  }
}
// 1461A735E: variable 'v27' is possibly undefined
// 146109A9C: using guessed type int dword_146109A9C;

//----- (00000001461A7370) ----------------------------------------------------
const __m128i *__fastcall sub_1461A7370(const __m128i *a1, const __m128i *a2, const __m128i *a3, size_t a4)
{
  const __m128i *v7; // rbx
  unsigned __int64 v9; // rcx
  __m128i v10; // xmm6
  __m128i v11; // xmm0
  int v12; // ecx
  unsigned int v13; // esi
  __m128i v14; // xmm0
  int v15; // ecx
  __m128 v16; // xmm6
  const __m128i *v17; // rbp
  const __m128i *v18; // rsi
  __m128i v19; // xmm0
  int v20; // ecx
  __m128i v21; // xmm0
  const __m128i *v22; // rdx
  __int8 v23; // r8
  signed __int64 v24; // r9
  __int8 *v25; // rcx
  __m128i v26; // [rsp+20h] [rbp-58h] BYREF

  v7 = a1;
  if ( !a4 )
    return a1;
  if ( a4 == 1 )
    return sub_1461A7170(a1, a2, a3->m128i_i8[0]);
  v9 = (char *)a2 - (char *)a1;
  if ( (char *)a2 - (char *)v7 >= a4 )
  {
    if ( (dword_146109A9C & 4) != 0 && v9 >= 0x10 )
    {
      if ( a4 > 0x10 )
      {
        v16 = (__m128)_mm_loadu_si128(a3);
        v17 = a3 + 1;
        v18 = (const __m128i *)((char *)a2 - a4);
        while ( 1 )
        {
          v19 = _mm_loadu_si128(v7);
          v20 = _mm_cmpestri((__m128i)v16, v19, 0x10u, 0x10u);
          if ( _mm_cmpestrc((__m128i)v16, v19, 0x10u, 0x10u) )
          {
            if ( !v20 )
              goto LABEL_23;
            v7 = (const __m128i *)((char *)v7 + v20);
            if ( v7 > v18 )
              return a2;
            v21 = (__m128i)_mm_xor_ps((__m128)_mm_loadu_si128(v7), v16);
            if ( _mm_testz_si128(v21, v21) )
            {
LABEL_23:
              if ( !memcmp(&v7[1], v17, a4 - 16) )
                return v7;
            }
            v7 = (const __m128i *)((char *)v7 + 1);
          }
          else
          {
            ++v7;
          }
          if ( v7 > v18 )
            return a2;
        }
      }
      memcpy(&v26, a3, a4);
      v10 = _mm_load_si128(&v26);
      do
      {
        v11 = _mm_loadu_si128(v7);
        v12 = _mm_cmpestri(v10, v11, a4, 0x10u);
        if ( _mm_cmpestrc(v10, v11, a4, 0x10u) )
        {
          v7 = (const __m128i *)((char *)v7 + v12);
          if ( v12 <= 16 - (int)a4 )
            return v7;
        }
        else
        {
          ++v7;
        }
      }
      while ( v7 <= &a2[-1] );
      v13 = (_DWORD)a2 - (_DWORD)v7;
      if ( a2 != v7 )
      {
        memcpy(&v26, v7, (char *)a2 - (char *)v7);
        v14 = _mm_load_si128(&v26);
        v15 = _mm_cmpestri(v10, v14, a4, v13);
        if ( _mm_cmpestrc(v10, v14, a4, v13) )
          return (const __m128i *)((char *)v7 + v15);
      }
    }
    else
    {
      v22 = (const __m128i *)((char *)a2 + 1 - a4);
      if ( v7 != v22 )
      {
        v23 = a3->m128i_i8[0];
        v24 = (char *)a3 - (char *)v7;
        do
        {
          if ( v7->m128i_i8[0] == v23 )
          {
            v25 = &v7->m128i_i8[1];
            while ( *v25 == v25[v24] )
            {
              if ( ++v25 - (__int8 *)v7 == a4 )
                return v7;
            }
          }
          v7 = (const __m128i *)((char *)v7 + 1);
          --v24;
        }
        while ( v7 != v22 );
      }
    }
  }
  return a2;
}
// 146109A9C: using guessed type int dword_146109A9C;

//----- (00000001461A7560) ----------------------------------------------------
const __m128i *__fastcall sub_1461A7560(const __m128i *a1, const __m128i *a2, const __m128i *a3, __int64 a4)
{
  const __m128i *v6; // rbx
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rsi
  unsigned __int64 v10; // rdi
  __m128i v11; // xmm6
  __m128i v12; // xmm0
  signed int v13; // ecx
  size_t v14; // r8
  size_t v15; // rsi
  __m128i v16; // xmm0
  int v17; // ecx
  __m128 v18; // xmm6
  const __m128i *v19; // rbp
  const __m128i *v20; // rdi
  __m128i v21; // xmm0
  int v22; // ecx
  __m128i v23; // xmm1
  const __m128i *v24; // r8
  __int16 v25; // r11
  signed __int64 v26; // r10
  __int64 v27; // rdx
  __int16 *i; // rcx
  __m128i v29; // [rsp+20h] [rbp-58h] BYREF

  v6 = a1;
  if ( !a4 )
    return a1;
  if ( a4 == 1 )
    return sub_1461A7270(a1, a2, a3->m128i_i16[0]);
  v8 = (char *)a2 - (char *)a1;
  v9 = 2 * a4;
  if ( (char *)a2 - (char *)v6 >= (unsigned __int64)(2 * a4) )
  {
    if ( (dword_146109A9C & 4) != 0 && v8 >= 0x10 )
    {
      if ( v9 > 0x10 )
      {
        v18 = (__m128)_mm_loadu_si128(a3);
        v19 = a3 + 1;
        v20 = (const __m128i *)((char *)a2 - v9);
        while ( 1 )
        {
          v21 = _mm_loadu_si128(v6);
          v22 = _mm_cmpestri((__m128i)v18, v21, 8u, 8u);
          if ( _mm_cmpestrc((__m128i)v18, v21, 8u, 8u) )
          {
            if ( !v22 )
              goto LABEL_23;
            v6 = (const __m128i *)((char *)v6 + 2 * v22);
            if ( v6 > v20 )
              return a2;
            v23 = (__m128i)_mm_xor_ps(v18, (__m128)_mm_loadu_si128(v6));
            if ( _mm_testz_si128(v23, v23) )
            {
LABEL_23:
              if ( !memcmp(&v6[1], v19, v9 - 16) )
                return v6;
            }
            v6 = (const __m128i *)((char *)v6 + 2);
          }
          else
          {
            ++v6;
          }
          if ( v6 > v20 )
            return a2;
        }
      }
      v10 = v9 >> 1;
      memcpy(&v29, a3, 2 * a4);
      v11 = _mm_load_si128(&v29);
      do
      {
        v12 = _mm_loadu_si128(v6);
        v13 = _mm_cmpestri(v11, v12, v10, 8u);
        if ( _mm_cmpestrc(v11, v12, v10, 8u) )
        {
          v6 = (const __m128i *)((char *)v6 + 2 * v13);
          if ( v13 <= (int)(8 - (v9 >> 1)) )
            return v6;
        }
        else
        {
          ++v6;
        }
      }
      while ( v6 <= &a2[-1] );
      v14 = (char *)a2 - (char *)v6;
      if ( a2 != v6 )
      {
        v15 = v14 >> 1;
        memcpy(&v29, v6, v14);
        v16 = _mm_load_si128(&v29);
        v17 = _mm_cmpestri(v11, v16, v10, v15);
        if ( _mm_cmpestrc(v11, v16, v10, v15) )
          return (const __m128i *)((char *)v6 + 2 * v17);
      }
    }
    else
    {
      v24 = (const __m128i *)((char *)a2 + 2 - v9);
      if ( v6 != v24 )
      {
        v25 = a3->m128i_i16[0];
        v26 = (char *)a3 - (char *)v6;
        do
        {
          if ( v6->m128i_i16[0] == v25 )
          {
            v27 = 1i64;
            for ( i = &v6->m128i_i16[1]; *i == *(__int16 *)((char *)i + v26); ++i )
            {
              if ( ++v27 == a4 )
                return v6;
            }
          }
          v6 = (const __m128i *)((char *)v6 + 2);
          v26 -= 2i64;
        }
        while ( v6 != v24 );
      }
    }
  }
  return a2;
}
// 146109A9C: using guessed type int dword_146109A9C;

//----- (00000001461A7770) ----------------------------------------------------
__int64 __fastcall sub_1461A7770(const __m128i *a1, unsigned __int64 a2, __m128i *a3, unsigned __int64 a4)
{
  __m128i *v5; // rbx
  __int64 result; // rax
  unsigned __int8 *v9; // rcx
  __int64 v10; // rax
  char v11[296]; // [rsp+20h] [rbp-128h] BYREF

  v5 = a3;
  if ( (dword_146109A9C & 4) != 0 )
    return sub_1461A6A40(a1, a2, a3, a4);
  memset(v11, 0, 0x100ui64);
  v9 = &v5->m128i_u8[a4];
  if ( v5 != (__m128i *)&v5->m128i_i8[a4] )
  {
    do
    {
      v10 = v5->m128i_u8[0];
      v5 = (__m128i *)((char *)v5 + 1);
      v11[v10] = 1;
    }
    while ( v5 != (__m128i *)v9 );
  }
  result = 0i64;
  if ( !a2 )
    return -1i64;
  while ( !v11[a1->m128i_u8[result]] )
  {
    if ( ++result == a2 )
      return -1i64;
  }
  return result;
}
// 146109A9C: using guessed type int dword_146109A9C;
// 1461A7770: using guessed type char var_128[296];

//----- (00000001461A7888) ----------------------------------------------------
void *__fastcall sub_1461A7888(__int64 a1)
{
  _QWORD *v2; // rdx
  void *result; // rax

  v2 = malloc_0(0x10ui64);
  if ( !v2 )
  {
    std::_Xbad_alloc();
    __debugbreak();
  }
  result = qword_14611AE10;
  *v2 = qword_14611AE10;
  v2[1] = a1;
  qword_14611AE10 = v2;
  return result;
}

//----- (00000001461A79C4) ----------------------------------------------------
char sub_1461A79C4()
{
  if ( !sub_1461689D0() )
    return 0;
  if ( !sub_1461689D0() )
  {
    sub_1461689D0();
    return 0;
  }
  return 1;
}

//----- (00000001461A7A48) ----------------------------------------------------
char __fastcall sub_1461A7A48(int a1)
{
  if ( !a1 )
    byte_14611AE30 = 1;
  sub_1461A88D4();
  if ( !sub_1461689D0() )
    return 0;
  if ( !sub_1461689D0() )
  {
    sub_1461689D0();
    return 0;
  }
  return 1;
}
// 14611AE30: using guessed type char byte_14611AE30;
// 1461A88D4: using guessed type __int64 sub_1461A88D4(void);

//----- (00000001461A7C4C) ----------------------------------------------------
void __fastcall sub_1461A7C4C(_DWORD *a1)
{
  AcquireSRWLockExclusive(&stru_14611AE70);
  *a1 = 0;
  ReleaseSRWLockExclusive(&stru_14611AE70);
  WakeAllConditionVariable(&stru_14611AE68);
}

//----- (00000001461A7CF4) ----------------------------------------------------
void __fastcall sub_1461A7CF4(_DWORD *a1)
{
  AcquireSRWLockExclusive(&stru_14611AE70);
  while ( 1 )
  {
    if ( !*a1 )
    {
      *a1 = -1;
      goto LABEL_7;
    }
    if ( *a1 != -1 )
      break;
    SleepConditionVariableSRW(&stru_14611AE68, &stru_14611AE70, 0xFFFFFFFF, 0);
  }
  *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 380i64) = dword_146109A04;
LABEL_7:
  ReleaseSRWLockExclusive(&stru_14611AE70);
}
// 146109A04: using guessed type int dword_146109A04;
// 14611AE78: using guessed type int TlsIndex;

//----- (00000001461A7ED4) ----------------------------------------------------
__int64 __fastcall sub_1461A7ED4(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 result; // rax

  v2 = *(unsigned int *)(*(_QWORD *)(a2 + 16) + 8i64);
  result = *(_QWORD *)(a2 + 8);
  if ( (*(_BYTE *)(v2 + result + 3) & 0xF) != 0 )
    return *(_BYTE *)(v2 + result + 3) & 0xF0;
  return result;
}

//----- (00000001461A7FF0) ----------------------------------------------------
_QWORD *__fastcall sub_1461A7FF0(_QWORD *a1, char a2)
{
  *a1 = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    j_j_free(a1);
  return a1;
}
// 1461328F0: using guessed type void *type_info::`vftable';

//----- (00000001461A80F8) ----------------------------------------------------
__int64 __fastcall sub_1461A80F8(__int64 a1, __int64 a2, __int64 a3, __int64 (__fastcall *a4)(__int64))
{
  __int64 i; // rbx
  __int64 result; // rax

  for ( i = 0i64; i != a3; ++i )
  {
    a1 -= a2;
    result = a4(a1);
  }
  return result;
}

//----- (00000001461A81C0) ----------------------------------------------------
__int64 sub_1461A81C0()
{
  uintptr_t v0; // rax
  __int64 result; // rax
  unsigned __int64 v2; // [rsp+20h] [rbp-10h] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [rsp+40h] [rbp+10h] BYREF
  LARGE_INTEGER PerformanceCount; // [rsp+48h] [rbp+18h] BYREF

  v0 = _security_cookie;
  if ( _security_cookie == 0x2B992DDFA232i64 )
  {
    SystemTimeAsFileTime = 0i64;
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v2 = (unsigned __int64)SystemTimeAsFileTime;
    v2 ^= GetCurrentThreadId();
    v2 ^= GetCurrentProcessId();
    QueryPerformanceCounter(&PerformanceCount);
    v0 = ((unsigned __int64)&v2 ^ v2 ^ PerformanceCount.QuadPart ^ ((unsigned __int64)PerformanceCount.LowPart << 32)) & 0xFFFFFFFFFFFFi64;
    if ( v0 == 0x2B992DDFA232i64 )
      v0 = 0x2B992DDFA233i64;
    _security_cookie = v0;
  }
  result = ~v0;
  qword_146109A80 = result;
  return result;
}
// 146109A80: using guessed type __int64 qword_146109A80;
// 1461A81C0: using guessed type __int64 sub_1461A81C0();

//----- (00000001461A88D4) ----------------------------------------------------
__int64 sub_1461A88D4()
{
  int v5; // ebp
  bool v7; // zf
  int v12; // edi
  int v13; // eax
  unsigned __int64 v14; // rax
  __int64 v15; // rcx
  int v16; // r8d
  int v17; // r9d
  int v18; // esi
  int v19; // r10d
  unsigned int v20; // r11d
  unsigned __int64 v36; // rax
  int v37; // eax
  unsigned __int64 v38; // rax
  __int64 v39; // rcx
  int v41; // [rsp+20h] [rbp+8h]

  _RAX = 0i64;
  __asm { cpuid }
  v5 = _RAX;
  _RAX = 1i64;
  v7 = ((unsigned int)_RBX ^ 0x756E6547 | (unsigned int)_RCX ^ 0x6C65746E | (unsigned int)_RDX ^ 0x49656E69) == 0;
  __asm { cpuid }
  v12 = _RCX;
  if ( v7
    && ((v13 = _RAX & 0xFFF3FF0, qword_146109AA0 = 0x8000i64, qword_146109AA8 = -1i64, v13 == 67264)
     || v13 == 132704
     || v13 == 132720
     || (v14 = (unsigned int)(v13 - 198224), (unsigned int)v14 <= 0x20) && (v15 = 0x100010001i64, _bittest64(&v15, v14))) )
  {
    v16 = dword_14611B3F4 | 1;
    dword_14611B3F4 |= 1u;
  }
  else
  {
    v16 = dword_14611B3F4;
  }
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  if ( v5 >= 7 )
  {
    _RAX = 7i64;
    __asm { cpuid }
    v18 = _RDX;
    v17 = _RBX;
    if ( (_RBX & 0x200) != 0 )
      dword_14611B3F4 = v16 | 2;
    if ( (int)_RAX >= 1 )
    {
      _RAX = 7i64;
      __asm { cpuid }
      v19 = _RDX;
    }
    _RAX = 36i64;
    if ( v5 >= 36 )
    {
      __asm { cpuid }
      v20 = _RBX;
    }
  }
  v36 = qword_146109A90 & 0xFFFFFFFFFFFFFFFEui64;
  dword_146109A98 = 1;
  dword_146109A9C = 2;
  qword_146109A90 &= ~1ui64;
  if ( (v12 & 0x100000) != 0 )
  {
    v36 &= ~0x10ui64;
    dword_146109A98 = 2;
    qword_146109A90 = v36;
    dword_146109A9C = 6;
  }
  if ( (v12 & 0x8000000) != 0 )
  {
    __asm { xgetbv }
    v41 = v36;
    if ( (v12 & 0x10000000) == 0 || (v36 & 6) != 6 )
    {
LABEL_32:
      if ( (v19 & 0x200000) != 0 && (*(_QWORD *)&v41 & 0x80000i64) != 0 )
        qword_146109A90 &= ~0x80ui64;
      return 0i64;
    }
    v37 = dword_146109A9C | 8;
    dword_146109A98 = 3;
    dword_146109A9C |= 8u;
    if ( (v17 & 0x20) != 0 )
    {
      dword_146109A98 = 5;
      dword_146109A9C = v37 | 0x20;
      v38 = qword_146109A90 & 0xFFFFFFFFFFFFFFFDui64;
      qword_146109A90 &= ~2ui64;
      if ( (v17 & 0xD0030000) != -805109760 )
      {
LABEL_26:
        if ( (v18 & 0x800000) != 0 )
          qword_146109A90 = v38 & 0xFFFFFFFFFEFFFFFFui64;
        if ( (v19 & 0x80000) != 0 && (v41 & 0xE0) == 0xE0 )
        {
          dword_14611B3F0 = v20 & 0x400FF;
          v39 = qword_146109A90 & ~(HIWORD(v20) & 6 | 0x1000029i64);
          qword_146109A90 = v39;
          if ( (unsigned __int8)v20 > 1u )
            qword_146109A90 = v39 & 0xFFFFFFFFFFFFFFBFui64;
        }
        goto LABEL_32;
      }
      if ( (v41 & 0xE0) == 0xE0 )
      {
        dword_146109A9C |= 0x40u;
        v38 = qword_146109A90 & 0xFFFFFFFFFFFFFFDBui64;
        dword_146109A98 = 6;
        qword_146109A90 &= 0xFFFFFFFFFFFFFFDBui64;
        goto LABEL_26;
      }
    }
    v38 = qword_146109A90;
    goto LABEL_26;
  }
  return 0i64;
}
// 146109A90: using guessed type __int64 qword_146109A90;
// 146109A98: using guessed type int dword_146109A98;
// 146109A9C: using guessed type int dword_146109A9C;
// 146109AA0: using guessed type __int64 qword_146109AA0;
// 146109AA8: using guessed type __int64 qword_146109AA8;
// 14611B3F0: using guessed type int dword_14611B3F0;
// 14611B3F4: using guessed type int dword_14611B3F4;
// 1461A88D4: using guessed type __int64 sub_1461A88D4();

//----- (00000001461A8B6C) ----------------------------------------------------
_QWORD *__fastcall sub_1461A8B6C(_QWORD *a1)
{
  a1[2] = 0i64;
  a1[1] = "bad allocation";
  *a1 = &std::bad_alloc::`vftable';
  return a1;
}
// 14611CDF0: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001461A8B90) ----------------------------------------------------
void __noreturn sub_1461A8B90()
{
  _QWORD pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_1461A8B6C(pExceptionObject);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
}
// 1461A8B90: using guessed type void __noreturn sub_1461A8B90();
// 1461A8B90: using guessed type _QWORD pExceptionObject[5];

//----- (00000001461A8BC4) ----------------------------------------------------
void sub_1461A8BC4()
{
  dword_14611B3F8 = 0;
}
// 14611B3F8: using guessed type int dword_14611B3F8;

//----- (00000001461A8D60) ----------------------------------------------------
bool sub_1461A8D60()
{
  HMODULE ModuleHandleW; // rax
  __int64 v1; // rcx
  bool result; // al

  ModuleHandleW = GetModuleHandleW(0i64);
  result = ModuleHandleW
        && *(_WORD *)ModuleHandleW == 23117
        && (v1 = *((int *)ModuleHandleW + 15), *(_DWORD *)((char *)ModuleHandleW + v1) == 17744)
        && *(_WORD *)((char *)ModuleHandleW + v1 + 24) == 523
        && *(_DWORD *)((char *)ModuleHandleW + v1 + 132) > 0xEu
        && *(_DWORD *)((char *)ModuleHandleW + v1 + 248) != 0;
  return result;
}

//----- (00000001461A8DB4) ----------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_1461A8DB4()
{
  return SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)sub_1461A8DC4);
}

//----- (00000001461A8DC4) ----------------------------------------------------
__int64 __fastcall sub_1461A8DC4(_QWORD *a1)
{
  _DWORD *v1; // rbx
  int v3; // edx
  __int64 v5; // rbx

  v1 = (_DWORD *)*a1;
  if ( *(_DWORD *)*a1 == -529697949 && v1[6] == 4 )
  {
    v3 = v1[8];
    if ( v3 == 429065504 || (unsigned int)(v3 - 429065505) <= 1 || v3 == 26820608 )
    {
      *(_QWORD *)_current_exception() = v1;
      v5 = a1[1];
      *(_QWORD *)_current_exception_context() = v5;
      terminate();
      JUMPOUT(0x1461A8E26i64);
    }
  }
  return 0i64;
}
// 1461A8E21: control flows out of bounds to 1461A8E26
// 1461A8F76: using guessed type __int64 _current_exception(void);
// 1461A8F7C: using guessed type __int64 _current_exception_context(void);
// 1461A8FE2: using guessed type __int64 terminate(void);

//----- (00000001461A8E28) ----------------------------------------------------
void sub_1461A8E28()
{
  InitializeSListHead(&stru_14611B400);
}
// 14611B400: using guessed type union _SLIST_HEADER stru_14611B400;

//----- (00000001461A8E38) ----------------------------------------------------
__int64 sub_1461A8E38()
{
  return _std_type_info_destroy_list(&stru_14611B400);
}
// 14611B400: using guessed type union _SLIST_HEADER stru_14611B400;
// 1461A8E38: using guessed type __int64 sub_1461A8E38();
// 1461A8F82: using guessed type __int64 __fastcall _std_type_info_destroy_list(_QWORD);

//----- (00000001461A8E44) ----------------------------------------------------
void *sub_1461A8E44()
{
  return &unk_14611B410;
}

//----- (00000001461A8E68) ----------------------------------------------------
__int64 (__fastcall **sub_1461A8E68())()
{
  return &off_1461328F8;
}
// 1461328F8: using guessed type __int64 (__fastcall *off_1461328F8)();

//----- (00000001461A8E70) ----------------------------------------------------
void sub_1461A8E70()
{
  void (**i)(void); // rbx

  for ( i = qword_146134C50; i < qword_146134C50; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 146134C50: using guessed type void (*qword_146134C50[2])(void);

//----- (00000001461A8EAC) ----------------------------------------------------
void __fastcall sub_1461A8EAC()
{
  void (**i)(void); // rbx

  for ( i = qword_146134C60; i < qword_146134C60; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 146134C60: using guessed type void (*qword_146134C60[2])(void);

//----- (00000001461A8EFC) ----------------------------------------------------
__int64 (__fastcall **sub_1461A8EFC())()
{
  return &off_1461328E0;
}
// 1461328E0: using guessed type __int64 (__fastcall *off_1461328E0)();

//----- (00000001461AE220) ----------------------------------------------------
void sub_1461AE220()
{
  __int64 v0; // rbx

  v0 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 144i64;
  sub_1461626B0(v0 + 56);
  sub_1461626B0(v0 + 16);
}
// 14611AE78: using guessed type int TlsIndex;

//----- (00000001461AE260) ----------------------------------------------------
void __fastcall sub_1461AE260()
{
  sub_1461626B0((__int64)&unk_146106008);
}

//----- (00000001461AE270) ----------------------------------------------------
void __fastcall sub_1461AE270()
{
  sub_1461626B0((__int64)&unk_146106030);
}

//----- (00000001461AE280) ----------------------------------------------------
void sub_1461AE280()
{
  __int64 v0; // rbx

  v0 = *((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 48i64;
  sub_1461626B0(v0 + 56);
  sub_1461626B0(v0 + 16);
}
// 14611AE78: using guessed type int TlsIndex;

//----- (00000001461AE2C0) ----------------------------------------------------
void __fastcall sub_1461AE2C0()
{
  void *v0; // rcx
  _QWORD *v1; // rbx
  void *v2; // rcx

  v0 = Block;
  v1 = (_QWORD *)*((_QWORD *)Block + 1);
  if ( !*((_BYTE *)v1 + 25) )
  {
    do
    {
      sub_14615A710((__int64)&Block, (__int64)&Block, v1[2]);
      v2 = v1;
      v1 = (_QWORD *)*v1;
      j_j_free(v2);
    }
    while ( !*((_BYTE *)v1 + 25) );
    v0 = Block;
  }
  j_j_free(v0);
}

//----- (00000001461AE330) ----------------------------------------------------
void sub_1461AE330()
{
  _QWORD *v0; // rbx
  _QWORD *v1; // rdi

  v0 = qword_14610A990;
  if ( qword_14610A990 )
  {
    v1 = (_QWORD *)xmmword_14610A998;
    if ( qword_14610A990 != (void *)xmmword_14610A998 )
    {
      do
      {
        sub_1461626B0((__int64)v0);
        v0 += 4;
      }
      while ( v0 != v1 );
      v0 = qword_14610A990;
    }
    if ( ((*((_QWORD *)&xmmword_14610A998 + 1) - (_QWORD)v0) & 0xFFFFFFFFFFFFFFE0ui64) >= 0x1000 )
    {
      if ( (unsigned __int64)v0 - *(v0 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v0 = (_QWORD *)*(v0 - 1);
    }
    j_j_free(v0);
    qword_14610A990 = 0i64;
    xmmword_14610A998 = 0i64;
  }
}
// 14610A998: using guessed type __int128 xmmword_14610A998;

//----- (00000001461AE3E0) ----------------------------------------------------
void sub_1461AE3E0()
{
  _BYTE *v0; // rcx

  if ( (unsigned __int64)qword_1461090B8 > 0xF )
  {
    v0 = qword_1461090A0;
    if ( (unsigned __int64)(qword_1461090B8 + 1) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_QWORD *)qword_1461090A0 - 1);
      if ( (unsigned __int64)((_BYTE *)qword_1461090A0 - v0 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v0);
  }
  unk_1461090B0 = _mm_load_si128((const __m128i *)&Size);
  LOBYTE(qword_1461090A0) = 0;
}
// 1461090B8: using guessed type __int64 qword_1461090B8;

//----- (00000001461AE460) ----------------------------------------------------
void __fastcall sub_1461AE460()
{
  if ( lpBaseAddress && lpBaseAddress != &unk_146106050 )
  {
    UnmapViewOfFile(lpBaseAddress);
    lpBaseAddress = 0i64;
  }
  if ( hObject )
  {
    CloseHandle(hObject);
    hObject = 0i64;
  }
}

//----- (00000001461AE4F0) ----------------------------------------------------
void __fastcall sub_1461AE4F0()
{
  _BYTE *v0; // rcx

  if ( *((_QWORD *)&xmmword_14610AA68 + 1) > 7ui64 )
  {
    v0 = qword_14610AA58;
    if ( (unsigned __int64)(2i64 * *((_QWORD *)&xmmword_14610AA68 + 1) + 2) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_QWORD *)qword_14610AA58 - 1);
      if ( (unsigned __int64)((_BYTE *)qword_14610AA58 - v0 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v0);
  }
  xmmword_14610AA68 = (__int128)_mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(qword_14610AA58) = 0;
}
// 14610AA68: using guessed type __int128 xmmword_14610AA68;
// 14611DA20: using guessed type __int128 xmmword_14611DA20;

//----- (00000001461AE570) ----------------------------------------------------
__int64 sub_1461AE570()
{
  wchar_t *v0; // rcx
  __int64 result; // rax

  if ( *((_QWORD *)&xmmword_1461090D8 + 1) > 7ui64 )
  {
    v0 = FileName;
    if ( (unsigned __int64)(2i64 * *((_QWORD *)&xmmword_1461090D8 + 1) + 2) >= 0x1000 )
    {
      v0 = (wchar_t *)*((_QWORD *)FileName - 1);
      if ( (unsigned __int64)((char *)FileName - (char *)v0 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v0);
  }
  result = 0i64;
  xmmword_1461090D8 = (__int128)_mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(FileName) = 0;
  return result;
}
// 1461090D8: using guessed type __int128 xmmword_1461090D8;
// 14611DA20: using guessed type __int128 xmmword_14611DA20;
// 1461AE570: using guessed type __int64 sub_1461AE570();

//----- (00000001461AE5F0) ----------------------------------------------------
void __fastcall sub_1461AE5F0()
{
  void *v0; // rcx
  _QWORD *v1; // rbx
  void *v2; // rcx

  v0 = qword_14610AAA0;
  v1 = (_QWORD *)*((_QWORD *)qword_14610AAA0 + 1);
  if ( !*((_BYTE *)v1 + 25) )
  {
    do
    {
      sub_14615A710((__int64)&qword_14610AAA0, (__int64)&qword_14610AAA0, v1[2]);
      v2 = v1;
      v1 = (_QWORD *)*v1;
      j_j_free(v2);
    }
    while ( !*((_BYTE *)v1 + 25) );
    v0 = qword_14610AAA0;
  }
  j_j_free(v0);
}

//----- (00000001461AE660) ----------------------------------------------------
void __fastcall sub_1461AE660()
{
  void *v0; // rcx
  void **v1; // rbx
  void **v2; // rdi

  v0 = qword_14610AAE8;
  v1 = (void **)*((_QWORD *)qword_14610AAE8 + 1);
  if ( !*((_BYTE *)v1 + 25) )
  {
    do
    {
      sub_146177C20((__int64)&qword_14610AAE8, (__int64)&qword_14610AAE8, (void **)v1[2]);
      v2 = v1;
      v1 = (void **)*v1;
      sub_146177CC0((__int64)(v2 + 5), (__int64)(v2 + 5), *((__int64 **)v2[5] + 1));
      j_j_free(v2[5]);
      j_j_free(v2);
    }
    while ( !*((_BYTE *)v1 + 25) );
    v0 = qword_14610AAE8;
  }
  j_j_free(v0);
}

//----- (00000001461AE700) ----------------------------------------------------
void __fastcall sub_1461AE700()
{
  sub_14617D400(&xmmword_14610AAC0);
}
// 14610AAC0: using guessed type __int128 xmmword_14610AAC0;

//----- (00000001461AE710) ----------------------------------------------------
void __fastcall sub_1461AE710()
{
  void *v0; // rcx
  _QWORD *v1; // rbx
  void *v2; // rcx

  v0 = qword_14610AAD8;
  v1 = (_QWORD *)*((_QWORD *)qword_14610AAD8 + 1);
  if ( !*((_BYTE *)v1 + 25) )
  {
    do
    {
      sub_14615A710((__int64)&qword_14610AAD8, (__int64)&qword_14610AAD8, v1[2]);
      v2 = v1;
      v1 = (_QWORD *)*v1;
      j_j_free(v2);
    }
    while ( !*((_BYTE *)v1 + 25) );
    v0 = qword_14610AAD8;
  }
  j_j_free(v0);
}

//----- (00000001461AE780) ----------------------------------------------------
void __fastcall sub_1461AE780()
{
  sub_146177D60((__int64)&qword_14610AB20, (__int64)&qword_14610AB20, *((_QWORD *)qword_14610AB20 + 1));
  j_j_free(qword_14610AB20);
}

//----- (00000001461AE7C0) ----------------------------------------------------
void __fastcall sub_1461AE7C0()
{
  _BYTE *v0; // rcx

  if ( (unsigned __int64)qword_14611AB78 > 7 )
  {
    v0 = qword_14611AB60;
    if ( (unsigned __int64)(2 * qword_14611AB78 + 2) >= 0x1000 )
    {
      v0 = (_BYTE *)*((_QWORD *)qword_14611AB60 - 1);
      if ( (unsigned __int64)((_BYTE *)qword_14611AB60 - v0 - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
    }
    j_j_free(v0);
  }
  unk_14611AB70 = _mm_load_si128((const __m128i *)&xmmword_14611DA20);
  LOWORD(qword_14611AB60) = 0;
}
// 14611AB78: using guessed type __int64 qword_14611AB78;
// 14611DA20: using guessed type __int128 xmmword_14611DA20;

//----- (00000001461AE840) ----------------------------------------------------
void __fastcall sub_1461AE840()
{
  if ( qword_14611AB38 && qword_14611AB38 != &unk_146106050 )
  {
    UnmapViewOfFile(qword_14611AB38);
    qword_14611AB38 = 0i64;
  }
  if ( qword_14611AB30 )
  {
    CloseHandle(qword_14611AB30);
    qword_14611AB30 = 0i64;
  }
}

//----- (00000001461AE890) ----------------------------------------------------
void __fastcall sub_1461AE890()
{
  void *v0; // rcx
  _QWORD *v1; // rbx
  void *v2; // rcx

  v0 = qword_14610AB10;
  v1 = (_QWORD *)*((_QWORD *)qword_14610AB10 + 1);
  if ( !*((_BYTE *)v1 + 25) )
  {
    do
    {
      sub_14615A710((__int64)&qword_14610AB10, (__int64)&qword_14610AB10, v1[2]);
      v2 = v1;
      v1 = (_QWORD *)*v1;
      j_j_free(v2);
    }
    while ( !*((_BYTE *)v1 + 25) );
    v0 = qword_14610AB10;
  }
  j_j_free(v0);
}

//----- (00000001461AE900) ----------------------------------------------------
void __fastcall sub_1461AE900()
{
  if ( qword_14611AB50 && qword_14611AB50 != &unk_1461091A0 )
  {
    UnmapViewOfFile(qword_14611AB50);
    qword_14611AB50 = 0i64;
  }
  if ( qword_14611AB48 )
  {
    CloseHandle(qword_14611AB48);
    qword_14611AB48 = 0i64;
  }
}

//----- (00000001461AE950) ----------------------------------------------------
void __fastcall sub_1461AE950()
{
  void *v0; // rcx
  _QWORD *v1; // rbx
  void *v2; // rcx

  v0 = qword_14611AB98;
  v1 = (_QWORD *)*((_QWORD *)qword_14611AB98 + 1);
  if ( !*((_BYTE *)v1 + 25) )
  {
    do
    {
      sub_14615A710((__int64)&qword_14611AB98, (__int64)&qword_14611AB98, v1[2]);
      v2 = v1;
      v1 = (_QWORD *)*v1;
      j_j_free(v2);
    }
    while ( !*((_BYTE *)v1 + 25) );
    v0 = qword_14611AB98;
  }
  j_j_free(v0);
}

//----- (00000001461AE9C0) ----------------------------------------------------
void __fastcall sub_1461AE9C0()
{
  `eh vector destructor iterator'(&unk_14611ACA0, 0x20ui64, 2ui64, sub_146162820);
}

//----- (00000001461AE9E0) ----------------------------------------------------
_QWORD *sub_1461AE9E0()
{
  _QWORD *result; // rax
  __int64 v1; // rbx
  _QWORD *v2; // rcx

  result = NtCurrentTeb()->ThreadLocalStoragePointer;
  v1 = result[TlsIndex] + 320i64;
  v2 = *(_QWORD **)v1;
  if ( *(_QWORD *)v1 )
  {
    if ( *(_QWORD *)(result[TlsIndex] + 336i64) - (_QWORD)v2 >= 0x1000ui64 )
    {
      if ( (unsigned __int64)v2 - *(v2 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v2 = (_QWORD *)*(v2 - 1);
    }
    j_j_free(v2);
    result = 0i64;
    *(_QWORD *)v1 = 0i64;
    *(_QWORD *)(v1 + 8) = 0i64;
    *(_QWORD *)(v1 + 16) = 0i64;
  }
  return result;
}
// 14611AE78: using guessed type int TlsIndex;

//----- (00000001461AEA70) ----------------------------------------------------
_QWORD *sub_1461AEA70()
{
  _QWORD *result; // rax
  __int64 v1; // rbx
  _QWORD *v2; // rcx

  result = NtCurrentTeb()->ThreadLocalStoragePointer;
  v1 = result[TlsIndex] + 352i64;
  v2 = *(_QWORD **)v1;
  if ( *(_QWORD *)v1 )
  {
    if ( (unsigned __int64)(2 * ((__int64)(*(_QWORD *)(result[TlsIndex] + 368i64) - (_QWORD)v2) >> 1)) >= 0x1000 )
    {
      if ( (unsigned __int64)v2 - *(v2 - 1) - 8 > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v2 = (_QWORD *)*(v2 - 1);
    }
    j_j_free(v2);
    result = 0i64;
    *(_QWORD *)v1 = 0i64;
    *(_QWORD *)(v1 + 8) = 0i64;
    *(_QWORD *)(v1 + 16) = 0i64;
  }
  return result;
}
// 14611AE78: using guessed type int TlsIndex;

//----- (00000001461AEB00) ----------------------------------------------------
void __fastcall sub_1461AEB00()
{
  void *v0; // rcx

  if ( *((_QWORD *)&xmmword_14611AD68 + 1) > 0xFui64 )
  {
    v0 = (void *)qword_14611AD58;
    if ( (unsigned __int64)(*((_QWORD *)&xmmword_14611AD68 + 1) + 1i64) >= 0x1000 )
    {
      if ( (unsigned __int64)(qword_14611AD58 - *(_QWORD *)(qword_14611AD58 - 8) - 8) > 0x1F )
        invoke_watson(0i64, 0i64, 0i64, 0, 0i64);
      v0 = *(void **)(qword_14611AD58 - 8);
    }
    j_j_free(v0);
  }
  xmmword_14611AD68 = (__int128)_mm_load_si128((const __m128i *)&Size);
  LOBYTE(qword_14611AD58) = 0;
}
// 14611AD58: using guessed type __int64 qword_14611AD58;
// 14611AD68: using guessed type __int128 xmmword_14611AD68;

//----- (00000001461AEB80) ----------------------------------------------------
void __fastcall sub_1461AEB80()
{
  void *v0; // rcx
  _QWORD *v1; // rbx
  void *v2; // rcx

  v0 = qword_14611AD48;
  v1 = (_QWORD *)*((_QWORD *)qword_14611AD48 + 1);
  if ( !*((_BYTE *)v1 + 25) )
  {
    do
    {
      sub_14615A710((__int64)&qword_14611AD48, (__int64)&qword_14611AD48, v1[2]);
      v2 = v1;
      v1 = (_QWORD *)*v1;
      j_j_free(v2);
    }
    while ( !*((_BYTE *)v1 + 25) );
    v0 = qword_14611AD48;
  }
  j_j_free(v0);
}

//----- (00000001461AEBF0) ----------------------------------------------------
void __fastcall sub_1461AEBF0()
{
  void *v0; // rcx
  _QWORD *v1; // rbx
  void *v2; // rcx

  v0 = qword_14611ADC8;
  v1 = (_QWORD *)*((_QWORD *)qword_14611ADC8 + 1);
  if ( !*((_BYTE *)v1 + 25) )
  {
    do
    {
      sub_14615A710((__int64)&qword_14611ADC8, (__int64)&qword_14611ADC8, v1[2]);
      v2 = v1;
      v1 = (_QWORD *)*v1;
      j_j_free(v2);
    }
    while ( !*((_BYTE *)v1 + 25) );
    v0 = qword_14611ADC8;
  }
  j_j_free(v0);
}

//----- (00000001461AEC54) ----------------------------------------------------
void __fastcall sub_1461AEC54()
{
  __int64 v0; // rcx
  void (__fastcall ***v1)(_QWORD, __int64); // rax
  void *v2; // rbx

  while ( 1 )
  {
    v2 = qword_14611AE10;
    if ( !qword_14611AE10 )
      break;
    v0 = *((_QWORD *)qword_14611AE10 + 1);
    qword_14611AE10 = *(void **)qword_14611AE10;
    v1 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v0 + 16i64))(v0);
    if ( v1 )
      (**v1)(v1, 1i64);
    free_0(v2);
  }
}

// nfuncs=984 queued=811 decompiled=811 lumina nreq=0 worse=0 better=0
// ALL OK, 811 function(s) have been successfully decompiled
